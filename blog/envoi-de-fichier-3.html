<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="robot" content="index, follow">
        <meta name="og:site_name" content="@JochLAin on Github">
        <meta name="og:title" content="Blog de Jocelyn Faihy">
        <title>Blog de Jocelyn Faihy</title>
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-42074651-4"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){ dataLayer.push(arguments); }
            gtag('js', new Date());
            gtag('config', 'UA-42074651-4');
        </script>
    </head>
    <body id="blog" class="bg-light" data-spy="scroll" data-target="#navbar-example2" data-offset="0">
        <header>
            <a id="homepage" href="/" class="text-dark">
                <h1>
                    <b class="mx-2">Jocelyn</b>
                    <span class="fas fa-rocket fa-fw fa-2x"></span>
                    <b class="mx-2">Faihy</b>
                </h1>
            </a>
            <a href="/blog.html">
                <aside class="separator"></aside>
            </a>
        </header>
        <article class="blog container">
            <nav class="navigation navigation--dark">
                <section class="navigation__item">
                    <a href="/blog/envoi-de-fichier-1.html" class="navigation__link">
                        <span class="navigation__label mr-2">L'envoi de fichier</span>
                        <span class="far fa-circle"></span>
                    </a>
                </section>
                <section class="navigation__item">
                    <a href="/blog/envoi-de-fichier-2.html" class="navigation__link">
                        <span class="navigation__label mr-2">L'affichage</span>
                        <span class="far fa-circle"></span>
                    </a>
                </section>
                <section class="navigation__item active">
                    <a href="/blog/envoi-de-fichier-3.html" class="navigation__link">
                        <span class="navigation__label mr-2">La gestion en BDD</span>
                        <span class="fas fa-circle"></span>
                    </a>
                </section>
                <section class="navigation__item">
                    <a href="/blog/envoi-de-fichier-4.html" class="navigation__link">
                        <span class="navigation__label mr-2">Le champs de formulaire</span>
                        <span class="far fa-circle"></span>
                    </a>
                </section>
            </nav>
            <article class="blog__article">
                <h2>La gestion en base de donnée (3/4)</h2>
                <p>
                    Dans <a href="/blog/envoi-de-fichier-1.html">les articles précédents</a>, nous avons vu comment envoyer des données au serveur,<br/>
                    Ici nous allons voir comment enregistrer ces fichiers sur le serveur et dans la base de donnée.<br />
                    Nous utiliserons le framework <a href="http://symfony.com/what-is-symfony" target="_blank">Symfony 4</a> pour le développement serveur.<br />
                    Cette article est très largement inspiré de l'excellent tutoriel disponible sur <a href="https://openclassrooms.com/fr/courses/3619856-developpez-votre-site-web-avec-le-framework-symfony/3623841-creer-des-formulaires-avec-symfony#/id/r-3777443" target="_blank">Open Classrooms</a>.<br/>
                    C'est pour cette raison que les éléments de gestion du fichier seront peu expliqués.
                </p>
                <hr />
                <p>
                    Tout d'abord je crée mon <a href="https://symfony.com/doc/current/doctrine.html" target="_blank">entité</a>.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Entity/File.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

use App\Entity\File;
use App\Entity\Member;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\HttpFoundation\File\UploadedFile;

/**
 * @ORM\Table(name="file")
 * @ORM\Entity
 */
class File
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="IDENTITY")
     * @ORM\Id
     */
    private $id;

    /**
     * @ORM\Column(name="extension", type="string")
     */
    private $extension;

    /**
     * @ORM\Column(name="filename", type="string")
     */
    private $filename;

    /**
     * @ORM\Column(name="mime_type", type="string")
     */
    private $mimeType;

    /**
     * @ORM\Column(name="type", type="string")
     */
    private $type;

    /**
     * @ORM\Column(name="path", type="string")
     */
    private $path;

    // Utiliser pour stocker le fichier uploadé (variable temporaire)
    private $upload;
    // Utiliser pour stocker le nom du fichier pour la suppression lors d'un changement (variable temporaire)
    private $tmp;

    // Getter & Setter
}<!--
                --></code><!--
            --></pre>
                <p>
                    Les getters et setters des variables temporaires seront légèrement différents de méthodes basiques.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Entity/File.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

class File
{
    // ...

    /**
     * Set uploaded upload.
     *
     * @param \Symfony\Component\HttpFoundation\File\UploadedFile $upload
     *
     * @return \App\Entity\File
     */
    public function setUpload(UploadedFile $upload = null)
    {
        $this->upload = $upload;
        if (null !== $this->filename) {
            $path = $this->getRootPath();
            if (file_exists($path)) {
                unlink($path);
            }
            $this->tmp = $this->filename;
            $this->filename = null;
            $this->extension = null;
        }

        return $this;
    }

    /**
     * Get uploaded upload.
     *
     * @return \Symfony\Component\HttpFoundation\File\UploadedFile
     */
    public function getUpload()
    {
        return $this->upload;
    }

    public function getTemporaryFilename()
    {
        return $this->tmp;
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    À cela, j'ai ajouté quelques méthodes qui nous permettront de récupérer le chemin du fichier plus facilement.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Entity/File.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

class File
{
    // ...

    /**
     * Get folder path from web folder.
     */
    public function getFolder(string $prefix = null)
    {
        return '/'.getenv('UPLOAD_DIR').($prefix ? DIRECTORY_SEPARATOR.$prefix : '');
    }

    /**
     * Get get filename with extension.
     */
    public function getName()
    {
        if ($extension = $this->getExtension()) {
            $extension = '.'.$extension;
        }
        if ($filename = $this->getFilename()) {
            return $filename.$extension;
        }

        return '';
    }

    /**
     * Get path from public folder
     */
    public function getUrl()
    {
        return $this->getFolder().DIRECTORY_SEPARATOR.$this->getName();
    }

    /**
     * Get folder from the root.
     */
    public function getRootDir()
    {
        return __DIR__.'/../../public'.$this->getFolder();
    }

    /**
     * Get path from the root.
     */
    public function getRootPath()
    {
        return $this->getRootDir().DIRECTORY_SEPARATOR.$this->getName();
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Ensuite, il va falloir faire différentes actions durant le cycle de vie de l'entité, quoi de mieux qu'un <a href="https://symfony.com/doc/current/doctrine/event_listeners_subscribers.html#creating-the-subscriber-class" target="_blank">subscriber Doctrine</a> pour cela.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Subscriber/FileSubscriber.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

namespace App\Subscriber\Doctrine;

use App\Entity\File;
use Doctrine\Common\EventSubscriber;
use Doctrine\ORM\Event\LifecycleEventArgs;
use Doctrine\ORM\Events;
use Symfony\Component\Filesystem\Filesystem;

class FileSubscriber implements EventSubscriber
{
    private $fs;

    public function __construct()
    {
        // To manage file downloading and removing
        $this->fs = new Filesystem();
    }

    public function getSubscribedEvents()
    {
        return [
            Events::prePersist,
            Events::preUpdate,
            Events::postPersist,
            Events::postUpdate,
            Events::postRemove,
        ];
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Avant l'insertion en base de donnée, je récupère les informations à partir du fichier uploadé et les stocke dans l'entité.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Subscriber/FileSubscriber.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

class FileSubscriber implements EventSubscriber
{
    // ...

    public function prePersist(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        if (!$entity instanceof File) {
            return false;
        }
        $this->preUpload($event);
    }


    public function preUpdate(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        if (!$entity instanceof File) {
            return false;
        }
        $this->preUpload($event);
    }

    /**
     * Preset all parameters with uploaded file informations.
     *
     * @param LifecycleEventArgs $event
     */
    protected function preUpload(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        $file = $entity->getUpload();
        if (!$file) {
            return;
        }

        // To prevent strange character
        $filename = $entity->getFilename() ?: uniqid();

        $entity->setFilename($filename);
        $entity->setExtension($file->getClientOriginalExtension());
        $entity->setMimeType($file->getMimeType());
        $entity->setPath($entity->getUrl());
        $entity->setType(strstr($entity->getMimeType(), '/', true));
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Puis juste après la sauvegarde BDD, j'enregistre le fichier sur le serveur.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Subscriber/FileSubscriber.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

class FileSubscriber implements EventSubscriber
{
    // ...

    public function postPersist(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        if (!$entity instanceof File) {
            return false;
        }
        $this->upload($event);
    }


    public function postUpdate(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        if (!$entity instanceof File) {
            return false;
        }
        $this->upload($event);
    }

    /**
     * Move uploaded file in folder.
     *
     * @param LifecycleEventArgs $event
     */
    protected function upload(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        $file = $entity->getUpload();
        $tmp = $entity->getTemporaryFilename();
        if (!$file) {
            return;
        }

        if (null != $tmp) {
            $old = sprintf('%s/%s.%s', $entity->getRootDir(), $tmp, $entity->getExtension());
            $em = $event->getEntityManager();
            if (file_exists($old)) {
                unlink($old);
            }
        }
        $file->move($entity->getRootDir(), $entity->getName());
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Pour finir je gère la suppression du fichier après la suppression en base de donnée.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Subscriber/FileSubscriber.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

class FileSubscriber implements EventSubscriber
{
    // ...

    public function postRemove(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        if (!$entity instanceof File) {
            return false;
        }
        $this->removeUpload($event);
    }

    /**
     * Remove file from fs if no other entity uses this file.
     *
     * @param LifecycleEventArgs $event
     */
    protected function removeUpload(LifecycleEventArgs $event)
    {
        $entity = $event->getEntity();
        $em = $event->getEntityManager();
        $count = $em->getRepository(File::class)->count(['path' => $entity->getPath()]);

        // Vérifie qu'aucune entrée en base de donnée n'utilise le même fichier
        if (!$count) {
            $rootPath = $entity->getRootPath();
            if ($this->fs->exists($rootPath)) {
                unlink($rootPath);
            }
        }
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    J'ai maintenant mon entité avec la gestion du fichier qui lui est rattaché. Il faut maintenant que je crée ce fichier à partir des paramètres de la requête.<br />
                    Puisque les bonnes pratiques préconisent qu'il n'y ait aucun ou peu de code métier dans les <a href="https://symfony.com/doc/current/controller.html" target="_blank">controller</a>, je crée un <a href="https://symfony.com/doc/current/components/dependency_injection.html" target="_blank">service</a> dédié à cela. 
                    J'aurais pu faire un manager bien plus simple, mais pour la suite sa structure permet son évolution simplement.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Manager/UploadManager.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

namespace App\Manager;

use App\Entity\File;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\HttpFoundation\Session\SessionInterface;

class UploadManager
{
    private $em;
    private $request;

    public function __construct(EntityManagerInterface $em, RequestStack $stack)
    {
        $this->em = $em;
        $this->request = $stack->getMasterRequest();
    }

    /**
     * Create \App\Entity\File from UploadedFile
     *
     * @param array<\Symfony\Component\HttpFoundation\File\UploadedFile> || \Symfony\Component\HttpFoundation\File\UploadedFile $upload
     * @return array<\App\Entity\File>
     */
    public function createFromRequest($uploads)
    {
        $files = [];
        if ($uploads instanceof UploadedFile) {
            $file = $this->createFromUploadedFile($uploads);
            $files[] = $file;
        } elseif ($uploads) {
            foreach ($uploads as $file) {
                $files = array_merge($files, $this->createFromRequest($file));
            }
        }

        return $files;
    }

    /**
     * Create \App\Entity\File from UploadedFile
     *
     * @param \Symfony\Component\HttpFoundation\File\UploadedFile $upload
     * @return \App\Entity\File
     */
    public function createFromUploadedFile(UploadedFile $upload)
    {
        $file = new File();
        $file->setUpload($upload);

        $this->em->persist($file);
        $this->em->flush();

        return $file;
    }

    /**
     * Method call in controller
     *
     * @param string $name : request parameter's name
     * @return array<\App\Entity\File> || \App\Entity\File
     */
    public function receiveFilesFromRequest(string $name = null)
    {
        $files = $this->request->files;
        if ($name) {
            $files = $files->get($name);
        }

        $files = $this->createFromRequest($files);
        if (1 == count($files)) {
            return $files[0];
        }

        return $files;
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Il ne reste plus qu'à créer le controller et tous les composants seront instanciés.<br />
                    Et aussi un <a href="http://symfony.com/doc/current/components/serializer.html" target="_blank">normalizer</a> qui viendra formatter les données à renvoyer au client pour afficher les bonnes informations et toujours de la même forme.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Controller/UploadController.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

namespace App\Controller;

use App\Manager\UploadManager;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Symfony\Bundle\FrameworkBundle\Controller\ControllerTrait;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
use Symfony\Component\DependencyInjection\ContainerAwareTrait;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Serializer\Serializer;

/**
 * @Route("/upload", name="upload_")
 */
class UploadController implements ContainerAwareInterface
{
    use ControllerTrait;
    use ContainerAwareTrait;

    /**
     * @Route("/", name="index")
     * @Method({"POST"})
     */
    public function indexAction(UploadManager $manager, Serializer $serializer)
    {
        $files = $manager->receiveFilesFromRequest();

        return $this->json($serializer->normalize($files));
    }
}<!--
                --></code><!--
            --></pre>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Serializer/Normalizer/FileNormalizer.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

namespace App\Serializer\Normalizer;

use App\Entity\File;
use Symfony\Component\Serializer\Normalizer\NormalizerInterface;

class FileNormalizer implements NormalizerInterface
{
    /**
     * {@inheritdoc}
     */
    public function normalize($object, $format = null, array $context = [])
    {
        return [
            'id' => $object->getId(),
            'path' => $object->getUrl(),
            'content' => $object->getFilename(),
            'filesize' => file_exists($object->getRootPath()) ? filesize($object->getRootPath()) : 0,
            'timestamp' => $object->getCreatedAt() ? $object->getCreatedAt()->getTimestamp() : time(),
        ];
    }

    public function supportsNormalization($data, $format = null)
    {
        return $data instanceof File;
    }
}<!--
                --></code><!--
            --></pre>
                <h3>Tronçonnage des fichiers</h3>
                <p>
                    Pour la gestion des tronçons de fichier j'ai créé <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/inheritance-mapping.html" target="_blank">une nouvelle entité qui sera un fichier</a> et qui sera relié à un autre fichier parent, qui lui, sera complet.<br/>
                    Ceci pour que tous les tronçons soient reliés au même fichier.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Entity/File/Chunk.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

namespace App\Entity\File;

use App\Entity\File;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="file_chunk")
 * @ORM\Entity
 */
class Chunk extends File
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="IDENTITY")
     * @ORM\Id
     */
    private $id;

    /**
     * @ORM\Column(name="index", type="integer", nullable=true)
     */
    private $index;

    /**
     * @ORM\ManyToOne(targetEntity=File::class, cascade={"persist"})
     * @ORM\JoinColumn(name="file_id", referencedColumnName="id")
     */
    private $file;

    // Getters & Setters

    /**
     * Get folder path from web folder.
     */
    public function getFolder(string $prefix = null)
    {
        return parent::getFolder($prefix).'/chunk';
    }
}<!--
                --></code><!--
            --></pre>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Entity/File.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...

/**
 * @ORM\Table(name="file")
 * @ORM\Entity
 * @ORM\InheritanceType("JOINED")
 * @ORM\DiscriminatorColumn(name="discr", type="string")
 * @ORM\DiscriminatorMap({"_file" = File::class, "_chunk" = File\Chunk::class})
 */
class File
{
    // ...
}<!--
                --></code><!--
            --></pre>
                <p>
                    Plus haut je vous avait dit que la structure du manager permettait son évolution, c'est justement pour le tronçonnage.
                </p>
                <pre class="blog__article__code"><!--
                --><aside class="blog__article__code--filename">src/Manager/UploadManager.php</aside><!--
                --><code class="blog__article__code--content php"><!--
-->&lt;?php

// ...
use Symfony\Component\HttpFoundation\Session\SessionInterface;

class UploadManager
{
    // ...
    private $session;

    public function __construct(EntityManagerInterface $em, RequestStack $stack, SessionInterface $session)
    {
        $this->em = $em;
        $this->request = $stack->getMasterRequest();
        $this->session = $session;
    }

    // ...

    /**
     * Create \App\Entity\File from UploadedFile
     *
     * @param \Symfony\Component\HttpFoundation\File\UploadedFile $upload
     * @return \App\Entity\File
     */
    public function createFromUploadedFile(UploadedFile $upload)
    {
        // Si le paramètre chunk_uuid est présent cela veut dire que c'est un tronçon qui est envoyé
        if ($this->request->get('chunk_uuid', false)) {
            return $this->createFromUploadedChunk($upload);
        }
        // ...
    }

    /**
     * Create \App\Entity\File\Chunk from UploadedFile
     *
     * @param \Symfony\Component\HttpFoundation\File\UploadedFile $upload
     * @return \App\Entity\File\Chunk
     */
    public function createFromUploadedChunk(UploadedFile $upload)
    {
        $index = $this->request->get('chunk_index');
        $uuid = $this->request->get('chunk_uuid');
        $count = $this->request->get('chunk_count');

        if ($filename = $this->session->get('upload-chunk-'.$uuid, false)) {
            // Si le nom du fichier est stocké en session c'est qu'il est déjà créée.
            // On le récupère pour le relier au tronçon 
            $parent = $this->em->getRepository(File::class)->findOneByFilename($filename);
        } else {
            // On crée fichier parent qui sera vide pour relié tous les tronçons au même fichier
            $parent = $this->createFromContent('', $upload->getClientOriginalExtension(), $upload->getMimeType());
            $this->session->set('upload-chunk-'.$uuid, $parent->getFilename());
            $this->em->persist($parent);
        }

        // On crée le tronçon
        $chunk = new File\Chunk();
        $chunk->setFilename($uuid.'_'.$index);
        $chunk->setFile($parent);
        $chunk->setIndex($index);
        $chunk->setUpload($upload);

        $this->em->persist($chunk);
        $this->em->flush();

        $repository = $this->em->getRepository(File\Chunk::class);
        // Dans le cas où tous les tronçons ont été envoyés
        // On rempli le parent
        if ($repository->countByFile($parent) == $count) {
            $this->mergeChunks($parent);
        }

        return $chunk;
    }

    /**
     * Merge all chunks into a file and remove them after
     *
     * @param \App\Entity\File $file
     * @return \App\Entity\File
     */
    private function mergeChunks(File $file)
    {
        $repository = $this->em->getRepository(File\Chunk::class);
        $chunks = $repository->findOrderedByFile($file);

        // Clear file
        file_put_contents($file->getRootPath(), '');
        // Append chunks
        foreach ($chunks as $chunk) {
            file_put_contents($file->getRootPath(), file_get_contents($chunk->getRootPath()), \FILE_APPEND | \LOCK_EX);
            $this->em->remove($chunk);
        }

        return $file;
    }
}<!--
                --></code><!--
            --></pre>
                <p>
                    Voilà pour l'enregistrement de fichier sur le serveur.<br /> 
                    Dans la prochaine partie nous verrons comment créer un champs de formulaire pour faciliter leur création.
                </p>
                <footer class="d-flex align-items-center justify-content-around">
                    <a href="/blog/envoi-de-fichier-2.html">
                        <article class="d-flex align-items-center justify-content-center">
                            <section class="mx-1">
                                <span class="fas fa-arrow-left"></span>
                            </section>
                            <section class="mx-1">
                                Partie 2 : L'affichage
                            </section>
                        </article>
                    </a>
                    <a href="/blog/envoi-de-fichier-4.html">
                        <article class="d-flex align-items-center justify-content-center">
                            <section class="mx-1">
                                Partie 4 : Le champs de formulaire
                            </section>
                            <section class="mx-1">
                                <span class="fas fa-arrow-right"></span>
                            </section>
                        </article>
                    </a>
                </footer>
            </article>
        </article>
        <footer class="bg-dark text-light text-center">
            <small>Jocelyn Faihy <sup><span class="far fa-copyright"></span></sup> - All rights reserved - 2018</small>
        </footer>
        <script type="text/javascript" src="/js/style.js"></script>
    </body>
</html>
