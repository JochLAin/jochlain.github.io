/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/pages/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/components/description.jsx":
/*!*******************************************!*\
  !*** ./assets/components/description.jsx ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Description = function (_Component) {\n    _inherits(Description, _Component);\n\n    function Description() {\n        _classCallCheck(this, Description);\n\n        return _possibleConstructorReturn(this, (Description.__proto__ || Object.getPrototypeOf(Description)).apply(this, arguments));\n    }\n\n    _createClass(Description, [{\n        key: \"render\",\n        value: function render() {\n            return _react2.default.createElement(\n                \"article\",\n                { id: \"description\", className: \"description__view view\" },\n                _react2.default.createElement(\n                    \"article\",\n                    { className: \"container\" },\n                    _react2.default.createElement(\n                        \"article\",\n                        { className: \"row justify-content-center\" },\n                        _react2.default.createElement(\n                            \"section\",\n                            { className: \"col-12 col-lg-10 col-xl-8\" },\n                            _react2.default.createElement(\n                                \"h3\",\n                                null,\n                                \"\\xC0 propos de moi\"\n                            ),\n                            _react2.default.createElement(\n                                \"article\",\n                                { className: \"card bg-dark text-white\" },\n                                _react2.default.createElement(\n                                    \"section\",\n                                    { className: \"card-body\" },\n                                    _react2.default.createElement(\n                                        \"p\",\n                                        { className: \"card-text\" },\n                                        \"Suite \\xE0 des \\xE9tudes post-bac dans l'informatique, les r\\xE9seaux et le d\\xE9veloppement mobile, je me suis plong\\xE9 dans les technologies du web en auto-didacte.\",\n                                        _react2.default.createElement(\"br\", null),\n                                        \"Cela fait maintenant plus de 6 ans que je d\\xE9couvre, apprends, aiguise mes connaissances.\"\n                                    ),\n                                    _react2.default.createElement(\n                                        \"p\",\n                                        { className: \"card-text\" },\n                                        \"J'ai pu par exemple travailler sur :\"\n                                    ),\n                                    _react2.default.createElement(\n                                        \"ul\",\n                                        null,\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"un logiciel de pixellisation des images d'une kinect ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"un \\\"power-point like\\\" sur web et mobile ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"un r\\xE9seau social de la maison \\xE0 fort trafic ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"un gestionnaire de configurateur 3D ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"le d\\xE9veloppement d'un CMS ;\"\n                                        )\n                                    ),\n                                    _react2.default.createElement(\n                                        \"p\",\n                                        { className: \"card-text\" },\n                                        \"Au d\\xE9part tr\\xE8s \\xE9pris de la programmation c\\xF4t\\xE9 serveur, je me suis petit \\xE0 petit form\\xE9, en plus, sur l'affichage dynamique puis le visuel des sites web.\",\n                                        _react2.default.createElement(\"br\", null),\n                                        \"Cela m'a permis de me retrouver face \\xE0 diverses probl\\xE9matiques, notamment :\"\n                                    ),\n                                    _react2.default.createElement(\n                                        \"ul\",\n                                        null,\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"la gestion du stockage de donn\\xE9es ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"la s\\xE9curit\\xE9 ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"la communication entre le client et le serveur ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"la communication en temps r\\xE9el ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"le format des donn\\xE9es communiqu\\xE9es ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"l'exp\\xE9rience utilisateur ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"l'interface utilisateur ;\"\n                                        )\n                                    ),\n                                    _react2.default.createElement(\n                                        \"p\",\n                                        { className: \"card-text\" },\n                                        \"En plus de cela, j'ai pu exercer mes comp\\xE9tences en gestion de projet et en relation client, comme :\"\n                                    ),\n                                    _react2.default.createElement(\n                                        \"ul\",\n                                        null,\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"la description du besoin ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"l'accompagnement \\xE0 la r\\xE9daction du cahier des charges ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"l'organisation sous forme de sprint AGILE ;\"\n                                        ),\n                                        _react2.default.createElement(\n                                            \"li\",\n                                            null,\n                                            \"le suivi pendant le d\\xE9veloppement ;\"\n                                        )\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return Description;\n}(_react.Component);\n\nexports.default = Description;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY29tcG9uZW50cy9kZXNjcmlwdGlvbi5qc3guanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYXNzZXRzL2NvbXBvbmVudHMvZGVzY3JpcHRpb24uanN4PzVhZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlc2NyaXB0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiA8YXJ0aWNsZSBpZD1cImRlc2NyaXB0aW9uXCIgY2xhc3NOYW1lPVwiZGVzY3JpcHRpb25fX3ZpZXcgdmlld1wiPlxuICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwicm93IGp1c3RpZnktY29udGVudC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiY29sLTEyIGNvbC1sZy0xMCBjb2wteGwtOFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgzPsOAIHByb3BvcyBkZSBtb2k8L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiY2FyZCBiZy1kYXJrIHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiY2FyZC10ZXh0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWl0ZSDDoCBkZXMgw6l0dWRlcyBwb3N0LWJhYyBkYW5zIGwnaW5mb3JtYXRpcXVlLCBsZXMgcsOpc2VhdXggZXQgbGUgZMOpdmVsb3BwZW1lbnQgbW9iaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamUgbWUgc3VpcyBwbG9uZ8OpIGRhbnMgbGVzIHRlY2hub2xvZ2llcyBkdSB3ZWIgZW4gYXV0by1kaWRhY3RlLjxici8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDZWxhIGZhaXQgbWFpbnRlbmFudCBwbHVzIGRlIDYgYW5zIHF1ZSBqZSBkw6ljb3V2cmUsIGFwcHJlbmRzLCBhaWd1aXNlIG1lcyBjb25uYWlzc2FuY2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImNhcmQtdGV4dFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSidhaSBwdSBwYXIgZXhlbXBsZSB0cmF2YWlsbGVyIHN1ciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPnVuIGxvZ2ljaWVsIGRlIHBpeGVsbGlzYXRpb24gZGVzIGltYWdlcyBkJ3VuZSBraW5lY3QgOzwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+dW4gXCJwb3dlci1wb2ludCBsaWtlXCIgc3VyIHdlYiBldCBtb2JpbGUgOzwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+dW4gcsOpc2VhdSBzb2NpYWwgZGUgbGEgbWFpc29uIMOgIGZvcnQgdHJhZmljIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPnVuIGdlc3Rpb25uYWlyZSBkZSBjb25maWd1cmF0ZXVyIDNEIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmxlIGTDqXZlbG9wcGVtZW50IGQndW4gQ01TIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJjYXJkLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1IGTDqXBhcnQgdHLDqHMgw6lwcmlzIGRlIGxhIHByb2dyYW1tYXRpb24gY8O0dMOpIHNlcnZldXIsIGplIG1lIHN1aXMgcGV0aXQgw6AgcGV0aXQgZm9ybcOpLCBlbiBwbHVzLCBzdXIgbCdhZmZpY2hhZ2UgZHluYW1pcXVlIHB1aXMgbGUgdmlzdWVsIGRlcyBzaXRlcyB3ZWIuPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDZWxhIG0nYSBwZXJtaXMgZGUgbWUgcmV0cm91dmVyIGZhY2Ugw6AgZGl2ZXJzZXMgcHJvYmzDqW1hdGlxdWVzLCBub3RhbW1lbnQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5sYSBnZXN0aW9uIGR1IHN0b2NrYWdlIGRlIGRvbm7DqWVzIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmxhIHPDqWN1cml0w6kgOzwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+bGEgY29tbXVuaWNhdGlvbiBlbnRyZSBsZSBjbGllbnQgZXQgbGUgc2VydmV1ciA7PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5sYSBjb21tdW5pY2F0aW9uIGVuIHRlbXBzIHLDqWVsIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmxlIGZvcm1hdCBkZXMgZG9ubsOpZXMgY29tbXVuaXF1w6llcyA7PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5sJ2V4cMOpcmllbmNlIHV0aWxpc2F0ZXVyIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmwnaW50ZXJmYWNlIHV0aWxpc2F0ZXVyIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJjYXJkLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuIHBsdXMgZGUgY2VsYSwgaidhaSBwdSBleGVyY2VyIG1lcyBjb21ww6l0ZW5jZXMgZW4gZ2VzdGlvbiBkZSBwcm9qZXQgZXQgZW4gcmVsYXRpb24gY2xpZW50LCBjb21tZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmxhIGRlc2NyaXB0aW9uIGR1IGJlc29pbiA7PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5sJ2FjY29tcGFnbmVtZW50IMOgIGxhIHLDqWRhY3Rpb24gZHUgY2FoaWVyIGRlcyBjaGFyZ2VzIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmwnb3JnYW5pc2F0aW9uIHNvdXMgZm9ybWUgZGUgc3ByaW50IEFHSUxFIDs8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmxlIHN1aXZpIHBlbmRhbnQgbGUgZMOpdmVsb3BwZW1lbnQgOzwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICA8L2FydGljbGU+XG4gICAgfVxufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQUNBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFGQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFQQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFoQ0E7QUFEQTtBQUZBO0FBREE7QUFEQTtBQURBO0FBa0RBOzs7O0FBcERBO0FBQ0E7QUFEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/components/description.jsx\n");

/***/ }),

/***/ "./assets/components/history.jsx":
/*!***************************************!*\
  !*** ./assets/components/history.jsx ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ExperienceDetail = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _uuid = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _classnames = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EXPERIENCES = [{\n    type: 'formation',\n    diplome: 'Bac STI GE',\n    label: 'Sciences et Techniques Industriel\\nOption Génie Électronique',\n    start: new Date(2008, 9),\n    end: new Date(2010, 6),\n    color: 'red'\n}, {\n    type: 'job',\n    company: 'Mac Donald\\'s',\n    job: 'Équipier polyvalent',\n    start: new Date(2010, 7),\n    end: new Date(2010, 8),\n    color: 'orange'\n}, {\n    type: 'formation',\n    diplome: 'BTS IRIS',\n    label: 'Informatique et Réseau pour les Industries et les Services techniques',\n    start: new Date(2010, 9),\n    end: new Date(2012, 6),\n    color: 'amber'\n}, {\n    type: 'job',\n    company: 'Mairie de Villieu-Loyes-Mollon',\n    job: 'Développeur web',\n    start: new Date(2012, 7),\n    end: new Date(2012, 7),\n    color: 'teal'\n}, {\n    type: 'job',\n    company: 'Vente privée',\n    job: 'Employé polyvalent',\n    start: new Date(2012, 8),\n    end: new Date(2012, 8),\n    color: 'blue-weak'\n}, {\n    type: 'alternance',\n    diplome: 'Licence professionnel IEM',\n    label: 'Informatique Embarquée et Mobile',\n    company: 'Urban Link / Meden Agan',\n    job: 'Développeur web & mobile',\n    start: new Date(2012, 9),\n    end: new Date(2013, 9),\n    color: 'blue'\n}, {\n    type: 'job',\n    company: 'Wanadev',\n    job: 'Développeur web',\n    start: new Date(2014, 4),\n    end: new Date(),\n    color: 'purple-deep'\n}];\n\nvar History = function (_Component) {\n    _inherits(History, _Component);\n\n    function History() {\n        var _ref;\n\n        var _temp, _this, _ret;\n\n        _classCallCheck(this, History);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = History.__proto__ || Object.getPrototypeOf(History)).call.apply(_ref, [this].concat(args))), _this), _this.state = { experiences: EXPERIENCES }, _temp), _possibleConstructorReturn(_this, _ret);\n    }\n\n    _createClass(History, [{\n        key: 'render',\n        value: function render() {\n            var _this2 = this;\n\n            return _react2.default.createElement(\n                'article',\n                { id: 'history', className: 'history__view view' },\n                _react2.default.createElement(\n                    'article',\n                    { className: 'container' },\n                    _react2.default.createElement(\n                        'article',\n                        { className: 'row justify-content-center' },\n                        _react2.default.createElement(\n                            'section',\n                            { className: 'col-12 col-lg-11 col-xl-9' },\n                            _react2.default.createElement(\n                                'h3',\n                                null,\n                                'Formations && Exp\\xE9riences'\n                            ),\n                            _react2.default.createElement(\n                                'section',\n                                { className: 'history' },\n                                _react2.default.createElement(\n                                    'section',\n                                    { className: 'history__graph' },\n                                    _react2.default.createElement(\n                                        'aside',\n                                        { className: 'history__graph--aside' },\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2008'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2009'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2010'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2011'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2012'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2013'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2014'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2015'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2016'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2017'\n                                        ),\n                                        _react2.default.createElement(\n                                            'b',\n                                            { className: 'history__graph--year' },\n                                            '2018'\n                                        )\n                                    ),\n                                    _react2.default.createElement(\n                                        'section',\n                                        { className: 'history__graph--content' },\n                                        _react2.default.createElement(\n                                            'header',\n                                            { className: 'history__graph--header' },\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Janvier'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'F\\xE9vrier'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Mars'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Avril'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Mai'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Juin'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Juillet'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Ao\\xFBt'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Septembre'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Octobre'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'Novembre'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'section',\n                                                { className: 'history__graph--month' },\n                                                _react2.default.createElement(\n                                                    'i',\n                                                    { className: 'history__graph--month--content' },\n                                                    'D\\xE9cembre'\n                                                )\n                                            )\n                                        ),\n                                        _react2.default.createElement(\n                                            'article',\n                                            { className: 'history__graph--table' },\n                                            [].concat(_toConsumableArray(Array(new Date().getFullYear() - 2007))).map(function (a, y) {\n                                                return _react2.default.createElement(\n                                                    'section',\n                                                    { key: _uuid2.default.v4(), className: 'history__graph--line' },\n                                                    [].concat(_toConsumableArray(Array(12))).map(function (a, x) {\n                                                        var date = new Date(2008 + y, x + 1);\n                                                        var experience = _this2.state.experiences.find(function (experience) {\n                                                            return date.getTime() >= experience.start.getTime() && date.getTime() <= experience.end.getTime();\n                                                        });\n\n                                                        var color = experience ? experience.color : 'petrol';\n                                                        if (date.getTime() < _this2.state.experiences[0].start.getTime()) {\n                                                            color = 'petrol-200';\n                                                        }\n                                                        if (date.getTime() > _this2.state.experiences[_this2.state.experiences.length - 1].end.getTime()) {\n                                                            color = 'petrol-100';\n                                                        }\n\n                                                        var classes = (0, _classnames2.default)('history__graph--case', color && 'text-' + color);\n                                                        var icon = _react2.default.createElement('span', { className: 'far fa-square fa-2x fa-fw' });\n                                                        if (experience && experience.type == 'formation') {\n                                                            icon = _react2.default.createElement(\n                                                                'span',\n                                                                { className: 'fa-stack' },\n                                                                _react2.default.createElement('span', { className: 'fas fa-graduation-cap fa-stack-1x fa-fw' }),\n                                                                _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                            );\n                                                        } else if (experience && experience.type == 'job') {\n                                                            icon = _react2.default.createElement(\n                                                                'span',\n                                                                { className: 'fa-stack' },\n                                                                _react2.default.createElement('span', { className: 'fas fa-flask fa-stack-1x fa-1x fa-fw' }),\n                                                                _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                            );\n                                                        } else if (experience && experience.type == 'alternance') {\n                                                            icon = _react2.default.createElement(\n                                                                'span',\n                                                                { className: 'fa-stack' },\n                                                                _react2.default.createElement('span', { className: 'fas fa-star-half-alt fa-stack-1x fa-1x fa-fw' }),\n                                                                _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                            );\n                                                        }\n\n                                                        return _react2.default.createElement(\n                                                            'section',\n                                                            { key: _uuid2.default.v4(), className: classes },\n                                                            icon\n                                                        );\n                                                    })\n                                                );\n                                            })\n                                        ),\n                                        _react2.default.createElement(\n                                            'footer',\n                                            { className: 'history__legend' },\n                                            _react2.default.createElement(\n                                                'article',\n                                                { className: 'history__legend--item' },\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'fa-stack' },\n                                                    _react2.default.createElement('span', { className: 'fas fa-graduation-cap fa-stack-1x fa-fw' }),\n                                                    _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                ),\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'history__legend--label' },\n                                                    'Formation'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'article',\n                                                { className: 'history__legend--item' },\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'fa-stack' },\n                                                    _react2.default.createElement('span', { className: 'fas fa-flask fa-stack-1x fa-1x fa-fw' }),\n                                                    _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                ),\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'history__legend--label' },\n                                                    'Exp\\xE9rience'\n                                                )\n                                            ),\n                                            _react2.default.createElement(\n                                                'article',\n                                                { className: 'history__legend--item' },\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'fa-stack' },\n                                                    _react2.default.createElement('span', { className: 'fas fa-star-half-alt fa-stack-1x fa-1x fa-fw' }),\n                                                    _react2.default.createElement('span', { className: 'far fa-square fa-stack-1x fa-2x fa-fw' })\n                                                ),\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: 'history__legend--label' },\n                                                    'Alternance'\n                                                )\n                                            )\n                                        )\n                                    )\n                                ),\n                                _react2.default.createElement(\n                                    'section',\n                                    { className: 'history__list' },\n                                    _react2.default.createElement(\n                                        'ul',\n                                        { className: 'fa-ul' },\n                                        this.state.experiences.map(function (experience) {\n                                            var classes = (0, _classnames2.default)('fa-li', 'text-' + experience.color);\n                                            return _react2.default.createElement(\n                                                'li',\n                                                { key: _uuid2.default.v4(), className: 'history__list--item' },\n                                                _react2.default.createElement(\n                                                    'span',\n                                                    { className: classes },\n                                                    _react2.default.createElement('span', { className: 'fas fa-square' })\n                                                ),\n                                                _react2.default.createElement(ExperienceDetail, { experience: experience })\n                                            );\n                                        })\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return History;\n}(_react.Component);\n\nexports.default = History;\n\nvar ExperienceDetail = exports.ExperienceDetail = function (_Component2) {\n    _inherits(ExperienceDetail, _Component2);\n\n    function ExperienceDetail() {\n        _classCallCheck(this, ExperienceDetail);\n\n        return _possibleConstructorReturn(this, (ExperienceDetail.__proto__ || Object.getPrototypeOf(ExperienceDetail)).apply(this, arguments));\n    }\n\n    _createClass(ExperienceDetail, [{\n        key: 'render',\n        value: function render() {\n            var experience = this.props.experience;\n\n\n            switch (experience.type) {\n                case 'formation':\n                    return _react2.default.createElement(\n                        'p',\n                        null,\n                        _react2.default.createElement(\n                            'i',\n                            null,\n                            experience.diplome\n                        ),\n                        _react2.default.createElement('br', null),\n                        _react2.default.createElement(\n                            'small',\n                            { className: 'text-muted' },\n                            experience.label\n                        ),\n                        _react2.default.createElement(\n                            'small',\n                            { className: 'history__date text-muted' },\n                            _react2.default.createElement(\n                                'i',\n                                null,\n                                experience.start.getMonth().toString().padStart(2, '0'),\n                                '/',\n                                experience.start.getFullYear().toString().padStart(2, '0'),\n                                ' ',\n                                '\\u2192',\n                                ' ',\n                                experience.end.getMonth().toString().padStart(2, '0'),\n                                '/',\n                                experience.end.getFullYear().toString().padStart(2, '0')\n                            )\n                        )\n                    );\n                case 'job':\n                    return _react2.default.createElement(\n                        'p',\n                        null,\n                        _react2.default.createElement(\n                            'b',\n                            null,\n                            experience.job\n                        ),\n                        _react2.default.createElement('br', null),\n                        _react2.default.createElement(\n                            'small',\n                            { className: 'text-muted' },\n                            experience.company\n                        ),\n                        _react2.default.createElement(\n                            'small',\n                            { className: 'history__date text-muted' },\n                            _react2.default.createElement(\n                                'i',\n                                null,\n                                experience.start.getMonth().toString().padStart(2, '0'),\n                                '/',\n                                experience.start.getFullYear().toString().padStart(2, '0'),\n                                ' ',\n                                '\\u2192',\n                                ' ',\n                                experience.end.getMonth().toString().padStart(2, '0'),\n                                '/',\n                                experience.end.getFullYear().toString().padStart(2, '0')\n                            )\n                        )\n                    );\n                case 'alternance':\n                    return _react2.default.createElement(\n                        _react.Fragment,\n                        null,\n                        _react2.default.createElement(\n                            'p',\n                            null,\n                            _react2.default.createElement(\n                                'i',\n                                null,\n                                experience.diplome\n                            ),\n                            _react2.default.createElement('br', null),\n                            _react2.default.createElement(\n                                'small',\n                                { className: 'text-muted' },\n                                experience.label\n                            )\n                        ),\n                        _react2.default.createElement('hr', null),\n                        _react2.default.createElement(\n                            'p',\n                            null,\n                            _react2.default.createElement(\n                                'b',\n                                null,\n                                experience.job\n                            ),\n                            _react2.default.createElement('br', null),\n                            _react2.default.createElement(\n                                'small',\n                                { className: 'text-muted' },\n                                experience.company\n                            ),\n                            _react2.default.createElement(\n                                'small',\n                                { className: 'history__date text-muted' },\n                                _react2.default.createElement(\n                                    'i',\n                                    null,\n                                    experience.start.getMonth().toString().padStart(2, '0'),\n                                    '/',\n                                    experience.start.getFullYear().toString().padStart(2, '0'),\n                                    ' ',\n                                    '\\u2192',\n                                    ' ',\n                                    experience.end.getMonth().toString().padStart(2, '0'),\n                                    '/',\n                                    experience.end.getFullYear().toString().padStart(2, '0')\n                                )\n                            )\n                        )\n                    );\n            }\n            return null;\n        }\n    }]);\n\n    return ExperienceDetail;\n}(_react.Component);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY29tcG9uZW50cy9oaXN0b3J5LmpzeC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvY29tcG9uZW50cy9oaXN0b3J5LmpzeD81NTRhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgdXVpZCBmcm9tICd1dWlkJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IENsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmNvbnN0IEVYUEVSSUVOQ0VTID0gW3tcbiAgICB0eXBlOiAnZm9ybWF0aW9uJyxcbiAgICBkaXBsb21lOiAnQmFjIFNUSSBHRScsXG4gICAgbGFiZWw6ICdTY2llbmNlcyBldCBUZWNobmlxdWVzIEluZHVzdHJpZWxcXG5PcHRpb24gR8OpbmllIMOJbGVjdHJvbmlxdWUnLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDA4LCA5KSxcbiAgICBlbmQ6IG5ldyBEYXRlKDIwMTAsIDYpLFxuICAgIGNvbG9yOiAncmVkJyxcbn0sIHtcbiAgICB0eXBlOiAnam9iJyxcbiAgICBjb21wYW55OiAnTWFjIERvbmFsZFxcJ3MnLFxuICAgIGpvYjogJ8OJcXVpcGllciBwb2x5dmFsZW50JyxcbiAgICBzdGFydDogbmV3IERhdGUoMjAxMCwgNyksXG4gICAgZW5kOiBuZXcgRGF0ZSgyMDEwLCA4KSxcbiAgICBjb2xvcjogJ29yYW5nZScsXG59LCB7XG4gICAgdHlwZTogJ2Zvcm1hdGlvbicsXG4gICAgZGlwbG9tZTogJ0JUUyBJUklTJyxcbiAgICBsYWJlbDogJ0luZm9ybWF0aXF1ZSBldCBSw6lzZWF1IHBvdXIgbGVzIEluZHVzdHJpZXMgZXQgbGVzIFNlcnZpY2VzIHRlY2huaXF1ZXMnLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDEwLCA5KSxcbiAgICBlbmQ6IG5ldyBEYXRlKDIwMTIsIDYpLFxuICAgIGNvbG9yOiAnYW1iZXInLFxufSwge1xuICAgIHR5cGU6ICdqb2InLFxuICAgIGNvbXBhbnk6ICdNYWlyaWUgZGUgVmlsbGlldS1Mb3llcy1Nb2xsb24nLFxuICAgIGpvYjogJ0TDqXZlbG9wcGV1ciB3ZWInLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDEyLCA3KSxcbiAgICBlbmQ6IG5ldyBEYXRlKDIwMTIsIDcpLFxuICAgIGNvbG9yOiAndGVhbCcsXG59LCB7XG4gICAgdHlwZTogJ2pvYicsXG4gICAgY29tcGFueTogJ1ZlbnRlIHByaXbDqWUnLFxuICAgIGpvYjogJ0VtcGxvecOpIHBvbHl2YWxlbnQnLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDEyLCA4KSxcbiAgICBlbmQ6IG5ldyBEYXRlKDIwMTIsIDgpLFxuICAgIGNvbG9yOiAnYmx1ZS13ZWFrJyxcbn0sIHtcbiAgICB0eXBlOiAnYWx0ZXJuYW5jZScsXG4gICAgZGlwbG9tZTogJ0xpY2VuY2UgcHJvZmVzc2lvbm5lbCBJRU0nLFxuICAgIGxhYmVsOiAnSW5mb3JtYXRpcXVlIEVtYmFycXXDqWUgZXQgTW9iaWxlJyxcbiAgICBjb21wYW55OiAnVXJiYW4gTGluayAvIE1lZGVuIEFnYW4nLFxuICAgIGpvYjogJ0TDqXZlbG9wcGV1ciB3ZWIgJiBtb2JpbGUnLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDEyLCA5KSxcbiAgICBlbmQ6IG5ldyBEYXRlKDIwMTMsIDkpLFxuICAgIGNvbG9yOiAnYmx1ZScsXG59LCB7XG4gICAgdHlwZTogJ2pvYicsXG4gICAgY29tcGFueTogJ1dhbmFkZXYnLFxuICAgIGpvYjogJ0TDqXZlbG9wcGV1ciB3ZWInLFxuICAgIHN0YXJ0OiBuZXcgRGF0ZSgyMDE0LCA0KSxcbiAgICBlbmQ6IG5ldyBEYXRlKCksXG4gICAgY29sb3I6ICdwdXJwbGUtZGVlcCcsXG59XTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGlzdG9yeSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGUgPSB7IGV4cGVyaWVuY2VzOiBFWFBFUklFTkNFUyB9O1xuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPGFydGljbGUgaWQ9XCJoaXN0b3J5XCIgY2xhc3NOYW1lPVwiaGlzdG9yeV9fdmlldyB2aWV3XCI+XG4gICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJyb3cganVzdGlmeS1jb250ZW50LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjb2wtMTIgY29sLWxnLTExIGNvbC14bC05XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDM+Rm9ybWF0aW9ucyAmJiBFeHDDqXJpZW5jZXM8L2gzPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiaGlzdG9yeVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhc2lkZSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tYXNpZGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAwODwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAwOTwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxMDwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxMTwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxMjwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxMzwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxNDwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxNTwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxNjwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxNzwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS15ZWFyXCI+MjAxODwvYj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hc2lkZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGgtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEphbnZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGw6l2cmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGgtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdnJpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGgtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1haVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGgtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEp1aW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKdWlsbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aC0tY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW/Du3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXB0ZW1icmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPY3RvYnJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImhpc3RvcnlfX2dyYXBoLS1tb250aC0tY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm92ZW1icmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbW9udGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLW1vbnRoLS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEw6ljZW1icmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaGVhZGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZ3JhcGgtLXRhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1suLi5BcnJheSgobmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKSAtIDIwMDcpXS5tYXAoKGEsIHkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzZWN0aW9uIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJoaXN0b3J5X19ncmFwaC0tbGluZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1suLi5BcnJheSgxMildLm1hcCgoYSwgeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgyMDA4ICsgeSwgeCArMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZXJpZW5jZSA9IHRoaXMuc3RhdGUuZXhwZXJpZW5jZXMuZmluZChleHBlcmllbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID49IGV4cGVyaWVuY2Uuc3RhcnQuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXRlLmdldFRpbWUoKSA8PSBleHBlcmllbmNlLmVuZC5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3IgPSBleHBlcmllbmNlID8gZXhwZXJpZW5jZS5jb2xvciA6ICdwZXRyb2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlLmdldFRpbWUoKSA8IHRoaXMuc3RhdGUuZXhwZXJpZW5jZXNbMF0uc3RhcnQuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gJ3BldHJvbC0yMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZS5nZXRUaW1lKCkgPiB0aGlzLnN0YXRlLmV4cGVyaWVuY2VzW3RoaXMuc3RhdGUuZXhwZXJpZW5jZXMubGVuZ3RoIC0xXS5lbmQuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gJ3BldHJvbC0xMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBDbGFzc25hbWVzKCdoaXN0b3J5X19ncmFwaC0tY2FzZScsIGNvbG9yICYmIGB0ZXh0LSR7Y29sb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGljb24gPSA8c3BhbiBjbGFzc05hbWU9XCJmYXIgZmEtc3F1YXJlIGZhLTJ4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBlcmllbmNlICYmIGV4cGVyaWVuY2UudHlwZSA9PSAnZm9ybWF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gPHNwYW4gY2xhc3NOYW1lPVwiZmEtc3RhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1ncmFkdWF0aW9uLWNhcCBmYS1zdGFjay0xeCBmYS1md1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhciBmYS1zcXVhcmUgZmEtc3RhY2stMXggZmEtMnggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cGVyaWVuY2UgJiYgZXhwZXJpZW5jZS50eXBlID09ICdqb2InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSA8c3BhbiBjbGFzc05hbWU9XCJmYS1zdGFja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmFzIGZhLWZsYXNrIGZhLXN0YWNrLTF4IGZhLTF4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmFyIGZhLXNxdWFyZSBmYS1zdGFjay0xeCBmYS0yeCBmYS1md1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZXJpZW5jZSAmJiBleHBlcmllbmNlLnR5cGUgPT0gJ2FsdGVybmFuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSA8c3BhbiBjbGFzc05hbWU9XCJmYS1zdGFja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmFzIGZhLXN0YXItaGFsZi1hbHQgZmEtc3RhY2stMXggZmEtMXggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXIgZmEtc3F1YXJlIGZhLXN0YWNrLTF4IGZhLTJ4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzZWN0aW9uIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvb3RlciBjbGFzc05hbWU9XCJoaXN0b3J5X19sZWdlbmRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJoaXN0b3J5X19sZWdlbmQtLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEtc3RhY2tcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1ncmFkdWF0aW9uLWNhcCBmYS1zdGFjay0xeCBmYS1md1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhciBmYS1zcXVhcmUgZmEtc3RhY2stMXggZmEtMnggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGVnZW5kLS1sYWJlbFwiPkZvcm1hdGlvbjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGVnZW5kLS1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhLXN0YWNrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXMgZmEtZmxhc2sgZmEtc3RhY2stMXggZmEtMXggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXIgZmEtc3F1YXJlIGZhLXN0YWNrLTF4IGZhLTJ4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImhpc3RvcnlfX2xlZ2VuZC0tbGFiZWxcIj5FeHDDqXJpZW5jZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFydGljbGUgY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGVnZW5kLS1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhLXN0YWNrXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXMgZmEtc3Rhci1oYWxmLWFsdCBmYS1zdGFjay0xeCBmYS0xeCBmYS1md1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhciBmYS1zcXVhcmUgZmEtc3RhY2stMXggZmEtMnggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGVnZW5kLS1sYWJlbFwiPkFsdGVybmFuY2U8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hcnRpY2xlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb290ZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGlzdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwiZmEtdWxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmV4cGVyaWVuY2VzLm1hcChleHBlcmllbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gQ2xhc3NuYW1lcygnZmEtbGknLCBgdGV4dC0ke2V4cGVyaWVuY2UuY29sb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxsaSBrZXk9e3V1aWQudjQoKX0gY2xhc3NOYW1lPVwiaGlzdG9yeV9fbGlzdC0taXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmFzIGZhLXNxdWFyZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RXhwZXJpZW5jZURldGFpbCBleHBlcmllbmNlPXtleHBlcmllbmNlfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgIDwvYXJ0aWNsZT47XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRXhwZXJpZW5jZURldGFpbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGV4cGVyaWVuY2UgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgc3dpdGNoIChleHBlcmllbmNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zvcm1hdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxwPlxuICAgICAgICAgICAgICAgICAgICA8aT57ZXhwZXJpZW5jZS5kaXBsb21lfTwvaT48YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzTmFtZT1cInRleHQtbXV0ZWRcIj57ZXhwZXJpZW5jZS5sYWJlbH08L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZGF0ZSB0ZXh0LW11dGVkXCI+PGk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZXhwZXJpZW5jZS5zdGFydC5nZXRNb250aCgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0ve2V4cGVyaWVuY2Uuc3RhcnQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7JyAnfeKGknsnICd9XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZXhwZXJpZW5jZS5lbmQuZ2V0TW9udGgoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9L3tleHBlcmllbmNlLmVuZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1cbiAgICAgICAgICAgICAgICAgICAgPC9pPjwvc21hbGw+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgY2FzZSAnam9iJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gPHA+XG4gICAgICAgICAgICAgICAgICAgIDxiPntleHBlcmllbmNlLmpvYn08L2I+PGJyIC8+XG4gICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJ0ZXh0LW11dGVkXCI+e2V4cGVyaWVuY2UuY29tcGFueX08L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZGF0ZSB0ZXh0LW11dGVkXCI+PGk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZXhwZXJpZW5jZS5zdGFydC5nZXRNb250aCgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0ve2V4cGVyaWVuY2Uuc3RhcnQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7JyAnfeKGknsnICd9XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZXhwZXJpZW5jZS5lbmQuZ2V0TW9udGgoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9L3tleHBlcmllbmNlLmVuZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1cbiAgICAgICAgICAgICAgICAgICAgPC9pPjwvc21hbGw+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgY2FzZSAnYWx0ZXJuYW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aT57ZXhwZXJpZW5jZS5kaXBsb21lfTwvaT48YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJ0ZXh0LW11dGVkXCI+e2V4cGVyaWVuY2UubGFiZWx9PC9zbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Yj57ZXhwZXJpZW5jZS5qb2J9PC9iPjxiciAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzTmFtZT1cInRleHQtbXV0ZWRcIj57ZXhwZXJpZW5jZS5jb21wYW55fTwvc21hbGw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3NOYW1lPVwiaGlzdG9yeV9fZGF0ZSB0ZXh0LW11dGVkXCI+PGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2V4cGVyaWVuY2Uuc3RhcnQuZ2V0TW9udGgoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9L3tleHBlcmllbmNlLnN0YXJ0LmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnICd94oaSeycgJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZXhwZXJpZW5jZS5lbmQuZ2V0TW9udGgoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9L3tleHBlcmllbmNlLmVuZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaT48L3NtYWxsPlxuICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBOzs7Ozs7Ozs7Ozs7OztBQUNBOzs7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVhBO0FBYUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURBO0FBeERBO0FBOERBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBdENBO0FBd0NBO0FBMUNBO0FBNENBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQWZBO0FBM0dBO0FBZEE7QUFrSkE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUpBO0FBTUE7QUFUQTtBQURBO0FBbkpBO0FBRkE7QUFEQTtBQURBO0FBREE7QUEwS0E7Ozs7QUE5S0E7QUFDQTtBQURBO0FBQ0E7QUFnTEE7Ozs7Ozs7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRkE7QUFFQTtBQUNBO0FBSEE7QUFHQTtBQUhBO0FBQUE7QUFIQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRkE7QUFFQTtBQUNBO0FBSEE7QUFHQTtBQUhBO0FBQUE7QUFIQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUVBO0FBQ0E7QUFIQTtBQUdBO0FBSEE7QUFBQTtBQUhBO0FBTkE7QUF0QkE7QUF1Q0E7QUFDQTs7OztBQTVDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./assets/components/history.jsx\n");

/***/ }),

/***/ "./assets/components/navigation.jsx":
/*!******************************************!*\
  !*** ./assets/components/navigation.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactFontawesome = __webpack_require__(/*! @fortawesome/react-fontawesome */ \"./node_modules/@fortawesome/react-fontawesome/index.es.js\");\n\nvar _reactFontawesome2 = _interopRequireDefault(_reactFontawesome);\n\nvar _classnames = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TIMEOUT_SCROLL = 75;\nvar MENU = [{\n    label: 'Présentation',\n    anchor: 'presentation',\n    ref: _react2.default.createRef(),\n    active: true\n}, {\n    label: 'À propos',\n    anchor: 'description',\n    ref: _react2.default.createRef(),\n    active: true\n}, {\n    label: 'Formations && Expériences',\n    anchor: 'history',\n    ref: _react2.default.createRef(),\n    active: false\n}, {\n    label: 'Compétences && Centres d\\'intérêt',\n    anchor: 'skill',\n    ref: _react2.default.createRef(),\n    active: false\n}];\n\nvar Navigation = function (_Component) {\n    _inherits(Navigation, _Component);\n\n    function Navigation() {\n        var _ref;\n\n        _classCallCheck(this, Navigation);\n\n        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n        }\n\n        var _this = _possibleConstructorReturn(this, (_ref = Navigation.__proto__ || Object.getPrototypeOf(Navigation)).call.apply(_ref, [this].concat(params)));\n\n        _this.state = { menu: MENU };\n        _this.scrolling = false;\n        _this.last_scroll = 0;\n\n        _this.onClickItem = function () {\n            _this.scrolling = true;\n\n            setTimeout(function () {\n                _this.refreshMenu();\n                _this.scrolling = false;\n            }, TIMEOUT_SCROLL);\n        };\n\n        _this.refreshMenu = function () {\n            var anchor = _this.anchor;\n            var menu = [].concat(_toConsumableArray(_this.state.menu));\n            var current = 0;\n            for (var index in menu) {\n                menu[index].active = false;\n                if (_this.top >= menu[index].position.top) {\n                    current = index;\n                }\n            }\n            menu[current].active = true;\n            _this.setState({ menu: menu });\n        };\n\n        _this.refreshPosition = function () {\n            var menu = [].concat(_toConsumableArray(_this.state.menu));\n            for (var index in menu) {\n                menu[index].position = document.getElementById(menu[index].anchor).getBoundingClientRect();\n            }\n            _this.setState({ menu: menu });\n        };\n\n        _this.top = 0;\n        return _this;\n    }\n\n    _createClass(Navigation, [{\n        key: 'render',\n        value: function render() {\n            var _this2 = this;\n\n            var classes = (0, _classnames2.default)(\"navigation\", this.top <= window.innerHeight / 2 ? 'navigation--light' : 'navigation--dark');\n            return _react2.default.createElement(\n                'nav',\n                { className: classes },\n                this.state.menu.map(function (item, index) {\n                    var classes = (0, _classnames2.default)(\"navigation__link\", item.active && \"active\");\n                    return _react2.default.createElement(\n                        'section',\n                        { key: 'nav-item-' + index, ref: item.ref, className: 'navigation__item' },\n                        _react2.default.createElement(\n                            'a',\n                            { className: classes, href: '#' + item.anchor, onClick: _this2.onClickItem },\n                            _react2.default.createElement(\n                                'span',\n                                { className: 'navigation__label mr-2' },\n                                item.label\n                            ),\n                            _react2.default.createElement(_reactFontawesome2.default, { icon: [item.active ? \"fas\" : \"far\", \"circle\"] })\n                        )\n                    );\n                })\n            );\n        }\n    }, {\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            var _this3 = this;\n\n            this.refreshPosition();\n            $(document).ready(function () {\n                window.addEventListener('resize', _this3.refreshPosition, false);\n                window.addEventListener('scroll', _this3.refreshMenu, false);\n                _this3.refreshMenu();\n            });\n        }\n    }, {\n        key: 'anchor',\n        get: function get() {\n            return document.URL.split('#').length > 1 ? document.URL.split('#')[1] : null;\n        }\n    }, {\n        key: 'top',\n        set: function set(top) {\n            if (document.documentElement.scrollTop) {\n                document.documentElement.scrollTop = top;\n            } else if (window.pageYOffset) {\n                window.pageYOffset = top;\n            }\n        },\n        get: function get() {\n            return window.pageYOffset || document.documentElement.scrollTop;\n        }\n    }]);\n\n    return Navigation;\n}(_react.Component);\n\nexports.default = Navigation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uLmpzeC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9hc3NldHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uLmpzeD9kYzAxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEZvbnRBd2Vzb21lSWNvbiBmcm9tICdAZm9ydGF3ZXNvbWUvcmVhY3QtZm9udGF3ZXNvbWUnO1xuaW1wb3J0IENsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmNvbnN0IFRJTUVPVVRfU0NST0xMID0gNzU7XG5jb25zdCBNRU5VID0gW3tcbiAgICBsYWJlbDogJ1Byw6lzZW50YXRpb24nLFxuICAgIGFuY2hvcjogJ3ByZXNlbnRhdGlvbicsXG4gICAgcmVmOiBSZWFjdC5jcmVhdGVSZWYoKSxcbiAgICBhY3RpdmU6IHRydWUsXG59LCB7XG4gICAgbGFiZWw6ICfDgCBwcm9wb3MnLFxuICAgIGFuY2hvcjogJ2Rlc2NyaXB0aW9uJyxcbiAgICByZWY6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgIGFjdGl2ZTogdHJ1ZSxcbn0sIHtcbiAgICBsYWJlbDogJ0Zvcm1hdGlvbnMgJiYgRXhww6lyaWVuY2VzJyxcbiAgICBhbmNob3I6ICdoaXN0b3J5JyxcbiAgICByZWY6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgIGFjdGl2ZTogZmFsc2UsXG59LCB7XG4gICAgbGFiZWw6ICdDb21ww6l0ZW5jZXMgJiYgQ2VudHJlcyBkXFwnaW50w6lyw6p0JyxcbiAgICBhbmNob3I6ICdza2lsbCcsXG4gICAgcmVmOiBSZWFjdC5jcmVhdGVSZWYoKSxcbiAgICBhY3RpdmU6IGZhbHNlLFxufV07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHN0YXRlID0geyBtZW51OiBNRU5VIH07XG5cbiAgICBzY3JvbGxpbmcgPSBmYWxzZTtcbiAgICBsYXN0X3Njcm9sbCA9IDA7XG5cbiAgICBjb25zdHJ1Y3RvciguLi5wYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IENsYXNzbmFtZXMoXCJuYXZpZ2F0aW9uXCIsIHRoaXMudG9wIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKSA/ICduYXZpZ2F0aW9uLS1saWdodCcgOiAnbmF2aWdhdGlvbi0tZGFyaycpO1xuICAgICAgICByZXR1cm4gPG5hdiBjbGFzc05hbWU9e2NsYXNzZXN9PlxuICAgICAgICAgICAge3RoaXMuc3RhdGUubWVudS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IENsYXNzbmFtZXMoXCJuYXZpZ2F0aW9uX19saW5rXCIsIGl0ZW0uYWN0aXZlICYmIFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiA8c2VjdGlvbiBrZXk9e2BuYXYtaXRlbS0ke2luZGV4fWB9IHJlZj17aXRlbS5yZWZ9IGNsYXNzTmFtZT1cIm5hdmlnYXRpb25fX2l0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPXtjbGFzc2VzfSBocmVmPXtgIyR7aXRlbS5hbmNob3J9YH0gb25DbGljaz17dGhpcy5vbkNsaWNrSXRlbX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJuYXZpZ2F0aW9uX19sYWJlbCBtci0yXCI+e2l0ZW0ubGFiZWx9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEZvbnRBd2Vzb21lSWNvbiBpY29uPXtbaXRlbS5hY3RpdmUgPyBcImZhc1wiIDogXCJmYXJcIiwgXCJjaXJjbGVcIl19IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgPC9uYXY+O1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbigpO1xuICAgICAgICAkKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoUG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnJlZnJlc2hNZW51LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hNZW51KCk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgb25DbGlja0l0ZW0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gdHJ1ZTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaE1lbnUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIFRJTUVPVVRfU0NST0xMKTtcbiAgICB9XG5cbiAgICByZWZyZXNoTWVudSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICAgIGNvbnN0IG1lbnUgPSBbLi4udGhpcy5zdGF0ZS5tZW51XTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBtZW51KSB7XG4gICAgICAgICAgICBtZW51W2luZGV4XS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRvcCA+PSBtZW51W2luZGV4XS5wb3NpdGlvbi50b3ApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVudVtjdXJyZW50XS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWVudSB9KTtcbiAgICB9XG5cbiAgICByZWZyZXNoUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lbnUgPSBbLi4udGhpcy5zdGF0ZS5tZW51XTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gbWVudSkge1xuICAgICAgICAgICAgbWVudVtpbmRleF0ucG9zaXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZW51W2luZGV4XS5hbmNob3IpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtZW51IH0pO1xuICAgIH1cblxuICAgIGdldCBhbmNob3IoKSB7XG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQuVVJMLnNwbGl0KCcjJykubGVuZ3RoID4gMSkgPyBkb2N1bWVudC5VUkwuc3BsaXQoJyMnKVsxXSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2V0IHRvcCh0b3ApIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBhZ2VZT2Zmc2V0KSB7XG4gICAgICAgICAgICB3aW5kb3cucGFnZVlPZmZzZXQgPSB0b3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkRBO0FBcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekRBO0FBRkE7QUFHQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQURBO0FBTUE7QUFUQTtBQVdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBaUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEvRUE7QUFDQTtBQURBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/components/navigation.jsx\n");

/***/ }),

/***/ "./assets/components/presentation.jsx":
/*!********************************************!*\
  !*** ./assets/components/presentation.jsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _jocelynFaihy = __webpack_require__(/*! @images/jocelyn-faihy.png */ \"./assets/images/jocelyn-faihy.png\");\n\nvar _jocelynFaihy2 = _interopRequireDefault(_jocelynFaihy);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Presentation = function (_Component) {\n    _inherits(Presentation, _Component);\n\n    function Presentation() {\n        _classCallCheck(this, Presentation);\n\n        return _possibleConstructorReturn(this, (Presentation.__proto__ || Object.getPrototypeOf(Presentation)).apply(this, arguments));\n    }\n\n    _createClass(Presentation, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement(\n                'article',\n                { id: 'presentation', className: 'presentation h-100vh' },\n                _react2.default.createElement('section', { className: 'presentation__left' }),\n                _react2.default.createElement(\n                    'section',\n                    { className: 'presentation__right' },\n                    _react2.default.createElement(\n                        'article',\n                        { className: 'presentation__text' },\n                        _react2.default.createElement('img', { src: _jocelynFaihy2.default, alt: 'Photo', className: 'rounded-circle', style: { width: '15rem' } }),\n                        _react2.default.createElement('hr', null),\n                        _react2.default.createElement(\n                            'h1',\n                            null,\n                            'Jocelyn Faihy'\n                        ),\n                        _react2.default.createElement(\n                            'h2',\n                            null,\n                            'D\\xE9veloppeur web ',\n                            _react2.default.createElement(\n                                'small',\n                                null,\n                                '(fullstack)'\n                            )\n                        ),\n                        _react2.default.createElement('hr', null),\n                        _react2.default.createElement(\n                            'h4',\n                            null,\n                            'Le code aussi bien visuel que structurel.'\n                        )\n                    ),\n                    _react2.default.createElement('aside', { className: 'presentation__right--arrow' })\n                ),\n                _react2.default.createElement(\n                    'a',\n                    { href: '#description', className: 'presentation__arrow--down' },\n                    _react2.default.createElement('span', { className: 'fas fa-angle-down fa-fw fa-2x' })\n                )\n            );\n        }\n    }]);\n\n    return Presentation;\n}(_react.Component);\n\nexports.default = Presentation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY29tcG9uZW50cy9wcmVzZW50YXRpb24uanN4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Fzc2V0cy9jb21wb25lbnRzL3ByZXNlbnRhdGlvbi5qc3g/ZDhjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBwcm9maWwgZnJvbSAnQGltYWdlcy9qb2NlbHluLWZhaWh5LnBuZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbnRhdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gPGFydGljbGUgaWQ9XCJwcmVzZW50YXRpb25cIiBjbGFzc05hbWU9XCJwcmVzZW50YXRpb24gaC0xMDB2aFwiPlxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwicHJlc2VudGF0aW9uX19sZWZ0XCIgLz5cbiAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInByZXNlbnRhdGlvbl9fcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJwcmVzZW50YXRpb25fX3RleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e3Byb2ZpbH0gYWx0PVwiUGhvdG9cIiBjbGFzc05hbWU9XCJyb3VuZGVkLWNpcmNsZVwiIHN0eWxlPXt7IHdpZHRoOiAnMTVyZW0nIH19IC8+XG4gICAgICAgICAgICAgICAgICAgIDxoci8+XG4gICAgICAgICAgICAgICAgICAgIDxoMT5Kb2NlbHluIEZhaWh5PC9oMT5cbiAgICAgICAgICAgICAgICAgICAgPGgyPkTDqXZlbG9wcGV1ciB3ZWIgPHNtYWxsPihmdWxsc3RhY2spPC9zbWFsbD48L2gyPlxuICAgICAgICAgICAgICAgICAgICA8aHIvPlxuICAgICAgICAgICAgICAgICAgICA8aDQ+TGUgY29kZSBhdXNzaSBiaWVuIHZpc3VlbCBxdWUgc3RydWN0dXJlbC48L2g0PlxuICAgICAgICAgICAgICAgIDwvYXJ0aWNsZT5cbiAgICAgICAgICAgICAgICA8YXNpZGUgY2xhc3NOYW1lPVwicHJlc2VudGF0aW9uX19yaWdodC0tYXJyb3dcIiAvPlxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiNkZXNjcmlwdGlvblwiIGNsYXNzTmFtZT1cInByZXNlbnRhdGlvbl9fYXJyb3ctLWRvd25cIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXMgZmEtYW5nbGUtZG93biBmYS1mdyBmYS0yeFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9hcnRpY2xlPjtcbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFOQTtBQVFBO0FBVEE7QUFXQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBYkE7QUFpQkE7Ozs7QUFuQkE7QUFDQTtBQURBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/components/presentation.jsx\n");

/***/ }),

/***/ "./assets/components/skill.jsx":
/*!*************************************!*\
  !*** ./assets/components/skill.jsx ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _uuid = __webpack_require__(/*! uuid */ \"./node_modules/uuid/index.js\");\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar LEVELS = ['Novice', 'Débutant', 'Intermédiaire', 'Qualifié', 'Expérimenté'];\nvar LOVES = ['Boarf.', 'Mouais...', 'Top !'];\n\nvar SKILLS = [{ name: 'PHP', type: 'language', level: 4 }, { name: 'MySQL', type: 'language', level: 4 }, { name: 'PostgreSQL', type: 'language', level: 4 }, { name: 'Javascript', type: 'language', level: 4 }, { name: 'HTML5', type: 'language', level: 4 }, { name: 'CSS3', type: 'language', level: 4 }, { name: 'SASS', type: 'language', level: 4 }, { name: 'LESS', type: 'language', level: 4 }, { name: 'XML', type: 'language', level: 4 }, { name: 'CSV', type: 'language', level: 4 }, { name: 'Bash', type: 'language', level: 3 }, { name: 'Java', type: 'language', level: 2 }, { name: 'C#', type: 'language', level: 2 }, { name: 'C++', type: 'language', level: 2 }, { name: 'Objective-C', type: 'language', level: 1 }, { name: 'Python', type: 'language', level: 1 }, { name: 'Go', type: 'language', level: 0 }, { name: 'Symfony', type: 'framework', level: 4 }, { name: 'Doctrine', type: 'framework', level: 4 }, { name: 'React', type: 'framework', level: 4 }, { name: 'Node', type: 'framework', level: 4 }, { name: 'Socket.IO', type: 'framework', level: 4 }, { name: 'Bootstrap', type: 'framework', level: 4 }, { name: 'FontAwesome', type: 'framework', level: 4 }, { name: 'jQuery', type: 'framework', level: 4 }, { name: 'ChartJS', type: 'framework', level: 4 }, { name: 'Webpack', type: 'framework', level: 3 }, { name: 'BabylonJS', type: 'framework', level: 2 }, { name: 'WebGL', type: 'framework', level: 1 }, { name: 'ThreeJS', type: 'framework', level: 1 }, { name: 'Docker', type: 'tool', level: 4 }, { name: 'Docker Compose', type: 'tool', level: 4 }, { name: 'RabbitMQ', type: 'tool', level: 4 }, { name: 'Redis', type: 'tool', level: 4 }, { name: 'Paint', type: 'tool', level: 3 }, { name: 'Gimp', type: 'tool', level: 1 }, { name: 'Blender', type: 'tool', level: 0 }, { name: 'Photoshop', type: 'tool', level: 0 }, { name: 'Sublime Text', type: 'editor', level: 2 }, { name: 'VIM', type: 'editor', level: 2 }, { name: 'Nano', type: 'editor', level: 2 }, { name: 'Notepad++', type: 'editor', level: 1 }, { name: 'VS Code', type: 'editor', level: 1 }, { name: 'PHP Storm', type: 'editor', level: 0 }, { name: 'Google', type: 'research', level: 2 }, { name: 'StackOverflow', type: 'research', level: 2 }, { name: 'OpenClassrooms (Site du Zéro)', type: 'research', level: 1 }, { name: 'Mozilla Firefox', type: 'navigator', level: 2 }, { name: 'Google Chrome', type: 'navigator', level: 2 }, { name: 'Vivaldi', type: 'navigator', level: 2 }, { name: 'Safari', type: 'navigator', level: 1 }, { name: 'Edge', type: 'navigator', level: 1 }, { name: 'Internet Explorer', type: 'navigator', level: 0 }];\n\nvar Skills = function (_Component) {\n    _inherits(Skills, _Component);\n\n    function Skills() {\n        var _ref;\n\n        var _temp, _this, _ret;\n\n        _classCallCheck(this, Skills);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Skills.__proto__ || Object.getPrototypeOf(Skills)).call.apply(_ref, [this].concat(args))), _this), _this.state = { skills: SKILLS }, _temp), _possibleConstructorReturn(_this, _ret);\n    }\n\n    _createClass(Skills, [{\n        key: 'render',\n        value: function render() {\n            var _this2 = this;\n\n            return _react2.default.createElement(\n                'article',\n                { id: 'skill', className: 'skill__view view' },\n                _react2.default.createElement(\n                    'article',\n                    { className: 'container' },\n                    _react2.default.createElement(\n                        'h3',\n                        null,\n                        'Comp\\xE9tences && Centres d\\'int\\xE9r\\xEAt'\n                    ),\n                    _react2.default.createElement(\n                        'table',\n                        { className: 'table table-bordered table-hover table-sm table-striped my-3' },\n                        _react2.default.createElement(\n                            'thead',\n                            null,\n                            _react2.default.createElement(\n                                'tr',\n                                null,\n                                _react2.default.createElement('th', null),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'Langage'\n                                ),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'Biblioth\\xE8que && Framework'\n                                ),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'Outil'\n                                )\n                            )\n                        ),\n                        _react2.default.createElement(\n                            'tbody',\n                            null,\n                            LEVELS.map(function (label, level) {\n                                return _react2.default.createElement(\n                                    'tr',\n                                    { key: _uuid2.default.v4() },\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        label\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'language';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-dark mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'framework';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-secondary mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'tool';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-light mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    )\n                                );\n                            }).reverse()\n                        )\n                    ),\n                    _react2.default.createElement(\n                        'table',\n                        { className: 'table table-bordered table-hover table-sm table-striped my-3' },\n                        _react2.default.createElement(\n                            'thead',\n                            null,\n                            _react2.default.createElement(\n                                'tr',\n                                null,\n                                _react2.default.createElement('th', null),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'Moteur de recherche'\n                                ),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'IDE / \\xC9diteur'\n                                ),\n                                _react2.default.createElement(\n                                    'th',\n                                    null,\n                                    'Navigateur'\n                                )\n                            )\n                        ),\n                        _react2.default.createElement(\n                            'tbody',\n                            null,\n                            LOVES.map(function (label, level) {\n                                return _react2.default.createElement(\n                                    'tr',\n                                    { key: _uuid2.default.v4() },\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        label\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'research';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-dark mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'editor';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-secondary mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    ),\n                                    _react2.default.createElement(\n                                        'td',\n                                        null,\n                                        _this2.state.skills.filter(function (skill) {\n                                            return skill.level == level && skill.type == 'navigator';\n                                        }).map(function (skill) {\n                                            return _react2.default.createElement(\n                                                'span',\n                                                { key: _uuid2.default.v4(), className: 'badge badge-pill badge-light mx-1' },\n                                                skill.name\n                                            );\n                                        })\n                                    )\n                                );\n                            }).reverse()\n                        )\n                    ),\n                    _react2.default.createElement(\n                        'section',\n                        { className: 'row my-3' },\n                        _react2.default.createElement(\n                            'aside',\n                            { className: 'col-2' },\n                            _react2.default.createElement(\n                                'span',\n                                { className: 'fa-stack fa-2x' },\n                                _react2.default.createElement('span', { className: 'far fa-circle fa-stack-1x fa-2x fa-fw' }),\n                                _react2.default.createElement('span', { className: 'fas fa-language fa-stack-1x fa-fw' })\n                            )\n                        ),\n                        _react2.default.createElement(\n                            'section',\n                            { className: 'col-4' },\n                            _react2.default.createElement(\n                                'b',\n                                null,\n                                'Fran\\xE7ais :'\n                            ),\n                            ' lu, \\xE9crit, parl\\xE9',\n                            _react2.default.createElement('br', null),\n                            _react2.default.createElement(\n                                'b',\n                                null,\n                                'Anglais :'\n                            ),\n                            ' lu, \\xE9crit, parl\\xE9',\n                            _react2.default.createElement('br', null),\n                            _react2.default.createElement(\n                                'b',\n                                null,\n                                'Espagnol :'\n                            ),\n                            ' lu',\n                            _react2.default.createElement('br', null),\n                            _react2.default.createElement(\n                                'b',\n                                null,\n                                'Japonais :'\n                            ),\n                            ' notion',\n                            _react2.default.createElement('br', null)\n                        ),\n                        _react2.default.createElement(\n                            'aside',\n                            { className: 'col-2' },\n                            _react2.default.createElement(\n                                'span',\n                                { className: 'fa-stack fa-2x' },\n                                _react2.default.createElement('span', { className: 'far fa-circle fa-stack-1x fa-2x fa-fw' }),\n                                _react2.default.createElement('span', { className: 'fas fa-info fa-stack-1x fa-fw' })\n                            )\n                        ),\n                        _react2.default.createElement(\n                            'section',\n                            { className: 'col-4' },\n                            _react2.default.createElement(\n                                'ul',\n                                { className: 'm-0 p-0' },\n                                _react2.default.createElement(\n                                    'li',\n                                    { className: 'd-inline-block mx-1' },\n                                    _react2.default.createElement('span', { className: 'fas fa-angle-right fa-fw' }),\n                                    ' Lecture / Mangas'\n                                ),\n                                _react2.default.createElement(\n                                    'li',\n                                    { className: 'd-inline-block mx-1' },\n                                    _react2.default.createElement('span', { className: 'fas fa-angle-right fa-fw' }),\n                                    ' Gadget'\n                                ),\n                                _react2.default.createElement(\n                                    'li',\n                                    { className: 'd-inline-block mx-1' },\n                                    _react2.default.createElement('span', { className: 'fas fa-angle-right fa-fw' }),\n                                    ' Jardin / Potager'\n                                ),\n                                _react2.default.createElement(\n                                    'li',\n                                    { className: 'd-inline-block mx-1' },\n                                    _react2.default.createElement('span', { className: 'fas fa-angle-right fa-fw' }),\n                                    ' Jeux vid\\xE9os'\n                                ),\n                                _react2.default.createElement(\n                                    'li',\n                                    { className: 'd-inline-block mx-1' },\n                                    _react2.default.createElement('span', { className: 'fas fa-angle-right fa-fw' }),\n                                    ' Gastronomie'\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n        }\n    }]);\n\n    return Skills;\n}(_react.Component);\n\nexports.default = Skills;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvY29tcG9uZW50cy9za2lsbC5qc3guanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYXNzZXRzL2NvbXBvbmVudHMvc2tpbGwuanN4P2E1ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXVpZCBmcm9tICd1dWlkJztcblxuY29uc3QgTEVWRUxTID0gWydOb3ZpY2UnLCAnRMOpYnV0YW50JywgJ0ludGVybcOpZGlhaXJlJywgJ1F1YWxpZmnDqScsICdFeHDDqXJpbWVudMOpJ107XG5jb25zdCBMT1ZFUyA9IFsnQm9hcmYuJywgJ01vdWFpcy4uLicsICdUb3AgISddO1xuXG5jb25zdCBTS0lMTFMgPSBbXG4gICAgeyBuYW1lOiAnUEhQJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdNeVNRTCcsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnUG9zdGdyZVNRTCcsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnSmF2YXNjcmlwdCcsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnSFRNTDUnLCB0eXBlOiAnbGFuZ3VhZ2UnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ0NTUzMnLCB0eXBlOiAnbGFuZ3VhZ2UnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ1NBU1MnLCB0eXBlOiAnbGFuZ3VhZ2UnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ0xFU1MnLCB0eXBlOiAnbGFuZ3VhZ2UnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ1hNTCcsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnQ1NWJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdCYXNoJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDMgfSxcbiAgICB7IG5hbWU6ICdKYXZhJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDIgfSxcbiAgICB7IG5hbWU6ICdDIycsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiAyIH0sXG4gICAgeyBuYW1lOiAnQysrJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDIgfSxcbiAgICB7IG5hbWU6ICdPYmplY3RpdmUtQycsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiAxIH0sXG4gICAgeyBuYW1lOiAnUHl0aG9uJywgdHlwZTogJ2xhbmd1YWdlJywgbGV2ZWw6IDEgfSxcbiAgICB7IG5hbWU6ICdHbycsIHR5cGU6ICdsYW5ndWFnZScsIGxldmVsOiAwIH0sXG5cbiAgICB7IG5hbWU6ICdTeW1mb255JywgdHlwZTogJ2ZyYW1ld29yaycsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnRG9jdHJpbmUnLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdSZWFjdCcsIHR5cGU6ICdmcmFtZXdvcmsnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ05vZGUnLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdTb2NrZXQuSU8nLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdCb290c3RyYXAnLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdGb250QXdlc29tZScsIHR5cGU6ICdmcmFtZXdvcmsnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ2pRdWVyeScsIHR5cGU6ICdmcmFtZXdvcmsnLCBsZXZlbDogNCB9LFxuICAgIHsgbmFtZTogJ0NoYXJ0SlMnLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDQgfSxcbiAgICB7IG5hbWU6ICdXZWJwYWNrJywgdHlwZTogJ2ZyYW1ld29yaycsIGxldmVsOiAzIH0sXG4gICAgeyBuYW1lOiAnQmFieWxvbkpTJywgdHlwZTogJ2ZyYW1ld29yaycsIGxldmVsOiAyIH0sXG4gICAgeyBuYW1lOiAnV2ViR0wnLCB0eXBlOiAnZnJhbWV3b3JrJywgbGV2ZWw6IDEgfSxcbiAgICB7IG5hbWU6ICdUaHJlZUpTJywgdHlwZTogJ2ZyYW1ld29yaycsIGxldmVsOiAxIH0sXG5cbiAgICB7IG5hbWU6ICdEb2NrZXInLCB0eXBlOiAndG9vbCcsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnRG9ja2VyIENvbXBvc2UnLCB0eXBlOiAndG9vbCcsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnUmFiYml0TVEnLCB0eXBlOiAndG9vbCcsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnUmVkaXMnLCB0eXBlOiAndG9vbCcsIGxldmVsOiA0IH0sXG4gICAgeyBuYW1lOiAnUGFpbnQnLCB0eXBlOiAndG9vbCcsIGxldmVsOiAzIH0sXG4gICAgeyBuYW1lOiAnR2ltcCcsIHR5cGU6ICd0b29sJywgbGV2ZWw6IDEgfSxcbiAgICB7IG5hbWU6ICdCbGVuZGVyJywgdHlwZTogJ3Rvb2wnLCBsZXZlbDogMCB9LFxuICAgIHsgbmFtZTogJ1Bob3Rvc2hvcCcsIHR5cGU6ICd0b29sJywgbGV2ZWw6IDAgfSxcblxuICAgIHsgbmFtZTogJ1N1YmxpbWUgVGV4dCcsIHR5cGU6ICdlZGl0b3InLCBsZXZlbDogMiB9LFxuICAgIHsgbmFtZTogJ1ZJTScsIHR5cGU6ICdlZGl0b3InLCBsZXZlbDogMiB9LFxuICAgIHsgbmFtZTogJ05hbm8nLCB0eXBlOiAnZWRpdG9yJywgbGV2ZWw6IDIgfSxcbiAgICB7IG5hbWU6ICdOb3RlcGFkKysnLCB0eXBlOiAnZWRpdG9yJywgbGV2ZWw6IDEgfSxcbiAgICB7IG5hbWU6ICdWUyBDb2RlJywgdHlwZTogJ2VkaXRvcicsIGxldmVsOiAxIH0sXG4gICAgeyBuYW1lOiAnUEhQIFN0b3JtJywgdHlwZTogJ2VkaXRvcicsIGxldmVsOiAwIH0sXG5cbiAgICB7IG5hbWU6ICdHb29nbGUnLCB0eXBlOiAncmVzZWFyY2gnLCBsZXZlbDogMiB9LFxuICAgIHsgbmFtZTogJ1N0YWNrT3ZlcmZsb3cnLCB0eXBlOiAncmVzZWFyY2gnLCBsZXZlbDogMiB9LFxuICAgIHsgbmFtZTogJ09wZW5DbGFzc3Jvb21zIChTaXRlIGR1IFrDqXJvKScsIHR5cGU6ICdyZXNlYXJjaCcsIGxldmVsOiAxIH0sXG5cbiAgICB7IG5hbWU6ICdNb3ppbGxhIEZpcmVmb3gnLCB0eXBlOiAnbmF2aWdhdG9yJywgbGV2ZWw6IDIgfSxcbiAgICB7IG5hbWU6ICdHb29nbGUgQ2hyb21lJywgdHlwZTogJ25hdmlnYXRvcicsIGxldmVsOiAyIH0sXG4gICAgeyBuYW1lOiAnVml2YWxkaScsIHR5cGU6ICduYXZpZ2F0b3InLCBsZXZlbDogMiB9LFxuICAgIHsgbmFtZTogJ1NhZmFyaScsIHR5cGU6ICduYXZpZ2F0b3InLCBsZXZlbDogMSB9LFxuICAgIHsgbmFtZTogJ0VkZ2UnLCB0eXBlOiAnbmF2aWdhdG9yJywgbGV2ZWw6IDEgfSxcbiAgICB7IG5hbWU6ICdJbnRlcm5ldCBFeHBsb3JlcicsIHR5cGU6ICduYXZpZ2F0b3InLCBsZXZlbDogMCB9LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2tpbGxzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0ZSA9IHsgc2tpbGxzOiBTS0lMTFMgfTtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIDxhcnRpY2xlIGlkPVwic2tpbGxcIiBjbGFzc05hbWU9XCJza2lsbF9fdmlldyB2aWV3XCI+XG4gICAgICAgICAgICA8YXJ0aWNsZSBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8aDM+Q29tcMOpdGVuY2VzICYmIENlbnRyZXMgZCdpbnTDqXLDqnQ8L2gzPlxuICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJ0YWJsZSB0YWJsZS1ib3JkZXJlZCB0YWJsZS1ob3ZlciB0YWJsZS1zbSB0YWJsZS1zdHJpcGVkIG15LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD48L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5MYW5nYWdlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGg+QmlibGlvdGjDqHF1ZSAmJiBGcmFtZXdvcms8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5PdXRpbDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7TEVWRUxTLm1hcCgobGFiZWwsIGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e3V1aWQudjQoKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57bGFiZWx9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuc2tpbGxzLmZpbHRlcihza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNraWxsLmxldmVsID09IGxldmVsICYmIHNraWxsLnR5cGUgPT0gJ2xhbmd1YWdlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJiYWRnZSBiYWRnZS1waWxsIGJhZGdlLWRhcmsgbXgtMVwiPntza2lsbC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5za2lsbHMuZmlsdGVyKHNraWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2tpbGwubGV2ZWwgPT0gbGV2ZWwgJiYgc2tpbGwudHlwZSA9PSAnZnJhbWV3b3JrJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJiYWRnZSBiYWRnZS1waWxsIGJhZGdlLXNlY29uZGFyeSBteC0xXCI+e3NraWxsLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnNraWxscy5maWx0ZXIoc2tpbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBza2lsbC5sZXZlbCA9PSBsZXZlbCAmJiBza2lsbC50eXBlID09ICd0b29sJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJiYWRnZSBiYWRnZS1waWxsIGJhZGdlLWxpZ2h0IG14LTFcIj57c2tpbGwubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmV2ZXJzZSgpfVxuICAgICAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWhvdmVyIHRhYmxlLXNtIHRhYmxlLXN0cmlwZWQgbXktM1wiPlxuICAgICAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPjwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPk1vdGV1ciBkZSByZWNoZXJjaGU8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5JREUgLyDDiWRpdGV1cjwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoPk5hdmlnYXRldXI8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICAgICAge0xPVkVTLm1hcCgobGFiZWwsIGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ciBrZXk9e3V1aWQudjQoKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD57bGFiZWx9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuc3RhdGUuc2tpbGxzLmZpbHRlcihza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNraWxsLmxldmVsID09IGxldmVsICYmIHNraWxsLnR5cGUgPT0gJ3Jlc2VhcmNoJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJiYWRnZSBiYWRnZS1waWxsIGJhZGdlLWRhcmsgbXgtMVwiPntza2lsbC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5zdGF0ZS5za2lsbHMuZmlsdGVyKHNraWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2tpbGwubGV2ZWwgPT0gbGV2ZWwgJiYgc2tpbGwudHlwZSA9PSAnZWRpdG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChza2lsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17dXVpZC52NCgpfSBjbGFzc05hbWU9XCJiYWRnZSBiYWRnZS1waWxsIGJhZGdlLXNlY29uZGFyeSBteC0xXCI+e3NraWxsLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLnNraWxscy5maWx0ZXIoc2tpbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBza2lsbC5sZXZlbCA9PSBsZXZlbCAmJiBza2lsbC50eXBlID09ICduYXZpZ2F0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkubWFwKHNraWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPHNwYW4ga2V5PXt1dWlkLnY0KCl9IGNsYXNzTmFtZT1cImJhZGdlIGJhZGdlLXBpbGwgYmFkZ2UtbGlnaHQgbXgtMVwiPntza2lsbC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZXZlcnNlKCl9XG4gICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJyb3cgbXktM1wiPlxuICAgICAgICAgICAgICAgICAgICA8YXNpZGUgY2xhc3NOYW1lPVwiY29sLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhLXN0YWNrIGZhLTJ4XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmFyIGZhLWNpcmNsZSBmYS1zdGFjay0xeCBmYS0yeCBmYS1md1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXMgZmEtbGFuZ3VhZ2UgZmEtc3RhY2stMXggZmEtZndcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYXNpZGU+XG4gICAgICAgICAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImNvbC00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Yj5GcmFuw6dhaXMgOjwvYj4gbHUsIMOpY3JpdCwgcGFybMOpPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Yj5BbmdsYWlzIDo8L2I+IGx1LCDDqWNyaXQsIHBhcmzDqTxiciAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGI+RXNwYWdub2wgOjwvYj4gbHU8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxiPkphcG9uYWlzIDo8L2I+IG5vdGlvbjxiciAvPlxuICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgICAgIDxhc2lkZSBjbGFzc05hbWU9XCJjb2wtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEtc3RhY2sgZmEtMnhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYXIgZmEtY2lyY2xlIGZhLXN0YWNrLTF4IGZhLTJ4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1pbmZvIGZhLXN0YWNrLTF4IGZhLWZ3XCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2FzaWRlPlxuICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjb2wtNFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm0tMCBwLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiZC1pbmxpbmUtYmxvY2sgbXgtMVwiPjxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1hbmdsZS1yaWdodCBmYS1md1wiIC8+IExlY3R1cmUgLyBNYW5nYXM8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJkLWlubGluZS1ibG9jayBteC0xXCI+PHNwYW4gY2xhc3NOYW1lPVwiZmFzIGZhLWFuZ2xlLXJpZ2h0IGZhLWZ3XCIgLz4gR2FkZ2V0PC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiZC1pbmxpbmUtYmxvY2sgbXgtMVwiPjxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1hbmdsZS1yaWdodCBmYS1md1wiIC8+IEphcmRpbiAvIFBvdGFnZXI8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJkLWlubGluZS1ibG9jayBteC0xXCI+PHNwYW4gY2xhc3NOYW1lPVwiZmFzIGZhLWFuZ2xlLXJpZ2h0IGZhLWZ3XCIgLz4gSmV1eCB2aWTDqW9zPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiZC1pbmxpbmUtYmxvY2sgbXgtMVwiPjxzcGFuIGNsYXNzTmFtZT1cImZhcyBmYS1hbmdsZS1yaWdodCBmYS1md1wiIC8+IEdhc3Ryb25vbWllPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICA8L2FydGljbGU+XG4gICAgICAgIDwvYXJ0aWNsZT5cbiAgICB9XG59Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTREQTs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7Ozs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTEE7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBaEJBO0FBd0JBO0FBMUJBO0FBVEE7QUFzQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQURBO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTEE7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBaEJBO0FBd0JBO0FBMUJBO0FBVEE7QUFzQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFJQTtBQUpBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMQTtBQURBO0FBbkJBO0FBOUVBO0FBREE7QUE4R0E7Ozs7QUFsSEE7QUFDQTtBQURBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./assets/components/skill.jsx\n");

/***/ }),

/***/ "./assets/images/jocelyn-faihy.png":
/*!*****************************************!*\
  !*** ./assets/images/jocelyn-faihy.png ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvaW1hZ2VzL2pvY2VseW4tZmFpaHkucG5nLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2ltYWdlcy9qb2NlbHluLWZhaWh5LnBuZz9hNWYzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQThBQUFBTzhDQUFBQUFDalhZTDlBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUIzUkpUVVVINGdjZEVEa0ltM0xsZ3dBQUlBQkpSRUZVZU5xRXZWMnZKVW1TSEdibUhwbm4zcXJxNnBuZTJaMWRySlpEaVFRaEVYb1RvR2Y5ZFVFUGdoNEVFWklnaWhCRWtFdHhPTHZ6MGQzVlZmZWVreEh1cG9lSXlNeHo2dmF3MGZOUmRlLzV5TXp3Y0hkek13disxMlpsWGR5OXVOSE1FdlFGbE1GSUFKUWtnaXRCUVJKTkNWTG8vNlF5VXNMcTdoNWIvYWsxLy9qdDJuajdoOTkrdG5pRkFORndFWTBrdzh3TEM5ZjErYmtvdzl5TEY2Y2dDRUROakJDUWNmM3k1WnFFd2N6Tm5OYS9BQ0NJYUFSc3VTenZmYlVVY1BGaWhCbUxHK0VtTThEY0lhVUVCQUJ6TTlJSVNWdTB5R2hSMlY0K2ZicTJ6T1hqczFxOFBQM20vWWZ2OU8xcVR0QTlSWkFBQVdVTENmUmxLVjZNYU51MS9makRGekxsbGdsbkpwL2VYWmFuZDArbGxMeHRTWC8vbE5jdlAvMzBiLytrcDZZaU4zZWFzVEliUHZ6cUY1ZGxOWGhabm9EeElSRWh5bDdxSC83ZEowYXJ1VjZlUDM3NFpya3NUKzgrdkN0bVJocXkzMzZtcFlqYnkvV2xMcytYcHdzQlNDbXJXd3NsRXZYMTg1ZGJmUGZOQjE2Ly8wKy8vMzkrdE9lYWEwcWdRVUhRVEJIRjByLzV5Mi9MQjVBa2tTUUpaSG8yNW0vL3crOXZMeTlWWmkrWkNaQ1VKRUZVdEJSb0FJd0dzbit4aFNBSVVsSktBaUFBU2hEOS9kMElhZno2L2s4Yjk4RUJFSVRVdnc5QmppVUFBTXIrVEVBem95UUh4dCtBSUJEbVpvUXcvcDc5dW1oem9aR0VVdFpmQXg5dnAxQUtZbDlva0l0RXRoYlpXa1FpSlFtRXpBM21saEROM0Z3UUpBaEdJNUFnbmNUVGxvdHJlVzdmL1hJeDFwY2ZZcXNoTW85TEZ2cG5BUURLdUUvejMwcVN4bjVmNXE4THNoNTdLbzB1cGRzU2k1Tm1CaUpzdnQvcC9tcmNPNDZGTS82YXd2NDdrcFFBelVoNnNWU0FGUHFOSHk4MHM3bEdFcmg3ZnZ1dUFCdy9FYVVFWEFMWUwwVGpvb09HcHZFVGNxeGQ5dnU3UDAxWS8yeUJVcEl3a3JxRVJVT21sSUtaeC9qc3drd3BObk1RUmhNMEZnQkFrMElTb0RRNGZVRnI2YTF0aWV4ZjN4UzM1bHUwNXhRRTBwbWlRYVdrSTUwSkNRbEFLVGV6akdxSTFFSWo5b2NIU01wTTV2aS9QUVRHMC91WmYzUThzT09SSkNJeU1sdUw5VGx2K3I1ZEU4eG1Bc2swU1pJeXE0RTBMLzBtQWtzRWpNcmIwL2FIUDMzNThZZVhkdDBhekZLU0tJNFhDc3ArOHdYQW5LY0hLZ0lTeHUvMTc4WHM4WXQrdWZ6cUlqaWYycmpuUlp3N0tBbnVOOGlPZ0QxQ3REOWxFSUNSN0ZzOUh6NW12NUdFTk45bHYvZmp5MHFuSUZKbTdoY3hWakpKb09jMnpwM2l2SUo3M0JGUnlwSjYvdVpYWVI0L3ZlWTFXMFQvL3ZocTdRdDlZK2J4Um1OVjgvaTkvaU9OS3k0TnpieWFYZGErUVB0bFAwWVJvT01QNUduSElBR0tQYVFrWmJMdmZiNFdOZlhiei9sRVNEY2JPVVNaUnRQNUVzNFJyQjZTaEpEcUd5N2RESE1IaFJJd1ZMbURnSmtSRWhRQ21MN290QTQ0TWdiRzl6R2lORytHVENwRDQ1SVNDVmRyWUc2ZU1zQnliRHk5R2pGQWtaRFN6VkdLTCtucjArdVhGcGx1RUVpcFZ0YXNXc01TTklka2hwREd1MGdKSnFTUW00SElsSW5ONEhONTlzeVdtY0VBZ0l6TTdMRXlBa05mNzNNOVZQWXRWMk5ScENKYVJDQ1RGNi81dHk5YmtnZ0NwSkd0MTFOU2p4eFpqem1VcUNobzlTZCsrdTN2WDE1ZlREV0ZzWlZrTDhaeUJESE5hSmtpemZVUUsvMFgwVmY2aU1LWlVIbGE4Zk4vYlVUdS9IY0dzSTVrZGZ3ZVJxV2cwNS9INjYyL1JweVorclQvQ1JDeXh3QUJ6dENYSUNDUHV5aEFDQ0lqbzErNUtQWmR3VWhCc2g2bk15TEc5dFQzTkRQMlBmdnk3WGUvL3I1NisvUmpxWkl3TXVqOXh0VVRjUUxrS1c4YWVMN3Nmc2Q2RkJNMGxRQVkxWmdwT0lyQ01lN0h3L2JPZmxVRU5TLzUyUDUweEs5Z05BQysrRWhYYWFUMSsyUXdNN05DR3BWSjZ5c1VBS0Z6TWtmMmZWQU9KSmdJRVZhSzVaNm0rbjluWkMrZFNldnJKU1FEZkN3RDlkS09RR1l2amlqUTZHUHZpUVpJR1JxWmg3bGRSR1FEd2I1emNLVDMvZ25XRXBuWWltaUZ3TEl1Q3VocUFFUVRBZVFtYjFrQWQyZUNWTlNxMGdCeWhLRXlhY1c0bUdWSXNUbnMvS2lrakVnbVFVVnJrVGtTQlB2dWUvL2tkY3AwbkxzaFIwSkpwZUFVV05iMUwvOGpaV05QTWdPRlRCSjBGeFZWYzdPKzFURFVUNTkvK3Z5SEg4THE2OUt6UUdvODdlanZqQVJnN3JaRUM5S096REdlVTg0dmh4NHFOdGI0eUtzUGVSRjd2VE1DanpPZ2RTVEVubUhuMzQvU2ExWWZNL0Q5eURwSENQZkE2RzhscVhlSkkxWUY5YUtwMzBxYkg2Y2NiVTNNTXFoL2Vlc2hZdXdsdk02N0tmY2tqRFcyNWNOZi9PWEhtMWl2dGJVazZjcXZLNCtSV2ZPaFlwZ1o2L3pFKzg3VUw2d0FTREdoRnJHVWNLY2x6YjRPWUkySHcxa1ZINWw1N0JqOWlmWjlUS1NOelZ5RUlDUGdSaGJRell6N2huKytCT2l0cWpBMWZ1cVM5d3ZzVjB0ekYwR2pPV2ltRkNGbEdqa3Fic1Q0ZWk1YU1vVmVPQ0ZFTjVxcjVzMFFtMEFnMDdKRmdHYVMwdERMS2RCZ2ZUZW5SNHZlcTh2Y25PNm01RktERUFpRm01TzV2WWFLZVErVlZHWUxSY3I2d3VvUHBEeTlleXFMTWFUTW1tVGgyRVlFSVRNekRRQ1Zld0RuZmtQdk03RDJmNmpST3FwM2VaWjlrWU5HMHBhTGd6U1ZFY0FvMklzTTQ2eWZlNVdmMjQrLys5UEx5MCtiZXk0Q3djeTlrcytSOEFHWWViRkxrS0prNXljSElNY0ZIZCszSjJDYkVhZXZLcjNlOTl5WHRzZ1J2Yk9mMlRQcjdKMW0yYmIveXZ4VTNtWGcwejZ3cDB2MWhMenZmenExYWNwTVpZdFVCaUNRa0lGOWVjT3NKNGU3Vk1wZUl4a0J5bUhmL3MydjMrRjJlZjMrcDFwYU16TyswVHJNVkpodkJmWlJXR0h1M3h3L0t6Yld3eTJ5THFYNFpZVlRkT294bE9icjdqT3d4bCtOTlpTVUloVHBFc3pHVmtPakdkek02Q09BOTVyb3JvQSs1WFZ6ZCsvTllnb3drTXBRNjZWSjMyMTd0ejMvZ29RWWlDWXphcllwMkZzVjlXS0xVTUlrRkpnWFZrUzlNbVZRSnBTUUVqQXBtZURvb2NqZU05SmNFU21oWlZRRERNN2s1Y3RydENZak1rUWpBbHRHOGRWS2doa3RjajdjUFlQUW5yLzU4SHhaaktiSVFJNVZPMVpYWnFaQVN3REJpRlRPamZjeEErOGhQRFAwMktSSExkZC9hWHNpSlZ1MmdEUE4xUU9XWmdaUmFuSjZXWXJVKy94czErM0xIMy8zdzgySnoxR1dEVkFxTkxvQXhSRWI1bTV1Y3VVQW53WVlkUTRWelNpYkpYU3ZHSWw4bzlRRFFidnJUSEg2dlZHQjc0Rk1Ic2wxWWgramlUd1MrVU5Wai9sRnlMRVA1WVFYeUR0Z0tUTlNFWkc5ZHpvK3NwZVpmU1ZMUjdJLzdndEk4dmJ1bDMvMTYyL2l5NGZYSC83dzAxSTgrd3I4Q3NqSS9WVnZWQ2E4dy9yR3crMDNwM0RmalZwdVpYRWxDbzI5c1R3MXBlS0JqNXk3VlFvY0NiRm5BQ29pSUNsZ3J1d0ZHODJzOThZT281a2hPMkQ1c3kxd1VTNUw3VHRqcG1Bd1NvR2tPZEFiWGlsc09aQUh3aE9wMXRLT1czUzBoRFRRZW5wTHlHbld2NUN5YmEvYk5nTGRVRXdoWmtBVzZjdTRQUVJnWnBiTWJKbjlRaW1uMmRQYUZxOHZOY3dVeG14dTBCYlYvTW5jWkJrMTlpdWROYTdTbHN2VHd0VXRXQU5OQkJhampzNFJvQ2tnWkl3bWVIUzZQSUdMdkUvQWVteU5aMks1QlZUcjFsN0RTelFmKzlGWXNWSWFhV1lrR0syMXdNdjEwNmVmdm55KzFZS290U0doVkNaRVFwazl3Yk9YdUc3R2xMbVJqM0NSZE5UejBFQjdSOGpwRWJmRTNqejJETTBqYis0TjY1RnplN0J6aHpydS9oMHZNejZpVk5qenNzMG0vTUFJZTM5QXUwT3dsQm1ab1I1NnBsN1kwNDB3ODdGejd2VzdxTDdCbUprNTRYLzlkNzhvMGhKLy9PMW5aVXNmWGZmWENDUzFYeGNmVzR0VFQ5emJYOW1vTWNyOHdVb2xwR0xXd0NLTkVRRHZQdUIreDNqWUxrUkpzcFF5WFZMS2ZJQyticlNlaGljNHgyTUJ2UjNCcmxKS09acTdZTS9uWTlIQUJDaU1nRHBPM1RjU3BxS2xoMm5INmZwT0d3YkNacWVUWmpBM1NrQzBwOHRhTmhMcTNURVZtVW9xQ1pVRDVnUnBORnF5SVgzQTZNV3dVTGxkdHQ0L3JWS1N0RWpTcmJZRlJMWkVoN3VQT3FabGdWRjVjUSt5WXNzd3o5R21hQXhwZWdMZWtkR0hQUFUyREwwditoMjJTVWxxaVlqWEx5OWJzNUpOaTAzVXFqL052TGdaTXNETXJLM21QMzc1MC9kZndoMnZOeTVMYkwyZElOb0k0SkdLZW9pUWJIM1l3UGJWdDlsemt3REpkMHp6YlRpOXI1TURoUjQxMHg2NWVRN2crYmZDT2RXZU11RlI4ZHluNE43aTlUR1drTDAvNGFrR1BsMkNNZ2NPZHpTM0U5QnhrNVFpNXA2NmY3YXpvN1hmL2VhLzhoL3I1ZHQvL2ZlL2UvclFiaWlqQW1sZlA3dHpONkQ3Z3VUKzRjK0NCanJXNTRBN0cxaGZsc3ZhYnMrMkZGTHB5aFNOTktkRXl3N0JSQTZrWWM5MDVvQllYdElXM1pLMWhma1doQUZXRmx2VU01aDNTTEVES1NTenAxTE9tc1hHUGxRcGxvVmFhdFFxSTVHVUlvMU9LOHR5ZFFOQWl3SWthWTFXREpTbElwSjh4V0pBbWdHRUFxWHZ1YjJuQVJVRWt1NHY3eTllbm90UXN5elFnZ3ZYMGxhbGtyTGkxNEtPbDlOczlFQUd1cFNabVo1V2l5bktMOS8vNC9acGc3RkJCQW9wb1RaL1RzdW4xM2orUjVXdFhkQ012VCszdFMyRnNrc2FWL2N2MjVvUmJiMFVSSzNKWW1hQ21acmZ0T1IyeTRRWEd6TTRDSFB1dWMrWldvQUdwSitTVmliTGJReEFqQ3pXMFA0UkJjdFRMdEhUcG1qT2xLUGxRclpZWGh2Wi92akhsOS9GRnRJdEdGQ2d4WktRVXZDQlBpOHdvOWxZZG9vY29UcC9MbElKc3UxZEwyejJ2aE9LVXZaT0VTQmlYNzl6N2p0TDJQNVhOaGFzSFFIYzMvU2NTMGJjRzhIbzhOZU94bVpQK24wYmhsQXlSYVkyUUFJNWE2U0NGQUJZcHZwaWlkWWk4c0RjSkpxWkFEb1JNZXY3QVhXYVdOUzRRdkJsS2ZiZi8rMzYvZk5mL01QLy9tL3dqcS8wQVROb1RtMzI3MmVDWWw0bmRLcHFNZWZVcDVHWlVNMllyYll5NEo0OXdsODk0UVg0NHFXNEd3MkNIaHQxSEhPM1BTTmJSNkY3UVJaUXZkVkVyNVRad1lVK3Y3bWJVdkxuWnBwZ243Y1FLaXNDa0ppZ0pLUmxaZ3hvYzg3ajBnYzRaemtIb0tsUnZwOHJGc0xBaEViTFNWeFdleTd2V1A3OWl5M1B2b1c1RnlQVlJLaUFtVW1jU2hHTzJtWExvSUJNRTh6WDRMZTFYQlBlQzZIY0FaQ3hZK2FXeWphYkw5QVhPa2Y1WmN3bnJ3aGxOREE3K3BTcGJJMXQ3VWs0YW92UVEzdkVNWjd2YVNJbDRHZHY2THNTVmJlZi9uRGQ0dTZPMERwOFU2Q28yMmJmdlB6MDVRKy8rK01yV2tzcGtwa0VEVG5IdnBoNGNrOURPbGQ5QS9lR2hHWTlnRStnTTc0R2IyWW5qRGxYMmp2VE41Y0VmMlkwY3Z5SUhaYm5XOWw5ZkZlU2MrcmFLemVkWjZRN0d0NW5nZ2psWXhJbnpVeW4yZEdPM2hEd05Fc2FXN2tzMVg3ekw3NzdzdjJGL1lmLzQvOWUzMkp0dlAwOTk5OTdRSjhmaXVyZW1wY3hpTjNScnhvQ0VQNmNQWHZPU0ptSXlEMVNyak9KQTVKazZrTVozVjZ2MmU5dng1eEowdTJZQ04vZnI2OUxxVlNrWUdhZzFSakxVK3JNbzNIek9DWUJTcFQ1V0RER3dabGhQTUdleDkyWE12dGdXZVRGTFZlVVMzeC9OVnN5UmZQaW5SR0ZoZnNYTnN5S3djd29LQzBFWkN0aExFWDgxcGMvdm1TSERyS1g3OG1NTVdJT09TMXpEaTdNRm1Cc25lWTBhMTlDRWFUWWFVMkRsR0lqaFdUZGxwYm5BTlZEWVJXUnZaTVQ3NnJ0QVRSb3RXeU02NWVYbWc2Ylk5K08vZ3dNc2w0TGEzejYvb2Z2Ly9RNUxFSmtKdFNSNVhiS0J1UW9kVWZNblNrWmlZbW1ZZUQzL1Rmc0FVd2FnK3A5cW1rZ2pQUDNzWThYN3hMUHVTc2VXTzlCMVNEL3pQNkYwMnlOUjBVLzZzbTc3OTgvUHdjMlVLVk1uWEZzd21ZQTY3UXpqSHZoSFZObHViaSsrWnQvOXVzL1BIM0R2LzlYZjcrYzJvajU5ZStiVytwdWgzcnNtZTQ3QUFES2FLMWxPWU1ObzRUWVlqUDN3bVJMNXFoUWxsNjY4UUVsdWFOOHpGbHBOaGRxYlRBamU2bWwzdGFmN2gvNTUrSzM0N0NpdVp1WDI5WVNTakNGSkNGMnJodkhyR1FRN3VZY0FRUDQ2YXYzbnZGakJCVE1tRk1EMmhJb2w5OTgrRk5MR1c4SjBoeWxiWnZTTzBqdjNDbFFHalNhSmIxbFNnM0NVb3pOVkc5eGpRSFFqQUNPQmtJeU5pL0txakVGNWl3Z1llN3VaaXl0UVprdFovY25rclJpSkFYbWxqdk1jcWJHOVFGcEx3VUd5c1g3Q0o1NFVWMUIwWmNxd3hsN0VHRHlaQVdGdlBycjU1K3V0NjJzTDltNU13RWhnSTZCNzltM0k0S1RhblBYOVE1Q2lkbWt2bUNDWFcvczJMMjA2YVYxL3c4ZUdtVGVyYS9UUFBjQVpmYmtmcHJxL2x4WnQyODRrRVJGMnVOZG5Sc0ZSV1d0RmRJWllSWklkK2ZYaS8vWXpraXo1VW5sbi82MzVkKzlYNzc4Ni8vemQ4dGYvSEN1TFNjaGxBL1ZLTThiOUdPRTd5bDdWSGV0dFpZcVkzaDcrbzNNQmxMTDA5UHE0dnNUYnY4enJMUWVHR2FRV1hJT2Y4ZUFvVE0zT3NSbXRQNDlad1lXZjc2SWxsSXltcms3YVpsempOS0xOSk1BMHgxMURRZVBzTmNCWmwvZHB4N3dvNlZTV2hqWGlPWDUvZkx1OWN1WFB2RURqRUp1clNFdlkyRFZDK2tEVGkxS2p4YU1BSUJpSm52NmxwK3VJYXJqS2dReUlvV0VNZXRpb250cFFzcUFXcG1nZVhHUzVydzQwUWE2YXlBNzhFeVBEdTdWeVQrK0J4VTFGc01vazNRM1hMMkRxYTlQUk50VU5HcUVlVXNDZ29rSU1MZFBtZkY2ald4d0UrY0lYcG1qaHh6MGlSNlFQT0tYUjlHM3ozMDFxK2RaUWorZ2NIdmwyWitjVDNyaHFCdmZEdUI5YUhiSC9DRlArTlZwcHZRWVpEUFNCMEZqa0hUN2UrVDk3NU5DeHJadHNXZG96dTFySktLWlIzbUN6enVsVGVhRjVadGYvZDFsczcvOTkvL21keTlGUDg1THN2SGtFbTl4S2MvTTVaOHJKM292RTlsYXkremNhWjI0bVcwQTl0K3ZUKzh2RitOR00rL0FNUi9XeFdPcndVNWVHaGZqeFNHNit2WDJPUzJQMFJ6L014bDRVZ2FNWmdSTFJwdWJVa3FkRzgzQkpoaUpHRGJZQzJNOTk1a0g3MHNrQUtBYnFENzBwWlVWc2J6Nzh1Mzc2MDkvK1A3em1FQXhvOTVxUlhhMDFzTEcrTHNZUngxaGFiUWcxRkxwRnJ6UTZhOUtxWU56QUtRUUFLZGVWWktMVzFCSWdTMXNGRnRJZ0hZcFpsc0xoVUFyWkl1SVduM3dNTkQzbGNjTVBGZ0kxT0QrNGd3SG5rdFBJS1YyL2ZMNUJUUTFIWlRZenMxT0JTSzI2N1ZlYm1FSUdWSkpLVUZsZElDTW8zU2VKVFQ1U0ZLY05HOElhVWtCc2ozbEhTUFkrODJsaXhScy9ESHY2c1EzYXVpSEhXeTJ3RU56OHVjeU1BbjFFWkg2TlovSkh2ZjdYWWVtbzlhNkk4OTdLM1dLWCt4ZDI5N0VkMXh3dWVUVDMvMFQvY2YzLy94My8rci8vZmpMbjc1Y1pzVS92clIwMXhKOG5ZSG5ueDQyRmxES3lGUmtoZ1FVUzh2N0htYjhJVzZJV0paWDh5SVh2WU40dkMvaDd2YUZQckRvbEZqSWkrV1FudGlwWDRDQi83bHhDRVliT1RZMEErQzFJWFdzMlNRRWszbzBqL25VQXdpV3NneVNsbll1VlVZdGtCRlMwcHVGMjRVVjY3bzZlVjE2ZVpTUkdhaWxNWUtaREFPVE1LaERoU0pMRWlhMXpLWXNzSUo0QjR2YThrZ0hpalRSVE82a0xjeGlzeFkxZHllaTN4TmIzTnh1YUttRWc5YW5PcUhzckkrc3RjVURTQ1ZxSitySTdKeDZkVS8wa0ZSUVViZlhUdzBaYlo4M0RpVkRpM3pOV3JldHhsYTFXQXFaMFFuWkJxVW1pTUU5ME93QmxOSWtkTTZWM1lkOU5udmdQRWpzZDJPdXU3bnZuK21vK0REUEpjN1NEZkpuWUs1VEpqOUpFREkxd0dib1VaRXo0amN5SXVOck9HeHduM3VSYjMzT2Q2TDZBNlM1WFo0K2Z2Y2RLdUxILytuMzVUbTM4dkh6VHBVY0xldWpsdVBoZzA3Vnd2MFRsVEphZGtDVVFLRWw3YlF5WEJDU1hETmU2L2E4clZhV0xHYnJqdFBmYno1M2liM1RoMEFqdzV3WnRzc3k5dXBQZXduTnQrTzNUNVY2WXUwSjFyelExVzg2SjVGVndLNFI0WjUzWjIydWZWUHBxZXE4Y21SbVp0RnBDWVl0eWFWOHVMM204ckhwVDZ1VG1SUkI4Mkk1bFNoSnBVbk5RQk9aSkIwS2o4elFMS2ZLUlhVdURYYWtRUkROOEc1VndMT3Q0OW4xMWtEWkJPdENJS015REVxQmJzc2FUczNCaDdEVmxycWJ1dC9QK2QwMVNFRis1aTBteHlCeFVYVjYzZ0xaMHNpREpxVnN0Y2JuMW1vbWltY29XcHBIaDlRM3N6NGVIejJ2blRMRWpzdnMrL2ZCbFhEckFTeHF6UDE3YWMySHZaczh4a1lQNUt2SEJQellNaDcwL0ZQNXpMdHArRnRadkUrSHFKeG94VU1zOWR2U092bk5kRSt1Z3UweUNlaTBjWXkySEtCb3hkZkxmL0dyL0U4Zi8rNVAvL052MzMyNGJseGVKLzEzTDBQRXQxcmN1Ni82Rm1yZkI2R1JyVytoS3UzRVQ5azFHU1JDb2hDK2VsbWZ0UERtaTA4V2dsSXFoRXM1Q0lZQW5hMUpyUWt3YzVRdjE4MDlxMmhLRnUvNlhPUFFjVXBFcExtRmhsaG96Q0JzS0NCS05wcDFBQ3l5TEZHM3FqNHVjU0RDZ25Sa3ZjaU1TcmhiVDgwcEsrYU1DR01HalZRWWZXYVFHQVAyNEZMVTViMUdSdE83eXlzK3JNdEZWc3dSeUlRWlJVWE5WR20rS01OOUlSVHBOQWl3eFluRkFzb2JyWlJsclY5dXBwWktJdEYwWGZ6N2Q2MnEvdDNyTForS3lydHJDbTRkcXl5K0xGUW9paHVRL3V6YzFCVGhZTFRhWkFPcURtQkx0VEE3eWR6Nnc4MEJxMS9ER0swNERVZmozNVdyWkdoUnRsWnZMUzNTakVqUjNKUjVVMFM3dmx5dm1RazNWTGhreENhcHNjK0NDbWRMZHZBVGsxTVdKVTIrMTZDSkdVb1hsSU9aTm9DS0NUZlhvY2VlbWJuMCtmcGdWQXdzVm9OSUJGTDN2RnZadnJENzZ6MHphVU9mSWQyanlTQmlaUGhSNFZwZi9xbENBeEljK2x2RTVQeWsrakJiVWR0RHlXTURNU2ZKdENtbTZObkdCM2hWRjR2TGQ3OThzajhzMy9ELytyZi8zMGRVbFNHV21jU2FaQm55MVVNWDNLWE9jZlRiTklxaUszdUwxVW5acUsybElpSUdtYU9jME1XN2ZOZ3g5RFRaQXRJWTZIbDZTZUZyUkhSS3N6WHdiWUd0YzJyNXhrNDZPVzRraDh4LzlveW5yU2FVcVpRTnZNTE1KUUlia0lUUktKdUpGekRQY0FjTmczVU1kOXZaclNBZTBUTFpxUHBDZmJaajlGWDI5QzRTNitwUUtXN3lzcmdaa1JsazhJUlh6SjJabmNBaUVFcXlNRTNZYWsxTGdhclhkNUVpdlB6VjczK0lEeVZmelpCUWVrdE5UYXFVeE5JbDJoWk1wZVpJU0R0RHJaYzJmQlAxb3lBYjVPYXVEK0Y1V2pHQTZCNkRwZU1uY3JRMHRaYjFkdHZxcmFWQ1VHRWRHYUpKYzNKNkZnL3RkYk9kdFFGN0k2aXBtbUJPVGRFY3VtcFduUWVUZVl5WFJFbUdXUzFwdE9lN0NNenVLa2ljMEsvOXkvR3Q2cHNFNEFmWUpvaGRrallXeE9oRnp4aEpoM1FqTTJMMnlQMzcrdFFoSC9xSHU5ckFKQytXc1paMS9mYTdqK1hUbXArKy85TVhuM0lzdkFsYXZmbDNaMFI5dkpaOURwK3BGbDNEUHFYT0pjOThTTjB2aXN4ZzJGWmI1dkpzT2VoakV5bnQ2L1k4Y1RRWlBUdlhHREpUREJqNC9ncnVGcUVOUGNMa2pPa09hK3RsSWFpa2VjLzByWVhnTXNwbzdIV25tYWRwYWx3NmEwWWhNVHQzTDVsOU1ETzM4azcza3ZVM0R5UGRzSmhUbDBncnJuQVNNRitLT1pFdFRVQXhJV0NnSGRzTm5lWVJVaUtkeGJsNHVWNVJMWk9XOWN2VDB0ZlJMeU8zVEFlU0JKWEl5SmwyQUZrQmlYS3gzUHFqNmlzKzkxbzNScUgrTTBOL2VZSm0vSm1manIxQW1YdVYxZElLYnR2dDlmUExGaWxUQ2d4TzFVOE9HcVFQWnFNOXNDbDh3TjQ1WW5qVVVMQ2RaRXllZE9wN3JMc09QY0xjRFhJZkcwTkVhczVqT05EUGh6SFBFWjJkZEt5M21CODg1SXM3L3BvQVkvQi94aHlaK2NnOTdpT2FxSm1TaUR4dk5KMTlOYUh5TXdVYUxuanhqTEkrdmYvNDNxUGtUMy82L1V1NWpLbmFvMXhKT0xlazkySWVuanY4WVIrQUdNMXZ4QlJ5OXRlWE16M2pFZWFIb0FxcnJkVWxsblV4UjY4Y2R4M0NFYjltNWxDNlFXNW1xbkkzR1J0L2hsQkQ3a3BQU0Rud0tUN01oY1l1bXhKWXpBbHVQTS9RK21TMXU1ZWM3U29HVTJvcGl4ZW5RVTdZNE1OSmt3RFN0OXpCdXFGN0FTN1pCQVNqRTM2dG1QYzgzVHZYaklUYlNVQnVNaVVScWVoWHZ2aDZXWGlMbGthMitDSGJXbHhlL3ZLYlR6ODBmLytsYnlNcFpXamFGTW1HZnNUWkRVWjJhZm0rOW10RTZFMGEvRjdBNWx0MkhacVVQV09mL1Vja0FVUUxaN3k4WEYrL3ZEUUJLL0lvd2JnUGpBWkFDQmp1OVBHZHB0UWRXUGF5YnhEZDlqSFRpWGpFSTlQMUx6T2oxdzROeG1TdkNkYTU4OVlGeHRJRDZmK01Ddk1zQW5nRWdVajRQbHJxNEVwb3Q3eWdwZ0hBcmpEWlVZRld1NkVLSjB0U1E4cmNnWVlUQ1d1V1pDU0IxZGZsNmQyejNWNisrZUVQbi9HQm5VUjRtbXZya0FMZVN3bjZXT3cwNzk2TFlnSkVCVE5xRjZYdThXOUVtVDJGSHByL0hQdGtLQ09qbHV1eVh0YkxxZ0lROUwwODFTSC9JNVdlWSs1ZE81RnVxSjkwMWpQT3FRK0hjRFZ6WnVEemhwRGpydlFyeUVqUXk3aURFdUtRMEVGOU9BZGtaR2ZSU0luTVpGdGprYnJqRnFHMGZwKzZJNEwxRXFUZnRnd25VVlpUeTVSbG1obTl1THNoRXhKYlowbDBHeG9rTFdlaVNZQ3A3RVVzbjliTFdxNC8xZjZFUDBQdkxpdFh2UHV3Nk1mYlZzYTBaWkRLTzZkbUZCaUVPNWhpenUxaDhuSEVWaVB5WjZoR2tqS3FMS1h3dDdrN2FXWlN0QzB6UlE2Tjh2WFRwN2JkYWtKYU9rYks0RmtXTkd3NzdwL2J5VCtwV3lnOUFMbnFMUXA1QXFNa25FbjVwSi9uVDZjVTNTbXdaNlpYL2t3SnV1ZjRONW1YTThYYlFVdE1TZXc4UGg1Nlh6Nk9YQ1ZGZEk3empyMlQ2aTV4SkhXTXF0WG51cUF4M2JMcStkMkhaVjB2ZHJ0OStlR0hmRnF6NWxkRWtWRlUzZC9OdnFHY1Via2hqeDh4b2dZb1dnMW1qdUxFekVZQVQwRC9Uamk4KzQwZzFSVFdscjR6aHBsNzk3VzR2M0xTbEdTbUdDSFUzRUxJdERtcmZEc0RqNmVtR2IrODE1Vk4vYlFpMVV0RUcxcDMzcWxEUjAwTXlkTUFKUXpSR2lQVzdBOHg5N1oxNkV0cE1oaktRTElUNm5OcklaQjA5N0pxWFpZaHY0Q2tsa0l1UXlwL1VpdlNIQmJKVkNiSXdyWFkyaklqQXN6dDZ1UzZGTlhMZC82UGYvakxYZ0JvZHpRWVBqOUJqU3ZNNUlDdWVlTGV0ZFpMN3ArYjdkZVdKZDlhNlRvSjZyUFRUZ1NvdFd1dEw1OCtXd1lNMFFYem5XaTJTK1VOUUNIUFhlNlUyaUZQWm5Vbkc2c0RRU1llaXNlRERHbTBnNW1sbllzL2RMcldaeldUa0hVdkZUcDB3T01ESjZYakRlTEhsQzFPWnNuOHFOR1hIMGwwbjFNUFJsdjNGY1F3SHJpVFBtSE93K3cwakNhTmpSUzhyS1ZZM202djE5L0NYSnVWRzk0WTdBbXl0ek13dnhKRjlxSkVEZXIyZ2RKb0RNeTZJY01jYWVtckFmZ2tIQVBabUgxRlhySXNOQ1pNekhOWWR0aEYyVEVhU0JIcGpQU0hyOC9qbnAzMk56RG5KbjgzbHVvUTMyNHd3VTdBYUNFYWs3dXlXaGtsMDd0T2t4UlNhMmE3aFplbnRTOHo2N2pwSktFeXJHOFhReENXbmJKZ0RoQ2Q5V1VPdC81MFRHenNGT3JaMFUrQmh1WWNGNW9WWnhIU0t0cTFOVnVZbTBOWUMybnJrdGtPR08rUTNrdXNvR2dneTVKc29laDZOMWlmOWFxMTFGc1plQmpISWJ1NUZkL1N4d3RRZFFkb0ZzcUFwQyszMTlmcnRqVlQ1eUczemdUYTU1T2RRQWM0S0NGMXlCSTYrU3NtU3NFN0pjRWhhNWljdWNleEUrODlMS1pVU2tjMHpaNnpPMWYxN29XUEFiejd2WTFVTmVzWnY2ZE5Ib0xvVVRQYWlPSGNlKzZSNXllUktTS1ZrZnNrZS9SNTNqa1U4TEZGbVNaZHF2TnhDN1E4UFY4WUZpMXl1OVpsWlNic2tTZ2lUbGV0dDBFc25zdzE1N2VPYU5tRWpER2pOZE9VeHcwbTFpQVBmb1VXU3gxWHBQUzZiTGZMN2JZOEo5MnNvNGFQekdXbHRHU1lVZktBdWFHK3RlWjBOeGp2WTUzSFFkaVlLV3ZmblVZeForYlNIQzZhK1docnV6YW9FL3k2YVNTelhxdDVkalp5V1VFT0thZDJBQUFnQUVsRVFWVGRWVExKSkVVVHBZZzVSdTVFblVqMFZxTmJxSTZlTnlXRFVrcFB2NXg0TzZTaGRMZUtiaVZVU2p6VmwydTBBbWJiSUNLKytiQzk4cSsvL1RmZFZRRGVwbXRpNTFKVklNbWlRbDhFWlBUZHFUdGdnQXE5WFVtZXUrQzNVQ3p0Yzgwa3paalJXbWJtOTdlWDF3MSthZjBaN3k1TlphS3VkTE1KcE95UmV0RHhFcnZUMWJsbk81bXA2UTY4NUM3TmRqOThSNkRkTG1YYXVBN2V6MmcxcWN5T3NUOFNzbzZNejdlWVczdWFIdWdBNzNyV28yU2ZsTkN4S0JYUnNzc1hPbGd4TTYzdmQrRXRMUUM1QnArK2ZZZm16TzFhMi9ZdXE3blg2bmZRN0luUC9EYUl0WmZRODRNU3ltZzFPd2JkWmYvREJNNDRLcVJNMFdMVzlDbVk3ZlVHaDRzYVZ0M3E3WEpiOG1LdVl0TmtvYVBWZ3A2UmFyVU8wTnlFVWxDVEs5SFl0UUJuS2Zad3RESWxJWHBCOStlVmtDeHFZZWJSdFR1aVc2b3ZldEhnUUJxc3BQVmQwNncvQ3ZOaWxQa3RBSU9aSlBQSWZObGFmZi9Pb0xJbzBxMlZ0VnNPdXlQVCtyakRUZGxDaStuVjBPcVd0UHI2aW1WNWVpOUsxdTBvZ2R4NEFiSXNaSFVpZWpvaEFTM21MVVJLMFNXQmw0OStlYjE5ZVRMVmpMajlpbTNqaDlYL3haOSsvOW5YcmxMbXhTUEhOcjRpNUlXOWszYkkyKzM1RjEvcWg1dEpLY09IOXVrRFlsdVhEcVlkOXFwS3VOQSthN0hjNE1lWUkwVVBSYlN0Sm14OVdsclNFRnRUZTducUg3b205amJZcHgxOUhqc1FBYXlpbVRJNjV0REpKZ1Nad3lCZ21KeXdrWGRpaGY2QzFPNi9qRWt2MmVtenVjTmJ3MFFVMGMzWjdJUmVtdEJoQlIxa0NaN2NLR2xtN0hSSWdVRGxTQU1USEJzUjNqSUJaTnFJVW5hK3A0cXdDd1VuNlRaYnkwNnloTTJ4V2JvaFdFcDJaeWpNMEdnVEN6T0RrTWoxK1YwUkY2dTNhdzB0b2lOU1RpbGh4amk4dW5aVVh6dkVLSFI5UGF4MjF3aldNVFdNYksxRnlESlRoSXVoOUdJK21HL0ZxQUd4emJGOGozM3JzNmE5Tk8venM5eFlNMWVWcjdDU1FLSzEyanNXTTVSY2xocTdaZlArejVsNnVZT1Qyc3NHblNYZFNyQVpwNkJydG9RMkN4QXpMOUtEaFF6UUpjSGRSQkZOTktQS0JZYnVzamNFWTZQK04zYStnMmlReE16YVdtdjU1V1ZiTHFhMjdHN0RUZ25Jem1IbVlWRGJQOVpHZjVqZGRjKzlyRTNvRm1ETXBwOXdnWmNzNi92WGVvM0xlclhGRjh1NG5HaGJuZUlYS1JERkNEcVdJQklKUzgrUS9neDV2RnVIZmVWMDRXRmVpbnd3c3hQdE5kdnJOWGJpSTZZQVVydDdpUTBBVFhjNm05bjZIcCt3cXhUQU81TGtsTGZwNUNKNXZ3cTZ3cW1QcTNqS2kwZGFIY0gxcUg2N2s2dWMvMmdETXpoVittKzBiamdSQXIrcVo1UTVyWE9Ra3ozaTV2VHpjT1JRVVhGdnRPbnU2MlYxU0YreVJnNm0yQTRYSC83eXAwczR5Z2FxU3lsQndBZTF3U2VlTnBtQXUzNjBlOG5NYjFNTW5VeGhlejAzUTZxL2tlMzRsaUZiVXJjV3ovbnNYNXR5ZFpKTFpMcFp3WnB4YWR2UXBObWthNUFQN29POEU0Nk5Pc0kwMGxvSVJhUlNzQWtkN2JwazYxVGJRNDZ5MHpiNlM5VlBCWWpJaUxiSTVjVkJLVVQyWUp3REphSExBaHVFMnJhSXVOWlByL25CVjUrVkFVMHdaU3BBcFNqSFRMNTlKYnBaeVpTYWtJQzVMWUl2UzcyWkFibFo2a05admF4Y3FEOXRnZUtMSSsvNTVIMU8yU1BZaXRNdXNRYlJKRkFSRWZsbjRqY1lvUk9mWmgvdnVYdkJNb3k0NnZYejU4UjJHMmNNWU1vL3hpTTNHczFwbytFeld1NUF6c2dUSXl4NThqZDQ0UHhOem0rSHY4ZG03R05uNkRyYXMwZVFlUGJ2M3Uxd0IyTDd4dnh4d2xkSkdnSno0WTgxTXgyblIyNmp6Z3RrMzErb2UxdUVDVDduTm1nVGUvV1Fja2Z1NlA2ZVovWWlHNlF2NWJtc2l5dmI1d0hkSlNjcEdIY1Z4RWxWTmVmbm5MMzdKS2VrZ0FJcW8yVlZST1NZeXcrM1YrdFVXSXBRWVRmaHNzT1o5cVFHT29uK0JpS3NEVjU4a2Q2QzdZM1dlUzd1bEdJcE1hVkpoeWZXaWJvMTNXTG5tSWtUWSsvaUp5Z2pkVUdhYUdMaXpzcXNtT2swNHg4ek0rMm5CRXdtUkkvZ3RuRFJtcXNsb2FTVE9WWmlvOXNneDZLRitMcmQ1QUMyV3o3YnNycnRwcnBFZjNGVEFubVpST3pwYk5BWmpja01LVE1ONVhuZDFucFZScFBwV25pQmNWbWZGclBQTGIveEo5NnU2OU9kVmp3RmpnNU05SEo1Q2w4Z0JaUmtSTXVmUDVZaHM3YThPNVRqSHMzdmFhMXRuejk5MHFLTVBKMlkwREgxTWJjem04WXZVRDhDWkhEWk9WdEFuVzBYVDBic09PWGlNNEdEN0ptRkpMbjFGU3A3RUJyd0xFL00wUmdUbGcveGV5ZHBJQm5qSno2cW9kbW9UVVA1QW5VSjMzaE42azV2TzcyTU8xWVVNY2kzM2NGZEpDeGw1aWNxcEU2ek1DTUNvQy9yOHV6dXFxMWV5V0duekhNRnNzOXo1ODNqZWZjNlpuQWE3c1JvWUVhckVjTnJSZE9CejkyTi9hZ2dBaXc5VEkxVEJqYnpaQTZndEkzN2xkWTdRZU5iSk96OWdteHk0SXI2QjAxdTNCUnQ2c3pUR0RTNktSSWVUSFBST3RLWkVaa0lRQndQOHNDd0M1bVIwY29Pcjh5cEJmc0RnSlRkMHlhVldkYlcrV2pIU0xyZjRUNTFpbEFxTTFwdTIxV2x3SkJ0cTBrbjd1RFJwRkhaaUtYYituVEs3MHdOQmk1Um14Uk5MSjVsYVU5eHUyYWFvNzIyeUFMNDg2L0tuejY5WHAvZFlndnVWSnZkaFNHVXBEVjV1VHhWT0pSQTBxV00vSG5MQ1RYVUdEcVF1N2xqdnduWlM3YTJiZHVtUkpzQjNCZVl1MW8vWW1ZMHFwTkZ1RlBxbVJoS001eFFGaDV1SElmM2xNNUZJMnpZZUZsdks2VWhnYnBEdHlZeDYyVG9sK1NqQXd3Zi9DZVArZVE0TDRjNDlOcUpzMC9uZkNOeGJybkhHVGFqTFZiR2NDMHkwYnRPbWtRUmxyVW9YL1pXOGVSQXg5RXRMV3R4cWtYZDJ1RDA1K1JJSHlqOW5XRGpOSVk4Q2FxSFdvbTlaZTBLdEg0YXdZRVBlaWNKejFlWDZDZUMyRHo0cUZ2RjlWT3ZTT3RuY0FCSXBZdEVLV1hzQVk4OWNJY09iSXhYTEpFalhnYlA1aXdBTyttSFJnYTJ5ZHZ0TmljZEtjbkltNVh1c2o1RzlqMFhkamZFbnB5T2U5T0hUVGJ5UlVhZmRUQjRTMTlXU05OdHVLc1JKL0Nac2QxcVJ0SlVhOWJ1ZVV5aTNhNkxPNmJqb0FDamQ3SkJzSUp5dXNxZzkzS005UXM3YVJVQ1N5bXBkalVMR3ZOV1czc3FwTlpmQVBncHZFanRlcG15c2Q2MlpTb3pPMkZhWEpDTE1naXBJREwxWndJNDFCM25Iek93TWpNbTJiOXRNTVlXTVhUM0FpU3p4VzNMbGhxblcrVEIydENjeHVwYzF2THVLWDROZTNOUE9QQ2huN1pKeURad0wxMkdybmlvelhjWEtHbE9wZS8xT1dmTjBkRis3VTRZRTh1QkJoVjBQd212VjVtYXdQWWRaWGRrNEZCRWhJWlR6bkdZR3J3c2haR1BWTTZwWC9XeUxtVlpDaklqYWd1YkoyVm9VaTM3bGRuRDRXdG5DdlBaeUd2U3FUS2oxUllhc2tHT0EwVWdOeDdxZjZKRTk3bTFuQ2MyMEhaa0Y2TzJIbmRydERQbWJtOXgxM29idlEyZlNXWkVoSkN6NWVFZENqK29mWkxySHNUcVdNeUlBV1crV3RjWkdhWWQ3V0g4ZVV6VGlKT1FhcWFRREluSlpHUlM2L2J1cVVaWlN6L2V4TWRlRXBsNWUvbXl0WnJyazkrdTQxUTdsb3N0cXJVc3g5aEJZMitJaFBMYU10MEhIMitRU1licXpwV043S0pBUkJZdld5aERKbWxkUUN6ZjhQM3Y0bE9XOTNHOUFDY2ZjakhWRDJFZ29qWVdTYzNIRVZJNnFmbmV3TENpblJRUWQ0eit6SXdSNWJXSmlKcVR5UzhreE9WU1NtdzFkY0REM3NFL0RjdXgyWExNVXhNNmorZmswSngzYk9LRGp6ODRHZHI5N3BKMzg5d1J3THV1YVZwMHpVYjE0YlNTRTgyNU80Ynd5T0tUZXBoM0dmNmtmaGorSmJ6YkcwWUdqdXluYlBiVGlZd1lHSWMvdmIvbzJ1SUJ4TUljRHkzTDVWS0tlODJzTFVMZUk3ZExYd1phd0R2ZmQ1N1VVcGlpajlNUkt1TTJ4VlpiQ0xIWEtKMjdrYnl6SzJISjA3bGRnL0FQRW5Da2psTWNpRVhUcWxSdjhnWE1uVVp2UHVncXJ1NG5zN3VSNzg5bm9vYVluczUzSU5hSThweW1CZGVSNzVkdUxqVzJVakRaTFdrZWRaVHptQWlPdVZrU1RDYTNTNnV0dGRYZ2FhbE9NRkZhSmRyTFR6OWQ2NVpQSDlmYnkrM3k3c2xKbHJXc2p0d3pSV2V0Mk5BN0NkZUZFSmc1dDVReFpJKytaaTM3bkl4VlJ1RFcwMmZic0FMSTlSY3F2LzlqZmY0RllwNUZranNpMW9zUFIyeE5iaUZacWNkcEtUL2pnOUJQOGN4cHMzRFFZbWFsTTJ4a2NxdVNSRytUVWlSSXZxeHBxWmJIL0haQU5PTTBpeDJ1Rm9lcmVPNWRZZytHOWpqSUg0MnRUZnVEL3YyVW8wRzF3NmpkYU4wMGVLd1EzVm13OHhGSVBwMnhsNW5sMFRLcEl4L0h2czZSZ1NtTHZzdnFyWnVZZzFmR2xHQlQ2UWErLy9pTDUrMG5xVDQ0bk15SzNNdXlMdWEyWlcwdGRSemY5SVpGNkVNSmZWQmdPTTVBNmh0b1pxWmFiRnZWM1JHYnc3dDV1QWFPSGJCVTgwbnE2RVljdmVjY3dpb09FbnRpRzg0YUNScVIzY1pWQWhRdFlkN1BtOFZTbEJLTXFEYzVJbzNtaGNwTy9uTFRya0N4TEhTSXlFNzl6Y0d2Y0lUb1lVdTBETEFmbzZWTHVaZ2tqMHdhbVRGc2lkMlE1RkN3bUVhYks3VEJHVjFtWDkrdVJIRDVhV2xyV1lxRnpLaUFzclZ0dTc1K0txWCt5S2cvZlZqZVhRcng3WGFOaUhaZHJDeW16TDdreENBWHo3aXViRlJtVzhveVQ1QXhJR0FHa1c1aFFvQjBtWmZsNWRxUVVHdGYwcC9LVWx0OGJOdnR1a1ZweFV1SFF6aE8rOHZzR1dGNSt2RXozNUVMaWRjYkFhcmV0bm1veDU3dWlqVVFkZnV5THRmeW5OdVRDK2FSRVlBaEd3a0ZMWUpDdGhzWU5SVFgvZkF2cnkvTDA5UDIvRnBLZTYyZU5zL3ZSY2NlR3ZhanlYcUpNUXBRNjJTOE50MGFPajJVTVZvSzc1NTloSlEwTXM2SzRlNzZhSUNoZFJiN05BTlF0MUtZQnlnZHhkbCsrcURSSnM0cm1FMG9iUTZWV21iMHJYUlNKamxkMzBZVHI5a0hnQ1JxcCtPckh6d1hHand4R1kyQjUyOCsvdWJYK3ZLTi9YYXA0VXAyK1MxdEVCRE0zcTNyaGJHMXlNak9hWnNFbDI2MEtCNHd2YzdvR1NiamJQWVVNa1BtUmtBUmVaTnNTV2xWajl2YW1YblJzUUZwbnNoUXVobzFKaXdON3o1R2ZUQTY3V1pGbEZHY2Rpc2UzanR4SU9tK0ZxdGJuVldVVFRhQkVlYzFKOTd2cTN6TENXYmdJMll1Wm5laWFJd0FSd0YydUtVUjZCWVVldzEzbkpJQlFiRHNaRXdLbGxYdEE5eHRFSzlTaWRlTTl2cnkrbnIxcFMyTU9tSFRTWWdJd3B6UzFrdURTVWhRRWdxdjF1Znl4SW5iQzA5a3lVd291UUFxeHBKMWl6RGljNG1ueFo4elA3YlBmcXNjTnBKNWIyczJ0TFVGNXBRNy9lazFidGN3NXNGTXU1Y3JHRElFcEIvT1FUcXBaVVkremF6UnU1bmNqM2podW9wUHJGdXROYVkyUVBQNmRYTEM0WEU0VTA5cjZ1dmxjSXplOVhXY0xsY2RselRocTE2MnIydG5IM1NQTFdDczlhbUZNcHpRMjN2LzZaTWI1SmtXbGRKWmpuZW9nTzZtT1llbjd2QXg3MjluWmFDOWlXTHU0dnNQZi8ycmoySDIrZjJMUkErWTlyT2JFdlIxS1dZYVNmTnNLSVRIa3hwK3R2V3hxU2hnUDVsdm91R0NlbFBhYjFXWk9OMGdzODUzTGZNODB2MDRSd1k2Q0cxenRFcnhPSU1sVW5jRzRyUGZTUGhLYmZmU2tINFV0bmF3NDgrd0FmZWQ2U1NhZHk5c2FsdWpXeVpZY3VsbklzeHFrdnZvZmhxN1BIaVlhWCtJbnRqYUxXNWNwN2RMTWpMaWk2SmRYMTVmTjJaQ0VSTzJORGV4RS9sQVVrdEc3bWVKR05Ta0NOSzQ5T1BFNXl4RjQxVHZTMVFObE5vV1o5R04xMHpEZFFHd2xOSys4YlVoVEVweWtKTk9Bc0ErZVhkNGJ5R1hsdGQycThMUDRsaXVXaTlRK2h0Nnd1bU1sZEhhdGV0amtKT21HWHhlZ3grV3dwdGx6V25ONXFSeXFwWFBGTVE3Tm5zbi9LUjI3RXF6TXg3YTdBRWRUYitWTzNkWTYzSy92bXA3TkdrL052U1lXOHhUKy9yRVoxaXFNU2M2Y3o0eTRWaEQxSjA1SHU5bCswZUl5L3I4U0xVL2VFdVFqR0ZNNEpkM3YzeTMyTFBldnh2TmxPV0pBK21YNXd2TWxLMUY2eXI3U1ZPWS9lak9WdVRYcGprekY5bWtobVIzWXFzdHNvdmFPMStmL1ZEQUF6TTRKaWxFVVlKSXFCd0czQ0RTTnR1NW9QTTR5em1iMFZmZ0ZjRE1hR3hUSXlkRXB5T01DRXJZbmVqNGF5YjNQWGc2cEF0Rm51Z21UbHRMclFVMmpMZHllQ2Nmd3U2M3p0clJBRnM1V0ZKQi9QRFVvbVBFUkxRYU4yWGRPbHpQcnNMb0paS2J5N3BRcjhrNHpodkdIQmVCL1h0MHBrTjNDR0dILzBHRHlWckhhNEtFK2FwM0RxdVJ5YXhVcHF1OFUzMStXdTFyUUdFMmdGM2xSRUowUEpsUU4zMTFxRVhIQnhNRmRXdVJzYnoxWm1PSUg2M1ZXK3pHcnhRSXEyVXQ4QSsvK3A0L0ViamFuTVhrdnZMT0xLUURidVJzTnpNMUlJQkJHSmprU2s1YjJ1bDZxanRORXUvRXpHZHV6KzdVem1QR2ZJQ3Bod2h1VDc3NzBYcjdzWU9IcnZIeENJTDc4ODlrbVJFdGV1c3llN0VDckVLYVhaNmUyR1RyMC9zYXJTZm5BU3pJM0plbjV5VW9SV3ZaVGlpOXVEdDdnL2o1WXlZT203M09tNEZhNTBKcDFsamtaRzRjb3lPZUtqQ2lwSFZKczQ5alNJWklQUVp2NW1RSHFzY1QvNllPZUp3STNzRFE3cmpaSXJNM2hBYUZjaUhmb3E4OTB1NlBNMEg3VytmbVMyUU50SlJpUlNuOTBEN1g2U1hIZ0YzM3hnZkljUjdhYk4xU24yNHRXbWhOR3FKdTBiSzFXbHNnZzVRc3h2eVQvZXhDdEJUV3JwbklNUjRkcHdWYktFTU9jMlBuQWRrQUo4YW1wK2orMGdaYVdjM1g3WG9MUTJ4U2xpSjdlbjY2aktrMTdhU2NQV1pxTm81TkVmbjBoQ1ZxN2tZS3V2YytGaEYxYS9FekNYZ0FGNjNXbXNjNjd5UjkrdkwwOGEvKytUK2libVVka3p3Z3pvZHRUc2JCME0vM1FPMTFWeDN1K0hQdVpGOUJuSHZaeGJkSzJERUhaQjVuSGZHK051YWUxWTd2TXN4T2p3SEJjVVRscmtJNlpyMlRETXN6K3IwamVKMHBVWlJTNzIwWE0vSmpiYUZsZlZwUkJmbmxxWHAwUC9MdSs0MXlXWmZGU1dXMkZoUG1uN1BRSXpqdlJYWVBjKzM5WU8ydUdjd1dHeUpGMjRWbTVIRUVjZWNSOTdmM2tlM0xNSmhCWTdvTWpJNTdjNW5VdENGNWpublhIeFF2RkEwSnVTRnNscEluS2VqdzhUdzRoM3k3TVpnWitId1FNdzFXQ05KcVpsWkVhRjJHaTNYMVE5NDVQK1dOREt3WWhPVisrbGJXTFJVdHNxMW16TmFpWnEzYmJkdlVHTllDSno4MU05STJpNFF0NVVaelRDT0JDYkprWm5oa0ppelk0M3JndERUdjlXN0hVUnp5NVhKemRNcytNM25DbDR1bk1TSDZvNy9uRlBPbkR3V1pMNFRkT3g0ZFhVbi8vYmh0K2FaaHgwQUxGTkhxY0tXd1E2NEd2dnZMMy96VC8rNlAzNzM3KzgvdjhzZHVwc3JSS2RGMWYrenRIbFREVGI2Tm16OFg5cVFKY25oMVRIUjNsT3c4OWJSOS9ncnR3ajN3NUk1TTdQS0RjMkJQam1NNTNDSDNBMW5SbFltOFR6dzd6SElhSVI5K1UwMFJJVEQ2eUl2dXk3SVd0MS9lYnRmTkZMZVFHSlZQTjA5MjVqWkJzbHplWFJ5STZQSXV4T2xzME83czl5Q1N4cHYrazUzdnF4UWpNN1BHZHNnaU94ZDdqOE5URDhCaktsVW1rckhSMG50dytnU3o5b09nNXJIdkdGZDVDcGFjZCs0MG14TDZ2RmtaMmJrQngvampmT0t5M3JEelBMSE9CUnFlR2lHVzNLZ2FrYTJNMDJtUk5sYzY5YVpIL05nNXhtU1AzY2JEMVRaRVpuM3lZcXExUmJSV2E2MXN6SXl3YVZNN1dLZk0xc2RQNGF2YitPaHhxRGdjdlhLU2xERVg0Unljc1ZoS3NINDZtaTFTY2NoZVVzb3ExMXBvNW1RcTVYU2R2L1YrQ0xUU09ta0FVY0IxdGJZRE1uZm1DNTJFdVcxcGIyYmdXWDlFYThPZnlLYU91QW4yelcvKzVULzlMLy9aUC8vci8rWGZ2dUMxVmdXdEE4dG05MmVTemZKTjAySkxBMm9OakNQV2VadyttSk14bTkzcjQ4VGltbURtUUNoa09SVjk5cmkzbitybTNsYnViakxjbVYrN2FrQUh3MjhmaVBGczJIZ3dUSWFEaldwbWRwS1F1eHU1THV2VDA2WDQrKzMyK3FYbTdRYzNjOXF6bHBMbkk0cmZyWmVWa1ZtejFUbHdQYVZVK0lOUis1c0IzQzlZaWt4a2R1cWtuWWtmNkNESVBzd2NodnFUZllncDZBY1V0Szc1bWhya1B0QTJuaGliT3dQamJvSGtnT0hOcGRnSDN0NTlqc1BaM1ZIdWQvR2Z4YkYyLzZJNUYxaVp6WmR4MnBpb0s3b3RabmNMeTN0SSt3d1dETnpFQmp0elZUK1NqSWd0M1dRT1UwUk90cUVQV094a3BOM2p0TFhjYnJmbEhXVyt1MVdSeFozOVRIcE9wM2xNRnVPY3FWajJ3OTRJb1NpUnk2cWFFVm1UVmVhQ0wxS0U0TW1Ia0J2OGwreXNNS2VRWGk3V2pvTDJ6dVlFSW5QWVhmMzhpaGtiMnFqWmcxM094M2UvL2lmL3hQLzZiL3ozLy9DNUZyV2RCVS9TTkNwbW5keFB6MjFuLzZxcHk4Nk5Ib1NFWVRHVUExek9pVm1jVGdzKzVIMTI2SVcvS3BxblVJWFRUWFF5b1k3T3JwOElzWmZlMDZYMmJMOTdwMFRuVGhkUURNMzNreS9MNHNhbjh2VDgvTFI2YWR2cnA4K3dsMlZaZlhsNlg0djdmckFDeWN0YWJJanRZOSsrcGdSSUozSCtuVkxyVFV3Nk02TTd5YmNXTmp5akJpQ3ZBVVhwVEJuSFNSaFFoa0ZNUU1yV0JmUHVabXk5MzRuOXRVWnA2Ti9IcUt4M2w5M1luSlpWRjlhV2dqTE1teFdLbnZMaVBUREdWK0hwd0lEeGZ6SnRuMXJFU0VBQ01sQks4MUxzR3ZLcUJXcDJwWlRxUkFsM29wbjNCR3dJSzdteG41VzdMN1JtUk1xWVZNQndjeUpUOWZQMW83RkNhbHRyN2Rxc21vZGFSQ21YMVNTYVcwMWJ5NnZqOHhmNzdoY0JvcFNGa1ozK2s0RDdtcFIxRTZkNUFFVS9zMmxRUU55NGdhRUVLKzJ5THN1R2VvTUkyYlUrRnpWWVJ0UFNpU3Frc0NVTkNDeTB2TDdRa3pTb2dXa1hlNzErM056UlpEN1lQZFlhakEybEtXK3R0cHRyRXZvdHV4MHVsTUZtUzhXS2VHNjNxaFhaRmlKYWdwRmwrWEw5MWIvRXEvMDN2LzdOLy9qdmYrdTBtbXBMajR5MnpQRmhqN3BZaHRERnU0K0pqTWlFK2I1MGgyMVVEREh2T1ArYWZaNXBkajVLcjF0ZTArYWMxRTQxZHBoQm9EWDJEV0p2NkthaDlSaHljVkNMcGdwcGVHdFFKNXYza1lkUGtWM0s4R0hCcFdqTHBjalhwNmZMNWVJZnQ3eDg4eFRiK3AzOWFIaDk1ZTF5ZS9tclgwWnVQOGd0RXBicHp4Y3Voc3hXNDVxWklHMlpkZjd3RHNqaDZUV1Rjd3lMdDNtNDY1NG9vaVdrZkcxVjNTSTdjT2hFRGlyVkpMeTQwRldxb3pvdjk2QWNKbFZtbkFESXIwNEhmeVR6YWRiTTdQandjSDdvSnJRSHZhMzdQajl5QVFjcmVTZEw2MnZYRG5NamVFc2ZCT0ZHMHhCRWNwN0QrVllCUFZPNGRTK3NmdVBVajFVSVl2bHNMRUdvdGRacWgzZlRTRVpFSklrbEFUTmtSbTNBSytnQm1uRVpIazE3OXVtT0loMjF5aW0xSDE1ZXZidnJCQ21TTEl1K2ZWVnJBSXVTeUxWQXJXV04rbTQ0Vll6em1zMGdtZS9zUldrY3BYUXJ5K0xHMFhRT1ZMUXZaTG9VajBqQWdJWHRWaUlTVm02Mk1DQ1greEkxOHVOMldmajk5OGhuNUMvK2g0Ly82Ly8yRHo4K2I5L1hadzZnYW1yQ2x3RnIxRkd3VG1aU0dtazAxMzZFQ2svQWxlN01kTGdyZng2VVNMdzdCTzE4ZHRaUmR4L0RvWk03OE41Rm5XcTh1NEpPdWNzTng5THJiaFV0eVNLTFZKYVB5L3EwUEpmTFdwYkZTc3ZsM2FyR3duZS9ldnIwT1JyS21wbS8rbUZ0YUdISnNxenZuMGdpVzYyaEI3R2o3dXArN0piWTVIbmd0Zk1zRWJFTGp1NjZ5UCtmc1RmNXNTVEx6dnpPZDg2OVptOXdqekV6TXJNcXExaEZzbGdTVzZKNklDQUlha0dDSURRb0FlcWQxdEpPLzQ3K0NDMTdvNFZXMmpRZ2RMY2EzUTJSYURhSFltVU5PV2ZHNE9IRGU4L003ajNuYUhHdTJUUDNqQ1NWcUVWbVZJUkhoRCt6ZTgvd2ZiOFA1ME1OOEtBajgveU44ak16S0Qzd2RqVHg3S3dobVpXTGl4TG53Zm14ZEwyQlpiS3ExVXlXejRQUFJMUjRnZGxuTGR1YzdqVFhRUGNiMlhNRUdpR3pxOVZFeEY0ajJvUTRNTXJ6Ry96OW8rMnozeTBTNEEyQW03djVJTG1QVHRCTWEvRUVRNVI4Y2JDa1VVMkVGSFdxYmtOTjBwdURXZGhtTkphQndNN01JanlyYUdscGxJSlhUTW1yVzdDT2laTnp6MldxQmxlaVVYWFhrMmxSTG9sU0ppRjNWbklYWm9FUmk4N2REeHJHd2t5TklpbUxIZVRPSENJSTlnb3hyZXZJbjlsdndBeXVhbTZVTnFQTE5LbUljaWNxVTZtYmp1MnpmLzhQM3FjNjdaNzk0MmZiZi9FeTlWMkZVdndPMW5TSTh6NDNoellHakRoQ0toUDUwZ0VURnVPVEwzTDZtYXk4UkFyNXZhME9Gc0hHR3E3RmpFWUJYUjFENTdBdm42VTR6WG9BdVVlOVhGdjJjUThzSzBsZzV0UTMxeng4KzJRcjJ3dVJKQXdSN1lpRklGNElGOW5MVUd0bU5idGtJeS9XazJUWjdET1JhUzJUVnZpS2tIeE9EbHFtNC9PTENxeHpsSDNCYzJ1dGFtYUtzMm9YODJJU0M1K0VQTjBQb1NGckIwSmFEN3FkaUpUajJHdS93TlBjVzZMSjloKzZ0MmRPSmx4ZEk0R0xadXhGcTdYUDNJWjV3WDdPaFhOYWJBNnJpMjNPWW02bThHaldSYU04T0ovYTNGeVM3OUNIdEl4VGJoVGFoaXlaVWZ5dXRWb3c4SkxGVzgwaDkwd0NGZ0cwakphWlhRdzJVYmJydEtrT1FCd01uYnRDeFBpRlpnNnlreldHVmp2OVhFd2FwOTFBbk5tNlRVVTFMOEpXUndHYmFpV3RLVWVNMitvR0pwYVYwNUpoVmN1WVZOVTZwdFRtY3JLTVdpdXhsdUwrUU9yUjBzTWsyVVRvZGxWSFlpZE1IRlQ2MDlQdGZqdjg0bC8vOTA0OTBmYVB1dXZQcnZNajBVVXNmNzVaUVNBdloreEpkWExxRVlBN09YL1QvZnp5TEpyRmlIbGZPTksrWW1qRnluaVpqc3c3WUlZdk5rWFFqRVJiekx1aFNiQldzNit2di90VDBkUytvclMybEZuQVRuaWt4U2gxc3AvNloxM3BIay9DN09RdUFGRWxWbmVTdk5uYXNjQlVyVlRLTktHajNFdG1WL0U2bFdMTFh1VThtRjJjRnJUT2d1THpxelBiYU0zTnZkWnE3bWJuaUdNc0d2TFpIeG5laE5rdXpTditOaGFCMVhrTVBQTzlHMEhCV29rTVdqVWFENk11NG1BMXJWUEV5YmphYkJOcU5RUm1lTjE4MTlKRExLM1RQUWpKZkFNbnFLcDZlMTNEbWdTNEI5V0x2ejhvdkxFb2c4M3RjMGtDbzBDR0U4allTR1doWWk1RUdnZmcwemlTRVdDTU91aG1kNUJKaVVpRmhJbGJtbmJMT3laM2J3SG9wRXQyWDZ1bUlaRTNIdlUxMDhha0c0WXlwUXlyZzJVM3JhNHNsUml5K09SeG55Uk14T0psTEdXa3FoaTN1MnlSTW1WcC9qNjdHYVlTN0ZuUXd5d0FGaUV5ZEx2dTFqeVJsUXhWb3c3N2o3UHQ4OTJmLy9pSDc1R05mZjdEMituZnZoVWNHajdjcEQxQnFhMHJaeUdicjF3TFRCeFVCRi9NS2ZCVm9EM3VKV242U3RIUm5EaVliMXErNXpiQ0luTll6NTNEejBtNFQ1bkQ4Z1N0ckRHZzVUZm5OaU4zZ0ZoUzZzQXA1Y1JQaDNSSlIwNHVESGR3WXJnYXM3T3BZK3QrTlBaYTZFZzd0MW9UZFYzSzdGYTFGSFhpbVduRzl3NU1uQ1YxYTZqZnFzNjJSc3NwTlhCUndibGNuSkhVSUJqTlJETy8vS0VoV2pTSTRWZU9QZEhNSnRKbUlWc0NnT1l0OHZrR3huZksxSGJKYVNrYUpMcVdMN2hxV0pZWGVNMXRXSGs1ZlEweHd0bEoxanZYU0dRRENFZ3N2ajZCOEwwOXNMZG9Vc3dBN21VeHlHMzJweVprWkhFU0xtTTFVelUzSzFWSkhheHVaVlRPeWtvTzd6SlRGakpYaTg0MlZtK3p0RFBhdHRqc05nSUVFUXV4a2tZNzFnbHlnbGF5eW1RMmRTQTFZMllsOGd5MmdNdVNFY2pVWk5iZU9td1NOUzIxMnFRcFdYZ2JZd0FPUWlDb2Ewdis4ZnZuV0h4UGpmSWxvVE1BbzRwWGMrbTZYZS9UZ2VoWC8rZC84MVJzQThVLzlQSnZqcW0vUTRqdXRMMUduVWNvMkhZUjQ4VXJwV0FDaTFBVEk4ZzVqcXBKL25pT0pEV3NzcDV3amxhSm5LdVZ5SHRWWGpmdXl2eEp1OCs1ZVBNejBzYmdhN24yZ3hDWStLY0FMTXljQVhEcTh0QS91dXpaOUxMbnpucHVDUnhOVHhEa09UTjBHRGZPTkkweXBjc3lKS3ViVFM4aWlwTlZkWXJrRWJUZGpjOUg5d0lTWEpnQUFDQUFTVVJCVklyZE14OVZ2Q0p4T0xYNEpUVlhOVFJTQmpVL2FyTTJ4d29JemVMT09PdkhBYUxjRG9lMFNrMDdGeUx0R3g5cDQ3UVF0TTcxL29NU3VwWGx0VmFyU0E3bXBsaU9OYzc5WDRLVmRPb01PNXRGZTJkeEZlYWhXV0lySlRJdW92ZU5iSTVWeHJTL20zWSt2NVRoSTUvTFVadHhhc3BnYmtzVG41K1Bsc1ZFRG5ZelozYUZ3QWQySjRoM0tXOEFZV2NOYmZTTU43Qnp3cGFyeWZKQkdnQUJKNkM0R3hNaCtkYU5XVFY0ZFF3eU1oL1V5Ym9rM0tnREd2WUV6TWV5azZraUpXUWFCeFB2bUVoOC9yQ1lqV0E2MW1YQSsxQ3I3azdTWGI1NExIdTVHcFVZbFFweXYza3lVaXFPdTcvWWR6OTVEQ3FwLytEakwrNXN2S1ZsdERnbmFMaTcrMmh6aUd4d3hMWWMvbnVlT1ZlelYzODUxOEdZMTBYblNLTDV3OE1NZ09RSE45VVNjRGJyYWxlRzRvaWxXU3BTRUhsTEY3eFgwSjN2OEJiYm03dk1GeXdNVGpKc0xpNDZxbXFacW1kcDltS3dLYzFVQ1VncTZEZE9kUnl5NzlPZFc2OFhYWGF5T28wZWQ5N3krTGY5dUt4eWlXWkoxbHI3TURlcjFheHFWWS82ekIwc1pNNVkydVdBTFdPT0hWbG1BWTJQbnRybmsyWnA4b3d3T2UrRkNmZTVndzgzcmcvZTQ5amZlT1hJQks1clYvWHE2d0xPenVkcDNYemtMTGlsTlMwZkJHVm1zbW5vMVlraG9zNXdDSjlwbzB6M29zZlg1NE9qVGJuUGc4L1U4ckFUQUxBRUZwVjVIcWFSTUxNSWlFV01qSkFta3ExYTdWMTVHc1VQblFNT0pNU3RtNWdaTUZKdXF5czRPUXh6SzJnTWRsWkxiVWRlM1RsdlBLZnhWSU1FSVFDQml4TXp3eE9kVzA2dnpMcFVKRzZPbkJJbm0wNndwNjBIbmx0OUkxQXR3Y0gzMVd0OEJzdHc0a3Mza21vM0EwbEo1cFJ6ZnZwMjgzZzQ5anQ4c252MG5HeEQ0Nm4va2RsQnozWThBZ2h2MjJOVTNOWFViSFN0cFZZL3V0ZWloRDdtSGo0akYwSzhTYjY4UTFFUnplL3Z6Rzd5T1RTc1NSQVhENDgzMWRCYVNlWUxydFlNTWVSZkVqa2Via3ptTGxEYXE3T0RwTDdyVXA5U2NoQS9GdmpFbEVwMnRWNFFMWWE3bUNORlFab3pjMDBwMjFRbWJQdkt2bFBsVExYV1lWQi9TTDFjcVJqdVpiRGh3YVVYeDd5NmFxM21rVzFwbEZvM29XZERWN01iUnBsM2hoa0VLVVFDSE9hSmpFamduanhHdXQzYVNPUkVpVnlkaGEzSnFjM0RnK2t0SlNibzV3d2haMGd4Z1d0bEJzd1pWc1BXSWZDSkU4Z1YvVGtNTFViUWtGWnI0U3pWOGhCbU0zSk9rNkhQSWk1R0JDOGs3ZU9Vd01TYUc1eFpXQ0ZVbmNuZ2JLN05vMHRHUkFKek40ZkF2UW9FMURLRllSVmlWU2RqWlJnY3FhYU5HQ1ZPUkpKZ3JpNU1UbHl6Mk9HMDZZZWRXZTM2UEhFSHJmRzl0ZElrd3UxUmlranNRTU14dVFJSkxLbFVxODRzV1FYaVVJL3F5WWpZalgyeXFlOVNSK0FrUlBsYU96STZkQTZWSkppU3A4YzcyVzkxSkI1UGgvTHNncWFjQS83cnBuS1FQSlZYejhmZVhTRlN3Vzd1S001VXAwVDF0TjBQM2Q3c2FkNS9jbFV2cTJLZnVrZVArZy9NTDU1MXVUNnBmLzcxdnB6MHplZFhzdk9VVkpIRWpZbWRxdXF6SkpReTE5eWFUWU5BYTFIRmNIc1lUOE5kUFJWMXA1STNxZFMwSlRKWEo5NEdlSnhTVlNVQksrSUhjbGlENHdBOWl6Ym1LTlBXUWlybHhtdWNkYU5UTTdZM1lFanJDWm1LT1NReFY3REh6aTE4dzFrWW52b2VxZHYwWFVKSHhFNkdMQkFpODJTUVRFYWlNVll2QktvQXVhY0U0LzNsOEZZdkgrLzdpNms4NjI1T3dsWjBtb1l5T3kxeU8ydDBabk8xQ2J5eHVEa0xCMTF1OFZQV1JzVTRtYmtqb2JRUmw1Q0pzRU1hQW5KQkRiR0FJR3puUVR4bVNKRjd1QVRuR0dtS2lNNzdLSDBOU0lrZzFoWHNwcVlxSmc5dytDMnJNZktqREMzVWdGZXpkU3htNFA4Ly8xZ3J4YVJ6b2k1UDZqQW50aFRlQko2aFEvYzAwS3M0TGJRcDVUellWcC9IOCtaZ3NMbTdzWk02aThEYjhPMzhvS3hIOWlFMk1uZFJ1MVU0RXVmZ3Y3RTd6eGxHV01uSVFreHhOZ0tSRzFIRWM4Zk1rVms2cis0MkVqT0hjMTI1c3NkejEzZ3haS0tRbVZJbGtpUmxKbE5US3FlVUdBRldJRE5sR01GMTZoZFBXM3dmdWxySlRQV1pvQlNUYkNROGxMdnV4OVoxNHJuL3VFNUZ3WGpVbno3NXBXdloyRmk4MnRSWFpZV2JVdGp0WGR5MGVPM2JBM2FzNm1tejZmb01BMU9keHB2cjY5ZHZqMzQ4VkJKeEowS21CaGRuNXRlNTM3aE93emF1eGRrTXRZU1kwVDBmTTlZYkZRclRReU50ck5SVWNaQ2NQZUt1SGdUTjRBMHpKVWJQS2FXdVR5dzU1OFJRV3U1OUQ3ZS9rOEZoYytnZ1p2MkJpQkQ1d1pueTl0Rk9jaDNycWRDa3BaNEJPdytSUHhHMzZ1ZGw3cjJkZEhzeVZNMThKcUpnaGF6bmh0L2xCdXRsb09rZ2hPZXA4d3hjbUIrNVJIQm4wQXEwMEZBcHJRT3llYmp0QVZwTDN3dWw5Slp2WjI1dUNIME1uek5yUUJTeGU5L043dm0rMEwxb1NvVmtrZWdFK0pKQ0tMSVUwUS96WkpaWnBXa3pTY2VNT2FDN1JKUTR3cmtzR0pnOFB3VGYvVVFXVWIyWnE3dFdkVFpEQ2lrTWhEWFVSWE93M0xMTjFwWml6c3RTaTExaXlxNWtTQjA1Y2EwMjN6UUFtUlppUThvaXpPUm1xbUFOWGdXQldMcWMrNXlTQ0ZES0NadHQvQi9FTGIzSWF4bTM2a3NsQzhBbFpsV2I2cWFHeENPbHh6LzdnV3p2cHVMb0x5NitDaHVkVkxGcFFzS2JYY2VUY1M2bUZTdSsxVUJKRldSREN6Vkxrbk95NDNIcSs5UmZwUFJJVXNjMmxTK3YzOTdkdkhwMXRkSEMvYjZUTzBsc3c5MjBFUzlHWGVSUk0wTmI1Y3dQNXFKNE9LYWVvWnZudE92bEFVWkVuc3cwVlhMWGhtSVF6a1FzT2NzRzB2V2RJTWFOelJicTU4ZnVBVXBpT1RCQ0xBUHFOOTFvSkowSkcycWhzZFpxdXA3QjMwc1hYdnpUZklZeXQrRlZLTC9ZNmxUVkFoYTVWQkROTzBQd2hQWnY3Y0lWRmppRTU2dEFWMTJ0ZXlpeFdORDQ1Vmg1QjJrWks4SFk0T1RRZWNITWt0L3h1dUZoWTd5V042K2k5dDR4YTNwWDFGTjBjdFhOcDZtYUVBQkp5d3ZzWjZYTytXL3JEOTUrTlo4QkFOYmlNQk5BcEZ6YjBIUkJKT0srbG5vVkd0M1d6YTVLcHNvK3VXa2ROcmxuZHplQkxPQ0E5VWxrL3BBbkRuWUpFVW1ieHJGTVpKR21ScDZKM0pTNGlpRVR4TjFxMVphcUhuUE12TW01RTBvNVNacnVSaTNxNHNwRU1HNTUyOFBoMG54eDJqZ1JwbkVZcTV0TmZjNVNKbU55ZEc1K1FrZmxkUHcyY2liTWh0cFJZckpISFpXaWpKT3JMdlk0Z0U0cTFYSW51em1LdU55ZENyR2c2N2pmaUxuc0x2WWJ4czgxNytqdHk5dWJ0OSs4T1k2REhqajNlYnV4RVY0TCtpYkViMXk4bHVkMlRsNG5TbTNMaTlVK1psblBlWlBycnpRYmM0U0xNY2VvakVVa3BkUXhwNVNUYkkxU0wyWXA1RWJVTlRHQTMxK0gzazhnZEhpTWxFQTUwelJNVGtxdVpScHBxRlhQVVdwbng1RXZ0K3c1ZkpPRENyUVlYdFdNWUdXcXdSMEt2M1JUSTgzSkVpbHlrWmQvSWpBbWxJZjN4dG1OSjVmWUNjd3RzZlRoYStUdFNvMjBJeWRqNG9YY3pWZ0RpSmMwS2dwbmJPenR6WEdmUDREdnVZRy84d0l2L2lZelBUV1hUWmh1Y2IvcWNxdzlZbjcvQzNpTGpKNWZaN2NraWNrbXpVM0hLVlMxT3NOd3J3ZHY4TnBtZG5Vd2FVaDgyWXZYV281UGRvbkpqUU1PdGxBT2wyMllBZVJCZEZ0V0hPeUNHZkRIUWhCaHJ0Nmt5ODBVRU53bFFzamtLV1J0a2F5V3MwZ2lZYVFrbGFiaTRENWxxS3NabXhKUm5ZYWlzNkkrOU5DcTFTVXhQUVViYWFtdmpGaHZiNGVuOVhDMDFLY3BiemFKeWYvQTZ6Qk90M2M3bE9NWWtuVDFHWklJSXFoUHRMSE1MSklTczBsR09SM0dRZngwQnkzUHpUaGxwbWZZUDMzMi9NZmI2L0h1NXMycjF6ZHY3cTV1SzVKUXYwdFcxVlB3TzB5YXhZYlB3cVhabnJwK3NXRytSTEFzUHNaelNDS1JOdDIvTVFRUXFTbDFLZWZVUzlkbEJtVXpTYURHa0RwUDFGWUNUY0paa3J1b3A1YThDS3VEcU5YUmRSaExwVkdyNFR0QmdIUHFkMlBGdDhvTGM0Umx6TjFVVGNtdHFzM0E3UmFxQWhDbE9ZMnk1WmlrcFFmbUpXcVdDTFAybVdZc2NBS0lPZmtNK3lKYnBZODFSakFNTWVFeWdGUmlmNFdIak1EenIxMTdTTllaZnZOUjhXNi8yL2RFN3NWNkFsSW9ZaDl3bHNwaUtWQ3dZQmpnOTVaSWJITW5ITWV1cVNVWEtEUzF3NFExT3F1VmpvWld5NEhRQUFoZ1FmT3RwbVp3bTVLenVwR1EwY0xQT3FNMVo2L2RPVjAydG56RXZ2aTNrQ1RsOHRiTlNaZ2JrQkFMVHR1dHFoS241aEJRSnhFNHdJa1pWUHE3QTVGNlNwQWErUk1nOGpxVXFnNnlhTGJKU2RLMmYxUlQ1dWwwZDNlYTlPMDRLc0g5dDBsaysvVHg1aG1ENmpTVnY2ckhZL1hoOUVoSUNUcHQwWFRlU3p6Mk5CTFQ4QVlzd3N4UExpNmU3TmowRFEwM2grR0lVUlhac255dVNKSjNsKzgvZXUvSDZYUnp1TDU1K2ZMbHk5ZDNPaDF6VHNKUjhCTWtCZzByejlGNXlMUG9FU04zYkw2U1o1NUFPL0VqbjhnaVZwa3RkeUxTZDVweVNqbExUbjBuaUdoMmdjeW1hWncxOTJmcHlMdncxc284cyt1MFR0Y0hLOU40ZXpmNFpFWkJhVGk3MXM2K3p2TUdqUzM4UDdQcHdseXRtcEs1T1JOQlNacytqVnR5QlVPSWFJN3N5VE9YdXZYMFdHRXFsZ1VobkpLRXU2T0ZJZGo5c3lVQ2Y1MHBKalhzMGUvNU84SkMvZnpHa1pQRHpKeG5OZjZTejhMdjdvSGY0VEJjUXFpUVhCaG55TW83MS9UclVUN09YdU80Lzl5V0NSUFkxSldZQldBNEVhdERHSzdMTWdJUGhTRWdOZzZCSTZuWHprM2NKaHFHN0pUN2xJQ1o3M3YrTTh3ekM4ZThuMlNmTlNRV0dWSU9ZZXJWeTFTVUNCcC9udVhiR0VjMk83a3BJRTZhd082ZWtqQXNPeWZXWVpvMGRZa1lxcXBNOERxcCtsbEE3MFRNUXFZajNvekh3M0dxdWljMzJXelNreGNmUFVybDV2cFE3cTZ2Ync1bGoxcWt2OWdkc2dEQ3lNSk9sQ1MzKzMrc1krYWVTbWVSTXoxOU50RGxoejk0OGg3YldMMU92NjZsMm5pblcrYzZuQ2c5M3orNTNHMDNteGRtUGw2OWV2di8zbDBkdEZUS2JWSXJUZnhpRHhDdmZrNE84dFpkK0dxbmRKNkR0dndUY1lLa3hMdmNpM1RiRFVRRUlzSWNPM1VqdUVONGpEVlcrSFRQUXZ3bHlzZlhQWjg3T2JpU3FhZWJrN0lmUno0ZXArazBrUmtCWlBlVWlBdi8zaHUvUElSKzhRTEhrTkZMNUl3c1ZOdFdVc2JRaWxzSlBmZkE3Y2ZiUHJnSlBIeWVKUzFiWm5laXhLR0tRQ0tMMk9MN2REVUFjQ05tUThEcGhHTlQraTZvVlhNem1SbGMyL1RjbG1jNkFQTCtmVGJnNy9seGhTU0JteERDTmZBZEVnQm01OGM5SVU1WWtaVDlUTWtIR0ZBemd1UkFTenBESFpMWUxUMUVpR001V0ZzaWhCRzVXZUhFcmpXVjRaQXNiWGVQNkY1T3hiMjV2QzJlckRubWQxYnBteW94Q1pQTGVEeU83bVpzeE9Sek90Mmk5SFZyRWVQTkxpSFJJZkhiMjd1cDFINS91ZHRsQXJzWjNCSHlQSGlJQTRqZ1ZPNE9WNit1eDBUbVdrcnhwNy83MGZ1UGtsTjUvZSsvdmh1UGd6bHk5MkcrN1hBY0szbWZhZFNVKzdoSVVpSWtBYmwxdGRmYzFhTTExNGIyRjJ6ZmZqYkpkcjkvL0hTNy95KzFqSWZyNjlOVlZTYURmMVZPZGZ2ai8raEh1NmxJL3VFUDlFK3V2dmpxbTYrK2VqMGhFbmY0VEo1WmNEZUxOaG9FcGZtcG1ZY1VjVTlxdTRZNE9MVElSSnh6bHBRN2tYNi9ZZUd3SEJGYzQ5K3FLbkhuUVZhWTkvTThpeSt3NUo3ZSt4QUx5TXMwMWVIMWEwL2JWTXB3cU9iY0VFMFBwY1JZdThqUE56cWNLZ0EzOWVLbXBtN0pJN3FoYTNuT0FDQkx0QVRoL0VLM0hoanhBaTg5Ly9raGIxUG9sRm9xWFRJMWpxa2VVd1AvZUNnK1BBYnpaa0NmUkFSV1d0Sk5RNElBUmhCSk9sZXNqTW9BV2VWNUJ3OFdKclc1QjNmVGtJODFzb2FjMlJHQWtTa25IUTBkSEpKZ0t1Wmc4ZEk3RVRNOEFlNnR4RHZITFhxVE4vaVM3aGdOUjRPY09FSGN6SWw1TkZkS29wa2NLZkRGeGs0MGFReVA2emoxaVpRYzBvVkVrSlhjdmFkUmMxS2pVYzJ5QS91TnE3QjF6VTA0YzZuUmVERVNOc0VXY0VnRVNlUlcxRmh5RmtIZG9oWmpjb1d4QkF0U012dGd0YktWZmMwK2VlZkh2akJYRitVT21ySmRYWDMxNmV1YmV2SDg4ZTc1ZTN1YnNtNnVzeHpUWVNqQkFTdlpwdUszVjY5ZXZWV3FsVjVUdjkrOC84RUhIKzhlYjhhdlAzbjU2dnIxc1hqdW4reDJXeG9QWTZmcVFrNUswanNSdHJIUUx2dFN1a3M1M0FweVpsVWhWM05tQ0lOU2Z3bG9mZjBhNENjWHo1OWV2aGluMCsyYnE2TnI3ZEp1T3Y3NWI1Nzk5Qi90YlhORGw2Y243LzFER1Q3OXpTOWVmZkdtZG4ybXUwMCtiaThPVGYvaHFja3pGWndTekxKRitGUUNYQU1BM2VCYmpmNE9NZWVVVXU0enA3N2JrM1B1TjR1MlgyWi9jcHNjTVRHN21yYTQySUMzUmI0eEVVRUtrNXNETlpFYWJOSXlUa1dyWG8rUXU4ODdQZ3duQmFBZ01qdHpiK2NZMEtYMm00ZFJTZ0t2UkVLbVZhdXhxNW5QbHpKWUtUSk9UR0xQMnd3TVJFaFpvdDhLaGQ5OFlDekdvT2dCZEJZbXhTK1Q0SzY3QUxEejYwOUxacGdMTTh5QkpEa0wzeHNjeHNucElJYTRPRXNTWVVXTXpjL3VqTys1YWQ4Wms3WVVOTllaR3pqb3QwRlU4WGZJbjg5VnZRYldld1dVZmZpVjV4bThVVXMyTTEzVkhTa0pnOW5iQjlzaVdsc29GdURzNUZaYnRqYXBtaWxJSXRRdGZzWXMwVzJWTUs4bnAzNFdqMUpnZURiRTFhZHA3T1pNUFdwdXBHMGFwZzZqR0RNN3V1UldLbTkydlpDVGxlSHU1akNhV3hubGVLdHVkWWZUZ2JIWlFnZmhSRjdINDlYVjY1ZHZueDJQWlRpWi9Hei80Y2Z2WFQ2NnVIbjlwNy81NHRYdGtJdnNuKzB2dHIzck5Cd1B4YnhhMVVvcFF1MHdVckFRYzBhYXZDYU9IazVITjVlb0ErSW5TT3JKQ2Q5Kzg4dDA4ZXpwanQvN2dkOSsvY1hWTGZlWCtmYm01dGQvK3JPLzkvRmViaTVPN3QzbXB6LytKemZmZlBuNWIzN3o2czBIMjFGSlZaU3NlVDZKQUpJR2c5ZkdlSzBjVDFiVDBGcEhpd01KU0RuM2twTGtMaVVDcDhUd0I2MlpuWlgvYmJjVEFvOGE4MTJmczZ4eWlCemN6VVoxTGNjeUZ0VnE0elNCUEdHY0poZlltdDhOMEhkaWlFa3dUN21kNXRDMHlIMGxvam1NdTcxYXdzeUlGMWptdmE5emF1THgxcmJpYktna24rWEd5NHlLVWxnTVJDeG1ZTXN2YlVCaXQxbGlLQkl0QTZlVUUrN2I3MXZKeWN6aGdnME9wT2s4UWtUcm5mMWRrVXJBdTE3b09RUFd5V3FObU10My9hUVZ3K1FzQUlteXY0WGtMRU9RNXRKcGN4RDJrSWFRYTFVOXA5WkppM3oxNWJ3dzFhVUFqK0swaGxZWlVGVjNCUW5QQjBNVFpMVmtLek1EeEV6aWVJV1Rzek16TXp1NUFzeVpFOUx4Wm9nNW01RUJ0ZFRFbm1VcW5XaDJZajFLN2tDR3plVUZnMEQxN3VybDY2dkNlWk0zbTJ3am16Mi91dEdMeCs4OTczZDJZM1VjcjI5dUR0UGt1Ni9Vc1B2NHh4LzlhUE40UDMzem05cy92M3Q5VTFQM3BLUCtjZ3NxYVR6Y0RkVlIzS3BPR3JnVENOY2dFTkZ0a3FHWXlBWVVQRjkzTXJaNFVBa095U0EzZnpFZGpvZVhLVy8yankvbHZjdnk5V2tvYXFYWUoxOGVQLzNEMzlsUGtqTnFmK25QWC96UjhPYnJxMzkxKytuVm8zNjA0QUF5Njd4cmpJV0IxdG1JUXNRT1pva29sUllreW9DSXBLN1BGK3BJbVptSldSS3ZsUk1OM01mTHJKa1FoOEVzTUFhNWN3dXZsektwYXlrRmVocmR5bGhyTlRQelVzTGhVMjFCdTY3cGx2TnlsTTh3dXRsSkU2aWZ5S3hDS0JyQ3NqQ25Lck13bUFYRUxMRzNpU2swendQRU05clM1eTJzTHl1UDJQV25zSnFKTkFjcUV3QVJZV2tzVm0wM2NPSW90U3RZV0JqZlVWV3h4ek1hU2xVd05jbjcyVlR3VHFyN2VTbS9QZ29XUjVZV3N2RVU0UXlSVFRsajdNK0dKVy84NFJXcXg1eXR3YkNjMWxsV2l4S05WWW5OaU14cXRiUGdLbXhLb2JPTjViV1pHU01CQmlKWGErRHNFZzhDZzR3VTRkZWNreXptUDFXdEJuYVB6eTI2Mndhc2I0cGVKUkQzM0lHR3RqaWNtTVl1Q1pseEo5WnRUQ0Z1eUtPbmJuZXhaNmdtSHE2L2VmM21UaTcybDVmUE5qMlRtNDNwMmVhRDk1N3NUcWpIdytIbVpqaE1HSzdITEIvOS9rL2Z1OWgzNmU3Vm4zLzJxMC9mYkNVLzNuYWdTdHVMVHFmNldUbU55bGxpTW00MmlZSVkwZ1ZOMG9Za1Z0RnZLQ0p0ZUc5VlRZMk5tY0VNTVJZaWR2VDVZaHFtWTczOW10TCtjdlBEcTVjVGNtZVBydC8rMWFkRWYzQ056YjdjM283RWVmZm94Ui9TLzNEOTYwOS85UysvK2tIeG1NQ2pEUjNaM00xVkN3dkJ6VVE0R0o5Z0VKczdPS1V1Q1ZMS3FldnpvMmswa1dBZ01OOGZoZ1VBWUNIQVI0WkpVeGpuV08xYkkvZnFjVGdWTGFmQlNVOFR2UEtjd0dwQWswMkJWbHJ0ZFJqVEdobC9yZytkM053MUdEVnpvODkyUm1lREJSQUo0UWtUYzJpY200KytsZUpCKzJ2djc1d1JzeElNcFFnaEVFbmMrTVFBU3hKR1JBOVJhaWdWbHNRdHR5RmVnQ1ZpNllIMFlpNGgzTzY5c1pnUjY5OTVnUi82enhmWUdjR3RNdW93NnF3dWJBZGVRMFRNT1lXK0NzZVR1UHRiS001Qy9GanJadGdCWXRjVVZvZHdoVnY3Zzg4UVhvLzltemNxcXNjbXlTSUpuQjNrRTVGUVNzTGtTclJDcXM0akxOZGFWTnJqRTVySDhKUkxzaGdodXBFNGNTZEdFN201TTVPYlRqa0xMRDg5dnNIRkFlNGlYVHAyZWYvb3NpT3JEb3l2djU0cU5vOGZYZTY3TE80K25YN3B1L2MvdktUYjBZZTc0L0htMXQvZXFxZjNuLzN4K3g4LzU3dHYzMzcrK291WHBYdit3UWQxS3FWT1puQktwZGhnenU0RDBLNks0TjdLb25TenlaMFlkdVFrSUZCU1UzZFNhK0RzcUsrRWpGU3gyZExCVFlmRFMrd243YlliUFh5ekxhZEgvRGRQbmt4SFk5N3N1SXczaDl6bi9lLzhWRjcvOUo5OWRpRWRtODBQUmhneDBCYjNaR1lkTjl3c1lqd2x6S25MU1ZoeWt0eWxHRHJINTdhK0NNNDlJUHZ5MzNQSUd4emFJbFZNMVZ4ckhjYWhXaDFHd0VZVFZOS0laeWlOMlcxeFU2dmMrNUJqR0xZV1VHaXpQOFhJYzE0NDhPeXNZMnVSalkzWFRpSVM0bElDTVFPNUphclBRRWxlSmN2TWFid3phSk9JUEsyZHVTMk9xcFY0ODJvMVhvQ3cwak9mTnpqM1YwN1dnbWpGSTNVc0xzMlpCUlRGdXpIOTNTWDBmQU03RWR6VXlVcDE1cnE2Z1pma203TjAyZThIVnJSVnpDcFpiL2FOSXZvaXNEc0xiQWx2bjRVWWtsTE9TWHgydWtYMmFwUkFyVDBBT1poSXd5dklzUm9TUGxPQWw4ak5LSWFYNVFmUEZQZEV6TzdtWkJZZlVON3R0S29HMTFqTDFDVlEvK1QycGt5TWVwUitQUGJkZHJQWmdGekk3Nzc2OHR2czI4ZFBMcmE5Q0RuNzhPYjY2WHZ2NyszdXBwVGoxZDEwT3Qxb2V2cURuL3pzbzhmMThOZFhyMTYrK1p5b2UvSDhJdDI0VnpYM1ZJYmlZL0dPT0tHb3NsZXQ1cDRiVitTV3dDa0pkMXJkcmJpblRnU0NZbFZ0MWMrVE94dU1lM0t6cWlaSThPRncrb3BUM2tqZTN1Nm5jZnZ4Yjc3WW0ydmFNOTh5SithcGZMV3hwei81WC9WL3E4ekMxZHVhalJ4bUVhSFNpQTNoSVdmdXdKSkVzS2VRRjNJckUwOFdvMHo3VG5ZaHpzcVBXWXNmOFVQZUhNVHVUalNNUTdFNmxXT3REcXQxRksva1VGVWpaaUpyV2k4alZuSno4VVdKVE9zNGlmbTN0M21XNFdRV1RjZktxa0dCL21GR0ZOQ2dKTXdFNWppaE9NYlFrYlFOMEgxZXhiSVpPYytodzA1b1RLU09aY0F6QjRMT25nZk1JR0VzOENvNmt6NlgzdE5NelNLT0JLamFGRE5OeXM5cmJ2czdJaVllM3NBemsweTVUSk11U2VCb3luVVlIcGdiRjBabkRMR3NhUm4xWG1iTGloaE94TkpjQWd0a2s2ZzlPbTI4RHNUODNkM0hrSXdqQlYzSTRkeXU3eGlMR00weG1rdnVoWnZXWXVJTFNVMkVZRTZRT0VEVXpIellKSEtTN25FNURhcE9UR3J4TVV0KzlON3RnVG90dThkODl5VDNBZFJOTkh6Mmw1OTgyNWZkbzZjYlNWMXlVTDMrYXZmcy9YMGRiKytHOGMwMzF3ckg3LzdCVDk3cnk4dGY2ZDNycTV2WGJ6OTYvR1NYN2U1MjFGcExtUW9YejRteTNKTEFIV3hhcWx1TDlBWkxpY1VCaExtV1VyVnpKYVF1V3dTQkw1U0lLS1hKcnZ2ZFJmSlNXUjEyRk1wNnZMSmU4TVJ4ODhYdTJmRnV1OG1NZW1USmlVejEyWk42L2NXVGozLzBPaWpJM0pRbnNFamxnc1FRQjh6Q0JKRU5TQ1JuMmMxOWwwUjBlRVVpTkF6eitqWllJa0ppZGVSbktyd0h4ZEpLVlNPY2htTnhxM1ZzNjZveGticDZoUm14ZVBOMnpqemJCVzVCNTlBMzBIM2JDN20xdURiVGVEeG9ZZWt3U2J0cEkyYWJZcllFRVljd00wTTV4UFU4RHdTYXdHZHVHMmRLZTZza0tJVlkwcUF4Q01NOVc5ODlqVnVUNUZnRXFqVWg4aEtCWjYxYmRDSlVkbFJyazNyY1p4UitaeGFGZCtiZFVoaGgzUXZYY1RLdERZVzNaRE9TcjMveGFvaGw3b0JRc1dBZ0w4blJpMHg5VmswU2kzbVRITTVmMVVuTjNLMzVjZWRzQ3lNZmlSSXhrSU52WlhGRHVLbERvc2lhSFNLK1NoMlByTldBU01iSmExRXJ0UkxhL1FRbUlzSEZxQk1pSjR3cUpSNjNzTTM3K09aNEtmTDg5N2ZYQTZDbE9FcWkweGUvL09LRzAzYXo3U2tKVFAzdzZyT2ZaajZkcHVNNERZZWIyN3pOLzkzelM5em80VWJ2dnZoaTJELzYwVSsybmRaU2E2bGpOVVB1aDJKRFVjNUJEZzdQQjJiL01iQzE2QUZGVUU3bTNMbFZWMG1OMXhNaGFnQXBaWUdyWFlMR0F1TEsrOHRkZmZOMnFtL3N6Y25yNWlUamI4cVQ2N0sxQSs5ekoyUWpnWHQva3pkN0dWOUh3OE9pTUJqQnpHeW10SENTUkNTSm1aTnN5SkZ5SjlKS1VKY1dpeXRzZFNrSnprTXNQc1B2c1FqclF0bEhCdU5TVCtOUUZYVTRLck9yZ3JTYWd3RWwxNUxWeUltb1F3UWVNZ01PUmxuZEdUTnI3YUVadzJOdEVWT0ZPWGFtcmJXRjBESS8yZ3NNQ1VCeUFFTmduSVNkakVrSURnUEJ5Y1RnYkx6U055MWJFNjh1S2J4WUtSZ2V3Z3l5NUNFSTF1WXhRdmdQamNBY2QwM0xsYk9HZTRnMUdsa3JNSmgwS2dZQkdFSU1aWW1iaytQRW4zRVAydFFqVWFnYm1Kak4yV08xSTZ6akJDNlRkdVllaCs2YzN3cDNOMVlHbkNUTk00UXMwS0ltREJlQ0xiUU5tOFU5YmdRSG02U0tsTFJrVW84QWVoT0FYVXROOFZNbEFTeWxWRUt0WTFoSWV5V0pXNVFNVnBROVcrM1V1cUpWUkJpS2R0c2FtVHZFVTRkeFRMbGo4cW9wQ3pGWnNlcVN1anJCczUweU8vZmFPOUhrSUZlRlU5M1hDWTkwOHhPbDNVLys0SWRjUHZ2TlZUa01Rc2xlL2w5L0lVOEgvc2tsYnpaam9weFBWNTk4ZWJGOWROajdGNzFkZnZZM1I3NzRULzdSMCtFNFhMMDkwYXU3K3Z6NWZ0dnBlR1NlaG9FSlZtdXhpWk5WU3V4Z0t3cDJDSm5EdGVrbklZa2dmZGNUK2dzcnRkVENrcEliY2xMemlEcFg0UXd5Y3ZOQlJNQkpkalpkbi9yOS9xMisrT0RQUHFscFFwKzcvL3QvL3JldjkwU2I3RFE5b1FFd3ErOGZiZi9OSi8zT1ZDRWdKWGVZd1ZsaWZBTVJGdWJNa25JU0pBS0VtYVg1N2tCbUREZHhKWkhaSGJnYVl3cTVKQjJsOVZNTTFHck1JNUhYOFRTbU9vMmx1azhlV1dLVjRPUnFWQUs3cElHeENSeHgxTkJvbVloaHJtZzhrUVZYTzZka3Rsc3NBa2ZEYmNVQTZjeVpaQWdrWkZjUW5wY1NrQVpNMkRmSW44WStJMWg4UXFLaGs0enRpQytxSlNUQVRSbE9sWTJGT1pHN3dhRnNCR1B5cG5ienNLekYyMm84UzdudTZaL21idmRzNkowM3o4NUw0VEVyYkFLN2QyODlkRmFZMkgxRUdOaldiTjE3QU9sM21wOFcycEtiRTJJMnM4b0R3SG44ZFVZOHJYMklzSEVZS2ZVaE1pVW5PMVRxKzY3cjZzek1Ecm56QWxzUVlqS3lNMFdsTGVNdHpwdElvSVZaWlJMbUxhZHBtcXFMeWFTVEsxZHc2bFdNM3hDNjdYN1RsUS82Q1I5dW41dkx4U04yb1RMSWNFVjArOGxmZm5XWW5MVm82amNrNG5kdjN0N0o5bEYvOS9xWStwZC8vZGxWdnJqRW0vOXdPNlp5ZFdUdVd2QnBqQUFBSUFCSlJFRlVQL3hnYitWRXc2QStIWTllcTdtWkhrWGNySVc3K0p6V0VCdFpaaUFCUkVtWWdaU0ZNUHA0UEZaUGJic0FqZWhMcXJLa2dEaTUyMUdTVjlsdDlYajk5b01mdlBvTG5xRGozYlE1V2ZJNlNxYTN2TzJzRWgvSzV1YVgzK3laakVQbDV1WVdzbDFoUm1hV25CZ1pJcHlDOThmTmhRWmFwMFN2K2RkRWFUYWpDSXpNdmJRZytvbFpTM1djdEdndFUxVXJSZDBwdGMrL0RaMGFkWXNhWm45aE1QcDl5OFVDWUo2TkZRdEd0czdwdDc2WUNyR1EzNWpnSVNoczAySm00dkE1eWlJQmlTODV3K3Y4WFJHQUlYTTNkNmZVNEhOTUlPVVVTMlJ1N0RCYmZCdHozbUVzcUxsRnpOd2ZLemZRNnp4djlsbkQ2ZzlRa1Q1VDg5K2R2T2huUTM3Z0ZKbUZXOCs3b0szbkVkWUNrdk8xampXMldzemhLeWZEQWtNN1R3T1k0MFdGYTFVSDIxbU1UdTV1cFJSU2ExUkRONXNtcjRhdGhBQWtJc1BOSWJNeFhZS1BRMm5ONkdPaEpDQ1kyeUNKaWQwdlBGSmdCK0s4WjZ1T0FrK1NRYllmSi9XZmdYT2ZtUytmMkxqcERNd0NxMmJicnFmcnE5UDFtMC9mYkx2YkF3K0hpL2Z0aC90OUxWZS9mWFd6MmUzYzNnNFgrdmx2cndmdGIzLzUrZTJoOWpaMGovcW5IejZqdTJJMEhrYXJaUnJVUUs2bUhuMmFjNmd1WjdraTB5eW9pRjMvQkRidisvUkkvSGgxVTZMckYyRUt3TGJENWV5YWRLVnBLejc1UmpiOXZyOU5GL1Ric2ZoNE5WMStwY21zUVByYi9qa3JuS2JkazllLytESTFQN1MxZUU4SWMwb3M2RVc0WTJHSm1kV2lXWjViemhYcDdveHRYVld6S2lCcm1HMHo4d21rMDZSMkxPT2tadWF1TmhQU1BCYTF0dmhvVjhNYVh5K1Y3K2ZZem4rWUdWVVh5ci9sUUlqQkVkT013R251S2tpRU1MVmhjYkN2dUtrbUVhRXA1enpOYzlqc1BUS0FMYW1zS1FwOEJibTdnS0dOek15MlhMRG4zUEU0V0l5VzRNdjdzYXZnMmNEdlRVVFJLcHVGY0xHRUI4Ry9aeTk4UHlVVURFcTVDQ1J3clhFd0lkUkM2L2pMSnA5Y3ZhSHo5MGNuTndjM09LTEhwUi9acWE3aUZGekFwVHlZZXlVUmJsRWdBWDhYVnJKYXBvU1F3OExacUFIb29xNXB1RkI0R0I2ZHdZSmt6QTUyRzVNSk8rRXFkNmx6VlNZbVU2V2J5bDB2M1NhbFRkK0pCQ2pHbU1kdTRvNHJocHdZbk1oeVo5OSsrZlhWeTJjWGVqQjdNMXo1L3ZPZi85NFBxVjUvL1kxKzlJVGVqdFNuYjM5RGZSMm1HNjR2eUs3eDlJZnZlNS91eHRIemNSZ0xFZWZLUnVwV0U3bXJnN3JXeXJVVVU4d0MvOERLa0JFRE1uYjVZdE0venQzTldOd2dYV1lqVXJOWURzdEtUNU9FVmZXNlBLb1hqei8vQmorOUc1U0dtL3JrOHhyRkh6M2FqMStkZW5vNlhwWTNyNlpjQ1JIcDZoQ3djQkxobElRVEk3SEVGY1V0YyttY0xCcG1BTDczQXE5U2d5THRqUnlBbU5WYXFvMm0wMVRVVHJWVUp3OTZKdUx2YVdiR2JSN3A5NlQyNTluSi9mZ1NPdk82TWVjYXRJMWprejFVbjRNQXNWQUxWaTl3OEZ3NFdrSStDNStiRnZ4TW9GUDRRMi9OZkFtN3UzdXFEbmJubUNJN2FRWVN1eVBOekxRRlJ0ZWF5WWFxRFVMWlBaQUZNNWpZWnpGSG5CQyt1SWFYQ05CMkhlSTc4VzFZNWF6UFdhWk9rbVlQQTlFOVZNbVpzYm15VS90aXlXd3JIdk5haUNtQjBmSStseFJpYTMvUytjU2JrMFdKUURrbkNnWkpESlNObUdIVGFXTVdjd0RNK29PNGYyemg2d1VoTUJiMTdBUW9OTmg2WVFRb3htNE9VdmQ4dWZuWWVadUlwUWU1MWFxbDR6clFibnY3dU0vbE5qOW1Nb2lRMWVsMC9kdFBEeFVYK2MzZHZyL1lqZFBocjE1KzhlSnhldlhsWVgvNTNGN1g3WDc0L08zVzlHaTdyUnkzWnUvOTRVY29ycWZKYlRyV3FHRjZWZWRxcG01R01OSTJZSEV6alJZSnpBSDdpMGhCRWxLdk1xV2NtWVhZM0tDQWdnM2dzTVdGK3BFY0p0a0tvVjVmWDd5bC9ZWGRYSDl3TitqZFJCZmkxVktpT243ay8rNWZ2TzZSL2VtVE43ODRUTW5uYTFORVVoSm1TWkthWTRQUmdQbDB4dFhlQTAydXBzNHorYTdwNFJLVHFWcWRYRXNwUmFjeWprWGRoN1pzWDAxRHlkMWNXejZ3cndHT1orajAyZUsyQmlKamhlNXRvSGJNMlNNTFpDUE9HVm02UVJiaEdGMmg5YjdneHEwK1EvQndqMUN5dXVsNGhsQzIzaTlaZTg3cUhGNEg4ZVFtOFZmaDJTWWN4ZS84Nmd1cTRONEJ1TnpBV0VJc2xzZ2pYNmFCRVFxSzlRMk03N3VCbTJxR2tXb1NudjMyeG80VkszTVY4NzdJTlphUEFBQklDY3d4SnptVGlOc3hab2tJNXNUU0ZQVnpkQ1VUUjl5dnhpUUN3R0FRdDFySTNEZ3hRa0EwUnhvdTBPeXdhYkszVUFPTGRFUXlDcHVDZS9aU0pmZGkyNHRkWm1hcVJRODNKL1B4OXViMittWTRKVXduN1BZL2V2L0Z4ei9hbXVkU2xkekxJL3YyaTE5L0s5dEhiOTEyOEwzTFpYM3o1VnUrM0kxMysvZjIzVlJPOHQ3dGwzcGx3MlFkYndhV1o3Ly8rL3cxTVhlNTNONzFpZHhWb1JwcXB0RU13cUJaWVU4Unl4STdwRGxIZ1l3c0VidXk1NE5LejhqdVdtdUJ4eHFUcGRLaVlJbkhwMHBpMU9FTDRxSC80ZE5mMG9XUDVNaUpqU1FyMWMwWGYvYW5yN0c1MG4xWCs2MXA4OFM2cEp4VGF1UFp4bERDT1lHQVcwdGxyZXVNNTREWEwzQkRTUkM1RzBuUlVXMDhIZHkwVnJXcERFWGRmWUpraEx1dHBTaEd0V2lMSFBKKzJOQTVjbjc1M3h4OXdsakhORGJxaTdXbE05UDlGM2dlWmdubW5qZCtRTnJOT3dQMHo3bklLOEh6QStTUG40SGZuaUNjR1Y3UnlFT0ZYVHk3QWViTWpOUmFBZzJoQjh6VXFEQjNZQk1TMGdjcFdsakZUczJsaHE5eTB0ZGhUM2gzRDN6V2xrWlJJYkZxakNla1BXTnI5eS9PME5oekdyelBYdXVFVkthaWxYa05EbTZlN0FCSGl0aUtZMENBTkJzNHM2bk5FdzAzaGRsb2hpVGd5b0pLeXl4anNjRjVpL2VDUTl3ZDRpWU9NeU56RjVhN2JudTUzL2NKN2pUZWZudjl4VENVMjV1VFQyVlFKOU90VDBVaDZaOWZibi92Zi9yUCtiZ0RVd2ZLOWZqcDE5Y1RsNHVwZTdLWk5KY0RFdnR3ZkxVcDNYdnY3YWJTVDdyRjYzcXN0RW1wRHRKLzhJTVg0MmxJdlhnMUhUcHZvaU5WYTNoV0lyQVhNeFoyYThyWEdQQzJQczZwQmkxQU9sWjNIV0ZXYTRtSnZSQ0J5Wm5Qa2o5enN0b1d5YS8zKzNyWWJqNytsWkNxazJVUkIxZ3U3VGUvVGJ0RC8rUWtXcDY4R0w4S2g2cEErcHlrdmE1OC8ybUtqYWd0VzN4YWNaVDRBVVlXYmxaVnJlcFVpSTUzcC9ZQ202cVRhVzFJeEZXOTEzcldjM2JSUFFvc2x0NnZiWTR3ZTFhd2ZwZmNhSG5rejZvOFhqanRTeFdkV2t1UVdxQmw4LzNTZk1FNHJhcEtlamRvcW4xVXNVWVNUc3hrM214V3BPNmdLcWhnRjNla0ptcjBTa1JLSE44SmhqRFlHUThxMnpNRTZqeFg4clhIQ0g1L3ZQeDMwaW5ubnhYTWdSQ1NvRTJ2Y1ovNnQrcUF6eEdXTEwyWDA5RXFKUEV5Z20vOVFhalN3S3NlZUc2Z0NjdzVTUnU3QVp0SlF4c1hDanMyNHRWeE1NUHJXcjFoTUFhSU9TeUtJYndFTWVmOHc4MXVnK0U0WEgzOTJadHB2TDZkS2lWeDdsVkpVaGJ5d1ZPWFhaL2kxNy9xUHZweHJ1WStNdlBkeXk5djg2UGgyRzEzWXR2ZDV1N3E2Rk8zSVNiZHZ2am9Rby9kem5mZDhXVFdQOXZYc1c0Zi9lVGo0YmYycEU5NkdtcE5kMTdDb20ybW9mQXJCQ0ZxMmh1ZFcvdlVqa1pyU3RTb1JJWGU1aXcrRnRXaVlIRjB6UENaYWowdjZaMk1BVmVqbE44ZUx1ak5QcXRacmU0R3lkV04wK2JtcjcvY1RHOWNKOEp3dHgySVJMSWtsdFNGUjZaWkVLeE5MR3NiYk5Rd0lKeUhPK2RTK2x5S2djTDFQQlc3THBObE9kNmExenFWb3NraFRMVnN5SlZCbUpwR0s3YzFrcmRHNEx6Q2lCZW9qVTJoU3hZeHI5TlRWaGR3UEZveUQ5dGFweWV6OUhnZVpyV3Z4dzBSMVhDVE5FczBqYzQzOEV3TFdKZlF2dEJXWXdhVW9vOUZ5K1pqTXEwVFN4Sm15Y1pNVlVLWWxNaVlXS3RyTFFxUkhaRkRBV0l5dDhCenNzQ0lXSmpNcXNhY2NzNVRRb2lWMnM3WmplOG4wa2ZwWTlaNjU5aUdHd2lUWktVeWxjek1JUFBjQXNUbW1pMXN4U0FWVmhWNGVLQWlIaDdzbEVUTUpVTUp6R1RhdVFMc1pxeTRTSVZkbmVxeGN1ZEU1TlZoU2F3SUlBbE9rakR3N2xDVE9obDFtNDQ4MTVPV1I2UzVINUI1dkRRazU2UTVuZ2NIbkNOVEFhN0c0b2dOK1VXMzJXNHVMbnU1K2ViVjYyOWYzZzdWdUo1OHUrdTZ6Q21uUHF3azlQVU9KOHAzTDNIejZQWmJKUk5YMjJUbzFjdmFYNzFCM3UvN2Z1ZmQrMjkvbG8rLy91MzFFNzFLdi92ZmZ2RHZudk53OGtIeTYvMUhqekVZOXovOCtVZUg2Nnd2UHh3VW5ZNjNiclVxRVpLYVdhMFZSVGw1MFNKQ3FqUDdIU1FBR1RHN3R1NFF4RUxEMkUwVlptYUdaTlU1c1ZVUnRnSVJ0N3pmanN4SWJKWE5tWG5USFhiVHNSOXY2OWRsbUhvU1p4MnpHRy9VaHkrN3d3OXE0UkYwUmU4WG84M2pyWmZFR1V4RzBuWU1HN0paSmNGZ1J1RVFQRGd6R2FmY1BtREtwWHBpVndTQjFFN2pxVmdkcGtJUi8ybXVWYzFhRVpreUFBRzFZUzJJeC9ieTUrWW10ek0rWm9ud29kV1FLaTh2T3RZaGllWm1EaGF1M0ZJQ09JbEVUdzRRSWMrSktTSWNTVlV6c0NoY1I0bk84ZG5uc1ZtQTA1MWJLSnczajVzdk1FWkt4bTdFb1d0MmVMaEJpRXpnbmdUb0FxbmhFd2ZxbE55SWtacTF4bGRXNXFWYzk1V2kzTTlCenNaejNCTFJkOFBrL0d6VlhUSU15WWxFaUlXbGNhdVlwUkU2Lys2N085cVZuTVRjcU41WlBCenFiVTdad3QvQ0pjNnJiQ3FmZ1pkdUZham1qdGFDZ3dEek9pbExsVnFKMjdjaHRHeHhEM1cxVkFld3I5TlUwSFZTaGlyYmk4MEhLWE81L3UzTlg5NjllWHMzbW01NC8reng3dkxpWXJQZmRuMU9VMHBXSi9NYkd1NVU2ckgrelplL2V2empZVk9aR1hxOC9zWEV0MlBhN3UvNnh6LzYrVWVYai9mRDZlNVgvK3FmLy9XTEgzNnlwNnVmL1NyWE9yN2g5OSs4LzBGLzJQVFkvR2ZiYWo1VU81VEpiRGdjcTJtSVFFM04zYW1xR3FFV2RvdiswYzNKSEVVU3d5S1lveUdkWEUxaG9UeDFRTmpnVm1NUXhPNXFUaWNUNldER2VVNnRQa3cxT2NaQm5abTNYWjdIa0k4LyszVGFQYVloVHVBeXdTRUNTamxVcW5POFdSTU5FbXF6SUlnSTNNbVloY2lLYnRwRVdwSE5GVEtXVXJXcUR1Tll6Y2FpUkthbHFqU200Ym0wNHJOVy9udkx2alZYWlk0MDludmQ4UXFjNm40bWNSREhJTWk1S2EzNG5JTWJsYlFJQTNKT01sdkZwbncvcWNidnlZWG50VlVMWHZEMUVKZTRKWWtKV3pLSW95VW5CQjdQM01nTm5NVEVTR1ovTWM0dy9YVW5DMS96b3IxdEtkYVNpVFBuYXRZNEsrNFh4UktiTWpGeVk3UjV0QnZrN3lxOTI3bVNSTmlVNmxEVlhaZ21vcVpqeEx6MnZmOEN0N2M0OUZUR2FtUStaMDR4NEY2bVVXM1k5K3lTcFdXMWtra0xtcCtJRTBINHk2N1BVb2JqaTgyTC9YWWpwTmZmdkhyMTZ1dTNwT3FiNXhlYjM5azhlYmFGMDA3TDhMb292ZHhrdmIyZGZGT255Wml4ZjNielIvK1lRWWFrNDgyblgvekxxK01kdWpMUVIzLzBCejk3bjVDcTlmL2dqLy9vMy93L1h6OTYrV2MvSHhONk9Yejc0c2VmdlhoeC9aWjNseDllM282cDl5SlRHYWN5alhZVCttSlNDM2U1TGNHdHNRcWEwN3luekNDM2h1TnpsMENLK1NTaC8weGdHSmtaczZzSnM1dVRUelc3SkZjU2Nxc296dFdDUWVUSWlTN20yUS9BWDMyMWtjMFVrd1dkVHNrZ0daQk1ZYUJwVVc1a3JSRktyWUlURVFUTElpWE1NZWhnVEFJZEN0S3hqbE1wa3c2bEtIbXQ0ZlN1Y1RPQjUzalpCaHVOU0ZTODh4cTR2eGxwbVZmTGloRVBVaFoxOGFQUG05eDRIMU96dWNocUdCZWc5aGorV2J1Qm0vdDNpVDdEdWg4OCsvMldJYythUVdkQnBjUXlmbmNucUdrTHFIUlhya3ZFYmdPNWVnbGpwYmlLenhpODVwOW9HSDZjejZURlFSa0lFemV5di9XNnhObHo0UXV3TzVvRmJ2NGlkL29PdytodjY2QmJFZ2Z0dEJxUjI4VG52Q3hhZk1EbkZ6aGNsWEFCSURrUmhXMm94aWZEekZyTHFNWkl4SW5SREl0a0Z0b0hHbE5LVml1OVB4MG52bml4ZjAvWWh5OWZINzU2L2VWYjMyd2U3eUVpT2ZNNHZQN0ZjSE05RE9QeFZEaW4xR1VhaDhuMkt0a21GLzNvbC8vMG4zaDNTMXp2WHY3MnJ6NzloRzkxZnp6Z2ovK3J2Lys0djV1Z2lYajc4VC85THo3NlozZGYvZUpEM3g4Mm9xL2YrNzFmUDhsM1gzY3ZQdmp3OVYzWmJCUDVhTzVhRFJaNkdKclVQT1M5d2tMRTV1WVFhUnhySWtVa3JkcHNxNHp1amtuanBGZEpLVG5NRVhMWDNIcVRRcnhoUVdKVnVDbVNtOVlFSWtudzNWU0RoQ1J5L1B6MjhlaGpkM0ozNkhqYW00Q2xlUUhqK1psVlFreE8xTWZkRVUrWWlHak1OS0VON1R5UmpzZWgwbGlucXJYcXFPb2dEL1NORTJiLzdSenl4eTF2eHhyM0hOKzlmTy9kc3ZNYWRkNzdMa3JBRmtGbGk1VXRISUNwM1dacGptbGJXRmR0R2kyUnZTRExDd3hlVFZidndmVVdXY2xxRTdUZ2trT3o2WW5Cek1Ta0RXRmIzU3lPalVEaUdJVGJDeWdBVU1CaWJoYW5HdCt6RWJrdEpiVGJnOXRZR0hCekV1Y0hWL0I5V3ZSU2pDK2dYWE16cHhSTDFKQ3R2eHVPOS9BR2RwcmhRQ3pZT3BHVnNmQ2MzUXJHdS96SjNPd05xcFVoUWl4dVRxU1Jqc29zVG1aMVFFNmN5TmJpdXZpUU83aHFWVS95Wkx0L2ZFbW5tMWZmZlBQbWRxcm1UemQ5bDQ4MjFXa2NxdDVkM1l6ay9yNFo1MDJmRGhOSjZyT09pcUxIMFUrL3d0L2JIN2RsTTc3ODlkLzgrdk9YbFZXUHcvUC85RS8rNDJlbnQ1STNVNnAzTi92dTJmLzQ3SDhmcm4vOVQ3NDhrdW5wK09MbmIyK09RSGQ1Y2JVNzNkMGtHNHlncXFXbWVGeG9UcXR3WW1FaVRPNEdnT3VTQUZnS0ViUERtMUd5Y1dMYUxzV0luUUcyeE81bXloWjdwODZVRWxMdll4VVM1NHJwT09SeUtPcEVUK3BFQkFqbk5INTZkVEYyU0tiazVuWG95V3Z0eGQxSjNTSVdybkVldmNVWkVJUG9BZ0RuUGxkVmRXTVhyMVhWL2FvTTB6U05wZGFxNW1yVmJWbmF6bGErRUVXMWtkSGl5Zmsrb05QRCtNMjRUcGJBeFhXaXJYdmM3QVNmcjFocDl3dWZIK2NGWEljVklpY2txN0d3bkxQZVZxYUhCemZ3c2lWMWkvY3lkZ3BtNXh1NHBUbFFWRDdNVERDWUc4OGg5OHljVXFEc1lKV2ROZEdzWEdrZSt3aTJtYVdVcTRUSm1MNjN3RjdIdTNUTVdIUWVjUVBiOGdiN3ZNZ2hidmEvQnlFTWYxc056U0xpTE00T0VSdmM4bGtIUUdlR3RDMUlsSFlEazlZaTN2WkFjN0FxbURrN0hHNCtqaHRISldsVENwNFZlSDJ0M3UwRWVQU2tuMTc5OHZyejA4M2R4RGxwMm9qZEhNZDl6bWwzbVVSc3FpdytGY0I5T0kwWHg3dFNVQXJxcElSUzMreitsNzlQZm53NkhULy9EMy96NmtEVmhydnk5SS8vNU9QdFlkcGxMOVd4WTcyKzdmL3I1Ly9Idis1Ly91Z3luVGFucjdZZmYzNDdQSkZlRGgxTng3c2tGUUJ6S3A0bytON2NPSzJPWUI3NW5KZ2R0MXh3QmdsdVoxVXNXTUlQU1E1eXE0M2RMeEExVWdJNUpkbE9WQXo3M3Vya0tVdXlZZkRKcHROWWpQUDdNcnBESkhYL0gyTnY5bVBia1ozNXJiVWlZdTk5OXBseXpqdVJsMlNSTE5aY3BaSktha0NDNVViYmNMOVlMY2hDR3pEYURSaCs4cXYvQkwvMnUvOEp0L3ZCa09HRzBYYTdwUzZwSlpWcXJtSnh2cnh6em1mYVU4UmF5dzhSZTUrVGw1VGJKTUhpdlpVM004L0pIYkVpMXZxKzM1YzFuMXg1VXRPSkNLa0t0MDZyY3ViYVZHV0VldWx4bWhzeUFEbVhtVk1FUUpzNzhXMVFJampqcm1uYndNdW1DU0RCQThlaysvNUdwd09pUFQ0TE5HeFEyOUx3WlZwZUhPUWR1eWZxWHBreDNQalNleU9KZmhwbkk0U0lmUmM2amVrR2lhVHRzWk5FVzNFV2tSSGM4azhIbnRxT2dLcFhRdW5nUjFDUitDOFJVYkE2TEp0K0NoUXZ5QlJGaGtwOTlvK1FBOEFrdzFiV0JOYkdIVkIydjFnSDlPNVc1OWgzampIZG1mWDJWQnJBOUVVTWJ6V3hoaFJSanRMSU5LaFgrZiszZmdHSlVJa1EwRGdMcU5RbWp2dFdHSmJ5Rlc4cFhiQS9RRXFpNFpyZG9BdEUwQ0FxZ2NHbU9XWHZTVlFBazQrZCt0ZnFsNDgvZjNIVFRrV3d0SmtwQmZLUllXOE9qa2VDNVhocGxFRTN5NDBDaEhwZFordnJSZDJ5Rm9hN3JBd2I5MGYvZkM1bVVUeDUrdjZuVjU2TXJ6cWRmdS8zMy9ZMU82ZU5qRm1kTnRjYk4vNHZYbjV3L1dkL3NNZTE0OC9taCtVemUxQUhmK0Y4QTlaRDNnZzRteWM4REJBNmlFbFJoZ2hDQ0dJaDRUcjdCQ2RES2hGc2lRTVJRUXowanlxQWVyRUdBZENSK0FDR0FDakxwbDN3YThhOUF5TmVnUXpZM0ZFR2h0QmtveVBUS1NCWjYvSkhueHZDQ2pjVXhBb290QTZxbXJLNmI0Z29SUjVGckJzaUU2SnNOQnBsYzBJUlFSUUlJWERneDl5MWJlZTU4WjJYaUVqU05KMEJCY1RFSFl5TmJDSXl5ZmJOTzhwZy9NSWM4b3VYNEpSTmg3ZnlpM1YzVkJvckxpY0dUaS9wNmUyajZlVGVGMmcxaWJhUkZqRDE4K1RZUWRIZGRGTGRIcVMzYzltMGRpSEVhYkRhSHVaT2FUeE9FbHNFRVNEQ1l0TlNNa1JJMWhuWkNYdmVtYURTSyttRHV5S3JWUG9KTU9JemQ4QkZBL1FqNmF3SE1kV3dCVkx5L1FaS0VMQjBoekhiSXc1K2FVd1RwSVFPQWVrM0lnSWxrU0M3WGZEazM3d05oeWRVWnl4RkpTWWdHclhENUNESld6bTJmMndFL1lFWkVEUmt4Nk93V1B5YlpyME9ibGJjWmFEUlpESWF0VkllanJnOXV6T0Y1ODlXemJTNXZ1WWN1dGEzWGVmYjdqVkNjcDNBeG5TZ1VsOTgvNy9iVzA3czVQMFBuMzN3c29GbWhSMVAzL25EYjNZRTBtMlVwcjRUOXRYNHNNNCsrZDM2WHkzLy9BZmhhdGFlcmI5eS80bVoxRUdhMWRyTTNIVVloU0NDaEVRQ1VRTEtFWStiSVlpeVY5T2ZBS1BVVkkweHlJR1pVR2hMUEpFQllHVGpvTStDZ01rVTFWaFNKbGZNUTdlNmFUbTdsMk1sYU8xU0dHMm1yZ2dFUE5ZV0VKQ01OUitjSDQwMjExbFZDaU9vd1VEUWRXU0VJaVNoNy9lQWlaZ05QQ1EzbWt3bm1UY2tYZU81cTVlTDVXSlpCMkVmV0pRMWRBMjRyRkloc2lrZEVJUjg2c0xZeEJQbkxhcmlGUy82ZndTVGlnT3BjT3N6dmcyU1FNU3Q0cU4vbytJQ2psa2FPMkZIWUFoSmtybnFscGJ4eTVyUXUxTEcrT3RlQXQwRHE5QnVqZm5HSUFFRzVUN3BqUU9MZW81TUJGYXJtZ0NzaEFhY3NRUWNKMVJrVkRDUWtsVUdVQVpRTVlFOUEwWTJqU0tDZURJRzFPQjJyU01oaExUditDMCtjNWhXSnk2ZHpZeXFCZldLWkFNaFNBcW9WRVNqVWNTTUJzRW9hN3A4cXdvenN4cGdWRVJsZGdnMHN0WEtkRTBBQk13NzR5Q1QxaVo3VFlkR2hZVThXRXNDSUlwV0cydHAxQWFDVnRrWUJLRTh4WUVDcXFmYzZxYU1oTWt3a2hpRzJoNU5Gbi83L2lYWEk5TEQ5OTZhMzRFK1BCSkF3UlV6QU5pSFZaZzBvVnBhWEhRY3VxYXF1bzhnTDBCTmp1dVpUdVhwbmYvcGpwT3I2dm16ang1OVhxRjY2c3o2blQvOVRrZW95SFdadGNaNnI0VzBqZWpzRDk3L3Y5NzQzLytCK2NoMlA5UnZmWFExeHB2bGFSVzh6Y3F1TnN5MXArRFpHRzRsSDdWT0tpbXhHMDJtdExtNmFhUTFKVy9zWG9WSUJrVk04dUtHUU1haWJ5d3BHR01nVUx3SjVxeWlxT3hDMTQxemh3QnFNbGxlNHNuQjNoMWFmN0EzUG15ZXZNQzVPMnNMVVZ0VVhhaCs3MEZibHBrd0dyLzV4ZkZKOWZtSXBSRU5hUGhtaW5helBEc0VObFlFMElLcUVCQmx4Z0M0Y2pRdG5NM0hEZ3IyZnJPNDNseFUxOHVOOTRyY0JTYWtEbFNkU29Ob0FUamQyVUU0MlFKaStZMzNOdGxoYW9DbXlzaXBUZGVEY2x4LytKWWdZQnd4M2c3MkVvUW9ZRWx6Mk5pU3draUhUQ3BQSUtCZ2tCVFZZTVR6b3FhanRNUG9rMEdLRXkwY2hqaUQwU2VhSWJaMEFNRGtIUk5WN1JDRU9RcmJTVVZ0K3BoK0txVmtGTWdpaWdpTHhEYmJRTkpMZTRraGc5YVluUVJGM1cydVkzK3N2T1h2dzFlRTRhK0lPN2Y4a0owUEcyQVpDcXhBSWIxRC9kR24vNVhDTFU4VXBHMVlWWkFkbWdRYTI3RXdJc1RnQzRuaGNicHpjTUw0NTRVU2R3bkFPQXloeTZ2R0ZvVmxGODhxWkswRnNvWkFQR0NXSTRwU01jNnBldi92bnNMWXlxeHRUcjczdXhQb2VXMEpNQks1eXptZ0I0enBhT3M2MjUrOVhIdndIc1J3ZDZjcVp6OC8rQjlQODdDNU9mLzB5WStXRzNDcXRsdTg5Zy92YlhDOElSVmtWb29uS0JpQm9mS3QzeXl6WHp1aWNmZmp5ZmQvK2VqaHljM0xHR3BuT0lXeUd0ZFVabUxhWlZrMW1BbU5IS3E2K1ZoZmNPaE1waHNhSmdDcUJrQTdSQlZFYXhMZmxBaEJFUTBhVFVnVERXMDZJd0lhK0t4Ny9mUm9wcHYzSjIrVTA2b3VHL0ZvSFJzM3IzenBHaUZyUjJpYW4xNGV6S0gwQ0VoQ2hFU2R0NFh4M25wUUpDUTBFZ0VWempwRDJYZzB5d3c2UTFLdEw4NHVybGROMDlhZElHTEZIQlNSZFBlSHA5dDR6elR4UWZxUzFJVnRKZDJaNzZZVzFVNUlHZlZtMnY0YzNTZEZnQ0w0VzRKQ0hIS09CNFcyb1g3SW16TDVNTVVneGNNeTdialdkNTJEdXRQZFZZQmVvaUdvS1BIT3JTS3lQY1hhcEVOQUpWVktoMmRDQkU1OVpLR1V6d1JJSE1BZ0VaSnhtQVFua2s1Z3NJV1M5K3pGbEZHZFhBTGJ3T1l0UTJmNzNzWVFzOGp5ZnVXZEdkVFZxRU5xSUJISkYxMFEyUGNhZXFJaHM3Qkw0WnpKWEd6U2FrY0dROHBtcDZjemJBd3hZQjBCeVZwTGFITVNWYytSdzIwNXdjdENpR2x0TmdPQWxuRTZkbkx6NmFQejVRb25Gc0Fkbjk1N293UnZkb09HQVJVMkZYTmRkZFhOYWxNN1ZCYk15bUNCVkFNcWluUnorYWo0Wi84bHR0ZVh6ei8rK1BtNVdDZU5oNjc0eGpmMFpxOWxsY0RxMVdOU1hucjErYmNmL2R2czhzNERsOEVuK0o5OEJ4dnNnbkZHUEdFRWxpQVJzMlNUS1hIZEJXY0RHcTViRWJSdTN5eGI1NVJOOUdSWXE0SkFxcEZDYWxIU0lpQWdFVEkyQnVaRTdXam9jaHRKeDlaMWwrMmlmbkJ5OU0yejJoeSs4Y3huaFdRazlVSW5mbm9uVytNa284eVg4bitmM2MwbTg2ZEdVYUpmcEszemtWYVRQWTNOQ29NSWlNWlE3akpyWEo0aHQxVW4zait2RnNzbXFLeTlENEFLZGFJV0R0VG4xRG1WVythYXFESHVtelMzcHcyeFd5UXdSQWxpdXAybDltOE1sUjBVV2RwUGcyTWNZbitYMHJSSDlHT2liYVJSWE1BOXFNcW1CZHhYeWlHTmJ3dVgzdDU5ZDdqUHU3a3RLU2czeGwrbDVwWWQySFJpUUFXUlZhTnRKZ2t1KzVOQkVGVUpCc2xRQnFnVXpYaElFWVc4NVRQclZsWWVsUkE3cnY1MGxNUXZvVklxOWtqYVYxZ2MvUXMxQUlhczdRVXRwQU1nLzFWQ1hvSndxVWdJU09TRVdCVVZpU0Q1cWlNY0JWR0VTTklkcjM5UFJTSWFYcU50RUROQmh6clM1MlprdVhZalJoVTJDZ0JNWUl3UkJVS0x1bGQ5K25UUlhyN0VZby9BblJ3ZXZ2a0djcnVkTHhzVkZoRlluVjJxN1JaclhIYWhOYlplbTVKdU5odGpCUkhKV2xPMFo0dC84cyswT1h0eTl2bEhUOWVsSUxRaFFQYmIzNnpXYzFtVGNBTmREdDdrbG1KQ3NlUmZlL0ozTjFKZktibTlqK3dmL3NHUHJpYTF6NHlRaTFodlFaSFdaVkJuZDQ2ZWkzU0M2alBmMWg2eTdOaVpHemJPeEVCUFl6Sm1RRkFjV1FNcXpyYXAyVUszVW9BVXhOamtkQ2RsTU9adzhmekZoOGR2UGp6TTlxZUJtb2E5Y2FGWjN1VEE5OS9DcHBnNDRSYkNyK3VzdHZPUElBc0toS29xclM5QzFaWmRZbG9wSUJwcmpEUElvYXVwZzJheGJ1dUd1cmJ0ZkJkS0g0SUljMnI5UjhGSHY4a0xxT3lFV3lYWHp6WjJFbCsxcnZZRGxPMDVtYmZ0R1lLdDdYZWJZYTJSM2VwUzgwcVNVOEgyUjlqdENrWkFNaVlWclQ1MVVBZDMwdkMwdm5ybjdkOXAzUVoxcTRKS0V0SDFyckZZTUszdTlJS0UrdFU0QkZFREpmd2xvN0lFUkVzbUp0MG1rSWp1QkN6RzFFemRBUVJ0WlpiRGVSZStKSWhCLzM1bFpKL2tqVUNPa0lLSkFBQWdBRWxFUVZSa2UvZllvRjI1UFhESFc2TWhGUW1LR3NRZ0dCSktBNklCMzZ6REI2b2tvUW9pTWtlSVBJY09XRlZkQitUUWpDL2F6bk9tb0N5aVluU1V4UitKaUpMSnJINTQvdUhIN2JRc0xjRDB3VnNQRDZjQWdzVXVTU0cwalE5U2g3eGJMeXZPRlNGMDBLd0xrYzJtQlNSbE1zQjdzNS9pZi8wbnVuejg0dG5aMDVmdFJOckdkOTVrSjc5M2NsRk9yak94d1dOdXNwSjlWVHRFWXluZy90dHYvWnpPbitVMGZwQy9QL245NzV6VlY1ZnMxVnFyYTQyYk5ocHFWaHR1aTJOOTJlWEdaOFFJNG1VMVBzeHV2Q2MwQnRHNFRFMDZJUm1qSVlyeEkxWUJJSUJLc0lBZ3FzcVlvWUlFb3dnSVJPeW0yajF0YnVyVCszT2d5ZVppYmFWdXRlUkdYcisvYWZlVU0zRGh4ZldNMS9PWnFVY2hPU1ZNNTFrN2RqWm1hVWcvNEc5QlErdURYRkdvdlFUdk9JVFF0bDByQ3Fnc1d3djNNRHZWN1FrdytRUm9telhaSDg3b2xzOTJaNFNKVzl0QTc0R0tEeWIyUU9MaGt3TU9HOE9RSW1oMjJiTHhJTDFGaU96TWczY0tFM3hSTUhLcis1d01FbjNIaW9WWjBoQjRPMjZ5Vy9kc2l2SUJJb09DcklrTUhkdTM2Tkw1Z2dBOWdKck1xT2xoVlFOUFRHQ1l3L2VtSCt5M3d0MFNxZnBxMDIvZ3h1N2FDdE1wQ1VBQlE1enRDVzVyL0tzVkdCV2pPaHNHcktzQXhIRDIyTUpPMElsNEpGSkZpdUVxcW9MRFFEeitVb0x2a0VVRk5hQkJhOTU3L3FUTk0ycERPcW9yZStpNkZ2ZktPVzZlbk4vOFJCa0thWXc1ZWZ1ckQrY0lJTFZrVG56ZUQ4VllsQXpDM3RoZC8vcTh6VlFWTlNqYnRnSXNvQVBrdU0zK0ZmM3BIeC9Eczk5Y25WOHRkRnB1Z2pRTmplYnY3SFhCM3ZnN0FOYlk2U1JidE92V2xPTlJHNHkwZGZIV0owR3diQy84S1BzRi9LZXZQNTZ0ZllOSzJIWSs5c2VORjhqdy9Qd3IrYXhhWnhhYkVOQWc2Z1h2SDVycldrdEVRcE1YYTdMS0hHc0xhWXlJaWhyZVdPNWlLVkwxU0JhVWdVQmo5UmtSVkkxZjdKMS80TzkrWmRaV2daczF1OG1xMVJtczBOVDVublhYUDVMOUlDRTdlaEZsaUtEcXBHTkE4Wk1RQkJBMUNFQm5ESGJpdTdieG9iSWFsQ0FzbUlHb0tOWmJ1UG1BQ2xiZFNaVktmWTdVWE5wOVNHNlhEKzBEQkc0bDd1cE9ha3FLNm80ZndOdmZ2YVVFVEIzbXZxTDJ3OThJSjA2R1lCelFIZHM3TXNIZlYzcjdYbGJ2YzVSMGFtWVJFV1hRbmRLcFlJZUFlMHcyZndSU2tNU0EyOFllVWg5dmlCb2tkRFN5enBEdDh4RTAvbFIzbURhU1RQdzlFZ1cyL3d3blpPMi9PQ2hLUEhQTEsrdFh0NU56UVJPekRBZUczcXR6K0tTUjFjUTZpZ21Jd1JPUW9kSVlVdTBudktSR09RWUs5R2F3OUQ0YkloQlVrUkNNcUtydnZEVmd6R2xXTHRTS1ZVV3lTTkJRaG1DeW5OcXp4WXZuTDIrTVpGT1RuZHg5ZUhwL29xMGFzbU1BZ0tKL1I5clF0cTFYcFRIczMxdGRhK1c5ZERWMDBBVzBTc2h4ay9kUEZ2LzBUNmFYajkrL1dGMHRRMDVJaFRMVC9ON0RWdkl1MkNyTERHQzN4cGRkSzVteHV2R3VNQlcrODhrVE0wRnVWNVhaZkh6bnBOeXZycTQ1TEgwUVZoZDdiZWdLYUt1WDgrS1FLczdyNEZtVUFaWjR1Q2NRQUluSTVzWEVnbC9YUXN5R0hMRGc5c3pzS0ozZDRyY2F3QmhDQTJBTmlKVEJlN1ZoY2JtLzd6Y2ZUMTFtbUlQbjBMWGQ0c2xtUWdoWm16Mys5MlhteHczZVhiVXVkWW1RUFdkR3E3a0dCZ1Z0bVVVQWNNTWNtRms0U0Nja29kRGdSVlhHd3BDOGZ6MGZhVWdIaEoxbFl0TEpXSGI5UFlqd3hWalFGT2lndmI5bmFDNzFVWUF4SkcyYmwzVnJQOEJ0RUNEdWFBTGk3VGNPeVhIN2U5dnJKZDdTYVE0Rzl1RXVuQ3B2V3NEQ0RLd2lxcEpTNi9zZW5PMW5zY2tZcFV3R0VaaHBhRXIyeVF0OXMwNDVBS0U0bDFtMjJtZWY2eXNwZ2R1WTlmKzQ4VGUraHFUVjJqVjZhQ0xycFNzTnBIQkovSHVOSktuMDQ5YW95T1FWeU5oeCtuWGZjeU1WUlJMQlFiRVd2NG94aE1vYStwbTA5MnhVR2JONzl5NmZMWGxVbzdIZUlEQnJOcG9maktzWG4zOXluZTJmTmpnN0xpZnZmRjN6VE5sWWxFNEdWaFFBcUcrV2krdDFGYWFUTzNlT3MvUGxrMXE3YmgxQ01DanJBTVRFd2FCMm4vM0pmek5yUHZuWG5HM3FScTNXQzJQeUxqdThlM1JSbU9YOGVOTmE0amFFQUVDTzJrYnpvTE9wTDkvNjdySXRYK3gvN2ZyWjQ0bjV5SDJsKzlZalcvT21FaFJDYXdrZ1UxV3cwd1VXODI3UnpjZStwUkJVcHN2clltK3FvUUpFdE5aKzFjbm0vTWJqQXBReURMN0gvNFlNRGFXWUdWV1ZERlF4c20vSW9SY0JzaVlzTDJDeGQrYzBhNnV6RzdVcTdZWkRmZmFvdkdOS2dOWG82ZnRmWVJtdmRMKzRHVkdjb0lzS1dORGF0VTBucWd6c2ZXQ0ZTcUxIdERYaUJUVzBDbWlGb1ZZbFk0ekZIV0JNNGpNblgvWk9SWXpZSkx3OXVuMVZzTEhERnRmZUR4d0pJQWpZQjdmSFpsNXF6NmJIbFlnUXc5Q3BHV0pObzFrZzNZRmxPTXJIaFN6RGhidjMwOXkyKzk2Q0JQUVJhU0xLSUwwOEdZbTNGRjFyaCtaU0gzOG1VZElpaWtTZ2hnd1JBT1RLUWNoWkF5REtqSXQ4Rk1nVTZBMUdoWExvYVVCUitkbGxvdUFCT0lxc05BWU5nWVllaVVMV0VNWUU5bWhhUy9kbGlySFlSZzBKZ3RZRVhjc3FvTUpnaUNJQVduekNYL1JoN3ZHRkM0QkZJVklFVkRBWnQ1NDZob0RGbUdzWlpRWXhCQUEwaW1veVFrWmlpejY2aWhRUWxja1JtMHc2ajlhUWhRNjlONlBNbUVYckpnOXVHcGlzZkYzYjNDb2RmT1ZCdG5qNjhYV2RuNUpXOC8wM0h1NFZCOVBHUWNPV2lJQXNCTFJSUFNONnRWNHVGNHNHNjdOSDA5TTlWcG1FeThWYTBIUmlqUW80Vm10ODIvemhQNXcrLy9YZkxGNC92MW9nYmRhTjFIVG5vUng5NVdSZWg2bmgwV2h6N1kwenhyVEJxbGVubzJrQkxQemV3YlBQeng4Vi8rRCtENTVjZGkrenJ5NFByMS9xMWZYc3lJT2piRHF0MWpMR1pZVTVQTnQ3dVArY3VzSXFHTnNoQ2VWR2FrRTBWamYxazZQRDhYUjFjZTA4R3ZSc0pEV3FhRExIOVlwSlNsb3ZKY3RqaXF1aGtHVVFrSW9vank4dGw0ZEhZdzdWQm4zRHpGbUgreFNtWU1QMFlsNy9IWTZOWCt5TlZudFhYV0Nib1hnK1ltK1l6eTRLYmJuVnliVUlCNDZDWGxYUXR1ZUVwcUprVWtBdklDSEtWcU1rVWZNNWpDMUNMMHhLbFpKNkxFeWNBZzNPSDlwYTllTHk3NUU0YWJicTR0UEYvZW5ZSlI5eXVtcGhtdjlDekM0a1VvaXVrZmdwUlZ5Nlc1dFVzcDMycDg4NE41R2RPS0QrNUFvS2tPQ1N4QnJudmo2OUg1VHNBSDIzM0hJNjNzYVhGVGNXazlRbi9hQzY3OGFSc1RaVERXS0FSTnNPbktnYUFnRWtBWkFRWWhMcTRKcFFGVUxkTlRac080SzNXbnhmS01oYjNrR1VqK2lYT0NUN01SWGVOa1BFMndHekFob2pJaUpCMFd3S0I0R1ZraEhpMXM0WE4vTW8rZVlnaW1oc3NNWVFHZlVHc0FzMmM0ZzBzWnRxMlhiZ3NPRzN2LzlkL3ZFdnUxbE5leWJBL3VIcDRXdDM1MVo4WG5HV2hjWjFqQ05yUllPZ0FiOWNMNnYxcG00ODFsbSthcCswMWVjM04ySDJZR28vbGs2eTNGanBhcWJ4a2Z1bitzTm5MMkQyZE1XbHJLL1g4T3ordllOWmVmZitPTS9iSUVqbnJGbVJvZFNFMnZGb1ZPanFPakNMM2p3OVUvdnloejg0dVBQaTRsRTFPcWlMMFdkaFhPOVppMmhkZUpPdW52Z1JQNFA5U2ZPOFBBbVYwN0x0TmtIMnUyZk4vY2xxN0lPU1ZmL3p1dzlQSm1WV2pDNlhNbllZa2lPTVF0dFpOQUxDYUV1QjRJR1FHVTNwMjdFRGRKdk1nYlJzdzJoRWFvMmNQRitqNVFEWmVmM2djRCtuVFBPcm56NmRHd2RlMlJhalNrQVZ5WlRCRXk5NEJsZHNRK3NYcUNuWk96MUhQRXoyRkw1QWUwdEFaOWhLZ1ljVFAvVUh4dUZmdXIxb3dmWnYzUnFCdHBmbElVVXJtcDZUd244WFk1ZllOelRjZ1hXUVkrMUNoZ2FtMTdaenRUMnI2aGZuMDl1R2t2WnNLZVVRT0NRM3czRC9INjdPTnY0UlJCNGF1ZjNRSU4wSTB1bWVCR01qV0JSQUNSMTBnYTMzTWFQR0tLaHlDSUdsdi84blNwOXFiRnYyKzBDVWZVZUN4MEFnd0MvSjZ1NVpBY3FCWmR0WTBGc0xXTDhncEl6bnBvaHVKbU9oMVJDOHNBQmJFNUJJd0dpSzBqVGFiK0FLTVlNSEFKZ1prTUMxQ2J3QWxxQVZrMDJsOGZrNHo2b1pyMWV6NzN6MXFQN1IyVlhUMVlmamFZSDU2ZW05Y21RVktQaVZqbHgxTFJzbzlxWkdWYXExUjYzclZiMnUxK3NPQVVLMWFnTWZ6cWJsckpBd2R0TXlEK3Ztek9iVCtkNHMvK0NHcXB0N2U1OWVjV2hYamNJN1h6OFZNeGx2QWdGdzQ3a202OENIYnMxdFZadmowNE5RcjljZDBPYkYyZElkNk0ydjdoM2RuVDVldjM5WDd0cVBuejg0Y3ZPaWE3VnV6KzRlM3ZuZzBmNjNuOTE0V280bnNIVFdqS2V6OXJLREtaeVBIaXpFQzVDb1dYeHlmWHd3TFE4bkwyc3ZZRHVOWVl3Y1drVUhYRGh3NU9zS2taQUZ5WG9HQitpbUFOeDY0WEp2Sm1GR3ZpT1FycEdpODlNN2Q4Wm9YWlo5K3NQekk2UWMya0NqMFRVNUE0bzJZMnRiZWZpZEh6MXJKb0Y1TlpLQktSNHhyY01DeGk5R21BekpBdjBWUzNjMXNyakRpQnZXQlc2Snpxa1ZqYmRNU0RSNDFIczgzcUJPZXVVYjBCMG9IVVFET1F5NTUxc29YejgyR3FTV3cvcDhKUlJJKzlTQmdldW9xcUFjZkdBZEhsWHNxMk5mZ1dsNEszWlN4WWg2TGdYMG1nYUswMkh4eXN5SWhsaDg4TklhWTQxeDFnSUlNN01ramkzSk1NVlNRVldsNFlTUFczbm5qdVBxVlNybHNJeUJnNC9EcVg0ZnhaMVdQUUxjTmlRbTM1c091eUdrSTFtUUxqTklYcmF1aTVTd2tIcVBaQVRKeGtpejJGTVFCa0ZVRm00MjY2a0JCY0o3bjYzMnYvbkcwZWdYcThzbGpHZDQxNDczRDZhRnc2YTFpa1doVWpnd3pUVm1adE1oMFZtOTlxQVNhTE9wVml1UGxtVlZVVEhlejhkMmZYRVR4cG1aNWJYd0tSSDU2N1dEK1VtRzRmT1BaRk5uK3c5elBEbzFkVjVDMVZxWFpkSnNXakxlYWZDeVBqOWJsVlczUU9UUWJOcW10YVRqMHY3bTArbWI3MzcvN09WTE9yeno3dVdGV1kxY1cwTzdhbDQrK01ZLyt1am4vKzQxTGwxcnpXcXRWTXpMT1g3bGwwOW5CeVpVTmxPMGxrYXUzcXh2VG80bjQ5Y1B6bCt1c0lpNFdDV25yWklCbzhDUTUrQVZJS0FGSXdWcHlJd1kzNGhTUVFjbjJWV04ybDdpcE5vMFNKZkgzL25hSkJoRG8rclRNMU53YTVXRGN5Tnl6cUlTdFRuVzYvMXYvZUdQbHpYVXR0QjZad3dZeDN0cHZKTWFScks3MWN2UXZZZ3RvdHNwbFVQMTdSMS9BNjE0bUcybWNvYTcvK2dnMHdkVjViU3drMzkzYTl3Wm9yZ1RiYkpmd0wxeHNXK0tBdTV5K29idkl6V2lkbnMrZlhEM0ZoYWlvc3pCYy94STNhbHIyd1ZzNGgwTlV1SXVpc1FJVERSUmdCVVFUVHhISTdJQUk4U3NVVkZBa0tiTHlCckRtVkJDV25FLzdvN0pNQVA2QTRjbzVHSGRKTC9JRnlwdzcySyt0UkgzdTJhYXh3MXlsMWYyeFlFTlNDbTZ4VkNNS2ExOTE0eWRzdTJIQmYyRzF1OWVTQVFFMWtaZ2toQVpBZ1UwekF6YTFoZHYzaHR6M1cyNjdMMEhkNXBIVDY4enlIRitQQm5aOGY1KzdsZG5aalpaWDVWMzd1dzVEWUwxcHNqRXF6WG94dGl1cWk1VVZkc3dtaTVRZVh3d2R5OWxBMVdZNUoyMjF4YnpITHE2N1lvaVB6MW81VjM5ZFhFSHM0Tzd4N2t1WE90MXZiR3pybkdacWlxSHpob2sxMWs3R2R2dXFaclJxQlNSOGZpNlFpUHo2dmthZit0MVpITVd2bTMrOGpjRnRaM2tOaC9Wejdydi9kN2R2L2tQaHhNSlJWWlBLZzZ0RFdoKzV4c2ZQQ2xtWWpLbkpodmw2OXl4WGxURndleG9ObjF4M1JnQUFUVTZ4cURPT0FnS2xPZkZhQzNlZDBBQVIvbmFGN1kyNnhzZGx6bFBDK0tibS9acWc5d0dyUzhtYjN6dGdOVVpDeC8rVW1hcW0wdzFFQlZqRTNNek9xZm4vdUg4K253am9XVTN6R0VsNFNJbExXQjhwVVhhLzZDM0N4V0hRVkkvcnJ3bFZveWtnSlRvUVR2Rklvbnh0Nk9qbmh5aklLSjlxRXJ5Ny9heFBLbVBRejJkY2xqQXVvMDF2WDJFaHEzdU4wMjk0SmI3WjNmOEs0bkJ4U0tkTUNzaThlN3l1RldCMDJYUURKOUxWWVNVMEJDQUNFZDFMSW1LU0hTTkFwS0NGMVlVWVNBbUU0SjFhT0xBaWxLOGRjclI1QUc5aXRzTDhCY3FNUHgvVkdCTmM2cStuYitqNE1LZG52NnRXVjdxcGNVTVphQklnVkhOSk9SUmxHKzIyc2FrNFRTV0ZDSTFFRVRWT0NaREJFRkJFYVdwemdKS01TN3M2VDUrOHB0TG1JSXRqKytWM3MzR3RxbENaNlh1MXQxOHRxZjgrTkt2emgvUFp0YVdMai9Fc0c0MkRhODd0bVVHdGlNN1BqNTB2cjZxOHVrY3pSV1padDFsaGRpajhYaFMyTXVTNWw4ejArL005L2RvYzdPb3ZNdEtYdExCYUZQVmJISWRjd2lpU0d6bkRuTVRmTzJMdmVta2VLbUNVRzE0UHA2SHg4VmQ2VjVmWG56MUIrR1gxWFZuY3N5d0dkUHppNjk4LzMvSWZ2TGprNk9WUDE3NUlHSEY0Zk52dlRYOXllZDgwaGhTUVpjVktxRmFyMTNUNE1IODRKUEhPU2N6a29JRVk4MWVhRHNWeXFiY1ZtMnJBZFVWbnRDTU85djZZSFJwcDRXNVhEVzRXZFNFWWZNN3I1ZGRYbzRKSC8zdFIyUTh0aDRCdTg1T0pZNXRIRXAyK25YM2wrZG01QW9JZ29QOWRLaVgwYzZIdDJOa2V3Vy9HV0poSTRXUGRtNitNY1F5RFlNR2pNWnVMdFpXdTc5VGdYR0xmK3hQN2dqREF0NGxwZTRLTTNZWE1QWEQ0dTBVWnV1aDZJY2Vyd1J5RGQ5UEZFeHlRZ0w1dnZ5bFk3dW83czZLd1VwUDA4QytSOTdIY0JwQTVaVDdhMUFqekNGNi9RTjdZYytxQUFFSTBYaVhHVXNBd3FtcmhxS0twTlNQbjNvK0N3QkNFaTdxVGtJb2Zra0ZIaEFyMi9IWmpsbGl5QTE5cFFTbnBESmtVU1Nqc1J0SmFwaVFLNDlZR3dOZ3JPbXZLYjI0MVRsbldFUkFGVEdHL2hJb1FBZFdSQURMeGFXWm5Nem41ZG5QVnF1Vmp1cTMzeHdKb1daVzE1MWFIRUc5dG5jZjdpMnJaNTllUzJqSFJUNlo3K1Y2MGF3V2xWaTdyMlNrN29BRnJMYnJkZHQ2RzFxUEJSbGUxakIrWXpRYjAvTGxUZVh2VHArdmJzTE5vdGljdmJ4WVlqNCtQb1pSV1ZPcGlDWmpsZUFEYXdjakN6WTBBS0dTR21YRk03RG55N0RKSHA3V1oyMWdPNktybzI4ZmZFemdNaFFvcXV6MDVtOC9mUE1mNlY4eGVmczZOeld6ZXMzKytoZGYvOTY5VDg4bkRBcWk3VjdqUTJERmhZVE5XTWNIekFnc29KVnpTSUJtSk1TdEJ6SEdHaHVJbTBzWjUremRTTEZtRnF6UHc4aFU3YlJhTHcxMzVmM3ZUYktzSE5scy9hUGZCRzFIQzlNcGFSdGcxQVZGRkhHMjJEczVybjRxKzl5QmxjR3IybXVRRXpsZmJibzM0cTJObXRDbzdrRHFZbCtaa2xVZ1RpYWphcW5QV2Q4V2dtUmJ3TnRMZUFjdUlhQUFKa0Z2Y0NlTUlWcUo0dlc4ZHlNUlVocFBEK2FHYlVUS0RzU2pwMGNtd2ROUWtIWWVlaEVWOEFBYVFtQ0phN3FYZHFTeXJVUHIzRW82WmtoYTRqUTB0WkZRQkVsVldRU1pES2dLdE1ZZ29pZm5QUU1STXFvQ0NhTWlnREQzaU5tWXN3MUlNb1NoNGJaNzErOXlLQWJnUzdrSU9MZ2g4WlpwY3JBOFM2eVVYeUNncE44VEZrVVQ1ZG1JQkdRZEJuRlpKNUdPbWZaR2haVEo2NXdoRmVZb2RSVVNWV1ltN0RMTEltRE54aDhjSCtiaEx6ejdaWGY4NEx0RnVPbEdtWldWYjAxcGREbFJ2L2ZXdlA3cHhkbUdJUi9kTVFUZDlXWnhJNWp0VDNKandaam1ldGxWdm9GUVM0WGt3bm1kejVFM2x4ZjIzcHYzQU5yVmswK2UyL2UvZHYvbGVmT0NMTnJKbkVabjliSjhPRmRUVHVaWjZBUkh4bVdXdlFJRkZUUzJOaU5wbCt2bWNIclM2TXVXekF0M2ROQlV6ZmpISjI4dW9TZ2ZkREJ5dnVVdzlpK3YrZmtuM2J1VFAvL2dubnR5VnhwV0hORzFYZi9vN3AySGx5RjRKUXBoNDAwNWNoMDAwRHlsVVRGdXZiQVl4V29VNzFFTDYwTWc1K29zYzY0RGFsK0VTYkhnYVVYVHZCWmpxbVlseXpPZStnYUx4YzI3di84YXpJNnlsdDNaTDY3M3Jycnlaci8yMWxjd3NrSEVrSUxTZUJ4ZUxqOXk5dWJDakdVZ1RsZ1k2bGVQT29vZ29OMEZUSUFrSkNqeDU0aHFvaFFRYjRYYjczU0todldMd3hSQ1gyR2I5OWw3RWFtVk9KTTlrZ1dILzZEVWJCcE1ESlM0VzRQZWFqZjMrNVpScnkvRXI4eGdkbTZPb2hvQU5BVFBxWldtdGwrLzJ6c3dBTVNBNzRqUzZVc3lJQm1ES0JpUjNtQlFGUXc1Z0NBc1lGQ01RdEFPd0JFd1V5U2dnVFhDQ3FSR0FoTUJtRGl2d2t3VmlEUTQwSmkwbHc0enJDU0lpb0VRMFpqb1FwS0UzZ0dDTG5hZzFCQzR2T3RDditJcHd1aGllamhJeUZSUURWcFVRU0pWSkRMSnU2N2VDeVBHbkxab0FsUWYrNHZLMFV3STZnSTVLMERTdWJGdEE0c2hEaFk4SzVGRmtja2FDVzFXci9IdTExN3pqODllS0dqKzhMdmZXSzZ1R3ZKQnhLSWxhY0c4cFAzeHA4dkZNNkU5aCtNcE5ldlZ1dmJ5NExWN2s4SjF5MnZpelhKVGk0cmladE0wTCtkemJKdDZaWnBOTjg0V3YvaU5CREhrVGwvWXp4YW1YV1hub2FQeDBlSDRkSjJIaTh1dUhSK2RsbjdkS0xqOUErcmNiRlRCZmxqNll0NjF2cXVvTEk0ZXVtbDRBcHM3OHVoT1dhOC9QZHI4WXZMYXljSG8wZEtOd1p0Nm95WGM0UFRIZk8rN3Y3b0VxaDd1L2Z6bDNmRTZheTI4dURvNGd2VjFKZVJvWkpVRnJVNUJFYjJRcURNK2lJaFBVUTVkRUl1Z0kzSTBOWVlXVjR1bnB5VmlZM0lIR3hwM1ZESE1MejllWmU0U3Z2bjloeWJYNi9tcy91Ui93LzMxaEs3NFVyVUxJc3Y5c2ZPcVhaT2ordGtuUGplMVRKUmoyZXZ0ZHFDaUptSFNkZGRKRVlIcmdJREFLTUFxQUlRb0JCWU5JV0FLMCtxVDdKQ0FCK2RxeE5ZTFJERTE5MEtMdEg3TU5nQXBrVHdBVURVbWxDQlNTdDRHSUNDbEFSZWJRcVV3NWdrbmJYVDB6bU1LWFl1ZnRrdkZpV0ZYTnRsN0ZrQUZFWUU5Si9tVjZiOFZFUVdrR01tZ3FrUjl1QmtPZTBPU0xXL3hXUEVQS3BGaURBS0tIYXh0UXg3QlJBdVMwVUhIR1VUQlNIOTlVS1FJSmVzVlBPbFNQNkJKdnFDRjdIRTRwRVE5TFZKdlF5WWh4bm1xUU5LVTQ4NzJLWU5kZXdoZEFDSWxRNzFYRUVETnJWWW1LQW9ZSklEa2Q0N3gwWUZDaHNhRE1kdzI2L20zMy9XZmYvNWlNZTFHYjc2OVQyZlgxZHFUQWMxTVJpaUEzdG5OMmFhUm1jMUhCTkE4V2wrdGNYNDB2emZlM0ZDSjdicXBHWHkxUVRjdk1GUlptM250bW8xL2ptU3RFUWg1V1ZDNzNKUVNLdkxGdUdQdmRhV1ZzQnJBUE0vcnArV2tzSjcxeFNNb3ltdzZjV3R6UXJXUTljNU90TGtKZDcveDhHZS9QQzhwdFB1bnh2alphWDFXM2MzM1g2NnEvTzc0dVByMEZ5L0pidHovcy8rOTMzdi9SZFhKL0d1UGJ6YmxmclZhaDhMd2NYRTRyaGhKRk5RUXhOUjdKbFJqc2x4Q0VERU9BeEFMQ3hqQTFKOUZNeFZjdHFPUjBicTVXVkJwVzlRV1J4Tlg0WU4zM2pzeStkekN6UDNpMzF4eGdLNXVKZGVZSlFyT2J1b3VnRGVlMjhvS3FnajMwa1hTd1ZaR2lGdEZ3SzNneXA1V0Zka3lNU3NwWnRFQ0VNbDJjUWlCSU82V1FkMGVtRy9KcUNDTmxSUG9Db2kyelpLME9IWnZ0b003Y0l1TnhhMHZlUGdhK21yTXIrSVhJMy83SzdjQUtMTnFTRWRwR2w3ek1IUFNsRlNoMGkvZ0ZQS2toSVIyTy9wTmx4RXlDSVJDOFlTODJ6dERVZ3dwMlM3SlNDU0lBRk9FN2xMazZzYlRPS0FBQ3ZVaW1MNngzTnVsZEdEeTZlNWduZ1lMcHNJdEZIZmtFU1BwRHB4bjkzMHg4Y1prQ0kwQ2FVeXEzRGE1aGcrVnVFV2pRd09SMUo3K1VnRkZnektpWm1NZnZIVy8rdUN6RnkzbTd1U05OL2ZibTgwaWRDS0NZSzF6RnF3aFoxcnZEUjQ0TWtWQk9sMmNMV0IrUExjMlZPMVp0UXBXcW1YcmlzTXN3N2J4NEVJTE5HSitielNibHhiaGw1dWJseDBWK3h0WVY2RURWNE8wM1hwVmxNNkoxeXgzVFZWM0UxUXNjcUtTcjFSczQreWt2RUVENUVBOVZaOHZqUStIb0k3cTZmd0hUWUNHTHY3NmV5ZDNMeTVobEYxOTYzYy8rdm1UVHg3bmpUeCs5NXZ6eHkvcTErZXpTM3Z5MGhnRXJCWTRMZ3UzQ1ZIekI2byttcVkxRjVzVjJuWXhpaGJVY3B5YTk1NjQ4c1ExR3k5dHB0eTBBVWpzaUxwMVpiMmJ2ZjdOdDl6bU9CUjd6ZC85K2Z2anJGUmZ0MFFLTENLNkdXRzdhdEVFUmgrcWFTa2lIQ0pvcFovZVVuK0ZncTJ4RG1TSWhlN3ZsY2svRnNFQ3RqY1I5RmZjZE9WU0dqalB1blVwYkxGelE1SG91NzFXRTdSajhPeFM4aDRQNTNPODVmL3R0YzY3MG1nY0xuMjNVUEd2ck9CaDlKdE96OElpMElkbDdHQ3g0aUlkVm5zSytMN0ZoZ0lpc3pVSnFyQkl4SThTTXZYSDFrR0xuUHBMSEtKSEluWjBXVkxNMC9EaUkyWlNleGhkVXByZVZxV28zbUxjOVc0aTNDR3Q0MjJ0dFFDU3BrQWYySFZHRDNUSk5EQWdNbW9FalRIYk1lRE9XdS9UQjRsSWhZelp0djdKV0VLaVRuRi9ma1NYUDN0RTJJNU83NS9jc1UvT0dxdUtSTTRaWjdJTUtjdUtKdVJUYkNweHVTdkgwT2FqV2RXSjNGZ2pUZHN1RjlhRW0ydlpIOVViOW9HY2ZjZDc0NGo5MTYzVnR1cjh0enZmcnBjTmw2emNocWFlYzhBTURBWWp3b2lXUmdWdjJxSm9wSmc3MTRsLzZqTjlORHQyQktxeXFSYWxYVHd6N3QzTEYrMmNYcHdmZlRTQmpadXNucTdmZmFPc0ZwMWRMWXZ4MTMvcitjZm5leGMvL2VTOTZXeHpiY1lQd3NYem9zenFWcUI1TVQ4ZUZWeDdpRFIzNlNlU3Nka1lXNndJTnJQY2VRRUJUd2FkczdSeGhiWmhVZThaeTJTNUUyanFGMmM2UGJuLyt0NUkzZWxZN2VKbmYvRjhQOHpMcFFkaUg1MnRzQkdxR25ZSUdrSkhvMlJTaXloTUd1cGREL3pmSGZEdWtLUWl4NXkxRHhraTQzcG1UbCtZQ0Y0cHNVbUhnRnNKTVcyZlJOaEs3OEhFWXprT1UySHFzUkFKMXBuTU9vT2RrR2hyR0x6MU9ONk9LUnN3dGE5MHIrTDdFaVJtQXpIMG04K09McXZQQ05YZUh4a1g4RUNQN3NXRnVxWGZDYVZHYnd4OEFiemxXMFJFbzloZlhSSzNPUnFyUTd3RkRLU0xoTmNkT3ZrSjI3eWI0L0JxTjRxRlJJZUNxSGlyQWdjeUNLREJiWDlXdDNRdE9GQThTV1ZRbDBVMkROMmlFYVk3Q1NvTDBBQlU0UWlYRlc3dHlSNDkvK2pUcnB5czRPNFBqdXVMZGVQOXBnQUZZMGQyTGdUY3FYMVJ0VGJUNVJLbWU3UFFoUFlGR1lxM0MrL1JIdTUzVjh0d09zdVJ4R1RsS0RPWnNHZDAxbG1vcnk1WGZvOGhLenV2eHh6VW9QaWJ1czB5RXpxU1RzRmFWQU5rM0xnY041VnR6ZVJoV3pFMXkrcGlSb1JHTnVkdWJRbnJNTjJEbGE4cWdwa3BzOFhOd2ZmUExvc3g0K2hnL2U5L1BYcm4zWWUvL1dqODFXOWUxUGIwVjFjZmw5Lzc3bTgrdWo5ZVg3Sms0d1hEZm02MERRb3VNd2FGNGg3UHpCS3NvaXB5VUFQTWlnZ3FBc2E0M01BQkxwZUJqRlE1bWF4cldteXdxbWNuOTA3dm5ab1cwUGpaaTMvN0s1bXRHTVBWRFppNmZ5YXRkb3pPSWpLb0pRMk9yR0VGM001ZmNDdTIyUG5KOThJSVRudC9VQUV5Sm1vYXlScE9vbmdjUHY2MkJ6MHRyS2htL3NJUU0rSWhZY2Y5SjFzSllHcGF4ZElndW9WclVKK0d0ejFmN3k1Z3ZRMGdWOVJidnZWZU82eXFyT3FGSlVhb2FzUXI5NXJLV3dzNFNUempHQ20rZ3RoRWl1cGlvSWhURjFaRjRaaVhxOElzZzNzWFVDTnpsV1FuWnpFVnpWNEVoZ2hxZ1c3dFNHbEg2OHZ6RU11TnI4eUNZejlab1E5NmxxM0NySSs4b0czQ1RUcCs3STRKSTdaakc0bVJkblV5UksrQ1B3QlVXakNSTmQ1VC8xZ0NzOEhpenBSZXZuajIxTHVxbmIzMzl2RnFjVkZsWStlVk5SK05SMjZ4V2k4dmJtQXNlYTdOdXVKOWRaUFozdkdla1U1dE5uSWJ0TG1nb2N0eFpzYmpuS2F1S0szZjFEZTU4VFdYNDNxVVpYa2VzczJUcDBzeDAvbVpNRTJQWnU3SEFZdVphOVlzbmVkMlE0ZGVzdGw4WkhPdHhZdVpscWQyMDRibDVUclA4a2w1aUFwRnZzVEZGYWNBQUNBQVNVUkJWRDVyNmZqQitzUDZhTitOc3NXbk4xT3Q3cHQyVkZCZWZPdjYrZXJ6MWJPN2F6aDg4KzIyZ1hkKytCZC9HNzUrV0g5MFVzd0xwMVhqbTNwT1RkVUkyanpQakhCOFpEY0l0czZjRldYdXBJTmN3VmhBMkZlMUp0VGRHeGVmWCtvSS9lUEpPSVBRMWJKM05NNG5KNGM1bWZ6RVZjdk56My84NjI3UG54MVUzZGw2YkVqU2VJZWtiY1dxWkY2SndIZVdqQTJTZ3JwM29yTjJnNXQzeGMweUZCcWdmZ0VuWVhKTUxidHREVVMrQlczWlJiaTlZbEVhZXRpeDB0djBkYmx2RzFNdjJieEZtOXdaQ0EvQXk1Mk13OXVHdWQwSzNCY01VV0ZoVWErY0xGRzdjb200aW5FUVZJS0dmb3pVWjI5THVrK1lyZEUyYW9hRmdRZ0FreVo1UjhZbEtnaGVXUkQ3WnQwZ1lGYUYwSHRzRFF4VHVVaW9KRUNoTFlSekp3L3RWc1puaWxHT1JGalcyNDBBd3RoNjdQZFBRVUc2cFN4Rkl0RmRtbStjN2Q1ZXY0bGxKdEtnSVpGb0kxUlZKUlFWTjdJWjRkT2Z2b0NzeGNuSnU2LzVUeXJqU2xWck82UnliNXJCMUlWbHZVSjRjSFNhYlpiZS9PcHFZL0w1TysrT2ZPdDlDQzZndEpVM2VYTjhXckkzbVRYWXJKZXJaallxclc4VU1teXVuNzdjU0hmWnpyS2cxU3JEYnBYbDdnMkdvdUJydDFCam1rNjBOSGxoT2lidlBScFRQNlhTZElETHk1eTBaVE10bHNaSy9tQTh2Um5sZUN4bGNmbjhsNStVWC9VcjNNK01DOWNmLytQZkhYM2lUdWp5bldyMTY5TUhCL0Rtd2NtdnV5ZWpNUVJ6aU9HNjF0WXJqbTNwaFZtRVRhWXFpa2lOTWR4UW5wR3dyem5YTVNXU0tRdEx0NjRXMTVjMWtMVTN2aHROcHJPdU9IbHdQTTR6VzRxZ2FhK2YvK3BYajl6b0xPU3oxVlZqV0Z4SXpuZFdaaVpEWkFTbGN5SktpQXBzWG5tMFUzU0pJbTQzWXRCdFV3dUdhUVgxSkE3RldJdjZnUzd1TnI5b1d4OEhqOEtPRWtHM2pHK0MzWnVzN1Q5N1d2MlVTQmQ2Qy95RXUzS2xYYlBFdGdMcmRoUzZHMXZHeXN3Y0gwQUEzV0Z3Ylp0WVEwWnhueXloQUZad1FJWmdUMHdub2UwdUlxeGtDRk13TUc3N1lISDAxb0dLMGhCMW90dWVtb2dpcWlIVW9meW1GU3YwS3Bxb3YvcHVYNWJoclZkNlNHUGRXY0lteGlRYUhXekErb3JCQXdmbGF0cTJvbmlWRUwvQVJnSlY3NkpvSmVrM0lRc3RvQnNYK3Z6bDJkSkNiZSsvZDhjL010UGdVSkNhalVPVGx5WHhhcjNwektnNDZvTG1ObXZrNGFTaXVucWE3d01DdGkxZ2RYTzV5VTVQRHZkUFRseDlkZE5LdTFqNHZGQzBySFZkcjZWNjhmUkdNKzdLbzROdTJiMDVzOVU2VjMwTkZKckxpMHViRitQT0EvbkRFN05ZaURVWXd1eWtxQytmK1hIV2RQWW9EemViYnMvZHYvNzhiUFRHQk56ejhxdjZ3WFcrOTdOUHRmbnh2ZmZxSXhmSWRzLy94VC8vYi8vc1gvN3k5ZG0vek9ZSFozL1owcmUvOGNkLzlQanB3bit6dTFuVzlYS1JCVVVxY29TMkR0d0pGWnpDZTRoQ3gyMmVDZnNtWUtlR2pHcVFheUJuUTFVOU50UDdyc0hpM1ZHVzd4K1dZdk9jeUJKMFUzZjF3WWVQTG4rZWpYbUYwOW5zN0pxeVJyTCt3UTVrckdhbDYxQ2tVNDF5QVVnUEhxUlpSNDlrMFYyQWxPNzQ0UHZJbEhTa2l5b29Vc1VoYUx0WFFPdXJHdW4rTHBmZ2NianRuY1E4NEw0d3BBZlhxUUlRVWErYmlKanlOSjU2UmNpZytBb2cvdFVldEg1aC9Kc1dNUGQzMFozVTRaMFhPelN4WVBBVzJDZ0dUZndmSkxRaXlnUVVnZjBzaVFHcFlKRURxeGpvcGRuQUVvZ0NKU09lTUNxZ2FZZHlIa3R5TUtDTXhzUjRHS0xlS0JJc3BiTTQzTUxzSUFBYUVQRWhDS0F5b1Ezc0Erc1FvcVpwUElTcUNFcnhFRVZFbGdBTWVWVlJJTVFZWkIwNk5kcDVzajA1Vk1Bb3lBNHZsQUFvSjQwQnk0YkdoamtBV1hNdDkrOWlGejY0dVZwVlRNVnI3OXl0bHNaVjVNb0NLczRPcG9kVHJCYlYxY1h6aTAxeGREODBaMktYdnNpL25WVTNMNWVmWGMxTG9YRW0xaGpMKzNmM3l0SmVicGExMzNRMzE3aEhqVHNUNHVzblo2NnBxa3JIY3orN2UxcUVuR2ZGaUR2YW45Y2txOWFPcS9iRFpqNlp6WER6NUJQSFRiNmZUU2ZWNW1vL244dk5panMxNFE0OHZUaDh1SmZaRTJ5V2JEWmg4NlNjZGxmei8rdy9YMTFmMzd6Y08zNXdkams2dlBQemYvSHRQOGIvK2E5L2g4SjFaYlZ1TG4vNTN1dVpPWm1KNHRsVE5vZmd0Y2d4SDA4UlF0dDZHZDlaMTI4VWkxRjNrSy9hZ3RwMjV0WmRnVzNJYyt6RVdHSldrK2N1SzhhRmRVWEdpQkJVUU1SazBESmVmUEw1cno4OFl6ZnZHaFVTK0hWRDdETVUweXVQa3o5MTF0WnJKYTJkQ0RsQnpPS0JTQ0xWUjRVd2xjMjB1amhsZHFYaWkybFhqck5qVklZUXF3dHRQVWNETHkwQktER0d1RVZ4cFBTVHhSU3BnOXZRQm9wdE5RTnhTaFhQakM3MmVuRXJBSXhmSDlDa0NKT2RLNENtMkFzWWNEWXhNUUlSU0NYbWo2V2ExL1JYMWxTLys3dXZwSW9iUS9ZVWpITE1oeFZHaXlKMmlPYmREcG5pcFZ0M1dzMkdTSWtIYnhjZ1FJaG44c0dQdjFVNGJrTkZGUlE1VHBMVXhFb2ZlNEM0cTBMUkwwTjA0Rlk1Ri9PTUI4cmxsOEFvZDlYUVNFaWtncnRaYWVrc0ZDMmllQXN4MmtPMGhnMmt0dVF5OWRvZTV1TmNYbjYrV0MzcVlDZVRlK0ZKc0NWMFZzU1dzMWsxT2p3TUw1N2NlSEN2M2FuODJCV09WK1ZobVZtcVJudmpKNXQ4Y21DN0VOVE5qaFJHWmI1WFBUKy9YRlQrN1Bod3VucktTcUZwUE9QbzZ1b3FqQ1lqcDRldjdZVTZLd3JuVktpZ1BhN1E3V1g3bjg0enAzN1Z2ZXdFV1VxMDNXeVMyODNWdnN1bHExcDl2SmpSWHJHdXo5M2sxUG91akVNMktjY3pmdi80VzErN0d6NzcvTktFMmVMRC9kLzYwL3YvK3Z3Zi8vZi82ai84QVZaWDdkNXJzdzAvNis1TWRGblBEKzVlUHFlSjVnUjFNS05ETWtUR3VFdWpkOTdhZFBNd0tlZFVtTUJyZU9BQ2xsMGNyR01lYjVxVVc2TU1CRG1xUWtEbGptSHo0c1htMCt2TDJ1WW9tNHpYNVVtK0N0eExKSWV5WTdOcG1RVVFBVU5vRUpTTTdzS3VVc00ydVd3Z1lqZkM4SFFrNSt0V0tSVm5sMzFPMEN2UDFqWjFFR0g3b09xZ3lNV2VacFdlM3ZRcGNlaW85UnJxM1o2MjRxNVZvUjlYdmNKdDNKclpVWGVWWHRDbmRLdW9Rai8zN1EySDJxK2dQaUVwL1NIZjAySUJZakQ0MEQ5UGI2MUUrMWpmSFVNRkpPc3NxbnBWeEpRZWw1NTd3Y2dHVGIyaTRYOXh5K2NLS2dRbzdCQkpWY2dBSWlNcTNXYm5mRms4U3F5MWNjNlhrdEtGL3I1UWpIN1A2K05ldG5mcG5vUTFNSGwxMEdZUGRtQkszZlhrOGdTajJXd3Y4K2NmZjJnMkc4bUsrZUZoM1ZKbU5EUFMxbG1XUy8zMGFWaWZueTNtNVhSYzZtaXkyQ3Z0cE9STm05dmorZXYzMWxVR2ZyME1ia1paQnJKWk4rdnJ4ZkxtWm1OWHhVSEdUNjV6NTV6V2k0ck1YcjNadFBMOSs2K04xc3RnbE1ubDFvQm5zVGw2Nng5T040OXZSbkNDWWIza3NEbW9OTiszSGQ0MFlrY1VjQk9XOXZEMGFQeDAwMDd5YkRacWxCeDdkTDkvOWhjLytzYjMzbnI3MDA4dkQ4Tm5UNDV1ZnZldFAvcy9mditmL0s5L2RmL05vN096OXVURWxudGpjM20rWDAyLzlyMlhQM25mc1RybnJENG1JbHNVMmNpdW4xNEVVK0NxSXVzY0ZjekJDVXNwYXJLY2FFTmtWRFV3R1ZDMFVrdlhWbFVUUGxpdHUyNjFiQW83THFxTmg0emNmRDZwcnVOUzJ4NEhBd1lhamNmazFWcU82UmhpTE85MFhIZGRMTU9FQk1OZ3hNZVVsaFg3U3R5UGpYYlU4Zm9LQnpxRk93RUNvQ0FCS1loSmo4Q0FZWS9pWTNEYWJ4TFFaLy9oOWhIYVByQTlQQSszdFEzaFMrNjQyNVBBMEZwUG5yMitlVFdZZWxGN3lMWHFkb0kwektuampaUUZCRlRFN29pYm9uMGUrbTdYc0FUSU9rc1NVNksyellDVTIycUcyWGZhMHJhYTdDRVBFVEQyQmtRRU0wWENZS2pQTXR4Sk92L0NHbFlCQkJXV25aRWFmbW1tM0Jkc1psdExjRXdTeFQ0RUxnNktVZ3F6NHBDajJJL05IWWxIVzFnajNwei8rTFBPMU4xby8rQjR1dEd5a0pwSzZkWTNMeDJJOFFFd1B5aG03ZmxpRTF4dWp1L3MrOHU2ems3M0N1N2M0WjJMcTg3WEFQY0w0d09TUGd0Y3VQRmVmWG45dk16YnRWejQ0TWJHdUVhRDEvTEJtMThweVJ5V0Y1ZnM4cUpRVU9JQXhycjhmbzdYMTUzWVp1d0tzS01jMWx3V2xxRVc0MHlXWjdwYzRmend3Y25wMWJYNFBMZkxMT2Rtelc0MWVkaDh1bno3Z2MvbmszbjkyZVhWeFRmL3E3LzUrUGlQL3BlTCtvMHlhMWY3UlhqMEt5SU9kdDJjek40cm50eXM4cGxaTDA4UkVVTExrNWx2cHJPYkQrNWswNGtORE0xVXFuQ1F0eG9QcW1ySklDanJRclNybXFBM3dodzY3NXRxMHlsT3BvRGRhZ0h6K1RNNXZrc3ZMOW1TRTZKbzBFdmFIMVJnTHJRaGxFNWJCMEFXUXBxUEFPN0tyYlkvMXQ0TEVJL01LV3B2V3dEN1pncmhibWRsSzl1NmRUZkY2SHJTeEcyRzRSbEJ4WWg5NkQxRDIwcWIrT0o5cWxrRWpRL0poMStpNisvSHZMMTJ3c0N1OW9Iam9DNm1vZDlxQ2FsdTQ0QjdUWXFLUWt4eVJtQ0tNbjVMMEZzZSt3Z1E3UFZUME9PQm9qT0hqQjJrbm9CcFBrdzJwWnoxMndvUCs2VU8wR3dGMVlDSUtvSkFhaWdDYXMzMmtLQmZHdTBrR0pPR2I3ZU52eHpFMHdzbFUzZ3E5aDB0QXRGNHJxWWQ3eE1tWGFiMm1XV0RpenJCUDB6V1ZoY2ZmN0lvcXdyTG82T1NycUFVMlNDSFpybHVLYy96L1RsdStHanlkNnZMbFk1VTJ1dm4rODRkM2Z2cWpLOWZQTDEyNTJmdDNiZmZ5YzBZdTdvaGk0WDR3RzZLZHkvT0xqNDVsMUxhVm14bTBibjdiNzAyVWJtcXF0bWVOZHdxcXJlNTQ3cWhMTXZtUngvOC9PUE4zdkxtdmdVb3N0eGNkNjQ2YXp1Y3F1KzBtQmFuMmI3aDVRZFA1dU5KdzNEOThvM0pYbDVmTmJnSzQ2Tng0WC9UZ0t3N0xNeUtmL0xlSC83TnAyLy84UTkvMW56N3Q1Y3ZueDBYVitkUzV2bTBXdHdjMWMxMDAxYWJUSGhwb283NFcwZmZ1ci9RYlA4M3dTUGtCd2QraG9zbXN6NDNWbndncW1QQ3ROd2djdHUwUERaNU9jb3l5ZmVsWHEyYjBOVzFUcTFjbHZ1djdaOHY2NXdUUWpLa1I1cFFJTFFzMkhvVzlMb1pPVUdqdk8xRURyZkpJWlZ2V0FBS1lCTTZwdS94N053Q2IvZVVzQWVyditvYmpGV0QweE51K290ZjcvVlZrSGdOSDNKV2NDdDhqdXFmUG5VUUl3UnZ0MitscjY3aDNiVGYyRjVuQlkwTE9MQkVpV0lLY0lwZFp0MlJiV2hpeHlsWXBhVEFTdUZtWm9COERYTzNXRW9IdERQR01xcG9BWVdwOTFtbS84LzAwWDZZUnNPN3JncU02cTA0bzBWVW80Z0liSlVJbEpoZU9SL3QvaVdBdlptYmpPbHAwTnZHeEpmZGdYdHdrTzdxMFhjcU1HeFYyRU5pUzBUb2kvWXIzcXZOclhTaE1hdFBQMjF3MVlWUk9SbEJCOHZMOFZqOXV2YlZxakdUTVRjOEc1Y2F2dE11bDIxWFYvc3J2N0dGTzZTYmw4K1hsd3U4OUxNSDc5ME42NThZYVRvRXVXZGR4bTNMcDRmdmhQUGYvT3BaYTZCYjU0ZnozOWwvNDJGKy91anFacTlvTG1ndGdRd0UyTkNLcGllSHJndW85bDVsMnBkNzdTWkFCY0FhT3FSUnFVVGNNWFNqOFlGYlhTMjArc3BkSUtMdzc0N2VmdWZCZStOeS9lVHpSVkUwNjZmVHVWay9YOXdOcjdtbkYwZncyZjF2NHlmbjkyY3YyaFdNY3g5NFV4WldGc3RMbGF6YU5KTzl6Rm9NcmVmLzg3UHYzNmsvYW1kZmFTNmZQSDYrQ3NmNW5Udjg5SnpuUllHZXJSMERnalVXd0diWkNGVFpaRVdtM3I4dzNmVlZMVENCRElEQi91RFkvYitFdmRtUFpWZDI1cmZXMnNPWjdoUkRUc3prWEdRVldScGFzdFF0dTZYdUZnekRmakNzdDM3d1gyZy8rY21BMFdoQkRibHRTYllzZGFzbXNrZ215WnhqdkhHbk0rMjkxdkxER2U2TllGWTFDaWlna3BXTXlKdHh6dDVyZmQvMys5NWNzZU9vb0JFVnVCL1dMRkNRMmtwb3FrWUlRMlZKb1VQNkRqZ3EzZmRBOXovUVBkNVlzWVBFRGZuY1EwTUd3UUdxQnZkcjV3UDNaUzhEQVlzU3luQjFIc2MvR0l4RDNkU0dRMzNLbURvYWJVSUgxT2RicHdqY3J1WTh5TWFPRUUwVVlRRmhoaTU4ZFNBN0hTcS9keDlnRUZMWkkrYU10NVo2M3REd1FVaS9ZVC9RelZTRVZZQWNRZWlybVJCUWg2U3VkcVNlc1hDM0E5TDB2SVRoWUpaQktJdUlDR3BFMUxBWjY2UitJeUsyMjFVU2dtQjM4eDFSbEcvZFlTa09KazNSZldjT0htUzdoQkE3QytidzZrWWlFREg5dDVIbnFjTUlHcmV2dnJ2bVdLR2Z6M3dVbFhiYnNDOTNXd2xCc1FGenRuNzg3blM3cFB6aFBlYW1ma2xzU000RHdqYWttYlgveHZnOHZUaDdjNUY2SUlqdGQrbHM3bm0zdmJUVGU1Kzk5ODZ2ZnJXK3JoZWYvc0hIN3hyKzl0bVo1TVUwQzJWYnJxUG5TWXFocVoyWm52b202UFJQOE0xNXVmbS9yaTRoTlVqR2Fnbnp5UlFLSDRKTmJQUzVBU2Z5bXJaVm14ZWZaVlErZlVWa2YvclJIL0g1MlZiQitteitJSmw5K3FWZmJQQmt6ZS9aelhOOGZKS3Uzb2hQaS9UTmJONSszenorcjcrTGJidlpjaGQ2c1VDUFhpV1AvL1ZQZi9ITlZ5ZnYvc1J1di8vK2IxYzdmWENQZGpmZUdqTENGVHJuSEp0VW0wWkZKRmMwWE41c0oxcmROSDVpRzJnYjkrVDNmaVRseXhjcndSREcwNndmWHd5S1JJVXF0RXpZb1ZEVmRQN2VnNVZreDJycnI1SjdGM0pYTDdzMzZCeWN0UWV5THg2U0g4YlpGRWNaVWdEUUFBMTZJd0oxN0dmczBxcUVBR0NNNllvQUI5NTBueWVFMGZ2Y3gzdDdTWnJ2UE1BSDJiOURjUWk3bWdWbUFCWEFmY2VlSEdTVDlFQ1ZQY3k3SXdLMlNHaXpJclc0RHhVY0lDSDNtVU9rL2dEdW1PNDZQQXBXRllBTWdvSUk2cmdsRzN5bEI1TzNEZ0M3TG0zUm5ZZmRWbnU0OXZ6d0NvMTdNemNTalVNSERkTGRRUlhVclp0M0Y1MlNBZHkzcDhnUHplVmpHcXEzaEFFWlJPR0JJM0EwVFNDQ2NmajFWN3U0NWNUbngxUFRDcXhiaUZ1c2RqVUxXbWdiaGtTcUtRUU9mcmRwaFYzS2JIeDQvdTdSb3lSWFNiY0ZYSzEycTFWRzNoTEdabHMyelR6SnFkYmxDM2QwL0NkUFhyNDJILzdvZnZKTVZPd2lZZ3AxRStQNjNDVm1jZVNyN2ZuMStmbkRreUl0bTluTXBrRC84cGUvcmswYk1HWnBqTGJjMHNtQ0hFbWJaTG54TXdtZnhadk4xZnJkeDhsbXMxNExtamZUazlNWk5tZmF2T0RKdzZ6Nno0K3I1d3VvM3kvTmd6LzU1dVl5bXlkVFI2R0JrNjE5LytFTnduOWZWdlg1bDc5NGFaTXNzNGJnOHVyWmx4OTgvcU5QcmxmUEw0cDNQN2ozcjc3NGYzKzlldStFdlZSZ1RDZTVnWUttR3NGYWcwZ3VvV2E5MlZtZzNNczJNVWNQUC96Z1FmSHpuLzBxdWhoODZEM0EvVG9JQWlFcUkzWHJTV0hzK3Vwa09Ec0hMVlhnZHUrbTluWUtHZ3Z5OWxJRDdoY2JJK2xLOFJiRHJzL1JkNmVEWUg4MTdtUDkyQ0Z6dXFSQXI0NTIxM1FpM2xzd0ZSQ3BMelhiWTJ3T1p1ODdXOWxiai9DZzdvcUlxREFQSXJmY3NsSEE0WU9yQjhzdkdzeUpRTVltazNtQm4vZk1LZWt3VytNSGtVcGtBVVFoYTYwbFZESWtiUnVqZE9WT1ZnWFFHcFBYWmMyRWxCYVowYkRiOGZDbVlWYWdycXF5U3haMFZ4WFRmMURHNTZtelpCU0lyTFZtdUQ4d2g4Z0tLRkp0S3pPYkd1Vm11OW0yb2tBbVNRd0FvREhXZE40VGF5YldnSUN4dWJHSWlzZ1NReERXS0cwVWlWS1ZWUlFoYTYzcFREaGtDTWlZck1nUUNKVWtsdXN5Z2l1bVpoZVBIdHkzV2t1YXVUYy9mOGIxcFh0NDhtUzZyaVl6ZXJuZGNENU5iYnZkUVdMYU9sTVJUS2Y1VkcwaVZTT2MwYlp5aStudnorOHY0T2IxOVhVMHRseWJtV2MwcEM3aHVqSFRuRXRiYmFzUVl6eEtKNFVwbDJ2SVV5MTNyYnFjZG5YY3JvNFdzM3lTYmk1WFVaTkpacFNQMWN3MjV4am5NNzY4aXU2NzY1MGhvZFNDTFdhMjNCNkRTOFBOc2xwLzlvbWU3K2JIb1ltK1NDMDgyZDZzVzBvc0NaSklNWHZLVlpPZXp1MGJrMUo1OXZ6cVpGRmVRcHFrSmlienpFem1xMFpUczl1MC8wNWRndGxIbnpyNjdnMWU2dWUvdjZDekY5ZnJEWDMrNU9sZmJ4OU9YNTJYV2RLS0U1ZndMaVJURVZFaXN2TkFMbGJpV29nMmJYWHh3U2Z2WnNWay9ld3ZyNjlhbjJCY1EvZno1UVk5VmcxdmQ1aTEvZlJtaitjVXVhNVlnUXlxK0Q1N05DUnk5dW1oVWRPaFBuODdsdEFpSW9ieHppeW9LRGpFeXdaZlZoaFJTdjJkN01BWjM3bEFCa3lwTVFnQ0RreG56dFJ1NHJVanFtZm9BKzd4T3YzM3dUL2M1V0FQekJqMUhtVVJoYTYvVis2ay9jTmdBZFd1eXd3Um1BV0pJcHJZYU9KaTZMVHgrWU5GWXEyeG95T2xUMmp3VUp1b09DWU5XQWtNZHF5ZTdoOXBmeVFUZGFiL2p0ZW5BQ1J3aXhnSHF2dVBTQWFhTlNHcWlaR0l0RC9TN3dhc2hnVWFkQ25kN3JKaXVpMC9hcThuOWVUcHZoZEdVUUgwTjYrbmIyRjc5anQySTRpZ0dpcWJUOTNpcVBJYVhLckxyODlYc1RXblR5YW1oZUw0S1AzZHB6Lzd2b1RwVWVYTitrYU1hVUdZRXB2VzZoMUJVK2RCNmVqMC9xUUNseFkrM29EVHh0eDNacWRFQnExUjd3eTE0R09TQWlDQUIrdWthYmRGRTV2dExtQjJnWFozSHJJenNaN2JjdXVCMG1aVG5IeS9jc21HVG82WG0rdlRUejZJL28rLy9PWFNGdzdwNHcvaXR5L2hQclJsSStiRW5wMjl5dTR0OVBrTXA4ZHBXL001a0N2WHRaNEtPWkRkOXRHRzJjbE5uZDJjVHg0ZUhiL0tqMHU5S2lFTEdxc1Fudk5jaEJzdUZuL1J4dVd2bnZvUGZ2eHBjNUZ0Zm5YOWZKbjczNTJFOWJkLzg5ZS85ejllZm4rWm5xN3JtclFzeW0wKzRXWkpSQWkreU9vc2JaWXJMSklpdHRsSG4vNTRodGFiTjMvejl5dGhnM1dJdU8raDdZSGdRczV3a0g0UkV0cldxcUE1Nkx0V1ZPMGZpTDJWanc0U3VaMGphYmhkNlMwOExQWUJvbjEvNzE1OHhUM0w4bTVCVHpkZ2FWOTZkQUF5N2w0U1BOTHBEbWlLd3dOOFFINjc0OHJDM3REUnY1SkVXSGpZdDk2Rm9mZkVIZTVHUDJYcUdnYVpRUlN0cXdDc1N4STNMMmFwSVdNc0lFbXZhNkVpOUFqNnpxZElvb3FkTkF5cElCMFVGWUgwUWh3UEF6MzJQTnI5RHJ5L3lYZG10LzRYc2VlRGdxSWhSS0wrcWlMbWJZOGNEWTVJR0FsSG5VSkYzZXNCRlJpbHI0STd1REhEYjlHWnhqK0JkbVFWNkw2K0I2RThUYVZpb01SY3Y3aGhhRGcvWHZpMlN1YTU0VjBncjFwdk11c29ib096QUNwcUV3akdKR1FhQnZDelJZYW5UcDZ1MXcxYkh4dVR3ZmFvcWl2RlJMV3EyNm90RnQ0NlVoYmRNWGpQNmF6VnN0dzBZRE1Ec2R5SmZlaDNhM0pTbTVDWjBNenVsZDl0RjBkVHQvU2JUVDJyMitUMGNmSHN4YlhRemZYMTQyTTZXOXE2VlhDRlAyb3FFZ1Y2RFRPMlcwNWNQaStjY0hNamFFbG8xU1lMWCsrS2ViQllYK1hadXk3M0gzOVlYZGRUTXM3N3VOMzVGRVBkMXAvaTZmVEhmMWQrdS91ckYvVGpCWHlFQ2ErV1NlNysvRTllL3FlZlAvb1hkZFcrL09iRzY2NUlHTmtjNTF2VUVEbkc0T29LVHhmVDJXa3hlZWNveWNwNmZmSDFseStxSkxKemlRWUMwbjRsTkZEVXlmbXE4djFmV3FoVFFDQkRva0FBR0h2cFJjWUhwRjgrRGJ6bGZwTnNZVnpKOUhMR2Ztc0ZRejhnUXUrVDF6RkplTHQwckNlODRvRi9tWWh3VEJHUFAyQjY2K3ZqZ1d2L0RqVG5Ubi9MbUNTU3prYXV6UjdVZm91SVBreU8zTy9obzZDZ0lpb2hDVXBnNTVOME1zdW4zcEdnTVJaN3BXWFlyZHZSNmQwejZuQXdWZlExQ1AxN2dqdGNCeWdRaVFyUy9wWXlGaUVQR0RzaUJPNy9kS0xZUHpuVzJtNmhOdHlBN3VxNTNYS2hYelVxQUFpalVxL2RDZzU2WXE4SzZuNEErSzNQN3kxM0RGQlhQaE5WckxHT2dzYkduUlRiNTk4WjQ5emt3VDFiYjJpUzFoZmJkVnZuaHBaWDk3THNuZG5Wc25JRVFReUFWNjdFSFNkaXJjMXppazBiYmxZNm05ZWU1bVFqdkFqQ3U2dWJwb1RKU1o3bTNrRUVEVTE0RHBST2lueDZIdXFxYkEyWVIvNUNwN0VTbTdibE5rYUdBRUJRbnI3QkJleGlmRExCOXRXbXRUK3IxNkZZTEYrMUZ6L0xKbm1lZkJHRkZOTE16WStjN3B5RHN0NFJuTnhMa2lUVkFHVVZCQkFVbGtjekNaSW5VRUI1ZFpPNHFEeVp5blRUZUlpY0c3dEZUQ2V4YXI0SmovN3dUei80eFp2dnYvMm0yQnhOSDV2N1I5bnE2dm5xLy96ZzkvN3Q4czJyVnpENzVFT2hadlAvdUFLYk1zYWRzYTdJaTJUaWsrejAva1NQNXBtSnI3NXByNy81NGh5OThaYmQ2VU43OFliM0NINGMzQmJPVjhFTlI1eEVad0NNZHZlMFBmYThXL3dpSGZURDQwSFJKWTFNdHdQNE1CNGc4VVljOFpESXU0dWRwZkZxc0RkU0RwN29mUXYxa013aE9IZy82RUU5MnREdzhYYURVVitlclFNdFZzSmJmalMxSy9nYzdXaERGNHgwZWhHd2NKeGsweXpOcHdWMFBRUmdFVkR3a1BaMVlFb2NpckM3RHFOdWdCNVdiRExxZEdSaWovOGFjSDUzVGp5aVh0OGlRbVNFRGp6V09UcjF0MVdlRWFHU3dXaUlUTHhEbnh3USszb2dHaDNVdy83MkEzaUUycUtDaUlpQTFtbWFvRW9ieTJsaExwOWR4YVp4NzN4UU5FMU1ySzVlWHFtQ1U1RDRxamc1ZldmbXo0SElxTlBBa1p1ZFA1Nm1XWUpnRUZub3lZL2F5M01TbStHV2t1THliRmxGV3h6VC9INVdsZCtjaEVpZU9LVE9ZZGhCUGl2cjd2MWs4N25SK3FZc3VkNUU3MnZhVm1seGZURXhueHc5djVyUFh1YVQwcDJHOGtWNWRwTSttcjMvWmFPNXJWNnZGMm9jS1dwcEUxZlllbHZXSUxZb2pscXVrYlZkWjlxMlRLRDV4VVUrdGN2ekozVWxpWk02R2kydk1mdm9aUXFWb3B0a1RiVnh4WDFiblg5NS9kTW52L09vL2JQdGVqSmRuZHZONU1tVEQxOC9XMzc5OU9IRDQ0K1B2NFBXSk1tRDlQNzVXVWdUWTAvSjU5UE0wWEU2blUzOWJuMjJ1Yjc2N3ZuaW54VjZjMVY1YkhueThOMzU2cnd4UTBrWTdpdEEwWklPakZXSGZZV0xpZ0pxbnhsQXRRZFd4VDZIMnljZEJndlVIZ1FQQUIwTUQvRWdTSGlnVkI0c2VRamd3Q1dwWTJKQ3VpTVdUTmVpMEF2TUJOeVpDY2Fvc0l3dHdyMkRzWCtFOFljejhBR0hYb0M3OVpVSzNuWnNFUnpTTlhVVVh6dG1rQ3BxRk13VE95bW11YkhlWSsrSzZVL2dXM3pjZmN5dUEvd1FJa0JFZ3gyNlhYczRnU29qc08wbVVoMmFESWNIdkh0amFkOGVNeVo3Y1Z5VEl4cERReW5pV3h1U2tBakJXSXJHa0dGRVE5YVE3bCtBT0g1NkI0YXovOUlKdkkrSXEvYXpFeXNnRmJPcGw2aUttTkQ2MVdWMWpuNDJ6MldIV1lLN2RjbU1KSXlpMnpyQ3FWL0lHc21TeDJCdHFnMDN0ZWVxcXRYUnBEaVo0MlcxdHFWNnJ0dzhDV1dZUG5qL2dTMHJGbDVlWHJVQjA4VEJPM25hM3V6cW5ZdVlIbVBxN2JheGJya0o3Nld1WGEvS0hXS3J6clJYeTJ4S2JidlNIV09kVGRjMyt2akR5MWZiOU42Ly9lV3ZneXp1WXd5YUpNYTUycE5VVUcwYm4yYyt0WlZsTmVTZHo1SUdXaUlsQW93czh0eGE0dWk4WVdZTmRSTTVLU0pIa2R5dk5xM0pqaC9kTEwrdGovTnA5cDVzTDIrdTAwMzc3Y2NmbnI1elh0K2NmZlh3bmRtZlg3NjV1R3pUNlgrMTNuQXlPNWtMV210QkpHVzUvUFZsQ1dkUVZYVW9xcDg4bm9TZkxhZisvdkVwUFh0OTN1UXdkcFpnbncxVUFXc0VEUUNvT3VqZ0RkcjlnSTFKdmozOTk4QkpCY01XQzBjNGpPN05VWERZQURyS28rTWV1NC8wSG5ZM0hKb3dkTGh5MzJLeG9YUlo4dEZQclFjK01UMG9CdGUzUE1BS29LWjNUb1lPNFRYcXZuSVludFJlNzRXaE1VUTdIQzRoR2hSSVQwOEtTak1IQ3VnSUZEU0szWGNkZGdxdUdlU2o3dU9qTG9tcDJoSWphbDl4U04yRkhCZzBHdFR1RTBFalhjcW5lOHRLaDIzRmdVeXhOM1JyMTY1a3JUVUloQ28wb1BKLzhBUmoxNTRoSXRLYjFycS9PUngrQ1BxWlc4YUZPNzQ5Nm5CbkJEN2dzd2lDb3FXamlZMVJtU2YzVHNwbnJ6Y1ZUMDRmVEpwcWE0czhicTRycUZ4cUxVc2txQzdxak9ZQmtaeUQ2STFEVWNsWHpRQUFJQUJKUkVGVURGS2ZHTlhJUWM5TzJzdXFnbmZLTkFwaldINFYzYjFac2x5ZFMydFBqKzdSTjhCUlhaNVNtb1p0OEVFNW1tazZTYmROWmMzYzEvTnNzZEJYdjNwdUF6c0lVR2o4eHZpdzJUM3g3QzBIdFZmWkIvOFNMNjdrczUvV3IyN1NSOWZiR2tBRG8zS0RTVEU1bmVYQ3hoR0ZxbzJOWnBBWUFTU1ZKTE1oSlBQWDh6eHNtOEpnRzdKRi9mck1iRnlxVlJYVG8wVmFDRlZIeHg4Mk4rVU51UFBUKy9XM0w1b3IxYk9YWHp3NmZYSXQ3NWMzWDhxOWJKNmU3cTVmLzdzblAzb1FsbWRYNnpUQnFNNWRMTGZ0emFWTzN6WEJQN2JuLytINTk3OTZaUjVOL1JOZFhwNXZLTDIxUE9xQUN4elZKZ09NUlNVcUtKcDJ5UDdDQVZmbjRNNDE4SlpwakthTnR5NDlKTG9yM0pZYWgrdTE5dW1sdzJEaHZyZ0VoMmFVTzFNZG91MkpoME9yeUhDMTcvc085VzZGR3R4S05mYzNaeGFOS3FLMzY0RUhqL010SDFKM3BoSXdra0V3VkhoTCtjbVJSeUxUNVY1RmhabnQzdnZWVGZMMlR2Y3g5cmJtaUVRZHNnUDZtaHBRQllGZ2pRQWEwekhoeDhhSS9tK2hWMTBGMUk2TktmMmJrTWdZd3FGazdqZVpxeUNTY2d3eFJnS2tQbDIyVDA4UGk4SzdScTdmZWdTUGdXb2MrMXlSTkZTQ2llSGt3ZnpacTV0bVoyY1BIL3BXL0RiMzlXcFp5UVNOQkJGdzF0Uk5PcC9NSTZNaGlEV1FVVVZhWlE0Y2hYYmFmQmVqSXFWcHFnYVdaNHZOYnZkR2dmTGNPNnBmZjNXWm1MYW14V3hsaVRWYnBEc1ZWRk5MbVVwNStobWRYVDFkWm84V0h6ejR4MFpkVmJsYzA2c0xUOGxwQk9Pa3BJZkY2MXFtUjZlN0wySHk2TW1tTmNadGxHSVR2T0xpb3c4WFJJVmNiUkNEMXBjWDY5YllTZDVkeG83TFhlb3hyaGJ4Mm1RVEtXT0tHbUYrSEhkc1FFUE1PV2FMRklQYjZXSytYalZhdEY5dVAvN24vRS9mZi9HcXpXYVQvKzZkOG0vY244Wi9iNDdNTG45MGFpOWVsVk5jTGVzL1Mrem1ZbXZ6Ly92U3ZyYzQzc255NFlTUEhoMC8vZDhhV2lnZGZmemkrbW9MRTR2VklITmd0NlJpUkJFZzJ3NTZyL0M0SSswc3ljUE1DZnRTSTBVMS9SWFd3TUhqcXowNkIya3M5TmI5OExvL2toQkJlcHlralByd1lWZ1lZREIyM0xGajlQS1Y3dEhtSGZDOUs1THZhMDhKOStTUHV3OXdVR0ZtNmMyS3RJOG5qUWFOM3J6WVg2RzVGNTBqQWhveVpqR2IrRFNsT0JFV0pPM3dyMmlORldNVllsOTRiUXh4MTJPbXBpZHNPa1FRaUpKeWpLWUQybmZrSExJUUl3dHBZQm02bHRGYVZDVUwzRm1adVg4NGpSTDNHMEx1ZUhma25iUEdFQWwxbmRyOVpScEVCS2dMOHlxamFJWWNZci9QWWh6Vzk2b0djSjhxSW1Pc01WMDZXTG9sdmNRWUJ5ZlhvVk1UKzMya1ZURWdZSlVaRUh5UmxzM003TmdYK2ZVM3k0WVgvbmhxUWxrRzAxNnZybHNrZGhZNE1FU1haRVZoV09lMkxDRjE5Y1JKMk5EOVZ6RzdsemV0VGRmZzJvalJSSzRhdFRrL2tNMTFiWDN1Wkx0cnYzK2FpRXVsclNidzVzYlBqMmRwd3J0ZGRDSnozTDM1OXVrOXg4bXhMcmYzUHppNXFLWnpaQXdiVVp6WTNXbkNjWDY4ZnRiY2g5MC9PR2tJMmpwemsvelQ4dmtYRnpZMXJuam5SKy83NWNXTkFrbGRCdDVjVno3ajlkb1VsZzB2VjRzNVJVQm9VcXBMbXlVWW5BWGpZcHJIU0xONnUwUFpWZ1ZVeTVhT1R5Y1A2S3VLdWY2MStFOSs5SWUvL0diVjN2enZQLzNUUC91ci8rVVAvNmR2ZnJGNjRwNjZKNnRaK1RVOFRGYS9LSTRtOC9EOElzd1VQLzNzNnArK2VlZFJWZFh2djNmNVJZVHRlNCsrdUdpQ0lXSTFaTG9MVXQrWllpQTA2TnFPYXdjZ1BsWUdjMmVhS21TbTFiUi8vWStuU2VpakJHT3ViRjhIaGtBSVJudnJKUTYzdWU3a0dCdzl3OG50ZXFzazlkeEZnMzBvU05WWWcyQVVPbnhhWC9FN05ETU1saEdGcnVyYkRjemFnNnQ1WjJycVh3b2kzUmZwU3NRMGFLZjdIaFNqM3JKYWNvOE9ZcVBSZUdsczE0NGdDR0NUTkxXUHlEZ1VkSUpXQVJERUdHRldzRElvdHpyV25CNDBOQjdZcjBWQjhGYWRveUtTN2xFNUFIdkhHaXBwaitWQjZYMm1oOVE1L0kySEpONmg1WGJPR1pXM2hSM0dtVjhPbTM3dm9EYnVMTlc0bTNER0s3dGhNa1picUNCcHZDc21qL1Q4emJKU2YzK2VhVjFIektpOFdiRzNUVGQxZ0hNV1lnMWgxWHJHSkxFblZBZUQxWVhqYlROUHZRdHBFaXRLTlF2ckYyZHhOcDlYZU84VFdsNkhFbkQxY2xNRTNhem05OHpaMGNPSDYvSUcxbjlFOC9XNjNNclI2WVB3NVQrVTdVZnBmSkU2V2Q1Ylg5NjhORDdibFZjMzFPYjQxZW5jeFUyVFNBaVZPSktDeFlzMHZGNjhmNytTdG01bXArbDUyM0FMMGxZdDJWODNadXJGSEZYMUxrMW5DRHRnWVdNcEVocExYSlBHTXRwa3ZqR09LVjN3elhxWHdWbHdDMjF2cEoxUGYzeTFhaHh0NnA5cit1a2Z4K3ViZGZPWG4vNFAvL1NWLzZSNnVrTkx5eXhHMzY2bjc1elppOVF5emxZSk5GODIwd2YyNWVwejkzVHp4Myt4K2MrVDJYSzlxZ0dJdWdYbUdCVlVJR0JTTkM3SmRsMklGeFZVUlFtVFdwQ003Qmt5L2JiU0RIYllnMEh6RUZlanQ5bDFlcmZ5ZnVUVWpjaXJUdVBzRXNHa0pMMWVMTHBudXgxUVl2R3d2V0d2Tyt2ZGRQcmhYSXdDZmIyd2NPaDFYM3piZ0x4SE5YY3ZJUlkyZmRiZjJTelA4OFRPQjV3YmpDK09EdXd1Z2lBQXlMMVBlL2hXR2J0bGd3cDFpK3l4ZythZ0toV3BkNmhTN3pERHNUS0NsSHJWUzRiVjlPaHVQSmcrOURjc21jYU5YRS9xLzhFRExGMEJhRGQxOXpzcGZWdXlVTy8rdm1FSk9iTGxFVUlOTXN1Tit0bGlkdkg4YkJOOGZweGhVOWJnckRSTm94WVlFSVdWVkZtNTV2WW1ueGE1bDdLQzFoMU5OTDlSaVR1VXlsa0NaK1AxR2hvMWtPUXBYeitEMllQSFpyM2RWTHRnd1JMejJ1bXJ4VFN6cURVbnFjRkd0VDEzK1UvZnU5bXROYXlxUE81K2ZySEV0SmhMTnJrWEJXSm9ySTFuZFl4V3VhckpPUW5RUmljYUwvUGl3ZU1wZmxNMTF4VExpazdtdTNON2N2Ky92U25EMlhlbG44VFVxMmt3c1JLQ1Nhd0trVGNvQWxJM0ZsSTBwS0RlWTl5RXVDa1JtSEFUNisyUDNSdzAxQ3huTjl2R25mNWtQZjNxcjMvMUYzLytkNi9NMGFhZDBPNStSYlBWTmIrVGFkc1NRVEsxY2ZOMCtlZ0U1YnpobS9uRm4zNVNlemhmcDYzMVJvVzFXM3RpZHlsRFZUWmduTTJrZ2c3RHhvcVJGVFJ2bGNqeVFhaWw2K0t4aDdCSzNYT2VEeUNHZll6dWxxL3k0SGE4WDJVRGpyKy9leFE2ajMwZldPdlh4ZjN2b0lOcXNpNTExQmNTamwxTWV3SWR3bUhUai9iclhSRVZsaFp1aXk1M3FKVDdlRDhpcVNpWlRrZWxMSm5NSnBuRDVORGoxRUh0VkVUVXFtRFBKYURSR1RhRUdoQVVaVUFONE5BSGRTZ1hJWEhYVTc3dmtUaGdzdmVaUUJsZlNmMXdQTnBaZnB2TTA4L2VvaUtBUDR3TEsreXBJWHR4Ri8rTGovQ3dneDR1Qzh5aXNWNEhPRm9rd2FaWjllYXNGanRkbU5qR2dFU3RpTXNpU0pZWURvR0lCVlNVaGN2SVpKQlMxT2JhV0R4eFhLbHN0eGtrenFmbkwxUHJjdGlzVmtsaDhmVjM4OVBqbzZQWjZZZmZmVGU3akhPek1rZmJtK0xSUEd6MUh6TVgyR2ZlYk9KMG1rK2JhMm91MjlSRWpubmhkRmRUbGtCVE53RzNYb1A0eElscXk5N2RSRnZ2TEpyVG0yZjA2SHJHdXRsZ1lXUHpPRWZBOXVYclZRdWU4bmZ2WjJDWFQ4OURvNGFiMWtwQzBZQlBqRlNzR3FxbVBDWXkzRUtBQjlNck9jbVhOMzFwNmMxOGtVWjduRlhGdHRxSk1jZXZmdkt2djM1MU1XOW5GSzZxazJuSm1UT3M4YjZLY0F3OGFUUW51OU9IUDcxNXVzcktmMmpzZzJkTkpKdDVEekVvbUM3eTFZbjRLRWlBMWhyTUxLc2FRV0RTR0VVeFNacnhlcVQ3aVB5bzk5TEIwdU0yNWJ1VFFmQjJhK2Y0bDA1d0dHbUFRd0lOSUJyczJuaDY0bnRmV0RsVXBJd2tqdjBPdExmcUQrZnRDQTdSUTRnUHFMQnlGR0ZtL2lFZXF3OHZESmZKVGhGbEpGUkJ5OFlhbHlSMjZvczhkVDJQUmxVSlZFVkF0R3NkWkl0NElDRU5RclgyZUpMdVZkV3Rva2JVeUo0dDFzR0hGQVkwN3I1VDdrQ3lWZGFCVk5ZZmtpT3M3amZ2bWthNHF6QndGSDJieXRSOXprUWRTNkV2YjNqYnYrVFdyOXJ1VmlIN0V4aEFPTVJzVW5ETUovUHJxeTFMdWppS01ZTHh3QkliTm1EY25MUUowUUtTTldTUS9hNWFzc3dtUHJWdnprTXVxVUdqaExpR0pNVXNtMTV6ZW55U1g1VXRUZDk5ZjN0MXM3M0o3UFJrL3Y1Ti9UemNtelkzYm5IeThINjZ1anF6d0NaTGlWeU9OeVU3Z3RnMmdhdEhQa25pWnQwRVlGWTNMVUprbTJYQWlCRXdCTWRBWElMUFdyZlEranVKazhuY050dGczdXkyT0hmWFp6ZVRYRTdmdjUvS2RuUHg1aHEwYnRNUXZYTWVSUkdNd2JyaEVOcm1xRFhHUzR3Mkw1TEt4SHRyU0F0ZlZkWExocUp5dFhWK21oNWorZkxvc3hmL3h6VGR1bXp5M2tmZlB6MjdtcVpPODRkbzJDVEFBU09yelhOZ2RsQzh2NnFNRHcrckwzWUpSUTRpa1pFNmpscVBjZEZ1MlF0QUxtbTRmL3NqTjFFQWpaTjk0UVljVm5UL0VOQzZ4d1hEQVFQZ2JmKy9VVGc2akRyQkFIa3doaFNWaUE2MlZrTlEveURCdWcvUzl2dGl2T3VaSERkbTNmOFNadWJJeXBGeEpJbjhZRDhOQjlYQWdLb1EyYnBvWEpvVmVUb2xheTBTY3Y4MUdVU1ZWUTFFa1JpaTdTT1Z2WFM3L3hhSEw5Q0pYMzFLRDZFTExuZEhtSWpnMklWQ0hhaEF4cGw0SDF0VUhlbjZuU2RzZExDOTlRUWVMOWFxcWhJbHRoSDJCY2NISjdVT2x5cjlEU2Z3K0FRZmpDa0dCMU5Obnk2eDJpZzRmekxWRFdmVFpMMEt5cTR3ZFlqR3FMQ3IxelVibjZiY0JDSENFS09nTS9pZ0ZRUmViYkpqOGxseDhxUnVOU0w1ZVVBWHJuYiszbWEzaWNmdWFCR0Q0T0xldzEzY05IR2pKdzhYOTU1KzA5eWZYVC84dlNjTkY2NWVXeFRDT21BTzRJK05QYS9GcFpNVXE3YTgzbTAzcllMeGljdW1qWWliRjJGYmdYV3B0R3g4N2lVaXJoSm82dVQrdzZNMHA5M1o1YzMzRnVuNHlaTjN2N2czdyttc1B2dmJ0Y2xoc2x0TkxNYXFSWjBhYWFJR3pKRURLOElaSlpORUJPQTZtK2ZyOUQ3dmd2Zk90ejVCbkpocTV6TmIxUTc4NnJ0cnkyVlEyaGFQRi9icm5YTzhVZEpkM29Ic1RKa1M3aHJHMWpvUUFYM3cwZVAweStkbDFrWVVRSUxhV093OVJUcFlJcEdKTWhZa1ZsUkNEaXphcUZFNWlQME5RZnJocVJEYzY4QjRvUHZxN1I3cTJ4VktCMjJCaDFkWEpDSWVjcjJESTdNN2hickVFeDUyUUNBQzdIVmxIUjZYVzcyaGgxMWxDc0F4YWhjYkZBTjY5OVdpdWwrQ0RlallEbnlwSm5OcGtXZFprY200UE90WllOMHlESWpieUtGcHJlM2JJeEFVQk1kMzBENlJxT1BPRGdlVVRyZWFBaGxlbFlQM2UzQmJJaUN5c094N1JBRmwwSDkvME0zOTloTjRtSUVqaHpicVd4N2cwZGtqcEdQNCtJNGU5Y01SdU5jRWpEMTBzTEVrNldrV1FqYTNONit2Z3MybnRLb0pZd1JMRU9zYUFHeG9tMGpHVUJ0cUVXc2h6NmRwZWJuaGhlZkNZeEtoRlpKbzNEeGcySzR5bU5UTjVhWDZ3dVVUdXhFMDJTUXJxbGVycnovKzZOTi9mREhOanU3TmRQWHRWUlB6MUVaR2pZK2NiSE1QMjBrMGt6VEwwMUN1Z0JYcUVuM2hZUnZTU1VLVGVhUXpTREpub3dLWlJMaXFKcHVXcy9scy92NTIzY1EyVkxPNVhaZWJoL2MvTjgzbDhvdXIxUy9MeFlkSEFPdFpvaEJCTVJKSVhWa0tFVTJNeGw2NkNUYU1TUnVEZ2lMTWZIQVV2VEJVRWFZcGJPMThWZ1p5WjgreW95dDd1blBWOStma2YrSldxRTFac1ZwakVNalp6T2x1MVVhdFpqYlFGS3ZYang3K2hLdHk0MFRSSU1UV0c0TTlZS25mNWhwQk5Fa2R1NlV2QVVjV0xCVzdheVR1bXhnSWU3bG1IOTdIZlMwWkRsQlQ3UXdYdDEvbFAranIxWEcyUmtBeVFzUG9PSWI5T2xUT29QUDJUd1BkOGdDaERrcXczdkpBNzA5VlZnWGdFRVY0L0RrOGJHUkEwQkVtMTE5NCsrL2JPQXV6NHl3dFV1TVNYdzUybFA2aUxTck1JaHFhdW8xTldWc2FML1ZkY0dnL0k0RDBLMTRhTzFKRzhBV29Jb2dvY1Q4aDkrZXFqdHJXd09tNHhiK0FnOUR3dUhyQXQyeWh4K1p0RUk1UjNxWVREeWFhQWVzSCs3SmtBTzIrczM1WUdmYnBnNmVheU5yaGJoUkJZbEJLY2lObU9ndXZYMTV6U2xPNDV0UkxnMm11QWdaSXVRNk5HSXRnU1VOQVE5Y1pwNjNNY29pQlBkYVhFRzJPTFlKc2dDanV3azR5clVNK1Q3RFp0TFlveUVGeit0SHV6V1k3K2Z5eHhITDkvMUYrL25YMjJSWWhWR3JONXNQVGNyVzB3cFdabU8wYkFUU1QrejQyWVZlcFJKdk1qL0Q2NVVXNzNHaW1ocU13dUJUaXVsN3B5ZS8vd1dQZWZWMnZseHN6L1dRaTI4WDh3L3MyYnE4dUxsWTgrUmMzTkZWT0h6Q0xVTG80Mm9LUmxnbnJOSE14TkJHUnBHd2NhUTVMT3pkYnR0Tk10azBFSzNYVXhkRzdsMmQ1bm9oNTc4bFhMNC9sd3AwZkhhY2x0UFZDU05mWHdkLzRJblhXMjhMRjNZeXIzZnJHTEFyRTQvSmxWVCtZSGYwRGdKQkFpQWFNQTBJT1hhSVZCSXdpQU5sQnBER3N3b3lONlU2U2tkTThNSVQ3NDAvdTlncU9OK01PTnp6RTYrSE9BenpHRnZDd1A3UVBGcEVBUU5jaUpEb3l4UThFbVgxSVJrRU9HTk5JbzR4MFFNdFJCWWdLb0RGRUZSbW00Z01SUnZFdGEranVBU1dUa0Q5OUtGbG1WRUVzWUMrU0Q3QTNVUlhSWFYwMWJiMnJyRlVsaXl5TmdqRUdaU0RqRzlVTzZLcXNTdEIxZllNQmhVN2NJdWtsYlJaRml4aTczQkxHWGl3M2FycXRndlROUS8zdDJ4Q0NLQkdMOUV0MU1uWVB1bEhXRHNNUVFoVFFvQ3pTYjdWRkRBRFo0VVB0QjJtSEd1bUhXUVhzWkF0VjIxMyttWVJBY1NpT1pUSENpb1kwYWRRNk1aalUyM0RxNGk3YVFIT3RDcWcyM25NVFRhc21UV0FMaU1RTUJEc2c2NTJKeXpLWE1KL3h1b1pvdk9ORUsrTjB4ekVxMlVndE9uL1B4THBNdmNZV0tkazF6VGV6ajM3LzlldUxlZjd5aWxabFEvYkhUaTI3NDNaZHF6L2ZKZExHTkM0OE5Jbkd4dWRGQWkwVjZSWXlYOTZZYzlieU1uM3dLZkZ1YTNPWlQxWXZFcHIvNklQaTBZY1A0OU52L3oyNFlqWXBraWVxYWxLVFZFKy9vZGxpTmsrZnY0YUpMdHZFcWRiWDJ5STdYUlJhTXliT3BzVjh2Yk0xUytiamFxbzNteE9rNlRiaDBwZzhORzNMVkovRCszYXFXM1d3ZEF1SXlhT0cvTTNhekpQclNJbk5UcmQxcmxWYlRHT1ZWcXlHM2ZHc0tybEtEWi8rczdQLzlQaTk5WnZyYlVnc2s3TmhsaTQxclh3SWFralZnRVIxQkEvQ3JyWUNRQXFPUXZDQXF1Z3hEUDU4MDU4VzNHZk9hTlE2OWpIQlFSNUVWT21UUXNDOWxZK293eS8yYTZ1T0l3NEVUSVlRbWMwUUcwUUxFSWNYZytuMFpOUlJXekg5eFZBQVJNaWFpQU14cTNzaE1TcDE5Ylk5MTFxMUl6aWo2VS9HdlpLcTJIWFBxNGk2UVExRkFsR0RDNXRrUlpIWnhGcEhFaHZmVVhleE5vQXFvaWdLeUdWZE5WWExiUlBzb01JZ0ROejNJZVhVQ2JDTTJxdmd2Umpiajh5eVh4aG92OUZHT0N3ZXdyMU1nd2ZkNTRldFlnTTUvOUFaQmVPa0FWM1FxQVBPRTNYbDNtT1laRThZUmhxZDZJZk9jUjJVc2o3VENJY1JVa0JsQ1lZUlRCU2t4RTBDNjlIRDVQcU5XbWVsaldKN3AzVExTc2Fxcm9HTXM0YUtwbTdhbURsck1ZcEtjelJaWDlZWnFWVm1OV1M0ODYzRlRBU1puSVZxclM3UjlTYURYYXRmUC91UnMxTTJaVTF4VjBmTUo0MmJKOU0wVU9DSVRVZ21HWkRMRm9UWGJic0dRcmhBUlluc1hyRExFNU5tUjRtMlB0dWRwM1BpZEhwMDJzem4vTVdyeTkxLzQwMnppZUplbUhTVzZ1dWRySXd2NXBQc3hma0tscHVLNml3TmFwUEU3V3B5dWJadGFHcW41RTJzdFRIV241MW1zTnZZTWt1ZEJyWnBGR0tXQ0wrWUhoVkcyeFlVRENiR3Z1dTJLTDRXMERhQ09BcWhXaSt6Qko4QlFsMkI4MFFZUStMKzZkRlBOLy9oUCthWkkyNkFMQVVyT0pkSVlweUFxakowMXl2TXA0MGFFRlprTFEzWUxsTVBNR2I1RHNvbmg5a1g5KzJldDdqUFhZNm5wMjZNa2Q5eGhUeE9XWWhvZXhEV1dLKzdId1U3dW14ZjRjRjNLSFU2OUNqdVpaMzluYklUZi91OHJ4elNxdzVTOHFBb1BjcFZGV3BFQTRBZ0VzSGwwNnh3V1pZNjA2RmxGU2wwVzFiR0xzYW5sUVNOb1E0eGRyWVEyL3RkdEo5dGdYUmtaSFdwaXo2a2dEMjVnM28vM0tEbkNvQ0NDS2lvSWhscmU2SlFqKzRhYUJ4d3QwOENEM0pQdCtYdC9yb0VJckg3c3dvRG1ZN2VES0Q5MmxzUFNzeHcrTnM2K1BYaDQ1TUI4ZGNoQzVSN3htM2lFbThJa0RpeVMzd2lXM3YvdmZSWlhZUEhLRkZGa0FoVVdrWmpqZXFEdGc1dHpUSGhxSWxGV2hQWlpINTY1SEszaTk2elZZMGNrVlZGZ0VPWXFLaEsxTXpQSWxQaXQ3YmVKWStlSkgrN3hJZEZreEFsazkzVjlUWE85R1o3YjM2VWxpeEJhSHBVQ1Z1VGVKZnNWcHVnaHB5amV0MkdGa1V6YnpCK01TMEkwdWxINjUwNG01aXpkKzMyL0x0enlORlk5aWFoRnBxZE13ZzNJV3h1a3NSVTY1akc3VW9OZVpNWVN3V3FDRXVFcUZYbVRTSVVXM1VvN2hKQkM3ZVZGS1hCelBYWFEyM2JFSlZaQ0ZnUjBkZ1ZmaERmYkhMbUFNWjQyaEJYVld5b2JDTnlFM0JTWktiUkpqbjkrOFliazEzZXo3WkFYTGQ1WVZwc0cxZWhsOGphYTdJcU90VmxUZG9TZytVZHBSNUpCUFZnQ3Y2Qmp0dmZlK0h1QXp3Q1hFY0M5SWhPR3FiZkFTSk1ZUHFjK1VCMkgwNXlZOGdnNmlnazA1ZytHak55UUlPeFNGSDdycEZPZjFMb3hSMFdrZEh6dk0vTDlkc3FHUTFGQ05TZE5LQmtmVEUvTHJ4UEU2c3NFYnVRci9SWU9pT01xREhzUWh1aXNFQmtaaEd3MkVjaSs4dDhMMkxUaUlDMFpFeS9JMURSWHNVZWdSbURGM1JvVlNWcmNNUXl5d0NiSGVacXdUNXdvbWJZUmFEZTJUVDF1MGNoVUk0cXhCMlljcVJaRGZQTjJEaDhrRDI1OVlvWW1YNHdvR01CUUZINlMxZXRSQUNFTEJ3RlVjcGxSbkx4L0tJa2c1RkZJemxFSkJVdzFxRHFNa0s2bUhxc1FWV0Y5UVRhYUtmei9LcU5QamNzSG93S2MvQ2dBc0pjay9NMlZ2WFdaN2x6emowS2x5V0pXZnlyNzE1V2RZMXVhZFBKL0xTVU1vUmRsaGgyVnJQQ245eTd4MjFabGlzdTdEUmxFVGx4dWxsdUsrZHEzdXhDSkx6SzB2VjE4aUJia2FXSHM2dUh1MDB0Sm0rZUdaZE9DOWdTTkc5MitmdVBIMjVmZkwwa2twbEtTUk5lKzdRZzM1SU5zenlVTFJqU3dORVlZbWNBdEpYcHl2czJ6V1BWdE1wcU1MS0NRWUJUSzFza2EwSU1RWUMwREthcGEvU1ZNb0FoNDlCUUVwcDIwdFFtVFZncVFzT3F1cmhhenRGTTMwc1hyZEhsODZ2dHUxRFRybDBvR1dSQU5GMW5DalRwWk5jYVJ0ZVNEMVZVQUhUYU5ZWU1rUndjN1g1dzhKKzdjVHlGVzRJaEhVZy9oeTBnK3hoaTk0VEtHQTd2QTI1a0RPcWVnSU43REh0M01CZ1lqU1Q5ZDZiajhkOHJuNUZaT2srd3dWdWNjdTNmTC8xU0RCSFFkZjNHbEdhejJTVFBuYkhXSWl0VEg2bnNycEtpSENNQU4wMGRtc0JJSm5hT0xla0NRVUxhTnk3MFAvSXlQS1JnVENjUVJWRVZBYlc5aTJsd213K3VsS0ZPT3dGUjRYNW5MVHFZendGMTZEWTVnQTkwRmhMUnQ2MlhVVGwyUk5pT243Mm56L2NHTGR5L1JmWWJpa09ab0xzM0lQWmRydjBHb251cGlEV0dESFhRMlJSY0h0S2orLzdWNVZhSklyT29KSVJnVk5DUUFlYVlKTW54Ty9lbkxpQW90eUVHcm1xVDFHMTUzcEEwa0V5c1RYbytOeW9pN3NCUHM4eTU1VExlLy9oZVdCdDY4RTVUdjk3OXNkVFhMVnA1MEFvV0NZTU40b3VVdHl2MG1hZlkxaHhadUcwYUpFOGFZeXRBaTFscy9IcFpsaUhxWEVQKzN2dWJ6V3QzNHBvZFZYK3pDY1VpYlZZcHFYSU1wZE42dFF2TDdKN1A4OHA0c05QZDZ6cFBQS3VTTVFCTGlTRFdrcUJSYlVHOWd4aWp5bWIyb2Z0dUk2cWhJY0R1aG9ZSVNyRUVteGFta1JCalFLWGo1cnViUEF1QUJLU3NxV0ptR3k0cklhbGRuaitybzdWTzI4MnhYbkI3blh0clVwbzBkVVFXbTdTVk5hUmtnTHFwVUxWMlpNZ2dHQ1FqSk53T3JNZmUxQ3Y5dTlyQmdROXkzeXo5VmgvZitLT3BkL0RNM1pIY1Q3MGo1bEwzRnNoK0c2Mmkwak00Q0g0RHErbVdWYmMvVFZoVWxUbDJscjEreWRYL1RCeVdrdlhsQzRLQUtnSXVUWDJSejZlcEpVS0FnQ3hLUFJxUGhSVlFOY2JBb1drYWtCQ1J5QUpFQmhheGhLZ2R2Qm1HMm04U0VFQkZHY0lSMm4xdklnb3FTRjIvU1g5L0lSaWFlMVdSckpBcVIwUkJCTmFCUUhUWVJUU3dnYlRqcnlNY1ZPYU02bndIb3haUm8zZnkyZEliNW9iUHJIK002ZTRKdkY5VGtuYmo4NEZqUlFXc05kajlhZG9nV2pjRzV5ZTVpQmVIc1JaaDQwR1ZyQnBVRkltQjQrcnFtU2ZJRmNuNnhHYXNTZTRpcDljcjR0SXNkcGtqcTBnZHhVc3hDOXlVQ2FVUEptMHVOZGdHRnZmYUZ6ZlYvN29wN1d4aG9XNENjZG0wZFZOQk1mTUNMR3cyNjljcms2UU9ZK3lkU3NETWJKeEJJQWh0VlB6Mm9Xd2UvZjc4K3BjUmVPSmVmUU51Y1pvR29VZUx0SzVyMXJoYTFvbmRmditWYlRaQkNkdVRFL082clRhVHRtcnJXakM5dm5MVGlWYk9VR3lqd0JGQ2JCQXhWT2V1amJYMUdGQlJoSVJGdTUwc0tsY0JSQWxZbEo3ckJLNjJpNjQ4VE1TSzBPVG9lTGMreHZLNnR0TkhUYVBLUWF4OXlZdkpjdjFobG5weS9wM1BtMmZQR212aVRJTVE5SlpLSmRVR3lJQ2FDQnJCbVdEQUpDbzhIaUJEY1FqdVVUWUhaYUMza2EzZElURkVFUW14aDA3dFhWUGRJVE4yWFE0NWx5NzQwOC9XMnJkazYxMHY5VkRSb25vSVpvSzkzWUZacEZ0ZEFYYUE0MUZ4SGtHVHZSbXlpK2tqWWtTYlR1YlRMSGVKNjlwV0JSalFhRS9RTXFDaXdyS1IwSlJWRzlMdXhxeEVCaFVVN1lGaU9rd1hDdjBiWUJDcVNGUzVEeUlMYVY5UjByMjkraDA4aE1pZDUwT1pZNGdpRWFQSVdHVGVseW9PQVAxdTZ6WDQyUFV3V0RXeWFUdDFhR0R1RFA5TlBXYmFEUHJjMkVGMU80dzVSRTVnNzMwZXBBTlNVTmg2VGh3WmRDTGdUZFBzNHU1R0wxZDFodHkwSUF3S0ROMDhwS0lzQmtXYUdxRG1xRDZmSkRjN09EN0p2SmMwYXlLbHJqVUVnZ1lqRVpHYTZKVTVxSE1uYVNKMWRET3VxM050ZHRYZnhSYlN6SEJCMmRTMmpIbFc0UHorQkZkTk5NaTh5OUFvUzJoelVXWkhlS3BOZ3c3bGdsSk9SSUhtdXZxcWZwTC9Udlg5V2JKOCtlSTRLV0xWSnNXOFFFRHJYYU9hekNaVWJ5M1lWSVJnNXg1bWIzWXh0aFUyamFBVjFjWnFQWE9HUXcxbVczakxvT3kzWi83SXE3WFFCalpkY0FPQnhBTVJRVnQ3RWJSUm9YbGpQNWcybFd2N213K1Q4MGxoWkNjZ3UxVUZzd29qU0lqZjZ6MFhRcHBBTVdrMlBEMzY1L0d6TDc2b0U0WnF5OUlmZ1FxQUdCVk03QjVnbTVrd0FXTkJoSG93TUpBZStxMjZCMVRmVW9xbmUyYldtUGNmK3FiN3M0TDZTakRxSzBXMTJ4cnJRS2JFdmdSSkZPNzJLeW1ZL1laR0JRZjdFOEFCUUtPYmZWV2tFMUlRQVZXR1dLSWVTRXlLSFRrSGlTajEyV3cyelYxQ0JJQmtrSUI3WkZSWG5RS0kzTmJ0Q3FYYWJLT2lkUmF3aS9XcUF0ckIzcUg3WFlFcXFuUVBsbmJwU0RxQVMrdWVBVDJBMUFFQlloUkZRNEFxRVFGWlVDQ0M0TEJOSEZobUJ3Z1VQWUFVL1lBTmRNc3plaUJDOTJ4N05RZHZSTkI5aE95MnB3dWgyOFVjR0dyNkhFcVJGRVhxbmZFaFlHSkQvYXZkQk9vV1FDQUV0bWJnYitPQUN3aGtDSUNvSWw4Y25SNFgzN2ZyRmZwaXNiS0ZjSm81UW1YcG05UU1JSzZ6RkNLbW1YVjVpblhaYmxvSnh4L2R2M3BuL2ZybHFwUjRybVNSOHNsaXNaaE5mTDFPMUdRWktkVG9mRW9hcndUSkdaSUxJOUhZM043WFdBZG10c3Y0dTNMVFpwUDNpL1hya1AzSm1UUzd4TXp2bTdLdXNrSTNhL2NrOVZySFl4Rm5HbkRUeS9QVFlyWWxUTVZYQUFBZ0FFbEVRVlRGcFpLbnhOanorY3hoUUJjdGdqRFJ5aGZPaGRCQ1JwVFVvUUNSc25aRnlnS0dxQXVOSUNMVkFJWklJZm54OHB2cHAvS0MrbkplU0t4b0ZEMjZDU2VmTnQrOVdJWld5VmhEUzc5ZzY1ZnEwOTE1T1Z2ODFlZC84SDcrcHRBM3BtMk1nbmF0ZW9aSUJFa0Z3Q3BRaWpFVGt5aHJaeDJFVzB6blVVY1k3WCszR2hBNkp2dFFZdFk3bUhyVFJYZmE3eG52ZTAxMmtGeHdpQm5Da0t1anZwUGs5dGZwZTNqM0paejc1MEtrbDQvR1FMT0NtTDJyWktCU1lrL3FRelRXM0VzbTA5d2JOTVpTTiswcVlHUWxSUUFSYVFDazNXMnFZS0RhYnBrbTFqb1ZGZFlPOFc1UldEaTJvVHVsQ0VtRm1mc1JsUWdqQW9KRWxzNEFvdmFBNmRmNUdZMEtXdU5SMEtBYUptT01GV0JPMmlZRUlPRklCa0dzQlJZZzZzWUE2VUtZckdKc3R6WTRuRjBSVVZUSnFFYmJ2MXpFV0lORVp2anJqTVlRR3NSSXB1OFQ3YkgvL1RSc0lUSUlnbTFZRFFCbnNUVUVoSXFFa2p4KzV5UnhKaTBTME9YR1oyaVRkMG8ybDh1cWFUV0tNMjA1SlNRaWliWUp6bXRnSzJJY2hDYis1TW1rNEp2WHkxYWpwcTdtRUJnNEVEYXRNUkk1cHFrME1NbmZpUkZjNGduYWMrSHladnVhZkw2WVQ0dUg2K09QeTAwd2lkMjlyZ3NmRTZRMFUxWStNV1ZsblZwcG1wMzFKZ3R0eTBtU01BbFVHOEdHc3FSZDErUlZOelpKOEdMeFI0Lys4bWRRUE9CMDdqV2w3UzQ2YmN6Y2ZuU1MyTzkvMVN5MkpSWVROUEpZUWp4T2J4Nm1oYTAzTlJ5TEh1WGxLaVFNbEdIYnV1VzZPSm8wTzkxQm92Y0xkNWtZVVlycm1YSENFU2xEVkZFRVVtVkU1TWhVaERjbm4zeGpoQ01icSt3bnVxbDBWN1hsZGVMZUtWYWJJQUtXbTFmVmduaEJOOHVkT2JYTjhhOGYvN1I2aGQ5WEsxeXNkcW1ycllUR3VGUlF1WTBkM2tFcndNdHNab1NvVTA2SkRBOGU0cjVOMS9VRnVOb1B3Z1BNemc3ZFJmM2g0cnVmR3dJUVJTSWFMRU8rUHdVRERBOXkzLzdWSHk2TSs1VXI5QUg5ZzNnQ0NnSlo3RHFhRkFBQ2RoYkVvQ0xNTXZCRjFIVTNTQTFJVmlXcVdwTEFaSUkzekFUY0pIbGlreXhkSkZsaXJYYzFNZ09DeE41UzRzcmdFK0M0TW5uMWZHTVVhNGdTeFlBRVJRVW9ZMVN5SEczc29HNWpCS3FEWHZWcDVxNXFXT0F3VFhBQUt1bm5TZTN4a01MYWtld1JGU0loSWhsbTZRMWFYWXBDQ1ZEMkt1N2JYWlFqSTFjQnBYK0FHYkNqVSt1NDlXTmkwanZ4TEwwYmVlQitFbWk4QjFHTkxqTDUyWHMvY2dTVVR5aUs3cTQ0aUwzZk1yVG11Q2cyRjlkYjByQUxabUl4dG0xUWpaR3BtU2JiNit6amp6N1BibDZjWGI2NE9XMEFZNlYrVWdkRmFCcXdIa0VFcHNiUjFLVkpHd1dkZDdRcnp5NjNEYlBUV0xaTFo3QklZUEo0WWgrNjlucHJyRnBSaEtBbUpDZ2FvN29ZZ29EQlFoUzRyTkI0bnlSVkV6T08ybFE3dlFZd1BzK1Q5YmNmZnY0L2YvdlhmLzk3aTNrYU9NK1hMb2VhVCs4ZlhmekhDNS9SOUdta3pDRG8xc1RXSmsxVVNpYUw0MWJLU01TVStjWTZZMndidHBRbWtkRTFHbGxpNHg4WkpSL2FXRGx2blVnWHp3dFJzaUducnVvU3M3bFpyRGJSZTYxOFUyMnBDZUFWdzZaRVVEY3gwRlRNWkNHSU5SVkRZTEgrOWZ0ZlBEMU52dHY1UmR3RXd6dGZDVTBwTENjR3U2c05HV0tOT3JXR3dLcEc2dGpwZzN4cVlBeng2U2dYN2NucHNLK1FIU1B6MHV1S09GSW1hUnl0OXlzdEFPak1ZRU9hcUcvTTJtZG5iK1hpVmZ2T3J2MFVyakNPbURxV0o0cnUremxWQWJ3eVdDT1NHWTdSRU16eklrMnlJdlhlV1VDSnREY1FpN0JvNmFaWWJzU2RWRzI1MnhJNEFHWUJGT0VoZ2lqTUxMWVZWaERzSTlSZC9oYXc4NnYwLzc3UUR4R0gxV3NvMEt1dktpSW9BaW9pb0dJQVVhMGlxVGpmQm01c0VJVU9PZEluLzZsTGJkN3hLUStTdW5Zb2dyRW5xdE8xZ0ZYSmdDRWRXYjhxZWlkbStKWkdDeDBHb01aakd5MnFhelYvK09ISGp3S2dLOUs2L3ZMRjgwMjlZL1B1dlNkSCtTdy9QZFYyZTNQeDdNM1RhVTRjeERBYUkxRU5WTEg0OE9QUG42ek8vK0huVFlKSE84b0tCd0lXV0swUkRvYVFXWEFKaU00WlFnRnlCbFFhOFlrQUpvaFNOYzVKNFlLWkg4UGEyY0l4bWRNWVk2d0JieHFiK2xZb0tBTkxBRVFFRHBFMUxSTDB5QmpWNW5NZ0Y1dXFxa1BsWDN6LzNXZUwzN2tYcDBtclNhclR5ODNrMFF3dnZyMVpyWGVUQnlZVmsyQmt5a0UxWWd5WDIxM3VJTVJKQ2xGY0hsY0NhSVZBakxVYTFGZ0VhU3VqRlZOeUpCRWljeVJESGE2TU9LQUNHZ1JTam1BZE55YjM1VzZYNXRxMkRTbmdob2hiVEx3cVdZdlNUTWduaE5hakNvYXFuaDYzVkY3WTNXc3hzeU05cy9lZ3JrUUFQU05aMXdJU0dRQ09MQ29pU0dJNnRER2EvcGJhVldRZWRnY04rVzRZS3NhR2V0K2hRMGdQd3d4bUxCWWNuWXY3eGwvcUxKRXdHaGFHVGMxQjduaUFldldtM0wzOVdWUkVsQStDTTJOenQrb2VXQjBpT2xKcEtMYmdjenRQOGpUSnNoUXQwV2l6VkZDanJLSUlhVmhGVG82UDAvTmxLYlUxYUV4a0pjczl6NVZFT0VZUnk4emEwU0s3WjRmN1VaTDdnQU1wbzJKM2t2VWlzS0oydmhCRVJRRVI2VjBnckQxaEdoRU1pWFV1eENTMGtUa3FJYUF4UFVDVER2ZjY0L083NTFxUHBEUGNBd2VWaFFYVWpMUmZ2YzNTdWhOYkdPcVJoN21ITURiaVhXUXEzdnYweVdRcnpwTnNWdGVySFp1RUF6NS9mZmJwaC9jNVBLK1dOdzNhVTVmYXNObzJrZ1lCUkpXc2JMSUpmZjNMdjlHYmFtNERONGxOTXpMUU5JRk42b2k5Vnc1b25VU3VCRFFuNjRLMkxWcDNOR2xhYnF3bGsweHlUbUs5REcvRW1Na2lVekNYeGhERXVpclpUeDJqcndFTktFSmxMTVFRT05aYlk2MDFMVUJFNDcxUGkxaHRkODBtMCtYZkw1NzgrQXEzMS9ELzAvVWUzWklsVjNibVVXWlh1SGdpWkFwa1FpUlFZQW1TUmRhcUFRZnNudlUvNkQvYnZYcEk5dW9CbTZ0QVZsY0JLTWpJekpCUHVMakN6TTQ1UGJqM3Vuc0VVRG5LV0MvRWUrNXUxOHpPM3Z2YlQrMVlQM2xHNVRXSWhaODFkN1lxVkxMbDVNS0VRYUtVYTZGKzBLSEhiWTB4UkdyVmkzQUZUV3dhSEp5YzBkeEsrV09TNndhNGFUU2JlOVpNRXJpSnVqT2pFQUlXdHJGNGMzWFhWcEJLWmdPMjRpUmpKR0VLNGV2SGczTUl4WUFJa2J3ZWtYUzM3Mjc2Si9XdlA3UlA5MXdkNnVmRHV6VTJOcVpxY3pDT2lZMEF6WXM2NUp3TXdIUnBRMW1LOXhZWjRhTlF3MUpJTkMvRE9aRi8zdmFXc2NzSnhRUWZSMDRYdkN5ZFV1aTRPTGxtOHMvVWhYU0NadUJsOUh4MkwwNnNLN3Q4ckp6K0ZUemhNbWNGQncrQjIrYkpWYXhDRUJaQm1KVVlYS0t2cm1idVVEM3VWMTkrOVdJek5GVVBoUU1KSVJCamNVTlRCekZWQXdhWnBCaTZuS2w5WE5mdGNKcUNBMTRtR1M4Q1A5T2N6UXdjM0FpbitUd1RJWW1YTU9ZOE5TZ1NBUnFkR2JKK3lWWHdlV1Q0U1lFQ29rM3hEelJ3TTYxUHVXT0hmNFZPY25tNmNXSUdkK1E2UUFBQnowKysrdUdMcWhSR1A0ekQvcUJ5TGRRUE5vSzh2bWVXMXcvZnZrMlI5WXZyWjl2bS9uR2tOQktENnhEYS9PdGZtYVk2RWgvM1ZsRjJKaythdGFDMmRXSXIyV0lnMEw0dlFFTlYxVklzNC9qWUo1Q0FZYk51MnFiYTd4NEczM1hoRmp4Y2lXcktmUjc3WTY1R0c0NWREbWFxRG9odVdWTlNxTXFnd0pFMnRlVERNV21GQUs1cXEzb2xhWHgxLzFUSUxOVytyemNyN3pXc2Z2UDdCdXJ1TWFzS0F2T0hpb0RJeXlaS0tXTTM3TktHbTJiVnhMNHZMazNGRkNYMUZvQ0p0SFJKVWlxV1pQV2wxQUhHTHJ1NWhNQVVpcnNTVWhEcDd4ODJhN29icFY0ZjMwaGRRUzZvVzJSR0wxMlZSa1V0SGh3MEJDejdRaEpEeWQxL0RQYzNyMTc5RmE3SDNZdC9tLzdMYnpFMk10Z0lCckhKSXhCb3lVWTgxa1ZCM0U0Ujl0UDZRakQvTTFldlUvUHpyTzllZUJZdlVvZW5vTCtmZWM0WFhzeHpqK2tpbFpSVENHSzJETTMvZCtMeHpNZDROU3VxSnlzRCtrV05OYnJQS1NwMERLSnFJZHcwYmJPKzNZYUZTVFcxUDlueTBQRThuN3pmK3N0dmZ2b1VUSjdtVjJsZ0p3RXo4QUptc0NBdWtFbmswbWh5eWJlZEVIN0xGK3lDSVBJUjhPQ1V0blUzUlFJUFV4Y2pHaUNpb0Rnak1nR0JPUUtpMFlrWSt2R2V1ZXpBTXc5L0dlRTdHSmdiR0JrYUZBUkNZdVlGWGUvMlNURUZmbHAvTkd2QnFDbFVtZ0MrK05GUHJpR3ROcVVjN3g3SGxMODc0RlhqUk05eWQzaHNidHBuVDM4MGRJL2Z2M216NzU5dm43MlVYNlV1ejJYS1kwL05XdnkrR3lCdStsbEh6cXBXY21Zb2xvMlk5K1JGbldqRUNDSW9mVTVESmdBaGlSVU8zZUcrYTY1WDY3VTVWeFNneU9IRC9VQjE3VkpLTjJpcTNVd2RRTURHZm5EVWFaVG9ISnRWWGUyUFZScEc0eGkrek9adVdjdVQ5cllMVlpYSEhhNDM0L2pQNzNOTEpGNUQzRVJYaStLREhqNjhqVmNyTDJOL2JNVjFPSzVhSzhrY0EyVlhMTmxESUhMVW5KNElrSVZRVzg2QVlSdHl2ejhXZDd0Uk0wM3VUYWhxMk8vbFJSN0hGS0E5VmdTQzdsZXFBS1hyZjUyaHFzQ1J5WkFqbGg0UXF2V2doM2RQaCs3cnowZjdJRTlDLy9uLy9sLys4SDBmbXpHeGVhQmNIRnlMQXZHMFNOa21kK0o1WmVvMDU1MnVZaGNlS1NSaU9tVnpGNVFMbkJGdEY1K2xwWjlwNmllK3dNQ2U5SWJUVVhrT3RpOGNpL2xZZmNHRFhkeFZPZzkzenc0bC9OUlhpT2dBaGNDVUtYelJybVBkeHBNNUlvQWhXQ2tuemNtUjNNeUh6LzdpWnh0MzRNMU9lNGlNbnJPQmpjQlRQWkhPZ0d1Wm9wa1QxWDd4S1M0L3ZOTTB5RHVYWnVQU2hyNVFOazQ2dTJJaEozQ2VUeUJMbGFRVFNhNmlqcXBBTkIzREx3WmgrT2tPL0JHSDM4RnRjaldEemYwTzQ4UjNueGtnaWg4TnNmN1ZTTDk3TVlnbGI1Ly8vZTBHQ2pHQ2R0MVlTanJ1elJJUjA5dDNULy9tNi81TnEzMjRmZm1UNFYrNjhYMitlWEk5dHJKUEJhVXRvd2NjanJzVnJlczBES0dxYVZRTy9aQzVYUVVuVlNmeUlxckdCQjdRc2tqa0k2M1dRY2lMcDkwWVhOZTNhMmkycStBUjhxN0YvUGI0c010VmdGNWdIQ2t5Mlh5V1FRQTFwdzVZR0RSL3Y5cXVObTFzRDQ1Q1RWczlHSHBPakkvV2hDZmJUWUNJZC8vVVBmM3krc2MzOWVFUGg4MHdPa1pJNlpsWW4vdnhRR0w5NEZTdmdrQjZyeG1VQkFDUWNtRVNidEduVFdJTVFacUdyZGc0YVB1MHFncTVhaWxNekpDSDFBOHhQbC92ajQraFRVZFliU0NvaGNiU21JdWhaa3NZR3pFVURkRXNrekdTaHlzNWZQL3FyMWZmL2VVM3Y1RDd1djdEUDM3NWIzN2MzUTBDaHVBdXNlL1MxS2F0Z09BMmhlbGhJZ0ZjMW4zTUVFVlltaEZPN2RIdWZPWlUrZ21OZm5KTVRrZnZPZDJFamdCeVltNEJrSDBDSmo4dFZEOE56cGE0dzNKVU5aaDlDbVo2dHVyT3NwdGZucnRwdWljcnlXcTFxajlmVmN3eUQ3ZlJnUXpkTlplVFZvd0lya1ZsZmR2NFNBRUNka05jSVpnV0RKNE5BQkdaQ3FFRENNdjBORkdsWlh6bUYvaFZuUjg2ZnJLTDRvV0l2aVFBRVJEUmxBb1lRQlowY01UZ1Uwb2JrU1JhVkNyWmtXd0dhUHhaN3NsRlRmTUZLSDkraGFhMlJJU01LbTZNd0V5dTlLL1VXSnoyOU1tTTQrYlJDWnhmL1BWZkQ3dlV4T0d1R1VkYUZlK2YwYUgwanFGNzhqZFBOeUUwdUh2M1FPMEtxdzhmeXZqKytQNm5LM2w5bDFFK1ZHMWtVM3BHZmZKeGtEWDRXTVo2ZFVpMjJWNXpnZXlJVUlxa3ZyamxIT0c0cXlxQ2FNaXJUVTM5N3VFWVZ6VzlyQTV2ZGdtN1lVTUgzelk2R3JURit6UTJ0aDhxT2QwZWxKQ0NPVWtweVVySzhlR3VldmxaRmRkV2l2b3d5djdnb1duV0g5N3JrNSs4cU1aeS8zaUF6My8wNVgrb3g0N2g3U1B2aDJaYm1SNmF1cnFwdnJwN0pkM2hNWVRhREhsNDZJY3JaZ0V3aUk1Q0p1MmhHQVVtSHF3UWNucVF1b3I5cnF0dXhnSFhrZno3cW1wbzFQSyticTllOHNQNysrd1lNYjI3MWQ2YTRPVzlHckJJK01KTXU4NURXMU1la0YwRVRkb2FKYjlsL2NjL0NQM0EzMVQvanY1NyswNmVoSDRFems0aElqZ1FhekVqVlRNQXA4bHhqRHcvbVczYUR2Mmoyb1psalg1TWNUL0ZjYzZ1WFBRVGVNTEp5TkhaRjEwVzBNaUJscDFwTmh6UmxOZ0I4UXY4Tk01MmVuUlV0TG55eEU3cjF5K0dYWFlKMnpQdzRMeCsrblFiUTEwaE1XaVpOdjJweE5mTWxvbFFRdlNjeGl5akVrWUQ4MkhYMTF3RUFaalZEQjJubWYzMEVKREphWW1pcDZ6ZFpFUmhuRU43Q0c1T1h1WXVrL25uY1liSmY2bnVRRUpZQUYxWmVFd3NJZ0NaRU55SW5NbmN5TmhMbm1hTWlramdHWUlwa3hQTnhOQTVBV1h6cmlrOENlbXNWaFNRekhUeXQ0Q3IrV1NaY0t6REVJamN5SWtZeVdtNk1VL3VNeUNFSXVSbUxqUUVBdGgrOHgvZmpoQzc3M0tFcUVmYXZMakJoN3ZIaC9IMjg3OTZ1WGw0dlQvMlZ3NFY1QS9qSDR0ekpZZnZYbDF0di9EQnFFVXpwcExaSWJZdnVkeTJGYUo0ZVpMcmwrdHg4QS9xMENlcWhsQ2xvMXRCdDUxeEZkUE5sbUVZN2NnMmVOdzhVM214ZWZmaHNSOUxEV1JZMWNFZjN4OURlOU9ubUIvM20rQ3VKZWZDRGhRb0pVbWRnam9UY2NPSEVXc2NDOWFzNzlROVh0WCs1REczK1hXczlydmo5bWRmMlp0dmN4NE92Y2hJRlJ1R29HTUNYTjMrNkQvOTlyOGphODZmUjBxWm9OdXNxM0dVU3NZYWFmVjVjRTVqemlaUk9xMGYzdkVxVXVvK1BBeDIrMlN0cGRyVWRYb3Y3Zm81ZVVubFhqTzN1OUxnZmhUV05HcFlOWm1xcXVIK3NNZXlmK2doMEZmWFhxVVV5RDFBa3BmY0RTVTl2QTR2Zi9MWC8vSi9sYi82NGYvNFl0Z05vZTJtOG5aaVZGVms5YkxIZFZCbzNEQm9RY2xUN05aNU9pcmFiSmc5MlozblFmVGswREozc2NrSkJjeGd3RHlYZ3kwZVpDZ01BY2xSWjVndFRTV2JtT2FIUXFhTHRzRWxOK2MyVzNoOVluazVUUFdnVTZNQ251UDREcUVZTUpxYWtLc3hreFVGWkhrVzE1dk5wZzdyeVNTTWlBN3FBT1lJWG5LbTZidkVBaXh3M0tYTjdlMDBUTlp5YkRmZGlySUZNNHNGcDh3UUVBZHpSSmx6eGZQTTdoekdtaFFjUUo5dDFiSk15ZWVRNzJVUnpOSzY1cXFNaEtaVFpmQkpjQ01YUitXUVZiMm9PU0dZQkNFaUlEU0dpMXZOOU80WVFGRzFtWU5ONS8wZTNSQ0FiQzZqWXBXWk1JbWY3c0ZFcDlnaElqaTI3TWtvM2VVTXFPNEdsbnNQN2NxYTFmckY5ZWUzM2NQNy9lcy92aCtlUndUaDNGc0lUc0RWL3Zpd2ZoTHVPMEZoUmtkR2lyZFBXOERyMjFWVkVUaUM2L0hEUTIzdTBqbkdhQU1hVlJnUWl0bElhZWZVTlB3dDkxWUgzYlByL3ZVZFZrVFlOcnkvNjFhdEcrV0Q5a011WnJ2b09nUEFFVmtrUGlSRkJHVFozR3lvZit6R24vOUYvc1Bya1I5aGRSWGR0MitmZjM3dGcrTFg3MStQci9iajNjTytsNmF1WW5FT1ZXQ3dNVk5kM256M2k3LzRYei83YjI4Z2pCd3F5QkxaaXhPTXgwWllSNGo0MUMyTlF5NWo4dEcwUnJiVVpWN0pwbTFMMSszMWk5cUxQaEIvNVpyN3g0ZURGKy9kSXhmZ2FHanBtb09rOSs4UEI5UXhtWkRkN1dYRllZMXFRNDdDNm9KRFZ2dDIvUmQvOC9iLys1K3l4aVoyWGRMSU9oQkxCMllvTHFpRW9JQW5FL3lmb3REd0FxbHoyb21uamNWODNnOG5UeVJlVU9Ocy9zZ3lNZEpGd1IyZUNVN29jOVQwc2pMNG5JVUM5TWxHcWVEdU92bXNMM3ROd0Iwd1V5QXZSY0Vaa2RGSFZ3anI3WG9iNnFadG9relRLbldhTEJkK1l1cVlPYUREay8xdXZ6OFdlaFlZSEFCQ0hycE0xV3FrNmVMS1U0NzVOSGlYbWFqdFN4L2F1ZkYwTm9MUGt5eVpYV0p5anV3dXlTQUFJeE5DTURCbGREQkRtbzJZaElnRTRvREJMUmIxVXNwazBxNEN6OUtBK1VkenFIUHdlZnJsZ3ZTZk1iZGdDOUlPd0huT1RNOGw2bitTRjVrRHBBNXVBRjV2NFYyclRvb0k1bWlkV1p1ak8xZjV6VC9kcDhZUFZuMGJvOVRCYzZqRlNwRTRqTHVuTjNVOENqSWhNTndUMTdFaHV0MjA4TkQxdWEydDh6QTh1Z0tET0ttYW1USXJDQVZIVE9PUWFlM1ZOVUNKUENiZHBmY1BkTDJSUEI2T1pYZWY2bFZiMVdySnJXQlRFcHBPYzZ2Smo4K2JxRXlHZk5VMk9DakVMeC8rNi9iekw5NithZzU5S3c3TmoyOXVWNXdlSHIvZmZ2UDZOKytoZXZIajUvTDIxWHZhc2hNaWVzdWplOWYxTC8rUDhyUC8vUHFYOXgwM3E4WlpybEV4c0tNaGV4bEJlaWEwa3N3UVhSVXdjOWlFNUxCcHE4ampNTzZiaXZ0TStKMnFrN3lFMzlXWUU0a0FNWmdCcUZwKytQWkRobElVUTVDWUQ2TGNidDNHWk1RczlTcVVsSVYrMmY3dEQrQzdWK3NvdFFRbmc2SFlhamdNYzhFUUlZSXA4a1J3T0dOY3ozWm52SWdJbm91L0Y3UVNMcklRemtHWitRTzFOQ1l3WGJnNVR1R0UrZWFLdmxqNUxsU1crU2c2c2VmZDVqTmluanNYNURUN09yVlR1d0VSbUNHQkdjVVk2dTJUcTVva0JHSEtPSGx6Q1ZSVnpkZ2RYTlhLYk1IY2ZYai9PSGpUckpxcHBhd01oMDZSa09lcG1oQWhrdkQwNDR2SUtVQkZEbk9Wd3pSQk9KODg1dVBxYVZ4OUtoSzk1QXpNTmI1UXlKME5wM2NBM0ltV1JtVUMwNkpCaTdxcFZTTEVpSWJMbyt1aVpuQjJjUkxQV1FheVJjK2QzMGtqTjhQcHNXTHVweXIxaXhHVzI1UXFXZVlaS1hENy9LdG56S3hxeUJoaVdKZkRROW0yVmZUSDcvZmpRMTlWVUdQQzRvaWhwY2pxb0JMY0RxT1ZocEhBM0YwSXl3RjMvcmJDUVRkUHJ5b2Z1eUlRK3lHVEFNRXcyQWllTTVmZVNTSUhCRVJJL28wOFBnZ1p2QjRIdnIzbThlaTU2d3F1dGc2S2xWc0tqRjdOMVZmZ29BQWxJZmk2Y2lFRnFmeFljbWJoN3R2OHh4L2MvbnovL2ZzSHZkazBYMlAvUUxYUjIyOUhpMDhmSDM3ZmZ2UDMvem45ODcrTVdvcVZpTEZwKzRmSDBYNTUyLzNmei8vZDMvM1RyMHBtZExkWXJBQ0VlQ2hvZ0s0SGhqd21vRnFSM2FJd0FuTGowSTJJaEJnZkNraEFGQzk5eGxpSEYwQzIzMkZkaU1sTi9WR0ZIZys0NGU2UTBVMDFaYzdkV0s4TXNXVHp1SUttdWxLUVAvNmZ2L2pidi9sQi9HMkpRVnBzZHUwd1FMWGVaNTl1VjZ4cW9DQ29DNlA5STVQZDZRMG11UEJJZzZNdE02WEowYkVzZTdzTXQ5QkVNUGNwbG44QlNqOGhxNmFLZ2t1UjB1YWl0S242Wks1YXNObmhkMUh3c255SG9xTXpDM3BPd0l4MHU3MVpoZGpXZ29RMGVUQWMzTDI0cXFvNW1abmxzYVQ1cDN0OU9HWU82L1dxWWtjQXlObWtpakFHSlNJa0VpUnc0Z2t0eFNFSU9UZzUrRnpsamJvNHp5NXJSc0Y5S1JyeWkxRDFqUGVaVGk5emRYazJLSWJva1lnYzNkRW1OZzBSSWhNYmxLTG1hb0dGUDhsalhUVEZ3TklGZ2JZbzlvZ1hYRzRITmJScHduSGFzajhTNmFmV1g3TkZibXFBMm1kZlBpRTF6ZVlJWWhhYTRmNXVFMjVmeHYxK2xHdmVkUTNuNE83bHlMSWF3WWtabVhRWW5RUFAzU0FyZGkxN3lNZlBQbi9ack5vS1JyektIYXdyeU1yTWpFT0NTTWR4NDJxb2hhNDRDcFNjeGszRVFWMTZiNTUrdWRtL2U4ZGhzeklBSGtiUHBpWFhZRVB5MFhIeTBsWFQ5b0ZISXlBakdLVGVoTklQNzNWMS8vdDNuMzMydyszejkzVDdyQjFpK3U1RDgyeno0dUd4RURaNi8vQXJlZ2h2SGhyWFhNekNvWTZXOWcvRDVxOVc0ei92Zm5qMW95b3dHT0NJZ2psWlpFdUdQbVltTWhCa0FtcHFjb3g1eUlhRWtES0pFSWtPRlFmTklVWXJwVDgrNjZUaFE4WnBOdUVlaUxHNTBVb3hKYmRpQjVGSUtlMUpZZ2o5cUVmVlZSTzFkTzNEUHh6V1Avc1BTWXZuQW5Fai9hTm1rSWxJaFdSNWlEVDF4ZnRaWGNTVFozS21qNTQ3Rms3R2hHV1lOQUhwcHJuenNvRXVUWWQwbWtmN1J3MCtwNW5ZMlV4OS9rUWFYbFIwNit4VzlCUGs3aFAzUWNuRVVESmw1ZGhXL09McXlRcHQ2dkZiRnEvNVdhZ3VXclNrbFBWVXBCQURFbU1VQkFNSGtSQ3FhSXpJQVpnWkVOMFFrUkVCSkFUeEU5dmVFSkZCWWFrWlE1cVFkTk9EenVZWDBKWk0zekpucDhsSWJiWlVib01yZ0FNVEFQTFNDWXFNaU1BRVRtVHVaa0xDVTdEWGw4amtndnQwY0FjdFJkWEFZVUxyblVjV3VLaHlOcnVpd2QzTi9tUUhYbHFUWm9Sbk5UcEhkQVFiUnlmRTR6Z2FtT2xiMzZYVldPSStRTmV2YWxzaGNSNEtJQ0VGY3RNeHhaWktaaEowYzFDZU9tNSs5TldQci9QRDk0OEpOcmV3MXdhSE1ZU0tnRFNIV29zYXRUR1E2VUJXK3pEcTc2d2FVeDZocnF0NnJLNnZQN3U3OThxSDNsWDltSWRrdFl5RHVWOGh1aFgzaWNLS3RBTUNaSW1ERmEwcVI3ZjRlU1AyK1Bycnp6ODhOR0lINzdTaXJqU2YvMlYrODZiNWlsZHIvSjlwOCtJSWFNaEUybyt5SG5lSEgvOWorK1gxYi8vaHlSZElKRXhVWXMzcG1DR2l1V25xWEtvWTBEeTVRQWdsSDdpTjBPOE9qWEdNNEFBMmVCTklGUkVvVmpUMEVyaXlUS2JBeEJBQUZMMGJtUnNDWVN3VmszczVXck1TRW1ObUhabEFOZDc0OGYvdFhxd1BmVW9GT0VpbW5ESW1SbE1qZ0VSMWRKdkVTL0FsVmJnVTRFNytnb3RBLzJWZWR6bzZMc1daanJRY0hlbENVSEwvWklHZWNPaG5mS3AvZElSZXJOQ1RIRGw3RCtqTTRZREx4cStreEZqR3NjYTZ2YnJaVkczYkJtT1cyWi90ZVdub05YZHpkUzBsbDVReXp5R2NVTnlCUkFqTUNCMkl3QlFvR0hFVUVTNVRWUUlSRWlBUmlNMDE0T2crblh0UHRqVUNWNTg1WVRPU3prODNrUk42YmxLR0VGbUVBUnhsQ1VRb0FTQVRJek1Sb09yMHQvSlVSdWVNVElSMFNnckM0cTd5VDV5UlB2Vk9Mbk9FazFMdWMxSHg5S2JZcDF6b3BVYmRuVUFCUUczMTlNb2VCUStQUFZZQmgwTkhzVkFzTUx5cVlvMHI1YVlrcW04TnNTL0tWbFZnWlV4QUl1UU9vMU1BQkt6UnlJUDQ1L0NyYnVUSVRiTU9vK2ZSOXprSzlNTnVsOW9vbXpaVHFDc3lmVnY2aU5sNDk1YjZ1b2F4MmRabG42NVhtOGUrZzV3U2lFRE94Vk9Lb2M1T0szQ3pZTTRoTURpaU9Ra1lzYVdka2pCUmUwV2wxT3NQaDgyTnBBNnJ4ejQrbytIWXZWOS84ZE9mN285L3Q5K1B3OFBqOXh1SlJNVHNadDY4YUQ3ZnYxejEvSmZqWFRFREpvQlZLUTBGUTZ2RUhXMzlhTWtpRlFXR2RHVE5hYlc1cmJ0QWhVQkFqV0xLSTNPUVJsTS9Ha3RtUC9DejQ0SEFpWVhnNkVPSFhCNEo2M1ZnZ01ydkgwRlpNMDAwejByUVJvQXN2R0c0LzhlMzVYQlFNNDZRZW92a3E0aG9ZQTVoSEhNQXplenFQRjJ0L0V4M1JXUTg0OVQ4N0hpZjZrV0phV0s0dWFNWkxmQktPbVY3NTAveVJldXduZHRabHAzcXo1VG9MZWU0eWZNTVFFdmdCaStjMlFnQW9NU2VvVnF0cTlWNnZWbEZKREdjMnpmZHpmSWtQZ0Y2MFZLbUZzMVNjckdwZ0JQR1ZKQ0p5VlFKRVZ3cHRuVndHWkNKUlZnQlZBMEptQkNJV0JTVzFBUVlJMCt5Mnp6bm1xWUNVenZTcWQ0SXovVzhDNXdPRVRGS3BJa2dONDNGTWpFNitoUVlRb0k4ZWNhUmtSelJqZWViaW4vc1lqNDlBR2xDK1lCT09RcWNzWk80dkdFeXhUSUpQOGFHZldSemRiS1RCNkRJazY5L29NZUUzYUZqQjBJU1lwWDR0aHJlOE8wR24zZjY1QWF1bi9jcEZ4YU85V2F0eDNFY1pXVjZ6TEhaT1U5SE0wdWRWaFgrRTF2QnRwSHRCaDRUVmlNSVZqeTh1OU9qZVd5YmFpeTVIOEd0N3BJU3htWThkUHFERjk0ZjJ1ZTh2L3ZOY1orTVNxOEVGYUp6SGU4VGJlcWlUS2FBTEhpWW1sWXhxbXZKbExkZStuNUVhVXFCL3VEeDU4TzdUWXRkZVVpTWZaR3JmSHdZWGxkTmsyUTdldHppVWVySTRKQVpTbWwrdWlrK1BCN2w4My9icDM0WXh5RWZCMTJ0MkJucVZqQUdHbmYzWGJKY3JvWEszdDNXdXFlYlZmM3kwR2ZYd2FVZHVqeUF5WWVxcnZLWWxWZmxJTStPdzZET2JBNFArckJybjVMZjExZHRSZTdVMzcyTzI3cGFNYVRzSWxtbzlKbVVuN2U1cytFNDlBT0NPcVZod1BnVkZYQUFBQ0FBU1VSQlZGWE1jaVFiY0FSaVVGV3dYUCtKMmYwTWVsK2E3VTgyS3A4TlJNVFQyTXZOMFF3L0lyT2NGdnBVOGUzbkJZeVgwdktuQkE2WThURmxYc0E0elh2UlR3ZSswdzBhSEFGRVlCeXJtNmVyWnJNS0ZNU1JrZHpLTkxzeFUxZHpCM1FySmVkaVhJcXA2dHkvRFRBVUMyaWpUMWRBTnc4M3ordzZVUStFRW9RUlhZc2hLVE01SWdtQk82aDdkRWZtbVRicDRETEYvNUNCcHU4WmJib0VJcGdyUUppUExGZ1FySGpsbGdsSnVDeXRSdTdJb0NtQ3p2Mk5SR0JBanJJOE1NRUFQQkFSQXBGUHEzK0NaQmtHSlJHYUpoSnE1aXB1eUFndTdnYXpUa2MwSFFlQmlLZVZTbGpBMVFWR2REVUN6K0ZvNGlWRDJXeERONVE2V1NVNkR0UlFoUkxpRmJ3cjErT3I2dVZoc3hMeTdyZmRuT2FpbkxpQWpXTkVsYlgzR1VnYUtya0hDeFV6UTRHV3RTTnFnaXNDS3VYZHNmU2xJMGtmdW5XRDQrR1lxSW5QcWRQWUJBcHdKVHcrKzhHWUQrbmQ2OXhReTFoazN3Vk5WY05XMnR1V3NqTm5GTXhqS2pJVzhsSXNhQ2tRRy8yWEtHTm5xMUE1aDZmZGg0ZGZ4OVhOOCt0TmwzZjdmUnYxTGdUWXZlY3FWQzM3K3NkM2Z3UlBTV294UzRVYnYzdTNWU2NwWTN2RnJFTnl1T3IyUTA3anVIN1FUZWRQcjlzbjM3QWVIdzdtaXF1NmY4Q3hHL0lWbXp6Smg3SksrMlBZamwySHNXNW95Q3lhRWwvN3U3SFpJYUVOdVJDMlJYQmJqMUlGSzA3cDliRjJ1YW8zaDA0QjBiQ0RFQ0NYZUF4MU4vcElIVzI0VHdCQ0hiYXJCaCtWSG85Vm5Tck1ZNFA5cG9KVUJOTzg0Mkk1b1hBV2tzYTVUd2lJeUtjTlljcUZvNERSZElxZTdzMW42K1ZFWTlJVEUxV21CV3pHak9mS0JaaXNpZ2hZcGhHdXNXcVpsdTY4WTB3bmRUTWlOemlOemR3N1hIOTF1d3JYSEt0SWlHUUdob2lLQktaWlRjME1FTTF5THVhZ0tHcG14WWdRM1ZBWmlYdXZTWkdUc05iSCt0Ly84WjZ0TnVjb2FHaXFqbUE0K3hGbFVscVhjTVg1emorejJSWTc1MnkzbW1PWEoxOHBvRTBPOFNXVjZRdkxvc3oyRkhNM1FYSWlOQ0MzTkhlYjJVa0x3Tk1zQVM5YzFuZ0dCNTZWNXVtb0RNczVpUDVNcUpnbld4a3BBQmlZOTluY1FXSnpjeE5TQm5NSElxSEFVcEFjb0xueXRzdnA4QVNoMysvMzNXckNDb0lacnBBSUszSExBOG1HQlEyQVJORWNTZHdja1pFMEQ3a1FsRjRKWFJVaWdKY1JTeTVkbDBpckQzRWprLzVJbUQ0Y0k1cWpiWlVDZUU1RGdRRURtNGlSN3BIUXNnTllLVGtQRTVEQkNnQnhHYWxEVjBYdG5XTmNQL3VxL0ZxUHhiSmtrVlo5TEtrdlhsMDNnZmFwanJySHozSVZuTmgxM0tkK2JDSzl5U2tudlBIdHFyNFNRSHFJRzRCMEhPNEx4dWpTN1ZDcXFxbnRuU1Vsb1BDdTNWVGxjTFhoZm1EUGNHV0U5U2JuZlNVeE1KYU1xbHdTcnI3cWUwVkNaNUVxYkdWc0FnMTNqeVBJVUxSMGgzek1McFI3Ym9uWmlFR0hQS2k3SGdZT2piZzhDcTlETVRVNDNPWG5mRWNBUW9TZXdjM05UUlphSkY3b3ZxY2NxWjk2QUhIT3h0RWNYN1A1ZUxZQW01ZVBPT0c1ekFnL1lrNS96Sm9oT0JmcXVzN0oxUXRoZXJudUJRQW5kOHRUcklLYjBMYnJ6U3JXRkVUd2xDWTBCRFV6b0hGaVprRXhWVU5ZK25ubjJubkVHVDB3M2VNUkFLcnJ6N0Y5djBjQ1prWWlJellIVkE3Q2dDalQ5MCtPTmtXWTZZeHJQdG1XeVEzSkdXMEtSdFBwS3dnNHFiaW5TY1BKTUM2MkVIZVZFakV3QTZJeEtoSXpueGZuSW1KOU1vNEdRa0thTkRrakIxUndKRHQ3T28xd2xnUStXY0RxWm9oVTVueFVjVkMxR0o5LytVSUdGUWQzWUlsMVFuSnlnQ3V5NEZYSmtMdmQrNFB6SHBHQXlFMTc1Nng4R0hLc0F0T2pPMkRGSktaT0VzWEVZMENTWkdNdTZNbEN4RlFpSE4zTms1Y0dxNXpLQ0VPc1Frck9nZ1M1KzJBMVViMTk3dU9kV3pGdWFuU0tnY0d4NzdHT21nT0NsWnh6bWgrRWlVUGRzQll5cUNQazlCMkh4K3ZyVmZoNzI3OTdQSzZiMXIwNFVQVXFlNUQ2K1l1cmZVTGk5WHBnSFRVSWJvZmpVSExLdHptbkVkb3dTaFdKbWJkbExFN2NXQ21saVpTdXpTRGwyZmxuWWZ0OVR1VGMrV2JRMXZaV1V4NzZRUjF1Mk14c0hHcVRldWc4WEVGZmlBTUFFMGlJOG02N0RuVWJJSVhvT1k4d0trWk1CZnE2QVNPazVENllzTHVyQXFJOTFWeHlkL1Bpb0M1cHhOelkxSk5rQUtTT1M2WFJETTN3NmZaNVdXL2ljNW50UENXaXhmeE94SHdhTTEzd1hPSGk0NG9YeXhjY1BwNXZuUnpRYm1xT00rakNUakxXakgzVmFlQVczWkZFNlBubXBpVnBHaU1pY3JmcHQ2bWhxWm9qNUltY0JYbkdCNUJQeUNlYUhVbE1RTVRBTXR0TFRHN0NhcFVmeVltWmNSWk9IVFNFUUNRa1o5VnJtaWJ6UjhIbUM1aVlPeTl5TlM3d2U3eUlGcDZBQ1ZQQWtYR3VUSEl2UUlydWdJUTJ6N3pnSTFpdnUzN01ycHhTbnJTZ2h5WTJPNXJSS1gyRTdtY0F3MGNGM283a2FEb0Q4WkJZUy9IUVhtOXczMGRPTkhVdWNwbCtCMjcwMEhYWU52ZWx4WVk0M0lOcnprVmZna0oxOWN6bzBaNXVkcTgrM0FBZ0dXSTFOemFxT1F0SkFEUUgweEtyYU5tNTdpYUtTVjR4a1ZoZFhVVWNoeUtjamNrQUlGZG9VS0Z4em9vQlNtTk9ybDVRcDY1eVFrQUpkb3JDSkFoMUE0TzFHTnJHdTg0SU9SOHRsdlgxdHR2ZHZTN3RkaHZ6NFhpMUg3MGM3NmkrNzdjdm12VDlxaExQbHZTQXNvN2tMb1EyRGdvckNkWVpNV2t4VjdXYnJ0dVZxeFVQU0lTbXRqZDE1YnI1ZXJmMzU1dmh1NE8xTjNXbGFCeU8rMTdxZld4YVRzVlM0UWpVbzNjcFVRelZhS2tqY25tdkZOZTEydnNXa3doQjBLRUhCUjRhTlVaaEcwdVJXaXdXeTRPT1JlSW1QT3g0YzVTL2Z2SGQvN2kvc3V6dXJsWWlUY3l0ZWNMRWwrNm9wU05wd2JlZmJya0daYm5DRWpQQnllajBxV3gwK25Qd1VldlJaVy92SE9pZldGZFQ4Y0ZINExhcHhzVk5rUWhja1VQZE52SEo1aXE2eDFEbTRTcWFPWnFadTZtNTIraXE2dWEySUVSYzUrREJSQ0RocVdpY2FWWmZTdUFWcCs4SmtZV1pnTm5jRFR3d3M0UktoT2JLUVYrV3hXVlZCZEI4TkNZd2RDTzBUOXAyNFFReldScU41L0lYSkRTY3daMkdVOWtUQWhJSnVJSFBwQVVDc0tuUXhnamhFd1Z1YmpVOGtjSXVlK0h3UXFQKytEOEZFblF0SjJHQnJWaTkyZXB4UE1JdEtzMm8wZEZzZXBzREpGK0ZKbGZYYXo5MitWbEovYkhyMDkxcWRmdlppdUQ0MmZxWi8rN3U4UzNIbWtNdEF6SWhxSG94UzREUzJQU2FNM3NlczJFd1JRZnoreUN5RFcwZE5XVVhvYXhBSWpWQmc1b09PTWFpQnRZZk96T3BBMWpBQ2hsNGFvQVVrTWhCR0IxRWxVVGRnY2d5VllHWlFsVkZlWGlBOWNzWC9jTzM0NjVyMnFiZUk0VEd4KysyOVhaMTA3NzlZM043RTd6Zkg1TUJWcXR0NDFGQ2lHTU93cWJKcUlTNm9keVBVT2R5ckZweEJOVlMzRlVkUnVZdlg0MWVOVG4vc3FuZlhkM1dKY1Vtcm5iSC9MdjE4OVhHNDZycnhzZVNnWFllckdRUkx5S2VNUHd3NHVDTSt0RHpKcGoza3BPNU0yVWVpZGtZTmFORTFsM1IzakFYeXNPNEg1NDkrOS9lbCs3VnQyVmp4WFBPQVlzSUYwZnlrMjBRenk2ZlJTS2VEQXNMOFhCU2crZkxseFBUUkluNUdGaXFTN1hXWlFodVJoVFBvU1FIQnkvejE0djdIRFh3anpQbzgwcWdpUWdBbWF2MTlaTnRFMElrQU5MNXI2Rmk2dUE2Z1M1SzBkSEFYZDFsQnQrUkxYaE9KMENhV3BtUW1NbHRHYXZKcW8xSEltWWk1UG1NSVVRc1RWc0puVU5TSjB3N25QWlpPMW1qWng0c25yTCtDdzloZ2ZtZFZQYkZxMHBBUG8yQ2ZjTGdBcUFiZ1UvM2Racm9WcE9uZkVhZTBKOXYramF6VHpuQTg3SGhULytFSTdHcks5aFVvSkVSSWE3WHE3d0RYY1dvbzg3NFFBY0hJTkxZVW0xRWxYNDRzQm9kQWRzMUVGVFhYLzd3T2owY08rNys0ZlU3MjdaRVFGeXhUZ2c5STNUTjJRaUFSWXdRWEoxRHNhcVF1aFVONWh4RHBHTldqbXhaU2dZWGxsV3dsQjRaamtNQzRoRFJpM3B5YTVBZ0Y2UTBYOGFZV1lRSlIzQlRyRU55UGZheHJzd0xpcnRlYTdjNzNqNzk3T3QzM3o0TTJFaTNXaDN2bWk4L3U3MlJ4NzdIVlJrZXZKakYxaTJWM1JBclJnd1Yra1BkaHNnQVptbHdoTENEdXVTKzV4dk40MWdBTjhPb1BtZ3FWT05EMHZBVkQvdkIyaEwyVmpYWDRRRGpxN3Z0MWRVTDJkM2Q3NFlJSkhVNDVsS1lZMXZNOVhsK3VQZFZoVytIMVVaS09rSjJZVlZBejFTaEFXaEJNMCs5Z2tHMXdwcnFjQTFmL0tnTi8rMy8rVU45T3dnWWxNeGhGSjRyUWs0bG91QnVvSDZCWXA5STBYZ1o5UE1aclRPZmZTZWM3THowY0NiQXptV2p5M2E4VEhsODhmMDdPT2k4bDB4aDFuTmM5WHpTbXhieFZNL0o0WWNTVjV2TnFpSXpJRnhPc2pqWkdFek5BYldrVkk0MERkYkNXVVMyU1dpaHVmTjZkbzJCR2JxYm9EdldxeHFJbVlpSnBtM1NLeGFKVFJ1RmxoL0RUM2Y2MHdyMm1RWjRhbEx3azluN29tSVJrR1lEMmlLTHp4dnBwRUZQOVMrbzB6RVlUK2dUbmhySENIVnU2Q1lrKzhTSWNlNmNjdkp6VCtwRnpRSi91b0JwdG9VcmtCc0JSUzhjV2k2Y1NFU1RqOWtZM1F2TlZWUVlXMlRMWTllWDJLNjIyK2RjdDl0Tld5bFVhM2pveXcvNzMvL3FEL1ZYWC80djNjT2JON3N4MVpPWVFFQ01EQVZUQURZSHdXelVjRDlNVlhEdWEwUVJTa01DRGpWbnJ6TWFXY3JWVUN5WFVCMWRrRUp6YTJsVUlyVUlNd3pNZldyZUFpU0pVZDRUcVFIaTFzeVEyS2cvZXIydXVidmQxZzkvL0ExK0V6Ny9xanplN1ovZCtQZjA3T2MvT3ZEeHczMUdGOTMzSmE3YlE5V3NIU1RzTlpXNEZzWFJFQ2tFMEtIUElITE1XZ1lVM0RPRE0zTXEyYjJNd3lOeWZvOHhmbUZsek9sMTN4U2xxcWxXNi92NysrKzNuejIvMlZRNFpPM1lFSWd0VjRTU0MrQVJTbllJc0MyOU9TUDFpZ3hnTGdXUXlNQzBPSUdOaFFpYzI5alhUeityaCs2NzF3UDg5R2ZQeDMvT21yT3BZWmtlN25UMkFNd1A4NHV1VDhTSlNIUEN4U0NBNEl6bW1GTHVVM1BZcFRoMEdyK2NpK1FuME1ia3NMSjVZSXFuWHJ3cFdMSTBFdENsL09UbVdsWEM5V2IxRFZJSUVraGNUOFdHN25OdTJOU1NsNUpUMW9RaU1tbGVDSzVMQm1QT0hjNzlYN01iQllIQUNKRWxDSkVJTTg4OVIrWWh0azBWb3dpZDF1ODhVSnJDbDdOSmNpbDZPOWVRMGZ6RU8rbHdGKzV5QjRBeXYwQXlKN0FWRVVGeDhiVmhJaUppSjVzckZSMW5wem5hVlBrdzY3MlQ4SHZ5T1o4QURIWWlsVjJjcGMrQUVPUnBPc0pUL0pHOVJzOUM1VmhEZ0x3N0FoY2dOa0J5QlFOM2NUUXQ0MkNyNjgrZXJ0Y2JCWmE2cnNUdkg3Tm01ZjE0Ri83Tk4zL3hOQ0VBMXhYMU9sRWpTNFpBeUlURXBJa0F4a3pNMXFzWnNTQVZKMGEwWEZPb0tvNDFJQnBpMFhmSEhOMWtWUWxwZ2xqbFhJTVFPdWFzZ0FBMUdGRUlFclFBdDNYOU0rMlBoMTdCaUNPbVF6OCtmQmpiNjNYOCt2SGIrT0t6N3NNdjFsZnJLQzgvY3orR24zeUJ2N0ErQlU2OWRkdFZKRHZzMjl3TldiYnIyaXpuRGtiT2ZaZkRadFhXcTFYcERudE1hZWd0SU1mZ3c3RXZMNDRqazdxQ0VBeVdxc1JQZnBCLzkyNy8vWk5iT0I2dWJnOXdaWGw4ZFFjLy9leDJ3RzVBUW5NbU1IVlhENVhWZ1hveC9lYTNiL2EyWGdkTFpqNVpma2txY3pOVnNESXdnQm94Zm5ILzY5OC91UkxiMm5xRlpFK3g5UHZPelFnRnhGZ3lYdmdsZmZtWW50T0Vpc3Z3ZFBxRXlMeTM0a1JZWGtEd3Rtd3dQTmtSME9DeVdlbjBDL05Ubm5ndTdKdmc2Q2N4aE00NVh3QjM1MnJiVnB1bjEwQkNFcGdLa3JzRE81anBGQmMyTTdkZVUwcTVtRE9RQTZHU0UvcHBtZnR5RDc2bytITUFRSlhwMUF4TXpNUWNabjhHeGRXbVprYUphSjVCUVJFSTBVNG9QNXRPR3FkR0NBV2dDU2swOGZvUWZmb1RZTVVsc0xzREF5TFBnamNBZUVGYjJsRUo1bVpoME9MRWpCVnhRRkFBbTJTbGtRa0Jwd3dnK1hRZlliWFpOVE9kaWV5RTN3WjBjMFRVTVRJN0NwKzhYS2JHVUp3azUrSklidFMwakdweHhBcmQwTmhWSlFTeXJBQklEQ3ZaajV0MVRQTGlaWjBQK3o1K2NZVkgzQTlEMXgzMnc0cWF2LzNMSCs5Lzg1dmRZMThLQlRaMUlLU2dDWm82RGNCb3hucEE5SVJXQ3JNYnlUcXFhemx5YlBNME94UkZOQ3U1TkJHVUkzUWJRQmJOQmJNUlZZaUJVWXVTSEVNQWE3NzhJbWphM3gxNFJWY2JOSE05SEErWjJjcGozSDkzWFBId3JlYjl3L1dMSDI3SGRMU280RmViM2dhRk4zRlZEUXJWS25BVEt4dG9pb1dtRlRScDkrQnhrRld6MjQrSEtLRmVWUXdqU2dWcHQzYlBVQnpzWFltY0RydzFLMzNCbk5yMk1MWXZtN2UvUE5JcWxueE1rY2RSdWR4MzMzLzVvbjN0RDhwTktBbWtPR01wWTljRUs0ZXI2OTBUS0xrLzFOdXhnQlVVb0xDNnFZZGR6RjZMVjV1K0NvQkJkKzlSY0orODNEZkhYMzVyVk5iUWJKK0M0NkFpT2lndG9BbVkyeWJMVkRXQVBHdkFQRC8rY2RGK2NJSm5mUlFIUko5a0ZvWUpMSTZYNlFoSEo2QzVFZEYxM3E1MDZ0L0NmRW9jNC9SM3paRTlyYVAzaGVxWHpkVjJYVmNTSjhFRUdNd2RTaUdFYVdSdHFqNGVlaTFEWDFDQ2lvUkFrNC9DQUhoS1dMRHBySXlWVW1vMERBRWNyRkJRMXdKalFRQ1d3REVnZ1RreFM3TmVSWnJUVUloazRrQ01OTlZwWDdRMkxuZmRPSHRBZlVIZm5KckdjQW90eks4aEwwakErVG5wc3h3MXh4Nm1rQkE0alVSRm1BRUFqUkJCZlZyQTgxRm1sdWZCczZzQ0l4WkMvQWg2TmFjMFRkbWhrSC9hOEdDbWFTNTRaaUZ6UjVZNnpMd1dqdXdzN21hZXVhcnJVWm9VS2h3SitPcGw3UjlTTHZ2OTNSSGExZmJKWjUrRjhzYzNIMzdkaitBWUlSc2dNUkVIQTFRRkw5a013UGZJcEVQdlRveU9wdXhFNmxuUkxiT3JLbm9wenZ6ZW5JVEJVSVRNcGcrYkZZS0JoVGtLYjdJSys5djN1SG15OHY3OXEzVXRqdTFLcW9hTlFQVlpIRzd2aTZWR2l6a2R1cnJGNFlOdnJwcDFDTWwyaHkvTUxSdEhJa2FPWEEySTZPWkdLQlZMSWxMazVoblhQWm9sYVpwRGQ4akZ5Z2dzREFGaktDTE9uaXR5SzBDd0gwV3FOanhySDQ2cEN2a3VJU0pFTEUvNzc0YWZmdEgrdnUrQm9kQ3FOMEpOR2VCUUNsVGFWNnVpcFhhUk1ia1dDbHJGNEVucDZMRVdkYitPakNTYXJWMVZlbmpzaEFxU00zWXdkTlg2eGJQZll5S0s1OXlxTG1mWnN6TnlTUXN0NEJwY3FsUStoaU11emdhNnVDK0QyMld6aCtGRmRuYStBNStpdFJjY3VDa25CK0FPNGlQRW0yMzdwRjZ2NmhBb0laMXlkYmhBVk0wOWo0UG1zUnRLR1VmbEdHdjRHTEh1azhRQ2l0UDFWQWt0WndSR01DZENBUVpENHFxcW9rZ1ZBZ0s0U0dpcU9ySTd5Q3kySU0wMTVzc1daM09qNzl3akF6eVZPYURqMlJFTjRLNFRxTWdFVHkvSW9yT2ZMc3A0a1JuUjZZYUJpTXhCQkJjcnVSblRWQVc0bExneXM1UlR1NFpQdlk0bnNPY0NWUG5YK1BDbU9Ua3lzaEFqSUJnamhrb3pTMkFreHN5QlFJdTZDSmJjSFZickZycFFTN1dGRDNzZEQ3OG8yanovNnN2ckdzdnU3djFEbHJiR2tna0xFQ0V6V1NETGF1QzVaMmIwd2F2S2hoeFZhaXpGc2hPZ1o0Zm93RmpHTVVXeDBTUVFTeFhRTk04NGNRSWpZVUpDQ2pFU0VuQWRkQ3pYM1lkeEtMSng4RFRlYWJtVnFxcEVzRGVyWTUreG9SQ3BERU9vUW96eDZXMFBoNGNSUGUrY1VMYXhyckZrVXRQV1RZRVJSNEpxVGFQSFpNS3Ezb2dQcFJ2Z1dqc0g5Rnc0QktFS2lCR3NaSzFueHJJVkJLUHQxWTJwQXJMMWZlL051cEd4eVIveTE5ZGZQQ1Exb1dUVHRqVmFHYjNhMU9YdXl3MWI2UXE2V1VIbTBBWVlEbEkxRk5ackdub1ZOR2QwdjJiZkhYc2xEaGE1R0c0OWo1MWUwVm9BQTAwdFowdnZQTXlCK3puU08zOEM4WVI0QlRqVHIvNUV6dmlvMXVjeXJMQkFLYWVySlBtQ1Z6NlZucDBKVGU2Z1V6MjhzMUY5OWZSMlZjVTZDaklTTW9DYmw5bThUVjRjUU1zdzlFTk9ZOWFTc2hQeG1VNzlNZGJWQU4wWjBaSE1TaVJ3QXhOZmFpbGtFK3RBVWdWbkpBcTEzSEpnTjBlWnB1RTBFNnhzMHN3SnNad245ZE1SV3JXY3JPVUw4ZHFuRXVCendmWlVUZUVYN3BaVEkvUDhtdVhwSU8wSXBpcENDOGFPM0J6QUp1RUswTmtscUpMWFpZbzZMUmdCOVBNS25pVlpYMElZSDQranJSZ2FCSElyNXRDSUJJbEZKY1RsV1lNSWdJR2dEUHVqL3loR3BWZ1ZPUXhERlFiOGVWeGZyWnVBM1p2WCsrTUJZMFRoNFRDT2krMTl4Q2xtQVdYZ2l0MWd5TzVKS3c4MWphYWUwYTBVaDk1SnhJYngwTFJTS1hnVnFwb3RnNW94TE1xdk8wUzFVVWRWQis0UXF2YlFEWVpWckhQZE1vQ1Z2WEFaaTJOTTVraFNseGdxdHRnMld1S21vVWRqdmk1cDBENVdUWmlvVGt4Q2pKcXprWERScEVIUVBYQ0YzWkNHUUM1VmhGMC9vY0lCM0ZTWXpBMGNiWHlNbnRVUnFBRDEzZDMyaVd4TG42VEpkdGcvWGoyN1RqZlZtMWNmZnZqNVQ5KzhQc1JLK3NZUmlZT2JqbFpGTDdzUllpQ0ZSMU0xSTFpbisvZmo1dW42UmIycU1xUmNSU2pPVXUvTE1HaFlOVDBTRXpLM3JrUFh2YkduR0lQMzVaUUNjZ2VZNGM1VG8vdDVCejA5eVhFbU8vdzVsQWY1UjdEazB3SzNNOEp4QnJ5ZS83bVRUbm1DMUUxc05uUUFXRjNkWEcvWEVTVHlyQVdUTzB4Y2RRZVhuQUcxSDdyVURhcG1TT3dRWWp3WlFqL0JMczRvYWxNaGR3ckIzQWlKV1JsY2k0ZHRDSXdrWXN3U1loMXJZbkpBRWxpMEg1OUZzUG1NTWt2RHB5T0htamtnb2M3MUNoUHJ6dHpPRTNsZnNIaUxTZTFFdy9hejhZTmhLbjg0dVZTbWhBbWQxdWVwYXlxYUdlaDB3L0daaEh0S29peXdybjl0QTU1cXpXR2FKcWdSaDZvT0xKaFBsRUdGZ2c3dW1UMXVHOXEyY2VTeVA3YTlOWFFZNEdXN2JiMTdPenhDdmI0LzdwbkN1cW1rdDBSZ2FnQ1dzek9aaVJkamNlTnlWQzQ2VHQwOWF1Q2FzaUlOWEllSzIxSWpoeUNJV1FRMWo4VlZFN21hektkQ0tRVVFpb281QWNUbWc0VlZnN2x2amtlVGRkczhrQUVJaHp6MmxDRlV4WWJEcUtFQ3QrWnEwKzlDR1YxcCsyd2RSRFIxdzVvMTkxM0pEU0NnSjRnNTVZQklSMm9xcmdVZVV6ZFNUV1huWUdWQXE3MW9JcUpvaEZ4WmVkdFd1VGhDVkdjb3cvRGgyVk5HTFZuV3BydkRlbjJUYkFQNzc3cS91MXI5cW92dFpIc1RvcHZIRCtNQjYvbzFVQlFrSUFyaUhpclNwS0Z0WWx0WFhrb3BqOXZXdXc3Zzl4aXFKdGhCKzZ6SUVvOUdWR3YvdGdreHFCc3VReVdmOVpERkwzQTJjdUNmdWdjdURBV241WUsrbkEzOWNwcThJQ3g1UGlRYW5PV1B1VURnSExpWmo5a3N6TzNOaTV0YWdqQUxUeTcrNlJqdTgzVjlMTWwwMkI5VFNXcUljelJkUy9VeGYvMlVFWlk1Rkd1RVFERUdZcVlwTlFzT0xpMHd1eUxpV2tLSWRZeU03RTdFY2taT25qRzZlQ3BBbm4ybXZqQVFabWJ6Q2NOblMwQUp6eFBDUlhPZkliVXpUSnRtYnhlRDgzU0lkbmN6VEVCa2pJNW81UE9TSkRBRTVHaklaVVFrZEVPYkFzdm4zRENocTdxYnNnUHhuNjVrUklTcHNRWUtWR0pJWlNETHZBelNQY0ZjOWtQeENpdXhidXgyL1g0TmJUcStLK3VuUXhjSkxLNmJwN2ZqczM5ODdaazRFRmxFejZZa1FkMXdJbzZncTF0Vm13Tzc4bWhZVXRMb0pTZER4TGplcmlMaDBCM0hFb1FJYkN3NXU2Z2l1YXJnblBxY1poQ0VRNjViR0hiMWNPeUQxRFZnSGdwQzhkaFVkUk5qYnpxTUEzdlFkTmhwdTk0MVRVL0p1aXRsWUswMks3RGt5TGdUSDBiVG5FSmRrYWJDZVhSd1pOVmRYWEdJTDZDb2pYZTdqZ082Z1pYWkhJVEFRcVlweFlDSWpDMGxBeDdIN3JqYnRtMGFqMXhmUVRraURmOC9ZKy9XYThtVlhlbk55MW9Sc1Mvbm5MeVNSUlpWS3FuVWFuVUxWcU50TjJEWWh0LzhWLzB2REwvNHdUQmdRM0pEaHJxbExrbFZKRlVrTS9OYzlpVWkxcHB6RGorc2lIMTJKbG15U0NRSUpEUHo1Tmx4V2ZNeXhqZUdWM2ZsN0gvNVIzK2czMXFaT2c5aVRtblR2ZkNvOWN5RXlhMkdjazVDcVR2STJ5OXVYblJ4RHZPQ0hPK0NjRDZPTTVneXd1dE90TjhBTlh2Tk9Razk5dEszbUMrNkdQaWVrY1BQbUdlNUVnVzBJSk5QWmlXZnNQOC9qYjY4b2trR3NDWS9mR1J0eFRPV2tpQUkxZTIyZjMzN2FnTmFzTXhFNHMvQ2lIQnpSNTNuK1hRWTI5dEF5RUZNRkg1WlVuKzhMb1VRNE81QldTU0hOc0drQ1djaUJ2ZTNZRGJqM0cxeXYrbTYzS2preEpMNGlvbk9MQmRVU1F0b2JjbSt5MTlNQUtDOUFXWFpuQ0hXSUZrczlxMVZsaVgwaktCOWJvV1hET0xGL1lCQVRLSktVRFpvQktzc21wRWdpQTZTTEJkMWh1a2NRYVRNc3N3dHZMMEFmdjhSVE13VUNJSjU0VDBQS1VVUmNTYUljTllDQVFLazVBRW9sZG1zZXJHU3puNnV2YjJrbUZ5Ry9DVVNoaS9MN29kaTU2NU05WVljN2d6WHdRRFNwQXFPZ094N2oweFdwaUR5YWtsYXJIaTMzV1pydmdrdlU4NTdNcS9CS2swS0hLNFVRYUVrU1VRMVZReWJMVHJyNzNLT3FWYnIwMTdZWm1JL0hnTDBTam9yY3hLT0NDYWJlanNVSHZ6OHhmNkx0L1g3NDNGRXFhTHo4UisyMjM3LzVpWi9UVFFqQXFkS0d0VmxONC9IWGxqNjNjMnVwNWR2L3M3TTVzbzhMemE3a1RVbm4wNE1Lek9uZk5iZWhIR3NqK2Z0MnpjOUc4bnR0a3pIMHNrNWpQRC9udjc0UmYvK0hTeFlGVXpIemF1dVByNDc3eWptcVpvbnlsMUhrdXZ1ZHIvbDArT2tZcTZEUm1lUmRpS0RtNTI3YnRzUGpIeVlQWStGbURTbk90ZkU4TlZwSzNReEV5d0V5Slh1ME81UWZGUjdmWnJ3OFJ6azYwd2ZMWkNXZzZkbEd3V3UrK2UxTkcwRndKSnJhd0VNbTVmN041dEJXdFBwQWpCRkJKaEZnMkEyVmE5MU9rK3pCVmdKNGMzcnAyazE2bjc4VmxrNHVQQndDcFlVR0ErbnFlTVVUS0FJcEYwd3pMbnZVci9kZEVsRmhTTWdsRmJ4eERKMnVyWmJyR0x4VlJ1SzhNQm10U3BkWStqQVMvM3diUHU2TWhwZ2xYY3NBRTRtWGcxZFFCWFBsRmk4aFRvTE0zRUlrUXVwaUtYOWxDdWNJV1Jna0t3NU1JczdDYit2QjE3eWxIeVR5R2JPdzJZL0ZHZ2lNSkhrcnJQbU1uRnlFeUpCdFJEeFRUZjcvV256ODFmeURRdGMrL3p3cG52L1ZPNSs5cnZUT2VXWTdVUEQvZkNZc3hiVHpLcWdDSlNjeG1vMmF5a1FybGE2TG11THdENU9vM1BLcVZQdSswcHc0NXlxR1lRUnhBeUh3Qk1ST0NYdUV4K3R1emxGVlhqcUNiT2wzVzVQNGJWT3hmNzYxWDU4UDNhYnowRGFvY3d2YXFUUHYrck9oK2szMzg3bHhkdUhLTWN5Mzc5L1JZaWdQSHh4Zmp3VTZYUGxiWStwMEs1YUdtS2NqbXBWdG52ZFBwM0d1VkltRmsxdFdSMUJZU0h6ZWVTK083KzhHNWc2UlpUN0VxLzd6OGM1RDM1L3p6eEZ2OVhUN2JlSFAvbjh0Yjc0TFRVL1hJbVNNS2ZOUVNoa1lEeUpkZ09KZm5hejErbkROOTkvbWNTTmdJMGRhamRzVTZUQmc3U3JlZnZaeTNHcWYrZWdDRTYzRTd6VHNMVGNpa0pYaCt1VlRSalgvK1hyaC94SGtyNEwzUG5hdHkvTEg3YWtDVUpXY1B6U0I2ZWxkdWJsVHl5T2lMeTkzU2xMWWxqVFJqRURFY0pLRm1GbG51MnhqdWVDbk9kRUZHWVFhUmt3bjR6WGx2cWloUzFqOFNBSmJIeTR2Wk5FSXVFZ2QwNUVrSkNoUzV2TnBsTVdhMVpKVGlvc0hxQ21IU1VTdE4yclFqM2NrSmhaNEVGZUtvbW1ZTG1tOW9VU0JZVFhENWpsV1d6T2k0NkdBTUJhdWJvZ0FJUVROU1IrRUVwVjRVSElHVTM5RUV6Y01ZU2s0eUNDMkNFRzV4Qmh5Z3ViYTh0TUZzN3NvdXlxMHJJYlFLeGhFUkZFNGFRODljbW03Uy8rL0Y4Tkg3NnA0dG02bStGOHhJN0draElnTmNJNW9VQllCb2w0ZkgvZTdubnVEemRkTU0zSCs3OGhEbjM5OXF1ZVoyT2x2M2w0SDFtaVpIWUxVVFZGVFpzWU1idVZlU3BiN3VIVm5FR1NsN3FERUFBQUlBQkpSRUZVbGFubk0vSnJ0bzBta1pTVGx4SmVKU2xGbVUxUzlzbEpFamxjV0lGTUJienAweEJ1SHVYRUhpeVBadENjMVd2VncwbUdmajZNTjNmWlpxZTdmci9OODhrMHp2ZmZIYmV2RWt0OThqLzREeTlleVRlLytmWGZ4aTdSZEtMOVRkK2xlaTdjdlRzYnlzamIzUlFKcDNQS2VwUEl2TzdjcTZRa2p0R2RjaitmYW5HRkR4OSt0M20xSDE3cjBTVTlQZnArcjQvWTVEZG45Z0pHSjJxL1BuMzU2cGhQUlhvQ0M0Nm5PdXpmUE0xemJQYzRKMlUzOWFyKzRFbUg5RVBXeDhlMDBhZHVsd2pvK2lFZUR0emY4T21jdnZ1MS91THVuNDQ3blUyK3Y1bVBMOE9EV0ZzcnhFM2J2QTZFMHhKVEdjL2RYc3Z1V2VDVzhzeGpwd3RJRmM5QlFrdTlTT1V5b2JvazZuM2tld2dpbGpCTElHR1Vta1lmNHVienpra1pIcVJDQmcydlNXcnByTUxPWTdYVDhZRlFuS3hLWmFBRkNDWmVXWXdYNzE0YjVYaWd6Ymc1S1ltcUVZLzNlYlByVVFjUVJhblVGeUh4bElkZHY4bkM3Y1VtVEVqU0ZLQVVxOUdTVmd2UUlxbFlDUFh1SG5BZ1dMU0ZTUEVhTzhWWDhqVCs2STJJNTBKSDZRcGoyYndMNjlSTEVDUlZYS0crNFBTYUZZSTVXRklQVXBPb2M3VndXTE53UUVFa0ZPNGF6SjlZUlpnRnFkWlNSWFhQUDl6LzZuLysxNzRWdUJOWVpzL3pnWjcyQVF0SVZpTnpBekZrSXpnZS93c3l6d2RPZi9UNXovTDVoMi9mN1I4L1BKN2wxWnR2aDU2RG9xQUdZRllibVphNTY0aFVpTzdOQXF5OXNqQ3lSV0lSRWVFdFIzUWJqUnlVK2s0b3RHZWZJVGNFSzlVSlNoeW90TkVrQkZqUkxpV0pla2RoOHpoV3N1cFdwOHBMaU1qeFJ1YmRHL3J3bUYvLzRrdjUvcnR2WC9WbWtRWXB4bG9QTW53M2ZmR3YvL0RON1p2cG05Lytab1R0RTVjcEhudnFlZzZJcGxMZG5xYWtoc1JnLzVwRXRXYzZLbnVCcHVUbVlJL2lUc0lVSHh5QmVkRGlpQXJFMDgxT0tIcFZFSk1TSm1DK3A1MTg4WFFvVlRKbG9mTjhma3d2ZFA1d21IYmIyd0I3SUVyV2xOSXR4bVNHV3FxR000aFZoMWRmSGg2ZXZ0NWplSjNQMy8xalBZY0xSMzFpemFOc1psbGM2c3FyQUo4L2pxUnR5R2U2QUorZTEwckVhQnp4SDQrMlBvbzNiSnBhK2pTcTloa3JTNWZZbDZEVFJEcWV5MlloSmt0bGptaTZBMGpZNU9YcE1OdDREa0lFcjdPdkZTTE44dnQ2dm9XQUhreUVFT0tvOHp3a0NqTEF6S0RDTGpyMG01emw4aUdBS1dtc1JQZjJMTVlxTTE1R2NWaE1BODJlWjhHaVVDVU9KbUpkdnFJSXkrSkllc1p4WWtsNm9OWDJ0UUtJaU52SnZlUUxBMHlFU1pPVGEydURtY1VYdFNoSkI4UzJwekxOcFZTdjJqNjZ4V3hSM1lSbFhReGNaTEZDSEE1RzhQdm8vdjFmL0VMTWJhb1FUb2N4ZXZFNHFUbUJPaEhSV21vTmNlMlpmUDVEMTV2WGJ6OTcrV0w2NFIrK2ZoZ3R2ZnB2MzlTdmYvMFBmNy9aYjNaYnJqN1d5eFJjRmtOalZMUEhnQ1FSRFJWaFRURWdTRkxTSFllblhtT1k1OG9SVnAzRngwTE1tclR6S055TENQR1FGSFVxRG5jUkFIK1hoKzJ3dStPL20wNHpOSFZuZUlDRTZzTjgzT0h0bi94R05qRnZYdSsvUGFUaEYzZVkvdGQzUndiM1hmZG52L3czYjgvZi9mcC9xY2VUN3JuY3M0VEhtYXNrRVFCNTRsMTJxK2FjT1RpTnMrVjlIMWFIbnEyYWlWVkt5ZUdrUWl6c0loakJ1OCtlNHZIRVNYM09mVG4wdTl0d2dndUlGVS9UcTllN0pBOVZNUFhTYitianFSNXVoaDFEYUJNQXJGYjNySkp1OTkvRjZWZ1RBallCckJMSDcxKzhmWHU4UDA1SG9idlRnMlYyZ0twejh2bm1odGNoVUF1WWE3dHB2cHF2MEdWdDFBaU1jbDA5TCtRT1dzeXl6UGprZ0hsdWd6OGRnK0ppZUcwcElPNFdJaUp6TnA4Zkg3ZWJuQ1FBSjJLRUtibEhpSjJQMDNSNEtsVExvblpxT2NmTmtRandQNk5iV0xpWmJTT3NaR1djZHNMR0NMZHF0R0VTNnJiRFZ2VTV0NFdJa3k0MTdvVlZRTUlMM21ieDY2LzJpSVJnQktRVnlyR1FOV3FMU1h3V2lGLytRbXNLQ3kvMjNxdW9YN29xc1pjbUFPRU9ZV1ZSNWRZRFN3aGpWbUtpbkVrbGRiWGFtUWtoS3UwTHdGMGoxbzNWK3Z3U3MwUklWaWQ1OGNmLzlhL1N3NEVpenBVUWFacmNjNFE5VVZKRUVEWFRqN3VLemF4Ykt0ejE4MzgrL3Q4TTdtL2ZiT3R1eU4zcmMxS3VzNTk5bGxJZ0Vpc0V6ZDBSYkhOeFRqbHhoSW9vaXdhelNPcHlNaVh5R1RiT0Jhb3djUktmQ28way9aREpJWm95SjBFd0hLQmN6c1VEeU9NRHA3N1BiOHI1UEU1VDdKa2lnbWo3YVAzNEQ5Mi8reXJNZk9wditYVDZwemsvM0g5NCttRGJsMFBjL2RGZnZQbjYvL2lyZCsrSU42L0RUaEtrU2VERmc0VE1yZWJYZDUzU0E3bUhTZDVSMkhtMjByRnFKck5hYTlva2hKTXdVNFFJdkNEeDdYREhoM0dpVFJsam1ySGIyR3lWQ2VyRTVjdzk5N2RjcUp3NDBsYUg5OVBYL1hhL0hTUnVDRkZPZFJ5aXBwSTJ3OTJwems2cG55a0NaTlNWdy90M3J6ZTlsYWREajQzVmJweE5oRWlTSFhjZE1RaXNLdktjSVhZdE1TQnBxajlwQ3huR01uVmRIdHlyWVZFRHpGdy93S3VVTWxiY3kvVnc2OW5aRXkzQnpJMVNIbkpmRGg2UDMyOTNxbTVNSVU0UlRFQ3RvT25wNlgzTUV6SXQrZHJ0Q1loTHhzaVB6VGVYNTBXV1FOQUFzeEpIbVlzdmJ4ZjM0QXdTSFlaTldnWW42MTRzU2ZOdFhESkY0MktpWDRQTjJ0UEhKS0llaTcyaURZdEZuczJhelBScE91L3FzWHpPS212TFgySVFXU051TEVub0xaUXBqRms1TVd0YmdqRUpPUXRDaEowbG0xZFRxK1lrTEMyckRsZGZqNTh2Q0ZHbkJNZXcvVy8rK3o5NS84TSsvL0JFeHhFMjYyMW5QcGVRTHUreUdKeFNTZ3hJemgzWGFtbHpPbno5YmJsLytLSy9lYkVmK256enc5Kyt0NzdMbTVBU3RVeW9OVlFZZVpsZE9oR3BGbGZBV1ZtN1pRcGZOZVdVaEk1RElsUXJUMFJnU2RvYkJEeG9ybGFEdy9zSWNFclNGZ0xDWnJWNldOelY4MWljNkl2Ti9xMmZEbU9sOEpBdTkweDVudWJ2L3J3VTV2bmhrZGwrODVlSHltL1N2bnoycTgzVDhJLy8rZno0L3JIOHdma3cvbkFTQzR1MEhRUU1ReElCczUxN0VneHpxZFU3ZGtsbXpta3kyL1RaNTlhVlVUaEloTnd0d29WUDlyVFo3Tzd1SDhaSDlOdVVkbmRoVnNFTVZCRXZqN0xWYlNwMnFsUzl1K3ZIK3p4UHMzYzMvWXM2VGFWYVRHQm9MOUtWalkybGF1TWVHSDd6K1F2NzNmZDNkN1V5akZTUDFTRENaSE1xRC91K1daSTBTVlB0UHVOZmw0RVVsQ0RONS9SczhBVXZnb3FycWV3U1IzSTVrYkYwaWJMTW9lT1QzZEp6M0tCNW8wbENwTjl2Ykt5em50Ni9jYUNhcWxTT0lJWmhQczdsK09Id0lURWE0NXFFbFZ2K0lqNVJibHpXeWxkeHVDRllJZFFFWW1uZ2pYWm90d0dWcEtIUGJRQXZ2SjZ3U1VLQUZiZXhUTjNXWHA5QnBLMExaZ1VCd1E1MkFqTnJTMlp0T3VjMS9PMG5DdnhZcHVidERkaWFkUXBDNHdHdFhCNGdMUXFMcXNSa0toMjExNVcyZ2xnMU5JZVZ5bldlZzRVVlFVS3FLc3R3NzVtcmhZaWc0VXgxMXMxbi85Yis0d2UrR1Q5ODNjK3oxTHFobktxemNHMUphSFZsQmU5dnQvWDlzVXJkM3N6bmVmaDg1eno3cWV1K1A5eWZpRXFOdnRkZXUyeFd2T1hDUmp1aFBBUWc3V3F0ZWVpMUlScFVRRXh1anFFYkdHVDVMQlMxdWxvTkVVNUpjN0VJU0hVSGV5anhGTUdxQkJvMDV2S1BJcEpUeEgvYTNON2ViTy95TitWOG5uZzd2TmpiL09JMW4zNDdaSDk2T0JWakZHeTIrdTdWOXZhejF6ci9sL3Z2VDNsMzJ6OU1vMWwwTWxaTFFLWkIxT0cxWnZINUdJa0Q1cFVrajlBd1V1R3dFQkhLMHJnTnljRXE2aExCT1NmT1ZGQjExeDJjZUhmem9qOVlEVkVCQ1ZNaU92WTFOTkcybTBvSkpsR1QvbWFYdTkzNzhUQzY1UDRoVWFYZGpyNnIyT2xUb1FYTkdINklidHZMWXhlTUNmTHltOG1IRGs0eERWUmkyRS9MNWpjdUFiZVhvM0dOSjF0QVdKZERjejJCK1JOQnh4VkxxOG1lVnQzRmhROE51VUwxTEFxT1dnd0FLcXVtM0E5RlRweW5NVFhHZVVJUUpLVzVIQjd2ajZmSHB4bERKMEt4UEk3dDRWbndqNysvZnFZbFNYZFZnRVU0QnpOY2hDRE1yRm1KVXU3MDR0aGJwYVJwTmV1dnV6VUdZcEY0TjhYS012WHR5VTFyRlhBTFBDVWlFU2pqOGpKWm5BM1hSQThRK3dJSldOdFdSb3R4NFVVcHRYNWp1b0JqbldJcEtFUkRoVklFczVBenFWTFNsTDFVQzJJT0VFdEttbHJFMHBYM01jS0JDRTBGTWp4OVBlM3VEdS92djc4aE1QYzNvU281Z0ZHWkFKZ2tYYkIrZm42OGo2NzcvTis4eHVsdytzNll6ejk4VytEVmh5UkExNUc3MlRiQ3c4em5RSXMvTmdlQmRlZkJLU2xIR0hIcWtyU3lPSVpPelJGeGk0amV6V3R4SnVqc0xhQmRpaXFKcWdTRjEyQlI0bzVCTUdWUXVMLzIweUhkdnJxNTh5RWRDM3pjcDhsWjZ0KzkySnkvUDI1dTdzWnArNUxIOHk5UzB2RnZwdE1QNmZZV2pNbGxseEpISkdJbFp4NloxYVp4eWlSQjBRbUtXM2pwaElJSnhpcEtOV3JNeEhBSU13VkxadGh5YTJ6bXA4a2w5MXZ3OXZVZHpaTjdLN29TVitySWp4RWJlTDU1cERJaDNYeHhpdTdGMjg3dnZ5dVQ1MDNLM2VCektJN3Y1clJqRVhWemlCRC9RWm5tTy9Wejc4VW4zTHo0MlhjSGtIc21nN3JuYlhnRUFyeEVXRitGTVRSOW55OE9CbWs2NlZYRGY2RmVYZHVTOEtNRnpoclh4MFNmMkdIVy9GKzNZc1JFckNrcmhXTnZSei9SM2QyT1BBaVdvbERNRC9mdkhoN081N05MMzQ0cGpvQUtFTHBVcU5KOE92ajlEM0FzMHNKV2xsWXdoM0hMVjJGVkpkV2hTMHlzRkxFWWk0Z3B0U04wZVUrQWlkZjI5OUxtdHhmYlFKWlV4SnNJRFlpbEFwSG5zb0N2N0pJWG11VWxFSmtGcmN3UFloQnJveDBnc1FpVzZvZ2FyWEp4dFF1VVFBcGpCUVZUVWxGTmhzSE5MT3JTVTdTME51YUc0N3ZFSW1Hc2FSYzE3UC84eGZEKzZmWDg3WFpEQmxNU0psRXkyekNjQTJ5V1diU2pwNWtldnp0MjIvcWZmczNkVFU4MGxoZ2ZKNVNjdThUekdXR3NtNjNjaTJpdzB5SlowcUFBa2ZCZWM4YytsVzFZU0Qva1dZUXBBcldXY1FyNDFxbmJpUlVyRlZacXpGMldBS0NFc0JMUnVJVE1VdW9wc1Z0UE1KS1V6eUxDMDRmVEx2Y3YrOUhwMnpkdjdwNytZNEcrNjNwNWdmSFZ2cU5xZHp3ZWE1cWZiUE1Mb3BSd1BLWUkwc1EwYVdLRjBmdGhtMEdCV1NVb012Y1dZY2JhdVNFUndwbktaTVZyU2tsVjVGUmRRY29scWMyejBRR2lBN3R0VkhkdlhweVA2ekZXTmpGSEwvNytERlZQdldhSjJyOTZxZDg4SGQrazhUNm9FMDNtWFQvTnA5UDhmVDZOcmxNRncwTlorTy9mM1BpaHZ2M3NtOElwajlQOGI2VlFMWkpLclhrZUMxVGNQWHhoa0QvN3dwLzUvOHlYOER0bURycmcxWm9GRmM5TG15dVVEdUlpMFd6M2R5ejc0TlVHNyt6a0NKZ1ZaeFZXVlNHdm1uYk01NUNiVjF1YlozUHJ5dVE4Zi8vZDQ5T2gxT2g3SzhRU0hCVGdZTVNLbTFxWkJQOU1EMHdVQVJFaEV1WWFUT0ZOcFFGbVVlYWNWWm4xRXUxSFJPQlUyNGdicVQxK0ROVWwwNElBZHlxaUFwQm9xS1RlWW1wRE5hSm9lN2VXWnFHNktNVFkxakFsZmdhL080U2RSRVNZVFpwZG9xNGR5QlZLakRVb04zK0poNGlKNWhSZ2VGdURFNmlsblNRUHpMM1h5TjBDQkJiU2xwSW5hOEUrVEhQdE9qNjkvR2I3bW44emZYWjJPTGE3alZHZ2hUMVFJUllTT3lNYzlQWjgvMURZVG42R2pUYnN0NDhIcE56bFBZTDhqRHpYdE9rVHZITmp5ZVRzTFIyU092VWdUU0U1SWJKV3l0Mm1VMVpPREtzdTRJSEhxZmJuMkdVbXpiYzhQcFNnTnI4U1lqaXhLQ0ZKVkFzYUVUNDNEemtMTXl1UnFNVDhRNy9acEczMURUMmVqMEVSSHQxMkVIdzk3RFpKaVZrZXZ5MlNUdDNOeTEyU3o5TTBQbzNBNlhFM3oyTGNiMjQvZkhqeGFsc25aWmpYb1o4a3lpUXB6NldFSnRHT3liMmFteGZWcEpLNHhoUkRMc2NpUUtUN3Z1TUNaNVlzWC8vbWVFcmRJRE5VKytxUzJiR3pwMjdQOC8zbnh5amxrR0szY3gzTENGSTcxTndKcGNmNGduNDkrdTdwaDV5SXVFNHB1ZUhHVDlxbGN0Q1ljbmVUWXY1VCt2dGV6ekQrc0w4OWZmamowdytUVnM3aGw4anRObkRScTEwbGsxeHdzYkxFZEVPSXdmNGpncHRmbVJ0QURGM2NoaW1hTE5pWUdSR1FjSE1QTWdSUnU3OEJpbmo3emV1NzArRHpiWG82VHltT3lXMTYvODJIK1IxNXFjbzZNRlFDQ0ZGbEV1WDIrN2xGa3pGTHl1MEJhOVZvQ0FJVXhWT0FraW8wSkpHVEZrSklKeFdhUUt5RHBLNVBRcUh4TVhVK3pRdFhjdlZicHN0TGJoVk50YTVWbHYxdzF3RHpUZGltb2lUUGxMRkdRZm1vOTdnYU1nVWhWbTM0UWdmQWMzQ1ZMNEk1dm9LWlhCQXpJa0tpd2dST0NORUljQlJHeW9rWC9DV2VNZjJ0cEo1blNIbC9UMy94cTlQZnowcWJxQkV4K1Q0QTh4cU5DRTgwcFN4RVJMbmZiSTA5T0R5WW80Wmt3SWc1QU5Fa21ycTBHRWtNQ01qaUkySzR1YWpPeEVZQjlBaWJLbEVQRnhtMkhLTVBlN3EvVC9IME1BNTl6eXpiL01McFlVSENyQVpKZGc4SFlBaVBCajBUWnFZQkRiRDRTcFJxdU85b2xwZmx1KzlmU3M1OUR2L0h2TjF1T3VHN0xmZUh4L3N4TTZmaHhldmJMUHNkMDN3M1phaWZ6c2NYdlUyUGViTjlxTVVWYkRzV1RiQ1pFcGxiVGxnSUtTMkJZRVg0RjRON1VGQ3dWMmRtT2VXd0tNWDNiaHdBY2x0VFNOUktkWnZ4Mjl1ZjdkOGZKcGE4N2J4TThRR2xpQVJOTXIxOGkzaTh5NWtOS1Q4VUZrQ1ZocjRlVlhkYkdaUzUzLzdnUDAvL0Q3OGRKZVhFWWY0MFFoRml2QmhaWmYzY1BsbnU4a2ZUNDBzR09INmNrM0tWZ3JuT3ZNRHdsczV6dGZSeDk1WmlSQ0xTYXVDbzlQZHZmMlYyR1AvNjVWZmJtL3VqZXprOEhwNE9NMWVLQnB2OEpFOXg5UXFzNmRjQUlMaWFoaU1DSkNHTmJORk9QTlhPRmJWb2JtVWNpK2FVOUtjay8ybThuTzd0cTE5U2lKWnp2eTNRbXhDRGhTVnhrTU5iMW5DTEh3b0FvWXVJZ3o5S2RQMW8vTll3a0ZobDZjc1FZUmw2MjdLV1dudHZhenhlTVJDTEp1RUlYUzZlSUFnSlhRM09YVkxtSUFtRUVNQ05uY2NFNU1HaWUzSDdaei9MMU8zSzlLSTRrZHM0VWtCWTFKWXBnemMrSnU3THFWSVNjb04ycUo0aWszbEVqU0Jsa2cxcmc5OHlSUVZyN3dZUmFycFBJcEJYSnhhSkNHWlNEb0t3Qy9XcGZIaTRlZjNMeDdkam1ZNkh4NWNUaUVYcDVncFRqd0JwQkJadldBb1BnRVZZbUhVSjVkdEVGSThncWQ3dDltbno2RFJyTU5RUFk1Y1FONXJ6WGU3SGZoNkx3NC9UYnFPRU9nT1N1N1JCSVRwUC9YNTNld2Fya2h1bEhOVkhGZVlJRmc0S1FKcVNya2tqaEZBcDNOcWJQQ3BJTTdOcVBjMlNLcE1FdVRKSVNJaUM2Mk5veG4yM3V6VTdUSDBhVWhsSFZDODExWEE5OGV2WFQ5UDlUYjVCUURva1ZUZlJjSWV5bmJkOXNzcEQ1dm5GTDU5K04wZGlUVnlycCt6aGhCWURqOVZTY3gxaDlOTnVwTlgyK3VPaEtsMm5wYTFGTTEyQ2FCRndkM2p6M3lHeHFLaXdpZ3A3c1QvOTgxZnZsZExYLzlmOTI4ZnZuc3ptRCsrT3Mwa3FCSC9tUDEyNDgrMkg4TVhCZ0NzUzFMSTBjWWNrRUhQRDF4Q3hwTFRwSlR4SWdQRGdsSHRWMVovNFBsTmRtUVZMUCs5THh0dlM0Z0xTMUdseE1md0R5UlVzcWt5QU05aXZtdlAxOVhnWkZYN0VISXFQOVMzTHozQUF4dEpDMVpabVJkdmtVU29ScTRhb0FDclNHRWhLMUVkWG5EVzNGTk5nUlB1eTdpMlJyWFo4UEczKzlMOTYrK0UzeGFwdndpMFFaZ1ZPZWRnTzREQmlsazRZQVpMemVEeVpKSjJkaFV1cFdaTEFTUklBVVlLUWV3UDRhVGgxbVUyQ0ZyK1RJeUlMRTJ0TzdrNmFsRjFWR1I3bnplMzArTTAvOVpMM0wzaWM4R1R6YkZEZEl6eWFmdDNOQTltY3U3eDZQWUxXRjVvdjcvT3lFRkZHeGx4ZWZ2bW5melZOczl1UTNrNlRWN1A2TGczYmJiL0JGQkZlamgvMjdLSWFPSlJLbW5PYUtZV1BtRjl1cEFhQlpvaDJaQVdpSkREdkZ1Q0ZMdGNxclR4dWR5Skl0Tm11YzU4b2dyU0xDZ0dKZzBSRG1HVFRUN1dZYk1kL1N2SWlKb2pDNXRGWWt1WnM1UTdEdGp6V3hDbDNOSi9tbmtRTkVYeWVOamZaUDFDVWNVelUzY3gvKzlYLzhGZC8zV3VBWU5VM3AwcmRkcGlQbDlGd3E1QnhGUzk2RFZtVVoySEVSMndPL2tpNzhZbU1Hb3N2dUJGajNNMFJhMTZlcXFvd0NUT2dSUC9oanc2bmJlclAzNTc3TXRuNTBaNk9RVzZ0aDFhKzdLMzQ0ajRFeVVYeWMzbUFMOWRWbWNJRDhDQWxFcktXcXNoZFRxbEZtTGlUcUdaUi9xbFhWVnJwSXN2cHlYV2grbUVGb3d0Uk1LakYvRW9EaWtnelZ6Q2NCRmhVTGhkSU5IMGtPcjFFbnJTL2UxdysvM1hDVHM4aFVhc0FocGFKZmpUakFCRFNvMDE4R2gwRm9pcGlyS3FMRURhYStGSTl3ajFBTlpoc0hxZjNubzgvSEc1ZTN0Y2FRQVJIdFJrZDlZUUNTWndJUVp4VHhySFdsS1NQWW1Ta2xraUVLVHB1Y3ZXNldGVTZVVTZTdTBJZUFhQlNtQlBIaGtHa21yZTFHZ2RJS1RobGxZZXo2VzR6bm1lKzMvYmRiaWVLOCtQWk1TNmZlS01NQXFVYTFjUWhpNHM4TGRtbzNPNHFLa3VTVEFqcThWeGZmM2srbkp4YXdnNnpxUHB4UEhTSnB6d01hdU84cFVKOWx5VFpOTHZYR09BaGpPbW9tY1pLR2lTZHB2Q1pkT2hwbmdXQmhkdTl2SVhEd1h6WldJWUtFOEhVb2hwenRLU0NJQk1HZ3NtMlF5NlRwbjQrNmI3ZlY0U1FlbkdYWHZzMGg1R1diejlzZnZsNlU1THdZVUtrZnJNUFJuVWhyK1VRODZudUNjbStPYi80Z3g4K1JCVjNxMTR0K3YxTGVUcGV4NEUrWnpMODZBVEdQM01DNDlPYThDb0NQSlpaYk1ETmZabmtDck5xU2szVDd5U2svZE1wLy95SFgxZUxSeFRnNmI1TW5oV3c1cTVYWFFOdkw3ckF0c1NSOWxSOUVzMUNUTUtJY01JTWhncFJCSkdJUm1KaHB2QUVEMUpOdW53N24yb3hreXdPWjIvQk1id2EraGRTUEl1c1dhaExFT0VDK09RV1ZoYThSRWhkcGNkZFJ6SmZuOERYaVJXNGdubzJ0MGxMbGJ2S1JwSTEvWmVDUW5TWk9hZFdjeU5ZaUVsazRRQzBFN2hwMlNOSWFEZE9xWnYvOXNNZi9uS1lqa3JmMXd0SElKSDJ1NzFIRzA4RUFTeWlVeTBXaEVpWWpEbm5GWjFrS2d1Q2dSY0pxaVJtWWJkYVBBRGpwbmRmbkRMdTdsQVJrbHFNdXo3dlJodWwyOStOMDN4NjlEemM3TFlkWWNLNEpPQnNDZUh1TVhibUNFQW9pRmxhNG53QS9ScHJLUXpBb2M1ZHJyLzU3YitpamRZNlQ5bEFRVUU1Z253QzJNclVEeS9UeWFaU0t0VnQzaERzZkdJSzU4UjIydlFxWUtFd1VSRm1aMG9TSlJxVFA3UjFOZXdSMGJvM1pmSUdQNkVBcWpzMGFadVZjRk5vQThUamtKVkhkRFVOWkp4ZmxseUJ2cHVMdG5yWEdJZGpmZm55TGQ4ZlJHMTZRcmZmcVVnaFB4MXE3czByaHB1dEZ2blpELy83Zi9jLy9tL2gxVHA0N1RhNUgrajA3bXA5dEQ3Q3k5cndvNm4wdFJUeWt4TVlIeWtWOEVta2ZQUGhCNndsSjVBczRuTVdZVm1TRDZCZC9zdkRIKytKYlgvYXFCL0gweFExT0l3MENDSnllUkFXNDEyRGJRaXY5OGN6b0g3TlBZNWxmQlRnY0dtUEZrTlRTb3h3aGtSQW9NTHJlT2pURTNnOUF4a1VjTDdLcVNBU2FjWUZXYnpUallPNVZ2TkNKTVJCOHV5NkpuNUdpL0hITDd5clg0RjRsa2l2ekIya3kyOTcvbmxoSW0weXRLZ0VWbFh1bDhHYWl3Q1hVRGptYU9VVjY2Slo2MzBtNW5vdUQvUytiTXR4S3dsd1l1ZXU0MDQxUkFGSjJ1UVlKbytuUW9KNTV0RlpXTlBreUp5MGQ0UzFiSW9MQzBVWWs5VXlGVVBBUkppVUJSQUJPU1p3NHN4Y0FiZUo1ZTNORjNoODkvMTg0OUxGWE0vVFUwZHpBUTJJc0FDQ2hWa0ZTdkRxSUhWM01QTVM3dFcyNGhGUXBxQ0lnR3RPWWY1dDdoUERUQ1VoTEJCZ1ZTSE1QaDlvMkcyN3ZxdWtwTyt6UURNVUdYQ2lFRGRPQXl1UjE0V01iMFdwYTYvcEpVZUlpU3F4SUNJNlNVSXRpbTZ4bGFwb1NzeExkZWFDOENDdUQ2V0gxMVEwaFVNVDkxRXRidUZTeDZtNmIzMklramFkcDI3Yjh4MDlJQ1V5U3Bvb1laUVVrRzY3eGNIZjNKM2V2Zi9xaXcrakJ5SHNGWlZ5bXNiSC9aWDlqejZPQU9WUHdrQS9mb1RwazdDalQ1UjdhemhRRU9CdUVjM0oxbDVOcXBkMFE3Q3dLdk1QZFU3ZmFla2V6M0krekRVa1lGUXZia2RjZU8xWEhDMlFyS0pCWE8xb1FFeFVhb0FGU0FERGd4Z2tLUS9iemE3akNPSndFT21TTS9RVERMaTBRQ01oOExZZnZpQ3NWbXhjTS9zc0QzQ0FyK09ScFprV25rMk9rQi83UGk3S2x3c1haU1dQUFQvenBDdVVaNTNXUllPbFNEZ0ZnWXhBcnJxcU4xbVdhb1d1R200aXNFWmJhemxqT3NyUC95Z2Z4K1BUL1l0WEpXbDRCR1ZsOS9tcDdyZ1ppVWtrckZSb0d0anFPREhuUVMzcVRNNWQzL1hSM05pY2x3QXRBR0FiUnlyekhBQm1WVzBCckNJVUNDVVNja0trZ2FPV2Vqd2YzbnoxaThmN2J5eUNpYm1NMWJYdmMyOTFxbE8xZTBtcXpMUlZEWFVXNDRDVExKQ3loZndmRVluV1lIY2ZQVGEzMzI5WUU2czlKRzNURHpkbkptVGxPby8xVExjM0c4bVpYMDd2NzMyL1NiSFpqNk5WVDlXRmxUbDVPRFBBQWpzblRjNTBOYVZnY2xVaE01Q1EwaW81SkpGMkRVUmI0Y0tZaGVGR2pPTjgyek9yeEFoVnQ5VHBOT3JRRnk2cXZyUGRsTWd6RHQvZHFXNzZ1L3hMK1BqKzNqS3E3RGJUY1V4Z1ZUb2U4ODhmK3M5KzkvN1ZxVGlZUFVScE9nMzVOcTR1OWNkUWpkOVRRbitLZDhDek80NCtxUTRYR1ZSNGRXL2MvaVdXUjNTUk9ZRkRKU21INi9kaXZQL3RmWDhZWndpSHRVMjFLZ0tYN2VuMURQb3k3dUVMcHVkcUdFN1ZtZ1FnUit0S01yRm9OMnh1dDcwU1N3cUExOE9Ebnl2KzU5YjBNMnBSaHQ3SXNNK0pZYzM5SWt2UU40RlQwclk2NGxpMFdnRElDY3lxcWl0azlvSVhhQit0OHFLbHZnaXhHak02cm9aWkM1anlJMzZIcjFrMUlFbVpKZHFSTEdFT1lsV1MxZzBrYWkxN2JybE1SQjRnWnVyS2VjYk5MLzZ3ZjFPK3JhOWZialpkdDcwWm9wcmtuTHN1VzVqM2U1MURVSTBZN3oxMTdON3FLUkd5WWF0ZXZTcHA3cnFjaVNBcHdaVVF0UnFFSlZOMTBYN1RNYXNNSWsxV0FoQ1R6ZVh3VkZ6MmIvc2RqdlJpeThPZVJrdGFBNUl6MlZ4WVNKS041R1lRVVorcmJMS2RZNTZOQmI2YVM3cHdWZ21ES0llek1JVnoxdGphOFJ6Q0lGaXdVSmdIaVloUUszSEJkWnJOM1Y5MGZhL3pPTzZJaGFINWt2NGpYUktBL1VJc0Z3clMxTUJUd21ock8zS2k4RlhudHp5NG1vV0UwcEFpZUNBTUwxNzBRcHVOUXRoRlZHRklaZ1loRzIyMnBKVDN0eDBpcTlYM1Q1TW1UQS9IOC9IRCs1RlRCVXVVaXNUYTczZEpreVY4S01NY1BycXc4a3Y3TU83UzFJeXJFWXVjSTF3K3pwOWRMQWtYMWpGc3FSY1dyZk5DbFg2VzdPUFM4ald6Z1RjUk9rMkJodGVUbEpJeXBlV0w1Snh6NGlodTc5Ky9mMGR5SEtkcTRaQm03Z3MyOUgxS1dWZ29QSkJhOWNyRUl0SU5HeE1tc0NSSlNZa2F5eXJjN09UUmNyakI0cU9KU2hxRzNZdFhRNWZib2xNRWxJZWN3RDhKQ2twWGtTVDR1Sk5ZOG9zYkRoQkxCd3l3UUhBcENVaERvQUQvRk1yekoxcVRIMC83MTJiZ09SOTlJUk8xN2xlSVdCZ1FFSEdFQzNORUJLUHR5YUVnbHFZTVl3NFdqd1kzTVpPMEdlaXNQTnlrN2JBWm8xYUc5amVhaFNpb1NnU0JYWUVJVWJxdEZkcWJnWVc5Rk90MU8zQXBYa1gwNHFJU3dOdnVTOE1tTXdkRUNJU0lJN0ZvU2xvTlFoRitORXh1YVhpNTYvVDQzVFluMnRiQ3lEa2NSSTZuSVJGTDdrZVFxSkxObkpNUnhKdklGT3VOVjhDYTRJSVFWbTRTOGhiRU5KRFBLa000TXh5NmJNNFg1UzFsSWtNUitYcC85L2J0ZEo2QjJUMTErYmdrUTJWaElSYkk4bGtMSzlwTTQycnRGNnN3dmhsWFFJdnRMb2pjdVpKdHB2dnVBQUFnQUVsRVFWU1RWcEt4S1BPdE1BSVdpU1VsVUNBTUJHNUpIWm8zWitkT0pKREpqdEZUYkwzT2xITlNNeWVpS0pwemw2RHY2SzdqOGRSNzZvVTBSbXhmaGtOa1htNFNXUlMrL0VsbzJkcDN5a1VUMytRZUFib0dlRnlLMitXaU5yTVFnQW5QWGI4SXN5NTE1bEt5TnhaNGdHYXI3bGd4cWMzZkd3RXdxNGhja1dFV3Mzc3M0Y0MrVEdxZ0NvQzFSTnVYT0MzWndJc3oxVGxyMS9XNXowa1lsd05PZnJ6VVhvZFlLOTF2K1liNFNnektCTC9vcVpoYkVFbzdZeVRXRVpTMmdoalA1S0tmcnFIL0dTTnpnOTJ0aE5DMlJsZHVmLzAyUDFMRWdoMFRvdlp1U3lGTXpGVVlKTUV0cEZGaXZRNU9GTlRUNFdjN3U2a3pGVmdsU1pSVlFPSzFPcnZQWmVCT1d1alFVR2ZrSkZSVnV4UzVha3E5Q01LVUY5NnZSQldWaUNBaGxqS2RuVWhFMithUUNzQ2FleTJPRklwUWdaV1Q2YmZEcnUvZTMrMkxiTFhXR1J4dElISXVtb2J0OXNXamxVQkZTRXFZM1R6QTJwYjd5OTNGU1pRQ1RtQmxkMjIzRER4blZPdjZEdTBRVGsyK2l4V3c0RTJWam9uWnN1eDI5ODF1ZzR3SWo0Qks2Kzh5WWdFOENvdXZMd0V3dDR2YU10M2IvWVVnUWc0d0lzQVd5aUd3VE5WbHN3RlVXRFRWY0ZVeTE1YXRvZWRGblQ2ejVpd1JYMFdBWFhVN2pjNUtSY29jeXN3MTcvb3NMbWI1ZG5odis2NUhBY2Q1dnRPbll4WnVacGdsR3VGS3JQRnhiT2hpUW4vT3FsN1VRbGZCOGNzdmxUVnBDUUVQWUg0K285dnR0ZUJyRjIweUNRczVhb3plM0VtcjF5bTRqU1pZUkpPdXB0blZYQU1DRU9SMVVrMmFOQVdJRk1GeWN2ZGdKaFZtWlkvVXRnMUN6SnFTcHEwa1huQ3pMYUdSNkNkWmZXbFZUcXlsaUQ1bnY3UXA3SEk5TDd0b0VRS3hXRk4rTUFoQ0RJcVBpVnJySEpyL0pVL3djbXdzaGsxbVdYdUpXSktlRm1wMUN6a25STERLVW5rRDdXaXdCalNRZGUraFFRVlJudDU2K09nNjlHYWtuZXBaUmVBV0FaaVM5Z05YZ2hQTzQ0U0FPUkZMNXM2TnhrakV5VWxFUU9HeWFQWllpT0UrejFVeTB5Vktnb0Z3cSt4TmJzQzNRYkhialRVZEh2c003cjdxdDV0OWViSWdCcE5nYTJWMjNXM1Y1M0dxckU2WUkwVEJpdkJuRmpKVEJDUkptSWM4bTh5SmRIRlJyM1pPeFZVODdFSlNZS2JiT0IyazN3NmRDR29wazE2WUoyMDBSL0MxUFJSVmoxaG1MNHVLbUJkWDU1S0Z4WlRDQ1lISXhCZWlLeUxpTVhVNVoxR1BBa2o0Nmw5Slpnd3ZaMUpsRnFFYnBscU1wU3NFOXFsdUFvN1U2V216eitUbXJ6ZTdmaytqYU9xbU9yQWZQK3ZZRXBud2NrcTB1NW8vQXFaZXVSdVdKcWpwR3JpSkdENCtUYkJHaEs4MllEZVA5ZWtsYWN1T3k1U2RwRVVUTTBXZ0ZMZHdVQnQxaFRRNVB4REFVbmt2RHpCZnFHM3RDbHJsbEZMU0xJa2xFTVN0UVZXUlJYcWtTaEFCQzdjc1F4V0dLOXAzemZ4N1Q4WFVwaVZZOU5FckgvYzVIeVdXVWRibDVwRVZnNHIyOWxudkduNWVvbCtiR2Y0bGh6Q0R5SmVPSnBvM2FNbFpKRVNRY0hNN0NJbUhyeUZVb0dCWEZkYlVRb2lKUlNSMENYRUhhdzVNMDNzY2ozUDBNa1dicndtelZ4ZXRFUlFPNlJpQ3NIaXdpQ2txYjBIVnlYM3cyWk0yWHhoZGdRaVlpY0pLblV6Nmdac0VOUkJRVlFBVllKSFVoZzU1ZXp1ZUJheGNTYjZUemFzN1NmME1FTno5ZHA0YzU1cUc0YlljenBSK0oreXV2YUtaV2FUcHRKZ0VVWkZWZFo0czFuY2NDR3doSXV5dUtpeFpIYnFZc3RxTnFVd1JCUlNhTXNjNDk5SnB6T05jYVAyY1czQ2NCaWpRVXY1VTJJT1dOL2FxMTExK2VQdFpGUXBRSUlJMWM0MFFoSFNNcWJnSnE2YWRJZlc5YW1HaUNJOWhzaTVubnpQQlMwcnkxQThkcytNMHUxQ0UxYUViQzNlSnRyM1VXc3RiU3JvZFpqWW10OGh5cWlwZFI1YUlBY1RIOTlqMVdIa1pmK0lTcnJtb0RnRDZaQ01NV3BSK0MwbkN6RHhpYVQxa1ZWNHRHSEpBcGRsdFBHcXBKZ0d3Qkx0N095K1h4SlVsbm15VkhDNFhJcEM0R2VmQ3hSSFFaVGxLSGNDY1ZGQW1hME15QlF1Q0ErYlFqQUE0aUVJYVU1bngwMFZ0eXF1RThzTGZYY1hlUzRqVFF0eWdDM20yN1Y4VEVCR05Sb25uMS9aSHlTOFhsTjgvOHc4L0V6eVducWJkTWJFTXZZS0E0RVhweGlRTGNCNm13VVFxdllCYVBCT3o2S0tYQlZPaDdpWXloTXpBRERpcnFqQjNqZjNJVmtoVndxdUE0R2FWSktxMURpVVFLRGxsQ1hlQVFnbE5KY0xrZ29DVnVWVEtRMCsrRU8vUjlKRUFRaVFKUzR2SEhISjN2OTNFV0x1YnAwSlBMN1pac3hBYzRTcjdUZ084dWJ2QncvMkVPN0tDTUdJUkFLekxIVVVTc0VEV3BCcSt2bCtaU01LbEUzTGlObW1aeExDb1BxTGR1azFhT3pWZUtJK2lYZWFzdGl4SGVhbHZWcEFLdDFKblNicGMzNTlFQ3lpQ0JBaW82TUtTWXJUdFB3U3VpYjBJQW1ScUZwU0ROeGtVYm5PcDU4bTNlK20wUmxUU25HSkR2WGFPSTVKR3puNWttZys2U2Z1TVdpd29LQ0NiMUZjampxcHBxdDJlcGNwemNpOC9JOWF2Q1JvWG1OSWFjbnVocWY0SWhyV0U5UzBaU0c1bXNlWXU4Y295NDZVdjFWYm1NZUJlTFFnTTRlRGxCRVlUeTlPeVZic2drMXR4RUFpUWFLdnpWWVZGVlZQT2kxU1ZSVVRNNFJDaUVHWk9jRUM3M1BkOXRIZDRTMHVrMzQ5UFR2MkZpYmVDTVo2VlUyMFh6RVFzaWdVWXRseldOa3R5Sm1ta2x3dVA1S1B3TWZ6L244QlhkQlE4Qnpzc055OVlsdmZaa2tjRjByWWI1eUJFUUJqcTBWeVNKRVFrdHFDQmh6TjN5TGUzTDNhK25TWWJFM0d6V05Ybzk5bEtoS1dPYlhyb3lJSHdMb3JYWUtrTmplT2o1T3dSY0JDOERhcEVoVXlzVm5OejFxUnQxdFJHSDhGdHpOU3VQcGd6NnNsU3VvRlBOaDBQTytCVThuNmZpVlZVVTQyODNSQ3I0K3l6bTIwUU9kZW9JZ0ozRmxuT1B6QkYxRkJRb3ViRVhId2s1SEFXUWpRaEZwbDZZNnMwQlV3UmJYMEd2QnBFSzNFM2RBcTVLUHl1NGFMRXFRME5nNjZUbjl2OXdFUkV2WnNEckszVWxGQkhMQVViZ3R1T2dFVDExRnJydm9jeklOMzlGSFhLZlI5TUVlSE1kcTdDSUZPMVVqbXgxOE94RTNzUlV3MU9PR3pJWGJXZmpiSlcxdEh5RGVaUVhPa0QrQm0wL2lPTTFVVWF1YWlEMTBjZVAyYThCd0lZYWVWVnRVRlZrcVZiWEJaSlNZUVJFUlpoRGhJQ1g0NGxibUZHeTNLcnJZMlhiV21icFVVQW5CSVR0L2M3aStTdTY1YWFWd2hZOUh3SWtjU2NVRE55UHd6YTRyVXAvRElKK3ozbGJNcVFDQ0oyZkl6aGxLdTRCckNLWGZNQW1VaWJUZ3VLOVQ0QUIvOExKMWNmUDhCNFRnRCtpTG5kT3BMRjhDbkwraWt0eWs5dHp6QVZBYlZrQjBJSUlaYithRjlQVHZyeXF6bDMvUllUUUI1TXhGR3dlN21iRGxGY2hHcFlueDFFR0dadkEyUVZWWEpQeW00bTJTaWlUUUJEV015OWpQTlNic0Y4ZWVWU0MzOWpUVHBJcTM0bHgzbE0yL3pCc2ZuaXE2Zjd1VTgwbld2Y0JrUUVNYzQrazNicGZoNHJoT2lEcEpTVGVRRmdXQVNWTGNwR3dzTWlhMjVvN0FYYUp4U0dwQkZCREtGT2lBT3h3SDJaRXBOYmVHaEt5WXNWSXFZbzRmMmlGMjVONm5NT1hVS1Q4Uy9WMzJMbGViN21uY0hpSXMxaFNZUmcwdXlOdXBMQjVFRXNyc28yUnMyd29LNm5EK1RsU1cvdmVwRndDR002ZzRWWk9VNFBvM1piSFN0MWc1RFZ5bjJXaDIxMmo2emgyckdYYnE0Nm5JOVZmRTF2YnppWmtDdnA3ZlU0TkZabFZWczdoWDR5aVZsTGJBSGdFUmlYbnhWdXphK3UrZGZMY2RVUkEyRSt1d2RFbDF3WE5EbUVyaklQaHBDb0tNdUY4TEdXdENTcFdYd0ZMYnNpTHcrd0VMenArVGc4TnFsanpWVDI2SHBKS0ZzUkVZUzNsTE80em1QN1pJaTFKQzUwYlh3TFhmSUMxNmFobFZCd3NBckQwQ0RNSWg1Z2xRaXdNSEVndDFUUVN3bk9sMjZrRldqYXFyTTJndVBuV3lHdVl5SmJhUVlPUmdvR2k1QXV6ZmdhWWhYTC9ORVJ4QUtDejBWRW1GV2NJbW03R2ttZnVydno1b3RYc084bmpSTjNqSlF4RnkxZmZublQyK1B2UUFtZU12ZGR6RldJeXpoRFFEcXJFS2VVNW5udWhtRWV5WWl6bHBvUkZtcCtZa29WSXNkTWhuYVZBaXc4aDVQMG9RbE9PVS9uelRuY3hsUHFmQjdIMXovL3MrL2UvMUNIMjNqQ2R1T2piM2JTVGRQSXdLbE5hNlh6VWtTSWhBSkNGTXdxMGI1MVlpSlVESnViY2pqMTdsQUZOYktDQjRETmtPQTdJUSt2YlJRQU42WmdGaVdRZ1ZMQ1daU01pZndLK0NzaUVzMzRKQ0hDSGc3RFlvVVhadmh5ZlJFSWNNZk0xZHRPZzR0SWMza3MxUDVZUklkTldXdGhxblBKMi96bC9idTVpS1pVdWgwZVRpUTVadDUwbUY0UDVESGRmNzRaYmg5RDc3WVBnWEk3ZkZ1bG85dHhQR2hscWRJbmUvalZiYXBQdHZGZzVWSnpNNHZuUzZrZzZoNmk0c0ZDM3NJRG1jbmFIR3VGYUVFUXpOekNNWVVSRERjUFFOYklyWXZycURGYWxkbzRPb2hRU2pWUXk2eGZDQ0JoM2w1OFZWaEE0SG5YK2F6aUNpZlN5K3h2eVR4UmFmQTVrVTNQRTVLQ1BGamhScDA2cDA1eks2bjdEYWZVOVpubWxJV1l5TmxCbERWMVRHQlkvcmphb0pTWDNzSWhFZTBid3JXNlJTN3EwMldYeit1STY1S1ZFcGV3bEk5NmpUVmErUEpuZlVUVS96MjljSHNtTHYrdUlhZnRmOGNGdjhtTE1vaklGdDZRcWdvTFFTTWtKU1Y0cE8wMnh3K24wZm1GNHlCUmZYdDM4eis5N0Q3ODdxSGNIVXN4eWIxMm5IclVhWHdLR1pJVjZ2NC96dDZzU1pJank5SzdpNnFadThlYUd4SkFvYlplT0QzU0pKc3pmSmhmd1BuRmZLUUluemlrQ0lVaUl6SkZGcnVLMWRQVnFBVkE3aEhoN21hbWV1L2h3MVUxOTBnc2habnVoNFpBa05HUjdtYXFkem5uTzRuZFZOTGR4T3JMWkJ1MzQ1SlUzZDJsbUxzd2tkVW1mWFkzcXg1d2EzS2hwTWZkV0phcVYzZW94MFBWZkMzanZEOThQZnp5azh2M0grN3lRTFhvYVBYOXhMQlMrNGNFMTlZMW5aZEt6S2V3VENaYmVIajI5SGQ1WUJpMW5rdTR1aGNGL0VqQ0xwS1hNSmVrZXFZNWFyUFE4eHNWYmQ1MVZ2bWM0U2thNmlpaVEzcXVqb1JZdmJsTlY2RTY5N3VLRUNoaEEwaDQzQTZiVVhoNU1tenZQK3lYdmRNMjdXN3k4bW96YkxNdWgzZDRtcC9XL2QyYm5TNDZpRlVlY2g1RVA3MlYvSEs2TzJnbGVBSWY3dlhsOUUydW5Jak1lSEFIdktWNHhkUGxiWnZVUTB0V3ROSzVZYWsxYUFqUk1jT0JXczNSbElSTTRiZVBDd0p0U3M4RXNGdXA1dXpFM29uVDZGOU9EOHZ1aU5aT3VRMGtLNi9JTnprSi9KbFpJQlFWdEhOU09GaVRTbE4rRFpSeVRxckNJVEJwUW1rRG1QQWRWT2swbkFVYVI4c2NENUczdjNnTUR4aHRMMGdBd3dJQUVtUjNBclZjODQvSDNOdzUzSHlLUS8vTEkybWNpYzliMGtQSVIxdStNRXVUaHdWMnZqYVF3S3haQmVSaVlOVFpSczVKOTIvdkFDbVZxWHp4OGduVHpkTnR2dnZ5M2JGQ1I3T0pSaDVxelpuSFlWdm5lVS9tbXFrU0pkVWIzOTlYZ2s3TU1CdUdtRlc1QzhUTktvYndLOE5paDBBQ1l0R2NRZTdFak9yTFhJenR3MmFqeDJuaGNudnoyZFhkVEZNcHU0RVBSeHN6bDByYTl2c2t4SUM3cFI3RGN4SytjbkMxcS92dWNydDcvKzZnZzFJTnloSXBrUmRubWpVRm9vdGdUcUoyRXZxRENLVE5hdTJQSTFnN2o3L3RSZHZXVTJSVjNtdEQxb0NFZ25rYWcya240ZVpvanR1OFplRUZUSTdsU0p5eVdMMFl0cU03RHdzRDJHMnhUV25ZcXZwUGhubnl2RXQvWHNTSHJaWTdHeVF6RFpjM1daOThOUmtiM0FrMDNyMTk4ZTYxYm9xcVY1ZDA4cFovL0xSSm1BTWExSzZkVGlKbjBEcVF0VjA1M0x4YURhMDVkNitReEFLei94V1VpVkJ0WGl6NEUrM2Q3VDRjNzVpZm5rYmZaTTVuMkM2bWxmbm0xS0FBNFpnMVlZR0RjMWVPQlBaVk9YR0FHcGxnNHU0TU4wak5WVGtRcngvVjBvbjdzcTlEdnVEdTYvVHBaTzFsUlBRdkNDNFcyNld1WkR1cnVNODJWaXRHbituakFkY2pnZ0o5cDVBVmtVZlQrY3Q4VXFMREc3RDdFZWN2MGtxZG1ka1h1Qjh2Ymk1M2NqODl2WlhYMzB6Z0p6LzdpVTA1Mno5KzgxcDJBL0ZRSXNZaW9RQzgyWmJqMFh5cDdiRjNrRXl2aHR2UktlVXNoSGxOWW5Rejg3alIzS3NMcXh1Y0MwVEd6WkJ5UGRDWTl4K2NvQ05VOTVJSEhZdi82ZDJUWjFmYnU3czlaZHNKS0RHeHBnQVpVN3pBSjZ6aUdWdWluK1FDbEZKaG4rN0dONGNsNXh4d1FXUVFHU2s3b0VKZWlRTnFJT3ZQQU9DTVJHdlU3Ym1Lbi9qRVg0bGt5QWl6bDBadDdHUUhGQVFOL0xIdkd6QnE0aEhxTUFwV2thVHNzMkVnZXVQSHQrL25pMDNpTWdGaVQ2M2FNbTdHVGIwL3p1TW1QNm5Ua2dxQnVIRE80ODRHOFV3bE1ibVp1RzhPcjM5eDkvcVdNNlA1NHVOdnFLdlVJT0lCMmorTHI4aktJSXd3Vm9FZk9Ya1RlcmdYcitZZWVTU05uUkNMeWc1WWRXRWhwOW1XR0hXY2FGeFk4M1N4RWxuanRWdFRkazlSWTJ2V1o4eE5wSm5jaXFqQ29lb3g4bzR4bDdiNXR6c3BUTURxQ2plWGFHOGZZWEZQU2l5Y3JyYzRveU1xQXYzVVdqMkUwdCtaU0EvazFKWGE3U0QrS0ZlNTV4cnlXVTdhWDE0TXk5bFY3TnowQ08yRXB4UEpMSHF1TnUxSFM2OHdFaUVXa3MzbGJyeThUSFpNdTNsT1R1SzRIdWEzWDgyMDVQU0xvVTZtcnpsdmFCaFNKcS96c2VDb1Y1ZjU4RkF3cUpOWStiQjlKdU5uOG1ZRVVlS3lTRHliVExWVWNCSnlFSGtRc3QyWW9YbXpHVEt6Sk1mODhFRkZrNExwZ3FhcVFQM2s4T3J1OXNLVHdvODFTN1l5dTFHc0lpSlZ1dDEzYTk5RUp6WUtFem1MMjdIZWYvM2lzeGRmdjVveHhOZ2dsZzBFRmJNOERvRTlFYmhyKzdBVUJBZ2FxSmk1MHRrcHNYNDlmRnFxZWdRWStPbGZnWmlvc2lvcnJSQi9rZERYV0tzTXZYODlBSkdvVmxHejZsVlFUVFliVGFNLzFBZFp0ZzdNaThnZnRzTkZxa2RjN1I4ZXVJNzBWT1k1TSswdXQ0ZHk4ZnpxZ3pJN2VhMXBQbTZmYllicFNaa3NrZG5NVVYxSzkrWTA3NjAzNVo3UVdWYm9JNVZXUE51cEdRY3JWa1dYU1BmSU5FME1XRGlKd014OGd2ZU5EUHIxMS9hbVRUc1NYMTFLOFlsNC8vcmFhZmdvMFN4NFc4UW9zNlFjaFlLTENDSEdscTB0Y1RlNGFGUkY3aFcxbHQ3dWZMd09UdElPcUxMQ1FOeWpzK2xhb0RYdlFDSWVtWm5aR1NDb3dLWHB5TmNRMGtjM01OUGpKcGpQSlczMFhRczZPVmQzTlBBWW9TV0FuMGo2aUQxWk00czA3d1ZZeFZtSHl4ZWYzZzVjN3Q2OFA5YjdMNTJVbCtQN0xhcnlQRzkydDVjNjMrMkxjWktzdkdoS3RyeGZpaHlXcmNzd1pLM1Z5dkZ2ZnY2a2JwNGV2dnhQMDFSSVBjS0pKYVZDVmltSjFQQ01pak9abVlya2NiTkpUSWVMN2VIK3VBelFhTVRIZVM2REF2a2lsM2YzT1czaGRWNVNFbCs4KzV1aU9DZVdEdVhGeVEvWFQzNFR5V3BXNTNKOC9zV0xWMjlERnlac1RIQlRKQ2VubERiM1poQTI2M2orMWc5UzdWNjJ4dUpId3k4OWhzQjQ5Tnh5eXBhMFRodU9jcEc5dmNBNHBYaDIrQlNhMTdLeW1ZSkhGU2JPR0hkWXBnZTUyQ1d1OE9wcHdPRmgvbkIxbmNwaWRKTVNtM0c2MVErTFQzcjVTM3FvNDgvK2VBY1NFYkt5b1RjUDI4dXJnYXhVWXE4Q2d6YWx6d3FPNGNpNWJSTzMxVlhWaXYrNFhPS1NpcEFFbU5jbUxJanRVUWo3Q0NHT0JhdHMzR3N0UzZ6bHVGVVpQZGcwaksvTzZMTm1FWldPWmxoMzBxY2JtRHVxcXZsM1lBdVNaWkVtZitEMUl1VEs1T1lpbERLM1dCWXpOZ3ZGYTh5YnpsYzFpYzRXOXUzbkIyRTJOTy9jVXJkakx1ZXJXajUrZ3NHbGk3YjhZempSeDBPc2xnM2VnSFhmYWF3K2crNElUcjlvNXduRU5CdkJ3bzhuZjlWL2hVeUhkY21iNTU4L3Y5RFhabFZ2bjZiWGh5WG5jc3ovOTU5ZVhLSlVQQ3pIM2ZVV0Q2MXRFV01aZkJ5NFRnL3Z4cFJITXpHemVmbW4reWRaZU40WFoxUm5jV1lDUzRRS0c0aXFVVkpCbGNnclRTbW5PTXpjNXFwRElnS3FtMVVBbE5NK2owT3RwZTRjUkhYQkZRTDhhdDR5Y01sNWJUYk9rOUZYMXd3a1ovUGJkLzl5LzdQYkY3cVltYk53WlJZSHdVUXcrZmJDajR1dDhDUzBjVE16NVhVaDJveHBmZFpEcTcrVDJVOVpZQzN0ajdUVkJ0SVpYZTJSckRGRjVOU0RYdGQzT1R3aWJKVWw3M2lxQnFXSE41Zjc2OXV0YWg3Zjd5M1pmTmo1QndKcE9tSnpzYVEwK0poVXltRVpiVHhPdTU5KzlSV3BLS3hBMzcwZmQ2bThyUldTeHMzVmZDd3UzUGJDM0pBMUlDZUJROVphMHFQRjZIQkVhTmM5V3dEcmFuY2pVS3p1K3hVeWlESkUxR0YxTGlVRTkxRTlyaE9za3l5dk8waEVWU09XeWMvTzMwN2hXRTlONmt4TitLeE9HNkdxTGVqTFRxWThFUkhSTEpsRkdIQXphMmhkaFdWcG82eUd2MDFuc3pvbVpySklVR1BWb0NFcDNOdGdVZHFBUzlaRUNqRlg2cVpscG84Y0U5KzZiWDl3SDR4SE02d1RhV2NOblF0V1YzdGwwVmRQUTcraENNd3BEd3RmZnZyVDNjT3JDNWR4Rktabng4WHZYdnZ1UlgzMVRuall2WC9tWC8zenFJdWFnRmxrSUhLREVpU1BHWXM5REFvaXMvbDN4Tk54dUVrNVozS0VyQ21jU0V3b1ByaVJLSXN4aS9KbXpDSUNaeHJyZE5RZDFVMnRWbW94Wm1XRDhOVjhkTTNrQjJJUm4yZk5HV1lwaFZsVFdOb1IrSzFFK1RZeHptWWtLcjVzOC9LNzNlMnRsWGtxVGlRcU1JaTZwdVV3NjNaWFlDSXExbXFZdG5ianNXbHVIN0dqbUZkSFFDeGM0RU5qc0hWSGovVHdNSVRTcU52NFBKcE16dTRuYVQvRkFCWUNFaXpWTjVjWGZQeXc5YkpOVm1lK3VyaTg4dWxQODFZNFNmR1VoZnpES0lOWm9ROVV3TlhuOTd2THV6ZFBuM3o2THltQ2ZmWmJ2WHg2czM5N256U2w3ZFgyK3Y3dC9lSnlYdW0xZ05HVjFJN0FxSEovTXR1L2pGZlB2QUllcE9tUU9zZGJ0bjR1TVJxVTRzVXNFcHlKUmJsUzYrY2FiR045VFR1Q2lOZTh0VFVsNUl5TjBadFBpQWl6RTRyTFFHSW1iVFJWbTN5c1NZSjVJMDU5S2dZNHpKMEFzdXpzZkpyS1FmK3VDU2I2WDBNNFptQWlvdDFyRTRhYk1pL0ZiS3JPcWxIcXV4TWJlbXBGek1qOUk0allhYXJWdk1iTWZiUExJRkhyVzZzd0k4dVp5NVBQcDFUeFJUU2VyWWkwK1NuSmpKRm52aVRrblI1bjAzLzliejZ6aDBNWktTVmZLbVErbXBzTUpwcTNJMDMwN3BzamViRTZMOHdnWG9CYWFpMVZtY2FkbHRSMGJrZFJIUzh2ZEdDWWc1Q0lSS2tjYTYyUnV4cFRTcHJkT1ErSjFESHNOb0pwWG5nYzB5QTJ6OVU1Z2lPaU5lWFk3OHlWSkttNGtTaUNmUVN6Rm5jbzNqWDB6U0ZrTEVsRkdKSnpoTDNtY2VEcERqVWN1eFR1TE5xUVU4NllSSWROc0taWlJTV04yZ2FNb213T1ZrMUpveFFPRFJtSVdWWGp2cGZVM2xPWDltM0FpVldaa0JMbWhaUllsVkVMV0ZOVzlsSDc5eFlKMWlDUC9UMlRMNGVIdTNsek5VamVYaXhjRjYvM1gvMC8vL0llWEFwNE55NEgzbTdCcU9Zc20yRzU4d3M5Y0dZOGVhbkxQM0ZlOG5qY2JRK2I2Ny9CL3piUjV0bG5MMjlHZmYvaG9XRi9lcS9iOGoyanVYU25VMkVCZ055OGhjMnJNSWdXY3pPejlwNklKRlVKWGpxSTA3REpXVlVGdUZ1cU80Q1cyOU5IQVJ6bUJmTUY0VmNYSmdlSnBKeUoyV3ViUmJVWFFIVnNiSjVtRHhaTkdtWHVYQzkyYnBLOE9sTlphaTNWeWp5WFphbTF6RWRLMjRGWkVsdTFVbmxRWXNaME9GbzA3eENZdVpXU2Vwd01QeXA3S1RaaXZRZ2hna1V1R1VFZ0RBOGRiZVAwMENsaTVySFkvR05JRVJPNGNZSk9DMDkrZEFuemp4SnZFV3NibTVjdDd0T2xmVE1tcWN0NC9mUW5UN2VTaWNUSUNsekUzU3EyVWkvSzRvc1Njd0pYSXJKU2xjajZneWVET1JHbm9SS3hrMWxBeFdLK0RpRTJSSXM2bVRrRlFBQUVjMnBEa0tWVjF4bkZrVlNxTlhwMkp5OGdLTU5xSUNjU0YzaWtQOFo1MEJsLy9hL29iV1BSbEdwTm1FVXRrQnFZb3JPU2Rib2dBSkdic3JMVzZ1dDEwQzBjUWd3bmFZVjZsMnVzUG9BdzRrVm5JbWhHZENJNitFb29GYUdjUzh2UGs3aVU0MmMzS1dLZlZBYVV2aE9RYzhXSSt0bit3LzdMbEpTcno1WHpocTB1UURFaFNjbGdkMDkvY25XLzVPdnRMai9zYzlrK2UxUEltTXBFeS92bDRucitleEtwaC8yc2gwbTA1M3ZRU3BNOFhZcmdjekF6NU9UZmdwdTVoOW1IdlFrMVFua1Z2NzVvSElsdUZ2TGdUb0hxbjloNnY1NVVEMGJleHVOTjFJYVRDNC9YTlRUNDhXSXdVclVxZ1R4aVkzd3lCMGZNYjB5MUhJQzdzWnNadVFrY2J1NzdsRlZZUkt3NndaRzZVdVVzejR5Sm5VRkM3Q1lnZG9PUmVTajdWWDJWRDdJTGc5Z0ZKNjZrZkMvYUJHZkFhSTUwMERNb0dkT2ppZlgzSWxKNnFSNDJYU08yV3ZPQWhmMllQLzJybjk4dWgzM09pWVlpUTNZZnRvZmxZYUtSanpVbmdNSHprQUFWbmxpRTNWZzlwaUZLNGlETmhjZ1p0YTUyVUhKd0pEZVJNTXVoN1VJMXhuM2VUbHhPYVRNSVNGZ0had2FLK1NOeEtoQTBra3FSek9qdGNPOHhNdDdhaEJYVWRxcGZYRWdDOXlyTU5Wb29LcXdpMG5KeW9za2l3R2pTbkNJeWFJVWN0Y0V4R1R1MVB4OEZrSUVGL0JqL1M0anRNTEZvUEVmTUlnek9tUnpDeVMwUUJLSHFVWkNBeVQ3YU5YRHozYnZWWTZHc0cwdGo0ZytITk9xUXZSanhZQWF5R1ZzU0hZdzRML25pOG41L1hBcVgrZUk2Zi9GNkdRdEoyUTdIZjduNzVPOE8yOFA3bzVIYlBOVk1NVUZpQXZmRUpNanAvY1U1cXk0dUM3T3dleHJZelVCQk00ZzhrZGhuTTdGb3lnS0FhaWtXeG1NL2wwU2NFUm9iSWJLUlkwNEg2YU5YOTl6STJNZXhmWXNqRGxnVlVBSEE0blcyQ283UnVrUU1oSVBnSm02MWNqVW1oNVZDUzZwSldJVGpCZllrcHpDMjB6Y1FPVU5PeklEVStLeGd4YXBqbEVRazd0cFNXYzhjSDQvSTk5OTVBZU0wclR5aktaeWQzWStZUmQ4VGhOeXJCV0VJWXpqcU03eXg4ZjB2L3ZhTGw3YzQzcjI2SDNaTStqQmVYVEJKMnZuK3ZpalRSUjY0VGt0ZE1sZFhvWkdVdWNKSUxMd2VrbHlGQTlRRGh6T0pob2toN2lQMHRheEFSR0lJaXQ2bk9BMHBpWnU1NlNBb3BjUUE4R3dveEVSZXJYcnJXVnVBZENCdG1saytQaHp1Vk4yUUtNYUx3cW5oRmdZT2NYMDhmOHptTFFxZGhlSHNGZVRzUUZvZDJXMFBTYkZha0ZnN1FKa2hZSzU4VW4xRnBQMGE5czdrN2tLY2NtWkNVdFJTTUlKWlVncHlRamNOME1tSTFtZGx6aUtTVW5Kakw0WGMwcFB0emNHWThrRHowU2h4dHFVWVoyZldKTEpkL09vYXMyTzIyWGgzK2NXdmlyaUwxOHY2Y1BqWjh6LytyaFpzTjFROGNlTFlpaEpPT01wMVozRjZoWGsxOGpETUdHNVczYk9aazdCSWN3T1JjRlRld2JCajlscExxWjZ3Qms2ZkNzVit1M3MzeDUwcEhMaWJmZERCR0YzejBraFRkRnJnTVFzcHV6TnpkVkNVd3hFcEYwdHBWVzJqWkhaM2gzc2g0cnJNNWc1bkNVODd3VDJkb2YzNjRyKy9XaXB3d05uSWd4MWlaczRLNWhUMlIrMzN0cHowQi83eFB2ZWozRlpmMXcwTXhtbFAwdDd2SDNFRHQ0SkVvaTdNSkhxWTB2YnZmL216VFhtL1RHOC83UE5jVEgwMzdEWXlEdlhpcFR5NHBTZEphSGJRVGNaaHBscFNyQytqSVpHVXF5Z05BNURkTzA1QWNnSm03d3M0ZDI4cnJHNnpEQ1JOdk82ekkwVWtuYkxCM0VrMHNtUk9Rd3dHbEpPWWVYT2NTd2UyaEI4TkhMamNlSithQUFzOVd0a0lBQ3VyTk81WEZBbk9EaFp4Rm1FWWpGQUpFUm9SL3h1WUNBdi9PZW5KQUFhc3NQNTFiQWlPUEMxS29nS1lNNG1tTExUQTRiVTRSRk1TRGxNN0VWc3d4Q0dQekhwTjVRVWpVaWtMSkluSWVEa2RaeFZCM3M2THk0Z3l5VkFCSFlkQjV5emxZYm04dWM2VjFDZTZIZ3NMRXovY1hLWjdxLzlVcnA0TnllN3ZzNURBK3pZRlo3TWpuRndFNnlYY21hMW1Ebk16UUJ4Z0ZzM2R6Qkd0aWlpckJDUnNtVXZvSnM4SzhYVXAxNXpvcDdSeGJWT3padVUvaTBqalBybGEvOUtvRjAwQUFDQUFTVVJCVkNoVzRKeHdBckdyVUF4MnZCVTl3a2pLckRrbFhhVlBidVJlV0JqTFllYVVsVm1pa0FBOHliZmVrVjdpRWttWGxibTZrbkdRaWVQOEM3VlpXRU40L1J6NUx4bjN6M1MrWjFES2ZnUC9DUHUvOUtmUGd5cnJ3LzdyN2QvL04wOSs5dnAzRHhlM2c4LzVac2hXY0NEbmxCS1Z6U2MzOTNjZmVPOEdhQjV2MG5LM3QyTzFwYW9pVkRDUWhLcE1lWUNZVll2bld0T1FVQzMwcmc2dkFIbEFLdnVXa2RvMUxNTGtWVktDSjVwcmdRd0hZdTNNNi9WZ1k2R0lnbG0xQnVjcTB6Vnhybk1kT3QrK2plc2FseXVzbk0zY1FTb0NNTE9KS2tNd3VCbElJOFNPaVZsU3pGbENETmtWbG1UTWNEQzB0M2pkNTl0d1V3TUxPUXVZQ0REUUlzSXVTaVVwRTZxTGV3OFhpb05ncmI2NnpnUG1WbmhIb21TU3hHdmU3cFo1V282empxUGVKeDN5VElMcXlNeEU4eDAvdVJ3R3JTVU5lWm5xWnFZa05kTTAzdjN1Nzc5NGNiZ2VwNGU2R0dvSTEzQ21jejVkdnpoUmRXS0hpdFJtSlV0TDlJcUprMnBhcjhTSXlzd3NURVpBblJkdnhFUkdSNXpnTkZtR0k3SVVUaExVdHNGL2ZBT2piNEZQVWhJNWc1Nm4vcml2S3lsaFNVSVVyTGVjQmVZYUVjckc1dVp3WHc3SDBVeUptTTBOelBBazNZWjdkc090eVdaUlJ5bXBtclRqdzZIZXBlUEVLdFkyUDRvV3FmTzk1SngyM1BXYVhScnM0M3lJeFQrUXY3Z3VydHZxdklFMHNlRDVYLy9ENS9MYjEvc25uMncvdk5NcmxTRXQ4LzNlNjJWaUhaY2hxUmQvWDR1T0YxbFN3aWc4MGhUU0QxS3U1a2FjMUlHNGROMEo4VURDYW85YUlqTW5jdThoTjZ0WUhrUWtXVGZPbXNVcXdjckNXVUlSRFg0a1ZHbnBNWVA2S2tHVTl2ekpxZ0hvaThlV1Q5UjZEYWUyMnhGTjdBallvQWlEWStLWlFrTFU0cm1JdFpzK1ZKWGRYR01qN09pQjBNS05RdkFSY0dZdERKMmNXQVRFWHVPOFpHVmhUY3BON0NOZGVCTy9BeGdFSldMVkpNMUFRZUxHR2w1REIrdFF6WTVrYW1TNlliV29BS3Y1SlIzbnZMTUhKQmt2eDFMdmgxd1R5azRQdTRkL25uLzUrOStPc24rTjdYWUNHTDVPNjlsT2I5YmpJVlpjd0tqdWdGY3JXRGNmclVCdG9qSkNMNTdadkZpTklYcDgvTEltZm5kSURnV3MyNnUzUGpQU3p6U2RabFZualVzMHRlZnZmeCtZc2JMRG5Gc2NJSk95Y2hJbUVTVkl5a3BlVlYzZ1prWldBY2V5MUNLT0NpSXU3aXhNU0kxZzhUMWhiOHpPTE41Q1JGZGJBZFBwZkluNmlabE8wVTdmMndWVHl4L3NNb0xUeEovUGVoayttNHFmMUxmdGg2ZVFKTGQ1UHF1VUYvL2ozeTIvL3VOMDgvTm45clZkbFd5Rk1OMWRGcHRFaWJmN2t2M2RmYjBvVlRiWnkrc0JTOXB3WVVUak1UaFQ5Qk5tME1UQ01JK0JrRld2UzNPK2VHcGZpVloxWVlFNEdVTkkyWm5Ua0hhbHVGbGRzbWdtYjVRRU9tM2NGVUxzQ2ljU2xyQnh4M1czZWk2eDdzNjR6YVdaMkZzd3RJdW9FQUdhTXdkRGdVbEVscVllRk9xc0lSWW5RUHNYcEVtSlFScVplRkpqM0lJVW5MZzFTOEJqaW9wKy85Y212aHJjaVR4NkxXYkl0bVYvZTl2NnR4dG9MWjBET3FpeU1Ja0t3MmNUSzh1eVk4YXh6T1VxajhkbG9yb0JqV05hZUhFU3NycU1MNi8rZk0vUG5oWk9ZNmJsK0pCMHlsam9RSjlmTElmcnR3OVBuM0E1b0dxMCtPaVJ1emg5ZnQrZW13QlltbTdEbWhhNWhBUlhQTUw2bUJDUm4wUU04bHFQbklNWHRSYWovWjliVW9yRHcvVVRnZ1JuSW1ySkp4OFpsRU1CZkRZQU96T1N4Sml2dDVETW5FQ1NoTUJaVVNWbkpqT3pSQjR2c0NjT2JQVkJFd0ZFeFlQTG5kb1U3Mk1yUG5URjdnRk9DcU1sVW5XWnZDQW5hL0tKUHNYMnRlOXRGMVpEOEo3MXhOMStGYjRROGhXakVSem9rL1dHd1FRUmdoRU5WbGlJWE5zckRHV3lVbTJJRUJmYi8zZi83dVhyMy96aCtNWHRoWDN6T2orN21KQnBiN3Y2SkM4VGo2bU0yY2Vydy9zM25KVmRsR3F0MVR4dnJUcU10YXFvY2pVcUJWUTBYOCtpSlFZNU5uUHdpQklUanMza2ZTQVFPQ2lZUkU0MXFhQXVOSnNwaVNZcUJtSmJQTDRoYmxleGEvT2RTZXpma0dvRmtkV3poMDBJWmtNYkIzQlNNbXNkbFp0TFV0RVFDNElrTWNvQ0lWZ0s1aHJWbFNvS0VncFZ0UWkzZTRMSll3MG9LWTQvSlNJU3M1cFh6eHV2cEE5U1pXdjhMVlloRUd1R214SExFTTg4eU1HSnJBUXJrZ0FoYVRkQk9Ic0lSbG1WckRMQkZxcVV1RlMreThPT0RDd29kMGt2T04wdE9hUFlsL2VmdnJ6ZlBiM2V2ZEgwMVRMT20vZkhMZmtvU1B2ODRSLy8rdCs4V1Q1ODQ3dDN1L3NraE1TOFpDRXpGaU1ta0lmUHZPbk9uSndTSEVhZ1dpdVlIUXAzQWlDc21xUkpjMEdFa0VDeUxiTUptWTBOTG1TdHgvT21uSFFoRkhjeU9OYjlvRE1wbkZRWmFoQzJDaUhBblpHRmNoNlNrb09TaUVUb0VCTllIU1JwVytaSUFvaGxKTU4xVUdkbEZSY0drU1NxTVZPRnBPUjFoOFVPSDFpSTJNMHdFMGcwSW01K2VPbTZxbSswcmNORVRrZlVPY2ZrVVdvVHZsOXM5UmVYdlBIUm1ha0tPWGdnSWFMYXV1Z3BaVTNNSmlKVzAzYjd0NS9ycjM3MXpiTy9lakx5dzd2WEE3a20yaDlsL050dG1pY3dybnhad0ZrSHIzQmlOdkxKeDNHMGxFTkM2eDIvb0pTMFliOFlWRU9yYVYzVDMzM1Iyc1d3TGM1WUcyM1JXeDVXZFE4dWMraHU0T2RGQmhnZSsxeTByRGpTZGZwbllJN0t0eDJuWGZITGdEYm1vUUFxSEhsRTdpZDlGRUg2MGdwdFlCNkF4Y2JTajlWWGZMUWV0RjRCVXdKWDRsYW85L1M1MkhrbDR1YVFpZ08zUk5JTzV5QU5lbzZ1akZJYjNrUkJHcFJ6RVlKMGl3RkhFaDdHZXZCa1I5NE1XNTRobVVuWXF5Y1ZjbUU5eWpqVTY4dWJ3N0xaak8vdi9mOTkySEFWT2x6bTRoOStQeitqdTNkZjRYSzQrYnhNMDdLVTR5Ykc1V3ZPaXNPWjJNRmdCd2dMbld1eldoaDdqd3R0TG9oZ05HWVZZSHBkS21kMTM3WTZtRThNdzFWdkdpTk02b3lxTTFZUHFDY2k4SW9Rb0c3d1diWFF4RGluTG52bGhoaHJkN3VBSWdhYms0NTVVTTJxcFhrTjVvbm5wVlJXSW5LcnZvQ1lOVW5pSHpiWU01TzRCT2NySGhVUkZmNTJxM3E2YWIrVlNmTW9qZTB2d2Uya1hRZFN6WWxSbFlXTiszZ2NYTVdUcVBxTTZuengvT2xQUHZ6bXErbkZ6MTVlMXVudDYzZTc3Wk9VcTlIbXlXNHpYSkRBU2ludUxKdXJPaThGUkl0bzJkY2lxbG5ZUzhzYzZKYWY0bHlxOStHRXcwMWJXSkMwcjB5N1dtL0ZPQWl6TUZrRGc3VjNwUzMyUVFzN0NYbjdhMFU4Q2pPUmkzam5rTGJRVEc5dXN3aVlZQWtzeE9tTGlORlFoRTByRVN3NHoyR0JpSWpicHZRa29MdFBRNk1VVUU5cThDNGlsdGh1TTljR2NXdjJ3VWhZWnVaOFF0MkJRMXVzbXJUN2ExbEVySkJHV2U5TzJsdks1cW9uanNXM3FLQlNUbVdVZTh2cSsrbnlhbWMyUUxOU01SbzJ6Z01ybmlRcXpqNjl2dDlxbmo1d0dUYUg0MFhpRDgvSzFmM3ZYMSsvWGE2ZlgxeldtM29zU1RkdWk5ZDJFR0lkQ1JLSHVTYjI1TEYzTjRjVFJheU5OT2dHcjNCb1ZoSEpzaHlPNzUyeXFLWlQ2SGRYa2ZkTmk3dFZkR1VqZjdRbFdTY2pQWG1velMraFBZbUkrZHlEUUkwQXFoRmRFQWxvTEN4Wmt6SG5QS1lzdkVKN1FiVlNxZFdZUUd5MTJFVEVtdnd2dnNERXpBcVJjQ295b3d0RnZuZmRBLzdlQzVnSlArb0dqcjlSSWlaUlY0bEUwbkJjSUFtQkpkTXdML255OWxwLy9lcnQxWC83TjV0am11N2VIMmg3ZlFuenplNzY1bUZXeVNQVjEyV2FTUk1yZ2RVQUc3YWI0M3ljUm85QldzTTlRdzFtVllUTFVnT3dCVDVKYkNsaWttTjEwVHhhTVlTUDZBMzRpVVNNWnRtSTRaUEcwZXZPblk4ZXIyU0NrNGlROUxCYmpxL2FHc1kxdHI4aTN1eDZBcEJvYXZGTVJNU0owWVpYM2ZnQWNyS0d3SkgrL3A3NHlFd1FGemVEaUJoQUVPWFVPTWlsL1QwVFdxaHBHL2YzZzNsb2podHYxTTZpREphVWxtWWxUdXRDVERxdnBiM0xBdVkweklzbEJzYjkzbktxVTVHQldUaXJ5Nmhxb0JjeUFsdDcvMDFlM2orNDQrS2VSNzBvZlBRNlh0NGZmdkUvZkgyNTVlWDFtOGxkVkpWZXdVbFBrOS80aDNOYkxERmcxcGh4Uk5wNmMwaGZaSVR5U2h4VzU0ZDdpQXhqbG1DRnJWamEwMU11OGRQNHJFN3BiWFk3Nkh3MUxmU0FYZWFUZWFHejNVNC9VT0NzVXRmWmdZaVFwcHlFaWNMZ0NEZmpCdDNqOXY4WjV1UmxMZ3RZa2tQVGp5aHFtVU42TEQrS3FQRTlKWFRmOCtJdkhCaTkxcDVTSWlkTmhWbkZtVXUwMGFMa2krV1VyaWU3ZVRidXYvblQ5cE5uTjBtR2V0d2ZhWGZ6SkI5dDl5S0xWSnNLSmE5ZXE0TlNQcEFEVnB3aFZ6ZjI0ZjM5dlBBYWtNRUFVelZuRmE3bXpFUVdCb1lnaXA1cDUrSUJYczlhaVlOOHpUTGkwVG9GSmFZQnlvSStpZ3ZwUkh6ckNjNUVUb3FXYzZ0S1VZanorYlVyb2RVVVZqakZNUXAzY2liVzhLMjJGOWdKem9nZ210QzdobHU2L1Jwa3BCN1RKM05RQzREdWRTK2ZoQndVcHBxV3lYSDZJaVVFdldSUlNGS0Jna1FFallhY0VMRXpLOW0yYWFNakdKNlpEN1N4UFRaUDNzNFA0M0xBMXFveUswK2VCNTZMbDNFYzByUGRmbnVMLysrb043eXZkRG5LQjNvNTdBL0pqNS84OS8vaFVHb3RjbjF4cGZOK3JrM2YyVG1kVGY1SjZMNWtDUjVuTEV2YmFrdEZwYTZMRzFaTlNhVGE3TWZqbEZqSXJiS2NqRWFQWG1EQXZSR0s4WWorMkk2dGRsK2Z1T3EwbWgwYmloNm5OQ2QyUkZSZ0VGbW9xNUZGYzBxeDlPdWpCWVpiVlNkaGR6TVRjWU9WNDFKWUVySFFYN3lCVjE5ajMvakIzWlcvdjUvOWptRGwwelQyeDhldEpHVnlXM2h3Y0VyZDdpakViaTZXemVUNjAwOXNXcTR2eHVVVlgydXk0cXdDeU9hVEYzTC9NTG92RHRSdGRpK1ZSRW1kakgzbjg1SURPZzV6Q2t0U2RMNFJseFBUdmFCUlM3VEhMVCtaV2k0QTJqU2RUMW9ueEtBZWlFTFZ2Y1Z3TVNkM25EbzFic25MUkN6SktXQkUxQU9TaFN3RytsMWg0QXhFbVVkQ0tRU0FZY1lOQlFtRlFqN3NjcVFnWjIreldXWTV4UWhSWS9FU2l5QjUxQndPSm9JMjNHNGZpbll6eFpuMHQxTTV1dXVPaVltR0dNRXMzTEJIMHFnRWRPNHRqSTlDaEZCM2UyeVh2ZXgyZHIrUVV6V3FCQmx6eXVNR3grVE9US3ppWDl6KzRmZlRaeSt2MHF1N08wN3pGZzhvdy95YmZ5dXZQOXhLMmwxc25qeVJ0L2YzQjZOT0NPZVBhcjhlaSs1V2E3VjJNbW5UL29FOEJzTXNJazFIVWN2c3dxS0tRclRCQ3N4WkFUa2dZb2VaMllyaStBZ0JkUW9QV2FOLyt5YTZLN0diWWVnY0FWUTk1WmFJSGFVK1MrOUpyRmRnSUxnYlVJdlhXZzFpeFgyZUp4Y0I2VmtKamU5N2dmdlgwb2xLN3FZaWJOLzMzLy9RRU9zSGFtZytsM3VBYUFRUE43eVVOQzhrVEZYYkQzQ3dNcW9mdHJ2NWpTM2pwK1ZvdWhzTEVZQnkvMjZqRnhmWkpSMGx3eE9iUUhCOEtESkdCRlhLdHN3VERzZGN5TTFaakdOYlBnUEs3cFhiYzloOTBMMk10ck1aVzUrMGRXd1FpM2M5ZXdNaHVQVWpWN3JBSEFaRVB4L0JqcVRLaUNDMk1MNDVRMWI5QmFHdEtMUkY3cmlvTURuQzdDc0NDVWxtNzZManVVcHJraFdkSkpkTUJyQWdBSVF4Sm8wdEF3QTkrWTE3eGc3TFNxOEVhU2RmQ0lmUW9RbXBNekdUbDlyRlJSNnFKRGJxV2t4aGNtYzJJU2FyZzlwVTBqRDRwUytGQnk3RzdrcDByWnNOT0ZFV2ZxQVI4L1BCbCtXNGpQblo4UFZEbG55Y3JzdHUrZlUvZjNacHo2blVzanRNeHpldjc1ZU5LTXliZkN4NGJnMVdGMFZ0aFZzMWc2c1FzU3AxSUZXcmJFTkliZ0NzbGdJbFZsVS9KZGIyVW1uRkhiVDBsYjYzNG84MzU2Y1hlUlhaTUJGWjZPQWczQTdWOVU4SlZhZnVkQWV4aU9aeFkwUmV3YklBMmtuSkRxQVVyMDRzdFJhM1paNkVoY1RoNmNmY2h0eTM0akVuaURydnY1VC9qQjgzaVQ3NXhQS1RuMXpYNCt1SHZXV3VUY2pFTUNFbEFsTDJyNCsyMmV6a21wNCszODMzN3NCeWVIODcycUc2aVdtQ01RdEw0c0sxS3R5cUMxZmRhTEZoYTBXTmlLVktITU1QbWtUZ3hoWWJXbW5QZ3FLN1hsWm1WV3ZIZWNXTkNJdDM2NE41RUxZano1R2x4eWRMS0RTMU9qT3BrMGRjbHZtcXNqUUlTY1FiY3hzQmdUaHB6c3BFUlZKaU56TldaVmFCaUxNM0hCcUFSRTV4RTBkd0w4VWlKM0EzN0tZdDJTcnM3MDNxc2FZZ052UU9RdWtsVEx3MGRVUnVmMjBoY3EvbVE2c3NGWnpFbTRxMms1Y0VFdnAvN24wOEJqZGxzcnJYY3ZCdDhrVTNwZWlnSDVKNGt5dTdnK1ZKMlQrVXl3czVjTm5JY2ovL2lsN0tuM09aZDBlNkgrZ3dYQ2JkWlpYdGkvdFhIKzV4SlI5RTNaelhTK0drUFk4bGNXbldmWmVtbStBVmJzTnRGc3N3czBuWlN3VXZsT0NQWUVNZFY5ZCtQdENhSThLM2FOUjloTldwbUNkalhjeEhQWTYxTlh5bFZkMjFFRy9hZjVvODVXRVlOL3U0Z092c2NDYVQ5Z0tIZWxaVG1xeWFsM25Pbk56ZEpjbEhSQXhlVCtTR1ErdTNjRFVXb3VRaERiQ1B4MDdrRGdyOUxFTEEwMTNVY2FQWStZSHdHSjUxWXBsR3BoRTU0RHBkZmY3VHo1L2wrZFZ2Zi91cWpsY0hCeEhNRk9Ta3lqcG9CUXovZWJ4NThmelNqWjlyZVYxdWIvenlGcStYcTl1blZyQWJxZHpWK3dsSkZtS3lpcVExenc5bEdPazlaOHBlRnhnZ0RONkprSmxiSkhWWE4wa3dCeGNXZGhieERwMXBQWVZIU3BDb01KbncwT1dzRmxZM1NVMDVtNG1kSlBQc2NJYVo5Z0YxU0pkcEFPSnlHS3hXSjkyWmtRcGNtSVBZSVhHYkpoSUNDVytEcWdnNGNhSllDNGZHZ3VGTXFCTEJ2azNkSWRtcXhkQXRBWUhXRVU2TVBTd3B3OXFDcWRNS2dsNEpna1N4a3lLS3EwVnU4ZENjVENJaHM5cGRUa0dwd1pSSHBWcnRTcWpNcHJtRWdsaU1VWm5BdXdPZTdlenc4SkJSd1lLY3hDbXAxL0Zpdk4vVDFkZFhlYkNIcTF2Y1BmdDNmL3JLNXMrL2VuT3orWEs2c0UxSnkwUDYwMC8vcC84ei8zemt3eis5ZjdBOEg2MTR4TFQxcXQwanBRSXA2SjVrQWJYbUZMTUFHK0thNDJTVnc2TmRyU3pGZWdaTGxzcURudGdFYlh6SFNtQkdOYlZhcTVPb0JJcTJjclFtSnFKSmlLb3dJUUtXNGN3cTRjT1dHR21hQ3ljakVza3dZWUJ6aGJzWFZrN01Da3lKaUZVdGN6VklTZ1RYc0RmR2tXR1dSSzcxWG9Uck1ydmNEYm5TNEV2NitKcjgySVFRem5ueG5rN1lqekI4eXliWTFTQm5MMmY4dkZYeVJvOENJYjhkVWhnRGZBY01tRFl2Zi9yVGwwOWwrUHpUejMvemg1bVZuVVZNdlduQ0J6c1l4QTh2WG43K1pKY3ArZHMzKyszT1g5SGRmOWJoUW55Z3Nrd0pTMEdwb3VQR0dPQnFuTXBVS01IeVhHbkV3ekswSTJ1Z0tEaFBxcmRnSGVXVktSakhxalFSVUZza3labCtuRnVDZXFUVjlYcGJZLy9BTEN6S2JOd2lLRGtDMjVyYUhvbEUwWXB1WVpJcXdzbzVVVnB6WjRPSUFFZjdEaVRHVGsyaTV0eW05VDBLbG50RFR5Q0I5amxKKzRVSElsRkdDRks2WWFhWkpsdGRLQjYyWDE0alRWcVowZnRlN3RsdkRDU2ZQVEhxL2VVVjcvZlZjdnNRVTZ6VXdGdmQ2anlvY25Gbm01TXl6RlMzQXkyRi9UaXdYbWp5K21UbTlHUzJ3OThlLzduZWZ2N04zYkFad1J0OGRTRjNDeS92WCtYN0k2bHpMcEZTMmZNWU9pdWFyTVduVWcvVDZ0UFhManhta1pTRTNaWnBMaFZKaUdFZTBHeDhGM241QkxqU2MyVXNQN3ErSUsxbENoVWZud0lVU1ppZHlLeUtuR1dPMWxxY2ZDbTgyWTRLVGxBaEt5NWpyVElTanBkdGJlbHVidTZlaVhUUVJVcXBiclV1Y1d3NjBzY1E1MU12MjUyTjhiMmxHR0hnVVN6NjJYK0s5VG1Rem1kbm5MM3cvTzMzL1R0ZllBSWlPZXJtaTcvNjdNa0ZqN2ZQUDduQUh6MjVzVkR5MGtEN2hVRzZ1Nzc0eWMyVnpEWHArN2R2Sng1b3ZoT2ZsdTNMRnc4NWs0d1pVOUpSdHh0NVIwQ2RpMi9yL3BnenVRRHBRdXpJRGppRGxKcEZJN0RCRG1NSGlXNWI3OUQ2WFdvRW5NWkhVWTM2a25zV0NtbWN1ejIvaXB4Rm5NMFNFVmlZbEVRaW44aEJyQ3QybllSRm5GalpBelVwek13cVdZUG1RRVNrR21rTnJaMVlXNjJ3NzUyQ05GbVVsZUpHOGhZVHdLdHZOdmlrbytNa09pQ20ydVoyMmgycnpBQWxzVFo3N01TUTN2dUhEczU3Z2lhUDFaeEZ4V2ZkWHFTSG82eDVCekdYeVRyb1BDOXNaSnJWcEJKZ0xoa01rOTAwSGU2R1laT0FyZnY0aWR6VDhSZitqL3VmNWNPOFNRdTI5SWVMYTNsYkZ3eURTYTNWQThEbjNYZmJSV2hBaFp0WnJMV2lFNDhQcW5PZGhWU1Y0WE01SG1kRHNNNGNyZ3hKZk1xM2ZyVG9CY0s4SWMxUnNrS0FlMGZkeTBpUjJFc2lISjd4QWlreG9aQklhT2Jnd1RxQ2JqQXZKQkF4WXZoU0NNREZacGZxQXJFbVVvZFpkUS9EVWxheDJVcXRaWjZ0aWdabDgyTUs3Q1B2RUhVbUpvdnlhUjk5em1QdWY1QlhmMDdYYkhSajE2Tkw5d3liK20yYjRBcndyWTdkeTArdU5obE82ZGxmdlp2dlNnMXZyamF0M2pKbVEzcjI2U1UvR05QMDhDY3pXdXJGTGluSnNCM1R2MHA0K0xDdmpzdk5JQWxXeUt2VnVXcVpGMHREbWpsdGQ3TE1VeU9TVXBjQWh1WXdqa25WbE5EaUc5dnZhRzVPb2kxK1Z4TWFXSmhXRFhOTXdYb0tvSW1vS0NGU2RRbkR1aGtNZjBMUEE0MGhpcE5LS0lSeW1PV1FXN3FjOXlhT3BXdW01ZlJOZUVCUFFSUXZxSWkySVphdDlJVDQvUlhtSkNMV1ZKeDZiaU1WUUpwNVFvUUJFcUVXdHlSUlRYRHpRY2R1T1hiQ0RtSWFrN0h3b09uaG00c1gxMG4yeEtLU0JLMmt6OEp3a25TSW5ZSk9ic0lPbXJJaWI1SXYrOFB0ZFJZbk9HK2ZqSDU4VWY3bHpZZmJuMzg1Z3pENCsvL2o2ZCsveEI4ZjBsdFFVakdiSWQzUjF4WjhJYmVxQ05oKzU0YXZRb28rSEZZUldrcVp5akliS1ZXR2VBUFRWZUh2Q0JxSVQ2NEc1Y1JQSHVEek43aGpPM2dGZWNzcWF4RW1ZYTVja3ArYVJ4YkpQQXozV0E2WlJ3Yll2YzdUVlBQblB4L3JrbmNWWFlrZGlRSmtSRXJsV014cUxjc1NFRjFZK2lpZUVmNDROdkJIYm42WlR1Qk03bURGNWk0S3pnVFRYN2lDVDJrQlJHNldMNTlmRFRtYkxwNCsvVmZITDczTTFSdFJqNWxvWUtqeXZXOHVMN1hjZmZYYUUxSGxNcWE5UC9uaWFUMkNiRDRlcXVWdHlyQnBjVGhKU2o0bytYemt3ZE5GWmtPaW1QU2h4dUswcVRlNlcwekVHOTJ0ZTExYURDT1l3WWlpQk13cXpZYlhWazFNcVZ1SG1VU1RwaHBwUTgyMHpaU3NXYkxvVk5xNW93SDd1dnF1VDVUak5oWnlKT3BtbWZYR0J5RFFrRzJUUkY1MzZHMk1PcnVkUzN2ZWdocWlVbFR3VVpoa1cyNzBtV3J6K1VhOGJWZ0VSYmlHUlJuZWt1ZThyNHp5WUVZNmFERTdwdkYyV2gyNnJkNmVYV1ZIdW9Ndmh3bXlXMnBLTmFWRWl3M0RwVjYrZWhqR01mTmlQck1OK1pmNzhmbmRILzNUK3RWK0pLYjUzYzgrT2M0S2YrSldYUmNFU3kyRUxzM21aK2FJZFY5MHJyTEtnSnR0aG9rNWswaWRINllDOHpaeWN5SlFwQ2N5ZjhjV0pzUlFqZEp4eXF6Z3RXM2t0V0p0NzBBamVLN2NYbEd1d1lVOVNiczRKYzRra3owUWJTTHF4T2Jqek9QTndGeU9Fb1prY2VwcUJZQ3RMb0dvdEtydUpFS1d2cVcwT04ySTNLMlZvSjQ2dXc2NzhKRlAvd1NQcFpQUmt0R3paazVCd2Z3OXNJMzFRN2JZTlY4OGZiWkxDWUkwKythVHo5N1BNeS9tZ2U4Qk0rY1pWOC9Hdzl1WEcxbmV2SnQzS0FVWmM2bWV5N3Y5WWY4ZkwwYml6Vld5N1pCaHhZaEVKS1dTRlBOOHNBMW4wcm9VYUZ0Nm1BczhiRFVyQllPNHJZKzRTVEZBeExxbXltREYvck9vdFJmSzNkejdpK1VPZFllSWlnR2FFcE54VC9ic1FvM2dPNGwwb2wwWWpKMVlrNENNV2c1dld5SXFCN200VzQyMThidGpnM0tPMzQ4OXNMYytYZGFFQnlGV0VUWUZBUkdZZnBwQ3Q2a3kxaWROUGRBc3dyR1A5c1lIcWhGRFI5bU1RTUkxQzFVZjBueHhYZVpsdDd2MmFuQ2dKWXhSbWljZGlQQzBsa1FFWmFkTWkrdE9iS204dTcxMDhib1p4aGxVNnB4MC9reC8vWUhmcHhkM1J5Nmc2Zm1uZi81YWRrVFBwdnY3d29hMUh1eTB3NmljUTJFVmF4bzVlZXJYeGwwRVhwZmpjUTdSbks4VkNKek1YYjZGaEdxNksxaXR2dTd3VC9KSnJJNWZEMGxreC9iMlNKVVFCeVRVcnBhSjRWNUQvMVdTcFV6andMU0UwUmo4dWo1Y3pvZjZDKytaR09hTmNoUkhsRnN0dFRxWkV6SHNXME9zUjN2aFVJWURFY1VZSEFuNldJbHk2cFpiS2lGV3ZPd2ExODJQUU83NFFlMTExSVMzVDUrTUJNektiQml2THQ5NzBVYXVnQkN6a2FqbUhWK1A4L3ZYODJZNzFZbXBWUGZMNGZqcUtPTWxYUEoycTVKOUZoNThKdUtVdEJha1M1bDh5UzNyTVhSSkVMWmFxcFAwcU9TKytBZWRaUXd4b3BFRk9rTGNJMU44RmF6MzVEOEdUc0JlMUJybTZTU2tiWTRkOCtObUVYRkhpM3dTRTNhR0tzQXBpNk8yYW13QWdUV0p4RTFNSGJ2b2ZhMFZVWVprRGVIY1Z0QnhWZ2lrdTdsYTk0YlFYVnV6d0tNdnA1dWZHQWdjYnVpeVF1VVUzdG5VU3VZWUlWR25lUkdaTzdFdnBvbHFjYitxWmFseHJjVmlWbExLUk9MN0Erdk9lVEZQV1NZN3ByeXRVOXBPdy9iZFllWlVKUlBZNXQvdnJqKzdPTnpYN1RnODdHL2w4S3QvK09UemZQenltL3RhYUpPekZ3NGNtRkdZTjB0UU1rNEI5UUhsVzdlU3pKSGVQSmRsS1ZiWFdRQVJ3dFRaMzg3dktxRmJSeVhxYTFvUXIvK25OVEdOYU9COUZIUXk4N3R5WWtQQWV2dUZJQUloenBpWjY2U1pLcUhXc3N6cE9OZGRxYW5iSmR5c3d0MFhGcVBpN0Y1TEtXWlVreE9zZmp6RVd0RW9maTdraU1zRUsyb29sbXNSQ0lHVnp0di9aSWpuZWhYZDk1by9LdWliVzlsSXRMM2M1cVdXOTNhN2NhU0xteSs5eDY3RjNjTzdSRyszMXkrM1ZwWk01YmdaQjVsbUhiWHVkZGptUkNva0lxeDFxbWxEOFYyS3dwaDNsOU94TGlESkE4VGNpSm1RNXFVVVVqbERrREhSdHhmbEZpSlZaNVpZZDNYMFF2dGlZNFloc25ROFlBdUlEalc4MDBBRzc5RnNZTXBOZEY4aU4xMWN3bUtlblVRWlJpVEt4RHhZQmFYTlVJV1ZJTjVpTXNnNnJsY0NST0RDa2IvTzhlNzFUN2Mzek1LZGd0ODNUU0NBMXh0NGpVa1NXWWZhV09YV2hOVGxwMjNPem5BM0FtdUlGV282ZklDayt2NmE0ZXpNYy9OdlR6N3V0a01lL3Z6d0llMjRWTXkrRlRhYkxwOWZUZmZUWm5OQmI5OGV4Si9xb0ptSzMveGZ1Mys0K1ovZmJWNWplN2RRM3YrK1hzbHhNa241SXUvd3paVFpRS2ppTFlwa1FWaXR1emtraHE0NHpXUWovSStuYVQ4N1NXUXBjMkxEeVk5Tkx2eFkyTlM3WFhSTjhYZHBoS2tudklBQVZ4ZW94K3hzSFZFTHAvYXp2YTNNWTgwb3VZQXc4eVpsY2llcmkrdXczSldicDJ0d1pMaStiR1kxVkd1Y2Q0ZkZxUGMwaGJhUFhVWDkrQ0FoQjZ0cXNpUk95Z1NJY09pK1VKdU9icFdrUklDYW5TazkrczdsckRRLzZ6Rzh2U3FuT3lXcFZiblkvUEtpZXJJL0hINytSWnFIWjd0TDJGRDNsVGE4TERyYVliUFExYUI1VStleXVFTjlZUm1MbTZaUllhWHUzQWFwa3pqQmp3OVpMSkhKbHBlRGdRWk45ZDFBeGh1N3Z4Nlh0MU5XMzZKV2NsUnhNNDdsUHhQRkxSbDdibEo0cmNJRXlmRUc1aEFoR3hWU2FpcWJnQjY2cGVDRmhGRENZd3hVU2JSRVBodzFsd0twdVNhRlNYc1JMOGdyYzBybWdJNmIvQnJNU1lCRlIrWThqQ3dxMWg0NEdQblFHdTJRWkJPTjdzNnNQTFNTUzBYY0lhayt3alYwT1ppc0pDUnZJRmdQUWdPeUVLVENWVTZCczB6T0MwZlZpVVpwWFFMVGtCbHV0VmF3cHNRdyttcTcyY3d6SkpNVnpzQ1NaZmJwOE9FNDNqRGd5eUpTZE16MjVqMXRyOVhaNnZqRnhXRy82QldaWEEwK0QvdFhuLzM3Ly9VYnU5QTB2M3U1K2Mxdi90cjhKMldrejRZLy9PRXdlNm9tYXJVa3QxcmRXd1RNaWNDYmlKa2dqazVNa0t4VWEzM2p4am5BQnhBeUZNMEkzd0FBSUFCSlJFRlVBZ3QxUkpKa2JUTUpadmFJZEdUeVl0UXd0TUZUVGl6bWNCR3lOQ0JpUWwwSUxqQkhGV3FtcmNvMmtGTU1PTldyZ3VIR0JOS1Vxa2xPOEdWckVCUWRIckt5TzZXeFB1eDV6TzVKQlNydVR0bXR1RllrT3o3TVJmTHM1TXVXNnpFeEkvMmdLd2dyYzNadGZJR1RIcmkxMXN3VTBzci9Zbm5XU1NITmp6T0JpTEtLa2l6M2Q3ZlBNK2x3c3ozVW1kSXdUS3dKaGJjUWxPMWxma2hsV1dwMG1kNlZNbWFpSTZ0NENYMi9jOVhRSHloTlpFTENkRFBXZmFsRjMxUGFiY3RDeFVWckdQdENYb3htRGFhV3lYQ0tsMnV6eFFDN0c4ZGNDdVRuUVFmZFBMa21qb1NacmFkWXJBZ1NadkdRbC9mQkpVTllraXBBQXFOcjkxYkhpb2lpb29GaVY1SDhHVXBPK29uTjFHZytmR3JTSHVPTFB0cVZjT2Y2Umc5Qm9MeGl1ODZrelNFYlFiZU5pamI5dERjT3RTb3NEWU9RZWZGSzVrNGpNY0VZUXhLeWVwdzJRM0lIOHlSU1BHKzJ2L2htLzJhOFBoNTNFOHZsSUpuWlpoQmtseTRPdi8vODMvOHZyd1JIVjY2SCtmbXovL1R1MWZ6WDl3K3ZTNjd5VUV4eTB1U25RZkRaRUxpblRIa3JDSVVadFhvcDFuWnA2TUNqV0twN3F5alJDTjI5dWlZbzErSWtFc0dHa1NJcG9heUxaMFVZQ1BLUXJEbFIzS1Uwc1c1cjliWFZ5alJhTGE0akpYSURXQWVEbUZtSmpzZjlYallYaWYyQmlVd1FxWWVzS3NaQXJiNU8yNmRCVkpYcnQ4d00vQkZaNTFFcU42aW5NSjF1VU81anh2L3EvK21TeExDak5tM2NUb21sVHZmdjN4MnVSQzgvL2R2clAzMllTOTJESk5lRjg1aTk4clcvWXBoQktGUlV5Z1RXcERUa2dZbGhUdEFrN2VOa2NuSm1DcXdDNVlHR20rZC9mamVCRHI2WldaU2R4SU9YMlg0cGtVQlNSSVBKSk4xdTEzcFJnbEdMMWtFUHFscExxblc3NEV3UTBTU3IzR3hkSGNhRXloeTVMWWFZVmNDNW9RWE1OMjZRdnJNU0xOSExudnk3ZG1yUW81UjJzYkQ5bnVWRnR0N3dISG1FRnJqNU9HUU82MVExTVpOSFk0MXV2dEwrM0hhMFdVQlhpMVJEYlpqbGtIc2tQckFSaTV0RWtpVEFMSXc4RG9tOHdnRlJXMnJPbDRmNS92NzVXSEgwSVlrTXd6QlE5V1A5MlVDYlBOLysyLzl3WEhSWWpzUGQzYk8vKzZmeWJQcnRtQVZsdkw2cnkxeHJFR05XcFgxZnhncVRoTkhiNDExVkJXcXRTL1YxOWRiY1FRS0pPb21aeVpsU1YvTXpzYU1TTDBzeHlleHRJTkpLTWhZUW1DV1VWeVJpcC9UVzg0eWdPQmlDY1dsTEZzMnd1VWdkZHNUbUpKb0VRblh4MUtiZDI4M3RiVm9xUzdCQW1nSXdDT2hsQ2JxTG1YbUREditRRnBwUGlMV1RPcW5yT3M3SkFpZjQ4WC9WNjR2VkdMRGFxZ0M2M3NEZGpzZnBXSVJrODhuMnM1OTgrUER1MVYydEdJZnNxUTUyM0xrZjBjS1FLWW1PYVM0cHFZcU1tejVoc0NUS1RLSncyTVFPZDZleWxNUEVoWFBTWVZQbk9zRVFzalh5aURRWGFuSUxsdUNDckJsZjZGN3dmdDdIemNvZjBUYlBwbCtROEo0bUNXdGJNNXdLaUpoVXZQV2VmQnFzaXFZMkpVTmxrU1RrVERJTVlpVStlMitzRlZvZDdXZlhrSUtKalRwZ25WbXdmbytNUnkvd3VoNEdyMFRZS0VFMVlyemRzT3JNUkVQSUFBRDlVeUlseWtPcEhvWi9rY0ZLY1JKSzdxenJRODFjM0JKN1paZ3ZsY3czeXVTb3k5M1ZicHFQMXhlMUhwQmprNzExdjN0Mzg5TS8rVjkvL2VYMXYvNzEvc3IzMjZjUDMvZ1huMHpiaC8vOTZlYzM2WTN4ODJ6djNqdzRKWmo1Nll4cHRRNlRvRVY5dHZSUWVDbExSSnF0RzQ5T1ZtUVBmNS9iaW11TTJWVTFYNndhdXJYRFZ4UVhTenZIVXdNRnJrVFJQZ1VIR0J6RStFWUg5bG9IQVJHcWwwVERFTmg5SW5ITTg0Nm9Pb2hlWGoyN3NyMGxnYkVRczlkcWtGcVVDRmFkMWQycm1XMVVVSXZnKzIvZ1ZrS3Z2MW9UZ1VrSUU4Nk16Z1NDVWZvQkdQdGZLS0UvTWpQRlozV1ZyS0tVWXRNRWNkMm1pMC9LOVBETnU2L2UzYnZrQ3NxYUxxNEdlUU16SStJaHMyajFtY3JzcWt4cEJVR3lDSkZJTTRTb3c5MXFMZE8wY09hNkROdFowdkZoNkFPUXNKOVJDdWMrcEZIY1c4QmFwL0RHcURkZTVOQk1oZHloSjZoMm5FcXZ2RmxGVllLZjNJdTBrUHBSYUh5NGM1bVpDUnE0RGlHSHNxWkVac1JwSEtVcW1PRVFwQ2FNbE5ZMmFNZTRkS0ZJdDZHM0M2ZEx4YzREb3AxNzRQVnA5bjRHVzJVaHJCMHdOM0pIOEdtYXNiTDllODNkYkNKTXFrTXR4ZGdobWdJaXc2b0V0MnJ6VXEvaDVpSktjQm1WRHNPblY0Y0R5LzlQMnBzOVNaWmthVjVuVWIzWHpOM0RZOG5JeUtxc3JzcmVxcG5xR21BUVpvQUhRT1lGRVY0US9sUWVFWVJYWkppWmhtbG11dW1tMTZxdXpLek1qTlUzVys1VlBlZWJoNk42cjVsblZEY0QvcFFaSG91YjJWWFZvK2Q4Mys4Ykw3eE9uc1dPT09hTjJtNzNPN3N2ZVp6ZnZMcDk2MU1lS0gzellWUGZQTWZQVE5MMThjM044MmRESnBDVUJwaG5kQmhHVEkvUTAxNDBLOE5zdGxLcVkwMU5vQzRzYS94a1pnbzNQeXNUY1NXaWF1WlRnT0VpRG5vWnlyZHlzVU1lNGRLR3BWaFNNdHBFeGxoaURpendPZzlwaHVSU1ovRDFxQ0J5SVU2azVKTzdWWWo2K1BUSm9kQ1dFQkVHMFQ1Mk15SzNpb2dITUljd3JFTEg5UGY0K0pmSVFsNGprbnFGc2tyT0dQUVB3MkQvZ1JPNGk3VmFLeEFnR2dUdVZ1SDdmVTNnWk5zTkNMKzl1L3YycjcvYWVkMWZWYm04NHZTQ0R2ZlRyRU95QkNQbGVqL1VKOXZyaS9FSUFJNStzSUpDYUM2VGk1RURmTHdyYWJENTkvamh5RmVidERjMlVtczVVTUVyYkdYanlaV1Z5TUV0VExKM0xBTjd4YzE3MWxkUDg5L0dycXdpSWFvSGVsQ1duNlRhR1ZybHpkRnpCZ3NMUzlKZ3hRbFFEYXBlMlQzejh1L0ZuTFpaWlU0YitSdzlHSndaOHVsY0JPc3hwRWYzQVdNdCtsZXhEZmVFQ09wWllOeUQxNXZYam8wOXFYQTBSWTE1UDI0M09IaUZnenpRUDh5aWpHb0VTZ05GUWN1bHVvNFpaVFRhSnV6dlhtaTZMWmVPMFdSSWw5ZnpEOTRjWDM1MzkrcDIrc0g0aTRmUEx4L3M5ZjFQOU52NjZYOTdPQnpmVzdxcXhmZEhaOVNtVU9EVEtBUjBBN1F3VWxLVXVSNFFyS1JvcVRzaW1VR1g2QVFTSmlkaWFIakRLZ0F6d3lRaUdnTVFFS1NyYXRqV1dWcXZvQ2pHY1MzenBWZW4zWlpHNUlVVkVCMnMySnd2b2hKVDBrR3IxMEp1czBIdXJpcHJJaVYzamZlZlhKaDhGdlppRHJpYk9WRVJjVTZiNy91QnYzOEMweG41SGdDdFlleDlzL24vdm9MN3J1V3IzN2ZGUUpMQUhYVy90d3dlUEZGMUhTOCsvY0d6cTNlMGUrYzdQRHY4MG5XY0swU1k0VUFla3R4NDhid1pVN1I0UVZtMUVROVlGSnhtQmxua1MyNmZQdCtrbjN6MS9xREkxM3N2NEtiTWNZclFDWmJJL0VWallyV3pWMFNUaUlRUklmSlZBbU5EUkl0bCt5UktnOEtjRW9Pc1FEcTJjVjJjY1NSUVdYb0JFdk9rN3RWbk54ZGk5WlNsSWVRNWNPNitjTFhCampVQUtSWnBDdVVtWThub2lVcmhaRUdUQ3kxMndsWTNOQWx2U3dDQmtIWWxXbU5zOFpvMndTSWkxc3B1YTVsRGxka1lpVXJ3SkJMNVFrTmkxbUdjQk9yTW5tTWdKM1FZTGpabGQrRExvZHhUT1Q3YmpPUzB1YmFIKzkrdXYweVhEL25weTFJUEpHL2YvUFRIZjdybmFkemN5R2JjVnJxNzJaUFUwNDVxNzhhMEVvZEVSQ0dvZFo1S2NYTTZiUzYyOUY0bEVzUktRblNUQ1ZRZEJqT1BEYzY5Qlo2alcwZkFaQzdFb1pMQ0dkV1ZJYXZiQjJpeDM2UktaUzQycDVSVFRrekZIUzZpQmhFWnE4eU9NaGVqY3YvV3VVZ05YRDhCcUVadTVxS28xYnhaTmJobVZsV1ZSUDlnaHUrWjhMazFKa1A2MVM3cEMzUGcvMDhUQzh1aEg2KzlPaWtBOTFKSUpmT1FTSXlKajllL04relM0ZHU3YjZaUDB0c2JVZVk4Q05PUWtTNmUrY092WnRqeDdzRXVHb0FtaVpLRmQ0ZmRpR0JlclZZenlwZXZmdmpaMWV2YjkzN2hCMk1BSlBGNU9BbFhGaExWMU94Y1RkeFBJRlpSVlpFMmRtR1BXMmd6SUpIMkdocHJjaytVMk9kTW9aYTR3TTVDVEJISkhVbG1ZUnRzNVIyblNwQ3M0c01vY0pMQ3djTHNKSWhGSGtSeG9OUm1EV3l1TnovOUdCL2JVRTRGTmd1amZ0WFV4WFM1dlhoZlUxLzdsc0NpU1lLaVRhanVEZ2FQdG5QT2VkdFpYQnhCbGpSVTFHbFcwL2pqZGxFS0NLUkVNZ29HclNNbjk3cG4yU1kvMXZKdi8rdkQvYXNuMzIydVAraFAvTmYwZzN6ekRYMTIrZWIxd3ppT3o2NGZIbDdjUGR6c3RteXlaTUh4Y25sWVBQZWk2bVJXNXFtR05adGpCSWVsdzZQR1RJMFNUVTRlM2tNenVKc1pTTEtiVVlvZTRFS0xEaWhPY3ptY1dIVk9KaW85bGlYa0c4NUtqbXB1ejRtYXV3em1tWFVHZTdoVnZOWnFySWR2ZDBQS25wdG0xMHFwMENxY0NGYXJoZGVObURWblBXMWkxZGJscUx3RXVFVG9mUXp0UFpmbzQxaTRkdEJValFudG5pdzlJR1lSRGl4elhqeWVXQ0RZRWJ3S1FOWnNIVTRrdkNrNEpqVm1WdytYSFNtQnlUaHRhdnFDQ0Q5Ly9mN2IyL2tUZnAzNUt1MThjTGdTRGpZOWZYallrVzMwT0dZbUdVWlROdVV5WFExbWtnODNVbmRISFZHR2FUTzgvdlhuZjNCMHdTeEdMRUkxUE9Da0loaEFtcFZNTmxvTGsxY21KMWIxeU91bEhBd2xaeVVpbEJydVZQS1pXTVdKVWtzVG5GcVhxNG5yQmJMY0g1bUlZS3dhQkdjaTBwd3FvU1Vzc1lvbW5sUmszRzRIdFVpSmFBVStVak1acE1aS3F5S2FWR1R5cG0wMHA2YTBaa1p6aHkxZTBBVjl3MFlpQUtCaGd1TGFKWWl0cWQ2eW53QVdqVFJjRjJKUWsvWEJXMlFKQ3hpSTNGd3FUQ21uT2hWTm1XQVZsNXVKdmREZ2g2TW1ZWkh4dm1CUTF1RTRmakxjcDZjUEQxOCsrMEttaTJGM0dBWS9Wc3ovNHNlZjduN3JMLzdzY254MS9jT2paQjcrOS8vaDUvL1Q4d3NaSzE3OThOcy8rZE52Yi9KMU9UTGNpQmsydEEzRzJ3R2NDQ1NoZ1N4ekJPUXd3OTJaVVJBTTRDeCt6QVFtVW5JS1ltOXdqaHpINW0zdGJSUnZxaFp0TEg3SlFwVFVrbXNpVkFzekNER1FvbmRCVHFTU3lGMUZoYVpFREpkaFNvUFNrZHpua29WcThTUm1HTFRhYk1aSkdMWi9rRXQ2SHJkcXJjeEdzQ25WU0pIT2h5UEVDc2trbHhkYktvbk9jSzdVL1IxTFhtaTQ2Z1FlSHl6blVLUHdnbkpaakV1bm5vaVAwQzAvbXZ6dy9TODFWSURvdTl1WEtlbVk0YlZZeEUrVGlGQmljV0h6TDU2Tjd3N3p4ZVdId3c3enhTZzgwbnd3MWJ5cHBlNkxYSXRrOWtyWE9RRTBINDlLWmFKNXVnSHlkcVREdU45UGpqZEs5NVNZbUJLUldhUC9jWE1BTmE0WWFTTUR0b1QxNkdzdE5RT1dnbk9abjNNMGwxaVlnK1dpM2ViQm5UY3E3VGVISFh5cFk5cUpFczR6d0FVcEoxVVlpSlhkWFZ3V0tnd1c5RVZuVzZFSlhsdDV2cUNNNlFTWjBDVzVUbzJvd2V6VU82ZUJCbG9PN0JZRllpYzYwZmJoWlMzVllTN1VUTTN0Tk5mVzlCb1luR0RIa1ROSVVJaEVRTUliRnRVa1hMV1NJYVYwZUQvTTQrWDE3YlFmTHpiYk9RM0pabkg2N09hWGJ5NmYvYjc4bTNIK1pQeDg5eUZmYVVvLy8rWEZqOUwwOFBDckQvWDJhT1F6Wnl5dGhEWXVhNnFUSVRZcHYzT3Jaazdwa1JFT2NPb3FMQUt4TVVlWGlvQVdEM3ltcCt3TzcrWU1nSFFySnNlVWQ5RWh5dGxZbllqSmk0VWNEOHc4WmxYVmxJNzN2TjFrV1A5Yk5wVm04VXJaYWhJUmVPQ1FwRE0rQ3h4d01PQnUxVWlaVVNlZkVrNkZHNzBiMDdDYzBiQm9nZlRNSW9JNGNDZ0k1TFRtd1RYWUZ3ditIdG9rL1FPR0JpSWk5VWhRbkNVTEo2RThKSWtST3N4WUVvUkZDS2FDaTZJMmZmbjY1b0g0V0M2SGtZOXpTZ1B6b2N4RnRpUnBHTE5ZWWlhb2NtSnl1U0JTelVQZDEwMnFFNmY3YVRna1pSQlZndGZtRndtcUhZbHFNSWFWaXhrQ1lOUUp1LzBpMWErWjN0NUNiZmpZN29kTkxVaGF1c0JEMXp0bytGWTAvRXdxZmV1QVJyZ2dNd0hielViTktmQkE1RkR1U3l2c1JOMXRFNUpxSmx0QWRNS29IYURaUTJ3Q3Z0Y1VjL0FJOHc0cWZHdVpOejkzVkY2dHN2S0dhRCszMGZXZnNjOWNtQmZzWCtTTnk1am5VcElvb2RTMHBFRTRaMlZLN2xaMTBDZkhENlA1eFhZc2RieGkxU2ZFNWl5VXJtRDEwODgrelgvMksvcmkycVhhZkJ6KzROdHNkZmZtN1FGRWVjTkdrdWNPa2o4TEZ4RFd5QkQwQ2U3ZXB0YXREOXNOV2h4K3praDJyU3F0RFExVWN6OEphd3VqSmxiYkhRQVBaRGUrZDMxc2twcDFkQ1BrQlNrbGtDVEtTY2dKbkJMc3FDT3ZhZUVzS2VjYWg3NG8xVm5JWko3cVhLcVJWeWxXd0JvQzhGb3JEVVJlRHVXWUh0OTBteFo3NGM5MURHb01UanpjUnB3V2I0VzAwd2VuSG9qZlFMZGNTdWkvQjJvWG5VTER4Sm5CS3R1TFRWSUdnTU5ra3BNMlUwNlJKNGszMlgveTlac1BINmI5MjZPbUxNWHJzRW41VUVqZnluaDVmYlZKalNrb0E1Zkp0MWwrVDZnZWpnV3ZKNmQ4SWZYT3paaHIzY1gwZ0QxU0hwbkJrYk1jNWpTTHB6STZTN3lvdjRXeGR2SjZPbTZEWmNSL2FSekVvbTJ2bDNiVVNUdVF3eWNiNGRKeGIyTnZWZ21CTUE5WmJiSTBhSk5QYUV0ZWFGcElCRlorZ1paUkp5dHdVTTRYU1lxZmlQeWJ2OEdaUGVJeFFTQ0p3N3ROZUZmTmZzRFkwSEFjU3lyNzdFMWN5S1J3RUVOYTBHYmMvcDFFVlM2eDF5UUVSN0dZdU5sY2lKbGNzbmlWY1hQeDNvSDVLTStTU2E2ZU4xN05pZm5tY3V2ejNYZC8vWWVmL04zN1gxMWV2M28vdjMvMzJZOTBPTjUvZVBmMk5qOFpLNXlVUFg0ODd0MzlpSllSRlFCV2EvSE90YkVsS0RSZW5BSVJFOThpbUdIQkphdE1zREJxTElIM0FIdVRyd1JLTithSjJzUjM1OVllckFGWGtRZ2cxVmdIRnVMa1dRdEJLZ0lLTXNNTWJFem1QZ05wcTVXU0NRdlpmTEE1elhhUTZmNVFNQnZWZWFJOFpuRmljak54SmRnOHJ5ZXdMRUh5UFZlMXgzczRVNkNDaEluSVNBQlZYZkpUdTR4d25TeDg5Tnc5ejN6NnpWOFZyRkpRMzkzT21YbTh1czJEQ2dNODdZOCtLcldPSUpBMEl3bTlrcWY3aDNuLy90ZFVXYWtZeVNhUGxiVTRKWEpnVEdLa0F6NDkzQjdjWmliQjRlWm0ydHpvUlpWRURKU2pqQ2dSRldWbXJZZ1FjSXc5ZFQxc3c4aEhqZjBRaGdSdjQ5RCtNYnBFY1d1UHRPNGRIZG5tVTR0b3Qza0doSnMwTThZWlRUYlB6QlhUUE11bENOd2JCV2V4NEhJb1Rob1YwdnVDanZkWFlvSDU0a0xxUFBHRjl4NW14czZIYmhHeG9IQzQwOElnaVhPMlN6MWJZSDNYZnpWa0h4d25wbWttWWtxWktXODJPeEM4dWgxamZxUTZUNVNUazZpcVlUT21RUzZNN0REU1JQVkFUd3p4SXoyeEI3b3NmL0cvZnYzZi9QUmYvbC96MC9UMDNZZmJIejlQOWZqMnpiRmFKWitQVHV5SC9BaXg1c1FzU2FVRWJqSXcxdWV0V0lxYVk0M205bWFqSXpkVWFYN3FaVmhHeEdSTjVVK2tvdEZmRHhGYjI0OGZUMS81Uk5raFdXUzdJWkU2ejdYT3RTcFJvZ2xlMFBMa3lRMlZTYk40ZEUrOTBtU1RITXNBdTkwWG1zaGtPakxsMEk4Uk1jZGNHbWZaU0NjcTBCTWFjSVBiOVJNbTJBOXlKcDdFb3NZS1FCeng5eE1iK0I5b2Q2L3pTUllYUmozYUpjM3ArdldnN0VJMGw0bzBYb3hWQWtOaktobUprQzd6MDBuNThGZHYzODFDeXE2YU1yRzg4cWxDaUZKaWh5Uk55dUp3RlBMajdZTnNmbWFIMi8wTS94VDM3MzNENmlJb0FhNWN1K3ZNSkltdHQybEVnM0RQU3dOZXVtYXlId0ZrY2VBdVFvMmxiOXNlN1FZTDVNN1VFR1lTVW9rYk56T0p4Z1NrajI5UWpmTm1PMGNWSkhITmk2WWZnampScEszaUhEL2RZcUZoMFJRcGc3eEFZTFI5ZHM1ZzZYZTdOVHFtRmVCK1l2MWtKdVZGQ05JWVFEUjR4QjZrRmpWcExiT0MyMXd3NVV3RzRvM1Y2bFpxSkZPd2FBTEVIYWFTVXltN2l1MkZjYlpaTXFpV0p6VlFIejRDeGZ6NkozL3k4Si8ra0w5K2ZmeTh6dS9KNTc4ZVh0L2xTejFpZDV5UlZDcmoxSi9PakVpN0lZT2JoZXdOalNMYS9yTjMxWVdKWE1WYnlIdXc1MkRPSWdpZ2Y0dHFXZFNCamZFZzdrUXd5Z3p1TThxekxMRUZPeHMyUkVuamRpT01xbVRWSGFveWFIRjNVOWtjV2dtZEFRdmhFTU5jbWhMVVVLcDVaUys1VkExeEhuTUxwNE1MUzhJakt1V3FFb2lDeVp2RXBmWTA1M0RaZ2RjaFJCc1FjNSszbnVGakg1M3dYZXpQdjNtbXhDQ1dOTzFuNVRsLzh1SHBoWmlvbTZzT0Z4dk9UR1NWMkNPeG1IeTd0WVBtZWZpU1BoU243QnplMXlPaEhpcnJEMXdyQU42QnhHZmdvbEMrSXM4dmIrNkxwKzNGWi9vQmQ1S291Slc1T21NeDk3WTdlV0l2N21KTitpajlDR3R3UFc5dGtiNEFMSHBMd2NaYUpvNDlCWFpCTW9TUW9Hc3JKR2xTWlE5NUVDL3lLV2JPc0l6RXhSQ2oyOTZzQ1kyWHNCSXY2QXZwemtZNHhBQmlSVjZ2UXN4Q3JPMEo0M1pualpkTUoza1EwWXJxSVd2dDNGbDdKRTJEb3N6TTVuRGhGa1RhSENBUmE4WnVva3F6VlhlQ3U0bXd3NDJac3dNc0k0UlJaOW9NU1RBT2h6SktvdnRqMWFBSXlKdkxDNytmbi83VCtSZS8vcTkrNU85SVhuNzNkMFJYdi9pMGJDN3pnZWVac2hHcGVGOG43ZjBWRVdWVVRCNEc0Y0R0Tnl4d1I4UVFzMGdTa0NncG1sR3laY0xLd3FtSU5qOHRSREE2Z2N3NlJmdEpIdXVZWkdXSzljeW1uTVl4a3pza3V4QXFTRm1HNHl4WmRSRnVKeTlXaW90QVFheWJVVFZkWEdmY1Q3a1NTQUlvSTJSaHoyUU9xL1hwQ1J4M29kaVoybEhOVGcyeFJLVXp2ZHZ3SXpWbkxoWlVMbiswWU1aL1lCTXJPUUJLOHVhYmQ4ODJ1dm5rNGZLSlZsTW55VEltZ0JsdWhXUVFPQW1ja0JTdStjWCsxbmRISXdHY0FYODNxRmxoUDFBMmQ2ZWZaTCs1bVlqRnNObGVIdkdyNzE3NzVhYy8vcXlNOHUzN2ZUYTNlWnBCV3BvL0JRMVR5QnFrYlcvMi90UXloOUNQNlJOT1FZOFZhVDFnOUp0eTlJMzR6QmNra0JnUnNoQnJUaHVKaVVpakszYUJNd25ZdmM2NEVoR2lCbVFQVDFnTE9xUitLSEluN1dDMUppUXNxQ1FXRGx6MFdqditScWIvT25GeTdoMlpUb2pvN3d3SkNlall4R1VhUFRiMHM3dVlqd1BaTkpQbW5GUXN0cDg2S01PY09Ca2xLMVBWa2Mwa1NScHBrOTdmMXR6cWxHdHl2YmpnL0k4KytkWC85dHYveVE5dXB1ZjFXNzcrNmNWckhlZjl1N2VIVVpQUGxMV3YzMjU0VENMcVhuMXlOOUJhVGFIWmN2cGhuVk1Ta0VocEhBMUJZZksrQU52N3pDQnZ6M2pzcWt2ZW9YTUQwRDZtcks2eEZ1MFVNRllXb1ZJck9NbDRhSGg0clFja1JrM0NRaTVPOERJYk1NbEFwR216MFRSZVA5dUFwbUhpV0wrcXdtNit4UGE0RVNGSlM2TmJ4dzFCNk16ZHg0b29HTXlkV0pTdHpVRTkzSkVZMEVsQUlBSjdYWjlVRUlIUzZqT082U0wxeWZFYVNjOHJXNUdFM1VFaWgyK25PbXRLUDBOQ3dpekt5aW9VY2dwbklWZjFXWVdFTUFnNW5uLzJjRE96ZUd2dXV1czQybHhvQnNsNGZYRzUwV3pWMGt3MDIvRjI5ODNFbTJGK3ZmczU1dHNQd3pBbmM1WnFQbzlEMHNScXNabExOc28yRmRiUUtRbUZPbEI2VzVlRExlblNiSUtaVUtIQ1kwTWdlSXNKbFNDOVV1dlJSbE5mbVN1emFrN2FrZ1dGWUUxZ0NZZ2tBWk5LQW8wQk5vMXNJb3BrMldnZXRxRnlERURRbnlnV0lpZkIyS2x6a2YwU2lNUVdyOGRFRk5seC9kN2RpbThIdkEzTDFLMnlKbTNTY0dLUXFOZUlEN1pTbFdEeDh3U0FLNmIyN2pidm9PT1lpMGphZ0twVjRzekFrYWxXem9OZnlHRnY0M0JCaC9IQ0QxbS91NzY4SDM5NE55WkZjUlpIWVMxOC9mWGxwOS8rMHY3WlAvdVhkMS84eVZjLy9wMy82TSsvd25hU0s1TmFhYXRNVmQyTHBGUmJ3QitqbEZyTmo2Y0NvOUF0dEN0K1hIcFN5aVBWV2ttaTMxWWRoZGdiNUVzYUxWY0NYa2c5L3pFbFp3OUswSVluVHFrckpia1FlVGhCUlloWXFwS0lpSktLK015cE9xdFZIbmkvb3czRHFvN3FJb0FrRXA1bkE2anVaMXc1S1dYU2xJZHhjM21sdUVNUzBMRGpsSVExM1pWNU5uZGhKOW1tNlpBVzVVaUhJL0laNGFiaHNOcFF3N3RpdGdmM3JMVnlEd3BmYlRIZnp3MWU2RmdCSXU4VXRVZEhRVlFJTCtaM3gzelU3UWdtZDJJblVWMFRYaVE3T0dBYURWOHRlYk54b3BvUTJWME02SEJGTTFVaTBMekwvUEJoejJPQkgrNC8zQjR1ckRDVkQzZC91ejNlYVZMMVZvYXFTQWU3c1RCenFjNFY2RnBpb2VZU2FrTUY5RHBrUVNPMkhkRGl0Q0lGTjJibFF1bHNrUTNjSUd2VTJFemNWMW5mRGtVMFNzVFRNWi80U1J5QWNQdm5XNUNBU3dzVjdHTDZHUEp5TTFRczRFU3MxV0EvcnZ1QkhQUHIwQkZIZXkybW84RnhhdDNadUQwVGNXcTZZMFpHendrR0tRTnN4WW5obVFVVjFVS25CWitZM1ZVOHFiQVMwV0FFeVp5K2t5eTBtOGZaazZnZ2FJT1Y1US8vNlAzRjA3cy92djNIYis4dUg0Qm5iK2U2bi9UcGkxc2lOMlpLbk56aHRXbTFTUnd4ZWlIbnBuZWpFL2s1VzJ2MUJ3akZmSG5kM29acjUwMGhQczNCNXNXbzhuaU45UGU2TmUyN1FpQ3l4Q3BzRWlBTkxKcEhQMDVIS0lxTE1Pbmlmcmd3T2xncEtBeFBLZ0ZmWlNJemMxRkpacDRZUm1QTnlyRW5pNnBvNHBDQ2N0ZG9DVWwvUlBzajZSNUpmZXVZb0YyR3NQejhURDNtQlh4TzJQSFZ0ZFJhcjExNUhwTkRmVlREaGVzV3dGZC84ZU1yN3UxWXVMTXkyaFhWSFEwQlVZYVVHM3BQTnRzTFZOOHdDU3ZMUk80cEQ4cW8wNHc4Z20wNmVocXZocndkeGhlZVA5eTVlcG0rMmliWm9IZzd5Q2hwMHpBRzBWaHFLVUlzcE5GRUZkWXdBTGE0WXVwSC92S3EyeFpUNHgyRGdEa3k0Q05sVE5yT0VQbTlRamtLYlV2ZENYZGlzZ3pKSFhjbllCT0FPRHNXOSsvU2lJaTdlRFExSWNIS0FoTnBnK1lxc3hCN2sxYngrdGwwaWxIUFRHMGNlMjRJWTNJS25CMHpCNk0yMnRVMXB0ZE01R0FuR25xV2xEdUxNb1d0RUZYSUt3TmlEcEl1R05lVU5wbFVoU1dMaWlieXJLQUx2TjhNaGsyaVVqVnBuU3J6MDkrdFgrMzAvcTllL2tEZi8vSFBmbno1aGUrbWNudS9qekpPZFZJVmNuSU5WeWNWcTNNcDVva0lyVU5CajZBVXJRS0NSeTBqMGNicmVDeDhMRFlYaXl1K2RkeDVLWmQ1SWNZVG4zeEZxejg2QkdVR3dCc01rbklheEdmSzRwU2FZU0VrUFltVjRjNUduc2pjbXJmTHE1bVRwb0dxaXdSM3BKWEU4Y21sczdrc1duQWRldklBYUQyQk81U3FwUi8yUXdFTGg3UTdxZmhqdWNGTE13dHJoM3RSUHVON1l5YWUzdjdOVDE5ZFJWdTdOdVM2RVFrb2tYRHdEcTFFK213NDdjZk5hTWRKRy8wb2lEOEdyVEJuSXJKcGNsRzFKSmZibHlLSGJib3ZKdm5IdFJvZGtHcXo3RGRxQmxoVVZabVVLaXNMdExOK1JaaDlEUVhqeFdhNzhNNElCREpoWWZibFEyMUN1eEI1aUxDMGlhelFRcjhuaWJEdUUxT1Fkd1AyY2dxSHdzQkpxRXNlZWNHbmROb0hmT0hmVWtOTUJPTDdveU04bHFqQlEwUFVYazJEa2dwSUFyaVhSQmkxR3ZvTnlDekVBUzBsTUFIaFRtUW1GbVdvU0hYQVl2Nlc0anJoUGhJN3BUeGNpSW1Tc3BLNHNaVmgyajE5ZGZ2TjNYTlNLTWc0Snk2c2VmZTduLzdwbiszTi9vLy8vdm45bjlQbTZnL3MyOFAydTcrNGUwWk1OWllvZCswNG1XTVBxOUhiNlNYU3VzUkE1Tm8vTlBlSUhUM0JPek0raXJ3NnUrQnk1Qjh1d3ZCdUFsbStmL0xWSmNKZXE3dFFrZ1Nha1Fmem1UMEpXV0hxOWRPUklLcUpIT2F1OHhRalAwTGszMm1DR0NzRHgrbFl6VWtNSUxjeXBaNWl5bXNGaUZPb0YwNjRWazZ1SFZvb1M2ZUQxcUtCejNsWEh3MEEvOTZ2NDZ5TEYxQVR4MVkvL09WbmZ6Qk9JNU5YZHdnSmlMVUZSelVuRU53OHNER2tuSE5TY1NKT0tROTZhYlc0VjNielBBemIwZXM4Vjlhc1ZBb1IwZnRkS2J1U3RpTXFFY3RRK2dXQ2c0MGRCQTBRUlJkMWxacjJNUGlPYWYwKzMyeXg2NTN5L1NVV2NBditGTzRNckg2VXRzYWhTQ2N6MElHZUFBQWdBRWxFUVZUVlVvUTVENmNwSHJ5NGh2b2dpbVJwaWkxczM5NUJqYktucCtlZEdNc1FvV1owc25PaVYySm9jY25XbkxYZU1vZVRpRURFekIzaHNZWlROMFVTTCttVDBqdEhKSW5OUUVSZWVkRnBzVE1ScHp3TTVDeXNuRkR1NjFheEIrbkY4NmU3aWxRTDFSSW5meDdudzR0Ly90bS9lcC95MTg4K09iNSs4c21mMmNOT3hwZFAzYXVUZWIwSUFwOHFNM210bUFMeHlmYnhPR3RJODVabWNtTnVKU3dXSkNmb2pPLzB2V1pzQ0Z5eDJEMldFU0Z3L3ZtdnowR2JXSkFYcm1DbnJVN0hZeGxNSlRXY2lKUFRNWkdxTUZWbVF6RWhKbGJ0VEtOVlNCV25MSkZxVmtHZDJ3TDJpSmYwSmJ6MlJMRE1RaDUvREExMUIzZEs3VjYxYlBSTUgzOEY1NWphL2xLeFBtMzBPUGVieFptRzRmZzNMNTUvbmt6cjNZNkZhQmlIRnVGSkpNR2JFR1ZCQkZLTGlMSWs1YVFwRCtNZzQxeHJvYVJFUW15SEtTQ3dRSjZQMCt5TzkrYm0wMnhpVHBvOVBBVEVUTnB3YnlJaWNOUnFZS2ZvVEFTUzQzVFNkTG9ScjZuYzhhc3VwL1k5WHFUUWJSSzFGRnNxVEZ5QjlYMlNEdWoxZHFMMm9RU2ZCTFg2STNmUjJwMVlCVUZ4cmxQUFVNSVpjWEdCYy9VcGY0K1k1ejRYRW1GYnhCcE1yS3hCbFdKdzJDbFJ1NG12L2ZNeGJEUHlxQTA5QVY2YlFGc29QTUxwNHNtRkJ5cVJCcTc3Z3FzOFgxNE5kL09GRmZIS1pNeUFzNGpnVUxjLytpLy8rdHZOalk5V3Q4UEQ1ZWY3V2wvNEcvQzRGYWFNT2xjd0s3bEg1c282emdTZlZvRHhjbXQ3cURWc20yekNUTjRmYjVlUEh6dzRJVUgzYnU4NWlNTFJ2dFU1dEExMzRDekVTcEtNaW5HcEd4MUdLVGFES0cwYTFOdWI0dFhOV0pQQ0tHL1pTVVRZbTNYSUdsNmJ4am5BTG1NZWhneEc2bk5KYldFekRlVW10bGk3bzR4cVhZdncwamdjNUMyVHZzMzY2WlRBK1ZHSkpKYVpVMHVxNlVYbjkxQnJURXlaM3YvZm16OThNYWZEZC91TEorbHcrWUpISVdHR3dlT3AxT1M2cE5LUU1PZXhKTldrcUx4M0U0V1pzR285SG9xTUk1dUxQWlQ5dzk3U01MdER0UnhKR1pUbXFjdlBWR1c1eFJEY1ppTUdKS1hvR25BS1YxTG5wSWRGL0hRTzJOWkFYK2hyWFJVMmxzYXc2RkhkMUp3T1BkMW5aYnB3UjJ5M1RLTys1cGI1Y2x0aWJZcEhqZ1h0Z281S1phYlVxWlV4R3V1U3cwVm0xSndVeXlSS0dwbEV1N3U1WFJ1RGZjWUtpbDNGdmEyVUZvcldtVnZLVGt6dXJaVUNaaWV2aHFicUZGV1ZZWHQ1K1lHS2tTVFNQT3lySFVpZER3OTR1dE9VQkRLTW5BQjNyM0l4dmM2ZmVxWGRabmQ0ODNsOWNuVnRiOGZ4bG9HMEhkbDN4SW1jcWJoWHF4YmpYckp3QTUwQWs3RWVsQ0txUEtnMlFVMGdBcU5WTHljZ1duclUwRnJSYmI0R01yUXJJSk5IdHMyeWdHTWxDV3ZqaUV1cHN5UFhJU1dwR3grT3N5a3JseUVNS0JEeVVvMzFldFI1UnpJMEx3em1ZaWQ0YXZlZXNlREVxaEJPSzhvbFpoMkx4bS9GTXZRSTJLVmFBbHo2TFBCRXFJR1Rmc0ZISTFpdy9qMHJpYXlkVEtkNXBRenh2Qm1uTCtmM1B4bmwvdHZweGF2THQ1L2tuQ1NnVEc0QzEyZ1pld2NCRXBOb3puRFk1TzdZWEZ6eWZEenV4dTJZYVo1S1RnTmNFdnc0SnJ1NGVyZmZtOFBOQnFxY3Rla1RtVHFZclFraTNFZ0psTWNtUTR5Vks2cDJIbzJ6N0ZheVNDQmFDMk5kd0gyVUtrc0xta01aeFYxQjNEa3c0UUZxRTBWZUEyeXdnQUpBSUdmcFFKVG84NjNkbXRYa0hqbXZzUUNCZGlYR3FaRHVYSGpUTFlRSlhTK0dGbjRJRnBhUUFoT1J0UVdjVmlFVXgyMlVpUnd1d2RMazJvck5IdGVZTkhKQUo2N09xa0lYdy9GaHVqOWU3cWFyemN2dGgrTXdKTmFjVE9Ed3lzL2srcFB2L3ZiaHBYOTM5ZUx3cjBiS3Q1Tk1UNjdsblpkYXFNNUhWUlltUGtTZU40U1p4YmxkWWJwNm81ZDZ4Q1NzS2FzTXpHU0JZdWo5cTdPSDkvdGlvMFdoaEJWWXN0WTBPRmVqbzd1a2hoNkFibDZyR1pzNXlTYlJHeTgrcTlIemRnYkR5MXlnNC9NTjc2WStZMmFnbUM4SjRuQzNhU3JWaUxuV3FNNVNEc2RFZk02U3RVamNKMXB1SGhLa2htSWx6WlNNd0pKeVVnYUxzRnZ0b2xKcGhhV2R6bjM3VzlOTzZHYmpRaXU0UVNMY3hqZVVHMGFxdTdLMWVzcjdQLzN6bjFveGZqZHQ1N3ZEdUptekZtR1FWcnRVZGhvd3pUbkRoV2pjSDF4c3ByQjhNbCtMUCtRUjd2dmQxZGJtK1RuVjhYcW9zNlVuTDRBeXZXZGlwOFRrQnEvUU1MQ3dwRGpVN0lMZ1pIV1dBQzhYSVJHSm9EMUswa2dWUkZUalJxdzFaaE5rbWtJWVVEbFI0WlNqcEtaODBnaVJidGdNclJ1RVdZcFRpOU5wV2g2TnZLVmV2L1lIUk5ERXd1NFFSL0tvZUoxRGdVakszalJaRFhuWnB1L0xTU3JNa0lZaFFFeHd3VW8xSkxKaTNJMVlLOG1BUWpKSmtjaEdzSjZsQnVvdHNoQTZpSWdoK0JQcVFKS1l3T1prWnV3RXlySy9TaGl2aDRma2tpV0o1MXp2L2Vsd1BHaTJPbTZmM28wcU9QcFdYNzUvczdtNC9UQzllalplcEwvOGVyNzg2dXJ5eStsSkpkMkJkMDgrZjNqellUK2diTDJ5Y2pVcnN4TjVqeHBoRXVvd0VLeU1EckNTcUtha2tjeEFZTlQyMjcwZnJqMmQ0TXlZby9HNEFtRmdJWXNnRFVYcjhXcEhna21rTExlaGpwZXNiQzZpZy9wMHhQeUxwODgzMEt6cGcrMzNQc2dOS1JWbjlnemV6SFExUHJkamhyT0F4MEY1R09lYXJPcE1rb1VoK1VDaUROVUViQy8zMVR0U3B4bk9WNnlRTEhTQkZnL01JbG9KQTRtSXB2QnhhSHMwVm96cW80Yk85NC9qMDBTNVU1N2xTcXhwQmxNQWJvS3ZRRTQ2WkJ2d2crdkJqT1ppeDVuSG1STWJ5emlNSUhMNC92QndPTXlHUHVFNUNCaVlIcUJLdXlNdTMrbGxMdVhoWVU2WUNyeE9VN1hJSkU4RU41OUR6MCtWUllTVmFqekI4VW5RR3JYYXBaRjJGcW1JUlNhcEtnR0I3QmxGTFZXUUZvUFArajVIRTRwN3Ztd2tKTFNyVmhaWkVUZmNSejdvazFvUXN6UGNoTUJ3T05NcC8zZkJuOHJqRG1JMHpxU2ZVTlJCak1rRHc5b3lGcVVEWnAzNVZKdFB6S0pzb05RRThyS01VTnBhYnhsTkdtaVA1SDdTbzJlbWJXYkVybW1RY2RRTkhZNWp3blRCUkdWNjlzWGYvZXEzZi8vdVRtNWVibi9JOTJYSTQveFYvc0YvL3VLUC9zWFR6OTdMRisvcE8wcktNRHg5S2g4TzI0c1pTY25tZmVGcWRKcWNJSTI3Z1VjQVJaZW9vVStnNUozMFMyQmJvbGlJUDk2RjlmWk5aWW4wRml5ZnJJaUdVNmxkZnJUQjA1ak5LMFBIckJOU3VadnlPQXlERjlRS3JnSnhFU2dUc1pBa3BUUlVuNGN3TXlFdUJVc01kUENsaTBrbXpOTmtuRnFDV1Vlc1VldVF0aU01UU9jaVNxeWlMQlNPWXVyRVVGbHdwTDlwQWEvUDdYSVhYdTN2SnowRExKaGg1UmhOZU9YSzhqNmVGNGJZcy93a0RlTlVhSGVibjgyaUJLVGtUTFY0bVcvdFlYK2NQWkNKQXBxSWxlM2g0ZUg2V1RyTXVtV3JkelVWQ05mai9mNndmelVYTjRmVVJZUWZVNVRDckpwVlhKV0R0d0VYWDNzOG5XWm9qZWZmNVFzdENJOGtUdURJNFc2UHRlaXFXK254MjdxWUdXZzErSzhDemJpQlU0eXIrSXkxSDZtQTdBWUVpSzMxSlh1c042UERVVlpVTVo5UFFnVEVFWXNNWDM2b3lEaFNGV0lTT1oyTW5KSFJXTm5ad0JTU0pGbkI4TndXS29oQVZZV3FROER4OTBXenlEeXpzNHFvQWF4NU8ramQyL3RuVjJWWExxNncvd2JiMy8zWHQzVXV3K0YrZlBXakwyOUhQR0RFZmY3OG4vLzZ6YkhrMjEvOXpwUGJleXNYcGpaY1BaMzIxVm1WeWxUZDNGbUVwTkJKMU04SmhWTVdEVkVRR2V3a2tST3I4WUNjSDc5ajUxT1U1dTVpTzI5UXczcUFSKzhLUnladklyaUtsVUkwNWxFdzUzSklWN0pOdEwyY0hpYVJ3aldsUVgwa3R6ampYWVl3K3hHUjEyS3J1Nmp4QWF3V2tRdW1jamhVU2QzdDdlc0NGZzU5ZFZEM3czUE9pcVFxUXViTVpxbGZlQ0VyT0EybkhTeGVVMmR4aHRWcXFLNE9OdVh6QmN3ZzEvQlVPQm1USU1WbFpaamYvT1hEczZmWFYwWFMrKzgyb2t3Smc3S1NGV0tVQ2lhdklHdm1aWEtXNm9mRDhlbFdqM09kWGhMZ2hZWWkvR1F6ZjJnK3dCaWJvVjBPdzdWRElOWlVjMGIxVlR6bTNVaFBNUXJtcFkrN05ueUZtYVNkd0pINmg2WThGN2IybElkUVpqRXlMRmNMV2ZETElaNVdqdVN4QmR5TXhhYlc1aExTMGxSYUlFcFRoM1FUb0hRbWNCdUh5Z2thaXdUc0RkYlFOMkJ1cHQvb0FRUjIrbEhhVnhzeGQ2Rm5FRSs3dkNUYWRvNkl0U0JVSWxRTE9SY3ptRlFaeFZDQkxDblRERXFKSENPT3gycmdteVREN3F2ZHErZlA3cis1ZkNiKytrTjV1VFc3cDBQZTNIejEyVS8veC8vNVY2OHVmLzNtcHk5dUpwRUJ2Q3Yydk41YnJsYXRHT2ZLTFQzNXBPSEVIOGxQVlFsZGFNdlVYRWprcHpUMmowOUMrNXc5UGdVbkpqWmpiWnR1WEVtVXBjVTdhdXQ3T0lnRTVWaW81b3ZSVkZHT3BHcHVrZ1RPcU1kTTJTejVWQ3BBWG1kUGViTUpsYXpYMmZxUU51UjU1dTd1VE03Q1ZtcEVxMGlQMUdCeDVZV1cyd0lraFJRa21XdlNCRnVpZ05jYzI5K1lPSGdTZU1pbmJMVTFNNDYrRjZibXpkbkRJREltOFFqQVZQWHl6ZTMyK1l1bk5NanJ0eSt1elh5N1VUWUZKNllrTUJ1VlBCUkNKQkFDeWpUVkh6N2JITzV2ZGo0OWV6RWNkNU43dGZ4MCsrTCtheEhTQ3NwcFNENGZDN01MazlNQXNLcXFqdGtLK3hyRTJDOFRxd1FLZ3NqM1c1Q0kzR2dBM3NuRUFjbkZ5ZmVsOFFMNkF1NFBXWFBNODlyaGpHbE9WL0laNFNRc21IaGE2dHB1U0c2MStsTFFkL0FFV2ptTmt4Wi95TEVFRWtFNUVWTkh3aUxVRmpEVGttZDNOb2l4TlgyVWV4SFMvQm85dXZKa3lDSnFKL0hYWUdhWUNMdnpWRFFQWE9WcWQxa0VzajBPT2NuOVBNeWZmdlBoOTY3ZmJLYTN2NmpqODJuMzh1Wmg0UHBHdnZqWlY1djBOcXZPRjYrRzY4T3RqMGJEaTdJUDE1ZDdpa1lkSmJRWU5tNDJ1cFBkUjRob0VFbkNMVitPME52dkpCMjJRVmhwNVI4NWdrKzRTYjMyQm1LS0U0NlJObzlQTFR1Nlgxek1hRWpwNGdMamNQUTl4ZzN5UldVWFpsZ3RWRUg3b3htTTNZcm5uTUpOWTJXcVlTdnFFR052OXo1blVRNjIzTkpRWXdFRXNpeGd0TGVjb095WlZEVXh5RGtOdWtoZysyT3lxRVZQdTNoNG5GbTYyRGQ0VFV4L05DZ1BxWFAwTGRVWlpBNFNwU1B4OGNnZjNqeUgyczNSbjlVWlBESU1JRXNzSXg4bkVUYXJGRHA4ZDBiZHovSnNQTHo3c0svKzYvMDBURWZTRi9mM2RYcmlrMXM4YlpNT1creW1raEQ5V1VYb29ZTlU1WDdxWjQ3eFVMUGtuNlFqcjVFQWNkTUFFOFBXaGtJcmtmdi9DcTlUNE9aOW9uNndpN1ZIeUVXVW5UaTE5a0QxUU1mR0NtdFJJSVJUQVVib3UrSkcxSkpWVHFZRFowOWl6MXBBeEd6Mi9VbWt1ZEE0Mm1CaHhXQkl2eTNFdlNvdWVBdzE4MHFMVVJpQW83WkZQd2l2NFBPSVQ0dHJvV2ltWTZGU05ROGdndVRrTS9LVDdWem1lYjRiZit2d1VJZk41Vlc2ZmZQcHdHbTZwR04rWGwvZlAvODhIZExXZisvcnphQkRadm90L1BWNy92cnJEQmFSV3JOd2xJc2RlZnpvQkVhUGpHa1JWWUlGck5DczNTeC9IMm9DaSt1SjJrVlBpRVdrZTJuelF1SllLVjBjVXcxaEhWVm1sT04ySE53M2gyTTVUS0w1a3RMa3ptU0ZVR1k2VEdTb1RHVE9oc0IvVzUzcktwTkNkTE9kV0JNMWVFUENTcG5ySjRpY2lsaTREWCtUQjJvOE9YR2kydGhIRWVjamkwU1B2K2NEWnNZWmhhUFo3TTZIcDMzQkI5TTh6Z2duZHZHZU9pU1ZRSVJ5MkRQVkk3aGMrZmFxR3RQRWNNdUNQTHU3VzZsdEdFY1F6RE52SjVUN0l3Ylo3Mlp4SG5LQlBUeTh3NHk1c3JuejBlcU95eHcvcVBlNGJnbmpKYVBhTWxYck15RHVDV1ZBajNRWFhreURTVFZjdTI1RUpOb0s3c1dwUUNTbk9BUUdUanFIQkdoempFQlUzRThOY2FIZ2N3YVJFbSs0WnorSE5yOGJlZ1V0dmJoNyt0Y3U3RXB0NEJQc1hUdTkyNlY5alZHTlJPUEd5bUt4NVFHT0M0Zkg1TjJ0R1kxcGNWL0ZBQ3pET1RFaHhidlI3SGlaT09WRXM4Z29lVWdWZEhOM01PSzB5WnU1T04xLzkyTjk2ZDg0ajArLytHcS9Ldy83KzVkWEZicmwvMmZ6NUtGYzNNMC9lVm9PTzN0K2NmV0VmL3ZxL2ZZSDgySHZxa1JHMm0xOC9WV2ROYkZXSGFtSTloSXZDdUYxL2kzTmpQU3hHaG85a2FXNTRrK1lPMHUvSUI0T0o2RW93a1NWV2NocDNBeUhDVWZJbUN4dDVIaVlhQmhrcUxVNmlWZEhuWG1xU3JCakJzT3Q5WmJjaWk4bGRKL3h3d0VveXB5Sk9TMFFFS3crVUNGWlczT3Rja3cxMUJLRE8wVzRhaXpnM0xrU1RiM3pXSGtsajBwb2lZQlU4VGk4Qk9lTklPclZBcGlkWGFnb2taUFZqYzJlQkdXblRPUnYzLzcrRS9jNkR4d0FQeUt2MDFUZHF6T2FzSjhKbEMvblJPSU9JMHRKN1hEM25hSjZGUnluU0s2amFVK1NoMjF0NVVHVk1BWlpCRis3UmRMZEFsM1Nybm9Bd1JINXdhc3VLejR6TUxFcUdLUWkvY3JjSmZSZGRydFdhUzBEa1loQU52aUNXRmQxNzRjZThjSlVqRFY4d1F5MzZ0WlFlSHdTZGVOckM2cnpqMDlEdDFaWGxJQktmTnhDWklqc3QranRXR3MvV2NUdnVmV29tc2lENVNJUXRLNTJKQlUwN2xJUGgzRG5KTzZwRzBrQmlLaTQ1bFNOOU9xWWtzRDlZVGZSZU9XWUxvNlc4L1RPcDVlYnc4M0ZqcCs4S05QdGU2UzN4K2RiR2E0MnI4c3g1Vy9xYnArazdMZHkrNi92Tnc5Znl1OXN2djNxZlVsaXZGRGNZZ1BYUjAyc3BTZmpycjFiM1pZNE05QU1ZeHllS2Y3Ky9QZXNIUWlHUzdTeVV2dFlha2MvRXB4QjR1ekNJc25GMlVWelpwb0w4cERMakRSTTgyNjgzREM4TWd1WncwMnFDeEh0Qm81MDRUN2NkendTT2dGd2QvVTZDd25yUDNGM1g0VmdRVzJTM295T1lDZ21VR1VtUmhvYVF3eEtaRmJMWEl0NTNFTGlMUWw0Y01QdXhPRXNKQzFzcXlrQm1NbkJFdFM0S0V1VHlDcDE4WTVWWTNKRVhHWU1KaHpRT2xlZmQvZjZzeDlpTTBJRk15dGJtZDUrZld1WURnNTNkNjhtdHA4MG1XL2s0Y0hZUmNYTGNYK294Vmd4ejBXVE1wTnZjMDRxY0cvZXhDTGpkcE4xYWRLWWsxSkZxcHB5U2ltbHFCQ2lEUlRzS0ZGVnpjb3Ntbk5XVVJFaUUyVk53ak9ubkJpbW9qbWxKRkRWS0hMNjlpaXMwdnlud2xLN1VwNkZRS3BnWG5WU0xXVmVoSm9KUWhRcENZRTRxU2JobUNrUm1KTm8ySE84WjBQRUYwSTVzdXpvSzJHazJYbFdqRGRhb2hrTGdWc0NRM2Vkb1VFTk9LdHF5dEVJRjRIM3V0blFQbVVBSkRsdjFDQ3FQQXhpeFVYOEIwUnFXOW5QeFRodHIrcUV5KzFRNys1bzU1L21PNXFHWjdqZlh0NU9vOWJoaVgyN3VTdmZzZHo4bzZmZnZOZjVacmFIeitkZnE3NTdOMWlkaWlZaG1BRndDL0VoTjdBQ1RtUTBNSWlrSVJOazFYbEVYS1VrbU5WaXRrSTN1MWdCMHNRc0drRXNFcDh2c1FwTFNycklKbU5lZzlXTHBEbXg1MkJtd09iS05POXVVZG5uWXlGaHMxcm1BdVJ0aG15OUZqTk5ubDJ5MCtWbHl2dzhJNzkrL1FDRkREeGtBY1RuMmFkRElZWGtKMDkwT25vNk5HV1FFcmtEY0xIV3ZEcWo3SVhrcVpjZUlGU3FaZ1lZYTFVTiswK1QvWnlld1NCaVoyZG5DR0xUUGpWVG9rMVI0dVJIWjlRNm5kWXJ2VDFQek00SGgzQTFTOFBUdktIWjZ5ZzNOdnJoMi9zUEQ4ZDVhbG5OWUNjL2xJeDhOVThQaGJ5a1lzcGVUZUhrWHV0SWdDUVphdlBEUzhTV2Uwb3EzTWo3SHVsTVJDWWlnVE5lQnRaNHhPZUxDYWtxZDJKY0Uzdm5KQkxzdWhWYndQeVIxQXZpazg1QU9GRld4R0FUUlMvUld0d1J4aTNLaDAvYVc4d3NZU1pFUjZCOUhMNFJ2K1A4ZEZtRU5GaGpTVnNiREN1ZDlxUXdiVmNzZW9TR1dsNlpSVXFtd056TWt5UVFhOHFEK0p4WnRaWmFKcDVOdGc5MU8rckY1M2QrYzArdnR2TTdQTC80MGVady9QVUVITWJoeWIrOWZGWHIxYkI3em5WUG8wenB5ZS93MjkyRFRWb3dDaGY1KzBCckgzUEh0ZmF6bkE0N1A5S0xiWDFFUEk3ZjY2bDFKd291NFBHZlkyYW5Fc3ExV2dGaTNvbFNMZFhKSFFtU2lNMDFRVGJpcUtYSVlFVTlNN0ZySENGTk1CdjNOdmN5RjdOUVFNSUFwUHNJenFQRXNZSU41S2NlRzZjV1U4ZE1JdDQ2bXNTR2FqVkk2Q0lpUEpKb1NzMFh6WjFTMmUwUmZXbjZTV2ZyRVpCbWVXTjVvUXQyR0VxVDhvR1pxRHBZdmZvMDhaaVo5VGlVdC9kYnYvMFd0VXhIazdrVDlNTldKbW0rZXpEMXlxakNEaE55WjY4MmUrU1VOVmVBQ0VHVTNVbVROdEV5dXZtSW5FbFRIa1I2K2R3bTVHSGVieklHWVUxSndVdnlkbzhFYTdsNXNxcEF1b0Y0dlZ4Z0RYakRpZXVwUTMyN2ZvOVptdzZrYWR0WmhVUGwyTll4bllWNUM1YlM4V1JMWFRlTGRhUDI5a2U2YnBiUVF6alBJMW1rTmU1OHZSajJFVEQ0WlA3ZnRiaTk5MmJ0bmlSTnN2V0prUkpRU3JYaTl6cGNYTnp0TnAveTZ5dVFmWGo2UW5ZUDZXS1Q1K0ZDMHNEbDh2cUhmL01MLzJHdFpYejZ1cVlOZG9lanBtdnc2L3ZFTGFub0kzUzFqMkdOVjExd280UXV1VzduZU5nVnMzcEM1MXhyNnFDdVM4Y1ROZU90NE13V3kwUnVNSmVjNXFrS0Vjc2NNd2dxVHNTc21keE5oRVRTWUdhb0Q2SjV5Tm9SaWRWQVVRVXo0T1JtWmg1TWJvRGNQUjFFVkZXMG8wY01rWmx5K2xhSUM5UUNkeXl0ajF4QmJtWm9JbmVxTENuK1paZjFxRDQ5Yk5ZNU1aODhSSXNuNEF5TVRlelJBWS9ESkZ3ZDN0VHpaQTUrK081RFJsTGExcnNQNzZuY08zc3BzL1BjZStvSzRaeWtUSk1CRUJmMjZqUzBBVEFkcUIzcEFNaVZ4RVZFeEp0ZWtoS0lIQVpsVmxCUzFaeDBzWTYxMFdtL3djWkZVRFdsRG1wRlA1dUVZTkRVWUhKd1h1MkR0Q0ttZTVNUml6blllNE9MVGdDdXpJRnE2UFZ2RzB1M1FySGQrYnlqbVh2d0k1M0ozWGpOQmpyOUhyck1MTUJ2MUNaaXdpc25GVUYvNW9Wd0hzd3VySHJzWmFxNGpCbVhkR25XVEpTSG5CaUFWMEloSmQxaUIwMzF2dWlMN2ZGTi92bXpRNTJ1OCtIK1NwOGREaVNwRGhmWVhHdVo5WjkrK0l0akd1Umh1cmpjRFpja0w3Kzd5VmZYZXM4K0cxZ0gvMWc0MzhmY3ozeW1PNkNHbE82Yjh1bUZsNWNFNVpPVkhWVUxBSGh6ZkhmelovK1VUdWp5VEdSV0t4UjJtRDBKQk9RUVlZRjVVOFNiTVRON2lZaEtxY0FnS2ZYWTB0a2dHaGRaY2lkSHpJaEVtZURrUURvR2VZS1Z1MERadjYrcGtzaU5FWEVvSW5CVG5idmVzNG5kTlRtUnB4YVB4ZmorZUJqbllPam1ZZms0S1BwRStkS0U5SXVZZ2N6Qis5ZHZuekxUY2Z2bXE1dUgvZVJEbmFlNUZIUmE1SnlGTmJIZG1qRUtJSW1ubzIzSGJLVzZ1N05Fd3A4ajZQVE56TUJ0ZnJlTWpaVEJKS0lwQmJmWis0YmRaNEd0QXFIMlB2S1NrdDNzSk42NmRrdWpVbmloeFBXMHk1Tk9TYzllaVgwckFCM09EZyszQml2OGhOd1JzOC9UTDJ0ZHlqUGV5K28zQkU3ZS85UDNYZHV0MjArdzFmRzZZbnVWWlU1d2loRmVXTkNndFJGK0l0Nm1FS1M0Z1RreDVXSHdOdWg0RFZBZEx1dmJpN1E1emhQOHM3RysvdndILytUZmZXZFhOTitua1dvUjBvdDMwQUY3NXkvK3Urdi81UmN2bi8vTlM4dVN4blNWN3gvSzd2cXovT1h4NFZCTVpmcG9RUDMzVDJEaFUrc2xMVmFZTSt6RzJRbU0weW5VVWtJSEdLdmZOYjcvQlBkeGhaZFNLWkhPTTBqSndYQVJzZ2JVc0lyaUJCR1o0UkZBNVFiSm1RbkNoRm84RG1CWllNRWNUWjRPbmtoVGk0MGMyc2VsNjA2NjdGamhMS01ZRTdaZjFFQ1VMMm9kRC9kMkNzOEtuN0FPem0vRXZUUmRVczFYU3ZqSHdPL2R4TEs0YzRoZ2NLTGpkNjkvdE0weXZmMzZ5OE84bTVQUFUzRno0NVpuQVdkSlNmeUd6YXF4cUhpZGZlU2hHTG1iSlJWaEEycWpTYUhSdVdTSmxrSFFoQnhFTGk0OU9hUXQ0RzZrMTdhQW1WblhyRjF1NGxnV1c5cElKOXdrUGd0MlBBT0huV1FHb2tVOHRETTVFZ2NZRVJTb1dCbStTNnNnc0RZTFRHK0ZNUExwMndsZS82R3pFMWk2VkJDTXhSVFpBa1NZVnZRVzl6RktmOHJKSVhIeE9sazFpK1did0FCWUJjTGt6RWxGK1REa3ROUHkrZ05kcXhUM2tTNWZmdk5ILy9FL1B2TDc0emFiSmJCRHlqMklTTFhldi9tdG43NTdmZnYrcTU5VFZ1emw4cHYwN08zck41LytsdXp2SGg1dWkvTkhycjBmbit1MnFMZXU5RzBEdmtpbFlIOThBai9xUDdlWERIRHZYUFd4NzZPZVJxU2hnMHFaWGJ3Mk55Q1FpRVZEOEd1Q3VYZ0JPMHNtZ3RlcUxLb3BENm1KL0dweDBrUnJnU1ZXYTYwdzd6bTJ5U05TbHB3MGhVU0FUZ1VzTFZXbWNZQ2pFT2VHZXFIMm9MUlAzY0VpcURGRkphVWw4K01qVkE2bTg4c2FQODRWWDJ4dUh0M3JucC9jYzNYRjMvN045V2VmNU50djM5N3NhN0hDVmlPQnJJMlJzc0RaMmF2WFNpd3AxK09oU2psU25TdHhVa0tJMGl4OHVwRFdwVmtlK2Y2WXRyR3ljTndXZWdXdFdFNHVFUWx0TThFV0JaVEhFY2JpRHBZa2kvdU1WN01tUHhxN25iS0orcGJySjFBalVWWHlWa3Q3Rk1wOUJPeEVKMlpoUXZkZm40NUNzQ1J1TVBWQjFxbjlkZW5XOEFMKzRITlRZK1Q4b3A5Yml3OFB6aXg5L05uR0IvRjNOWDZYUU1UYlVhd3FqTzEyNU1OUXYzYkFTcFcwUmZyay9zMWZEUzkvL3hkdmRRUWxyZE9nNVpaUjVzdW5Mc2N2WC8vb3MzLzNiaXBFTEpQbmw1djNSZC84OHVhWmlKQVZTdlFiTHNFZjdXdjF1M3UvNXltSHFXT2RoUzhuOEhrWkU1YnFGV1J5THZTUnN3WE1CSGl0QmlaWWhpc1QzTUNxaUF0b1JTM21YTTJUWjFpdEp1dzVTV3JqQUlaWGlxbDFJeG8ySkVva2RER0lPR2w3VEdZSmdpSTlFbVR3eWtCc3pyTGdra3JIZFhhSVJHU0hzN09hU3BTV2lEdkM2aGMrTDBiNFk5MUNYa2tkbmE4R2R1a2ljUkppZFU2UzcvNVduNys2ZUQrN1B4UzFnekw1VkN1R3BnRkR0YXFlWGEyNlNKSTBIZlpFZHBqTU9PVWtzN3M1SUxYNWNXbHR4c1RPQmlLR1dzdU81WTdiUlkremEzRTUwc0pLbWdTV0ZLdTJuem5HMUFHbmEvZmNUa3M2UzdCWW10YUxpcTlkY2tKOTA1cGlRWHBkYm5Id2xsSzErQWhPU3VkNkRreUU0RHdiOHF3RlRYVFdSZVdXTUxIOGZTZWQydVZtdExDejQ0Q1ZwWmR4WGxKRkUwdVVSYUphWkNhWTI4Z3FGOCt6ajVsdHFqbmRYckIrTmg3K3ovL2kxZkc3R3hyR1FTcHRuMjV2YnMySHphVmdlaW9QZk9XNGx6M0dhaGZQNnZUc1A3djU0NXRmM1QvTTA2UkQrWC9UZ2o2UHk0eWMzeFhHK2ZIUXJyVjFjUGJWaUJkWVQ2SHplVzNuU3pmT0N6UzVFQkgySkdDVVdhd2lsSU1LTXloUk5XZk5KYWlLM1N2Z1JOekpwUEU0RVlsSUhwcEhqUFVuN1JzaHhFOXBqUFF3NkVta0R3Z283clVZSlpKWTg0bHFyWXVIbGRsWlJMeE9Xa3VGMTJLT1FBZjBhM1RiLy91Y0pmYVl3SlNLcVBhRm50YjhvRmpBMG5PaVlPN21pWm1UTXUrMjh2RGg3VzE5Zjc4cjArR0l1ZFpTbmJYR0dKQkJMRFlkSnBnNWljQVBlMk9OdEZRbUwrUzFsbEpyRFBVa1Njb3BxU1p1WFZJalpvRTdRWEpLcXBuTUhmQmlDNENYQUpKTnlrbFYydXRpWG1hUG1vUlpCUlJKNmgxSDFHNktjdEpvUUVoUlpQbkRHaGFBNEMyMmo2RmpDaEYxdlZWdiswTkx2bFhoRXc2dys2S1U3cXNQRFRydmZYNGR1RkZaU2FQQlVWNzhVdEZvdFpZOFNLb2kxT1JhN3JhdTQ5QUFwQmloc1NRbE01TFNYTjhPdUpOS0l1ZzRpSU1aN3BMbXErM0RYbVo1djJFYVlSdktGNE1acGZmNzU1dTMvSHppVEVjWjV2MzJBMjhQL25UNDl2cFZmYXZiZVhqMit1N2xzM0YvZC8vbVQvN04vaWMvL3RIVmRIc1VxZHhZUnNzbUpNSUVVVit3S1FFYTNSRGFmaHV0M1RuczZlNjFWR3Z0UFY2MTZxSzlGRnFzMnZGWXA1U3pKbzJZQ1laSjg1VmxFV0hWaER3d01TcXNWTGhYMDgwZ0RMZ3F5bHpjT0NuS1BEc1JXTm1JQ0did1ZESEErSmNBQUNBQVNVUkJWTEJKMkx3d1BMbksrbkQvTmc5S3JoZE9WcDJZajJWL05DYmJYRjd5M0tCMjRBaUtibEw0Ujl5a0ZiNElONU8yRU1XYkdkU2E5eUFlU3REZUlWa0pvNnBFWm53NzJjNkU4WEt5clJPZHF2Z2FTUWgwSHNXeS9EQlZHc25OQ3FiRHc0Yko2bFNkU2FPaWo5VWJlaVVIRTZ3YWkzT2R6TFZiQjJYRkozU3ZyUUp3V3JDK1lCUW02QUF5WVNOTTRZSHVOdG1BbC9UOTY2TitqcldhT2UwNHI3aVBLTmVWNkl3cjFGSUVRTjRRdEExQ1p5UU9xQWZURm10OWR5YjFYWmxaMGtwcVdlbU1JSHBrR3FZem5lVWFTYm44SUw3VTMzSUNPaVFodHFhSnRoaFA5anlMQlRtZE9uRytteHBiTGlBNVJKVEo5cmk3dzVQaG1SM0g4WGlZa3lOZEFWTitPeng1OGcxZVZkOWNUbDlqZk5pa28yOTJ4eGVIL0FYOTJmMGxMajhiVXFYaEY1djgyYmRmM3IzODFOT21GTGRFOUZoQ2RXSThhRmJobmxxQmxhU2gzSnlWV1B6Qi8wRmY3YXlSRTRnZEU3c254cGtyVVZXMHlmemhibDFka1lKT0ZNU0FNSlNKODJZakJDdHpNbmQzcVBhV2FrU2ZrcVRjUFgxSld2R1lIazBjVGw1K254Y0M1Z2dFZ1ZBQklIRXlVQXZJN3RBaHIwYUFKbUdKOVBrMUVMdHBORGlDZnJybWRvV1VCSnBYc0RaWEYydE91eVZXQ2V4NGtxQnFibHZueU1QOExQWGZVL1p1VFpJa1IzYW1IbFZ6ajRqTXJFdWpHejNBRERBY3pwRENYWXJzN3Y5LzNyZGQyVGZLa2lPYzVWeHg3NjZ1cXN5TWk3dXBubjFRTTNlUHlLeEdFeEFBaGU3T3lzcUlNRGU5blBNZEFGQ0hDSUlDRTZHRGtQTk10WlJjaVFhMWtSU1M3SlZnS3daVE5wWmRoVk50R0dHZStmTTV3Mk5ibytYSlhmUVpMeFVBWElJTzJFejArWmV0dTVHNk5rTTJNUDF0czBXQ3VlU1ZKWUdza1RqWVI4clJsNys4cXZIU1E1YVlMTjNTZUZZdDRPYi9jZFAxVVhpRnk0MG9LU3RPYk4waTAxcVNJWUExSFQ3M1pDMENEd3MzdkZ2WFVvMENwNWtKRDV6cWZIcno1dHNmUHNVd1lnYXIyMTBWUEgrOCsvcmo4Zk92VDVmOUxpNCs3M0FSTXhtdDZpL0wvL2pOKzU5TloyWEV6OC8rL3ZUYlQvdVB6eCtycW5UcHl1WUdRb3NiYmZSUUJZa2tGbTc0c1RRUmt0NHBPRi9ZaHVCS28zQlZTblB4VGVUbk9XMVp1YXZab0l2TXJCVWs3aEU5MnJCRUZxb2hOS09LeW1VSXgwNVBPV3lXaURubXU4RmFYUkR1dFlib01MWWhkQjdndk5Pb3lLTitkWHdiREswdi9WUWtJdEFhT0c1MzFvM3N3TmFlbVFOYUxHQmExR1JncHNGbkpnZTZScURMenFrYlJST3VYNm8rK2w1OU50RlJ1T0duWWdnR1hSRVJpR2lqMU81RE5yUElYcnlJbVVnd0pEU2JFeEpTVFJRd2pkWXNhS3JQS1FJVVU5WEpoWTZodE0wTk92VVFhR1JuYkt4NjI3cEJiWTJxNk5iQlZkbTNobkV1dXNYTjFJVXRMeStuMEl5SUJzSExHeS9SMEJLeFFpU0pQbVNXbFQyR1JaRnkxZDgyc1VuRG5hN1F0N2dOK1lsSVRiR0ExaksrZzhzVE5kalFTOEpZeGwxR0YyRzRMUVUydEtWVlJMYkxEcWpFL1JUam9ZaTl0WHFhZG9jTDZXZWw3WTUzL21IL0g3Ly80N3U5L3pDOGYzTTgxMHZkanc5Zi94NlgvWnR2bng4SG5XY080Zi91RDU5M2YzUC82ZnpQODBTNTBYdGZkNjVvd2V6WlBuS3JaK24vUkN2SXJncS9MOXRqcnc5d0NHOFRrcGJZMkNzYmJSSlUxUk5TSEYydFNSY0dPWlVzN2VkQkFvTWM3NmhtS3ZScDhsRkxSdjZCSGswNDJCYVdMRjBMNEQwcTROV2VQM2ZhYWoxVEk2OGtwbXE1MzV5cG00VkUxR0NrZmN3RUtGcGdCT0VXYlNlQnhyUnNHSXZYSDM1WDVTSDZvS2NobHlOOFVFSFZVdURWcVlHY0Y0UTJ5UUdFVUNXTUJJT0EwSm0vQ0kxZ2hJQUpYcVJ2eUJJSzBSQ2FXVEhLb0E2aGpvZW83Z1M4T2FWN1Y2VE5tYkNRdGJjOTJPcENYQWFVZWdQaDVKWngzOTl6dGp2MUZwS2ZicC8rZVdzNk96VEQxaFd6TWhXbGpiSzQxRmE2VVJ5MU43S1gyRUc1RWlOcG85TXQ1dmhNSDBHczQ5MDJQV3RjbWxaR2FzWXpoVGZBUWVOZTVraW1yV0VCaUV5d1E3azhsMi9yUC9qWGI3OS8yb2xQTWMxeEh4L3U3eDVPLy9ycnIrVFQvTTNQNVllUGRYaWFmL24wVy9tcit0dmozL3orYjRyTnJ2TEpIblM0KzZkL21pN1ZFUDZ5OU0zWGNITURxN0NGQ1c3cUpZYUlDa3ptSU1uWHBKUkxQQ3kvTkJiYmhobTB6QTNEVGNKQlJLQk5oUUFvcHI0WkRWSzdheGFBR2FzVFdpRlF6aGYzcW1FdE1GNThicTllamlvWXpVeWpMUTU2YzREN29veWJCRkVBT25PRGNlN2tramJBTVNzNlFxUFdTSnVmcUNuZ1ZvRm9LQnBrSENWcWl5RkFCdmxkMVk0a3J1eU1DemVjSXRZODFFWjZnRElnNlRMVkVKVkFhWEZmbWx0TG02aERwT2d6R0psb3IyMFpMaUl5QWhFTUhKcEp3SnFDaXREQjRGRmNBU203dTNxWkY4dlVzdnhyMnVmZVpXemVNVlZjTFk0VTE1amhMY1c1TDNSd3ZkUlpaaEk1VWVKbXk1UkZUb1NrVTJTSmZaV05FNkd6dExCWi9MVElsUmU2M1hXL3VVNVJGVlRaN0pBZ3FyYW1ibVpUdVREUjJuQlNOUElOcmFMSzd1TlBlaEtqc2FVcHNOblZoa0dPKzUrL2liTWU3UEdOMEtmVDZTN20rdmhEK2VzL0hmZmYzSDk0dW5zNCtURm1lL2pWNVhkLytQWXIvKzVwK1BiNTZVbkw4SDU4T3N2RHovNDBuY2VCcjRpWWI4U2RMYXFxM2RTcm5qZmpZSFBPUVBtZjdZQTNwTFROOURtWlc0QmdMV29pUWlQVEcyR3FPYldLeHNKYTRnOVZJQmdHd1VpaFR6d2RBd28xNVpwRkFzM3hEaFFiaUI5S0RqOXh0VG5jakVYYTBMakZva3FHTi9ZU3Z5MUkxRXhMTWZFcU1qQlRuVWt3V3M2c3FxSEZoNEdoUkk1cHFGZnllSGJieEl0bzhENWtnWURXdktrMUJrUWtkNXJNb09tSVlFOXRDNHlJcVZhUzRTUkNvVVZxUkdTbjV0cm5semx4MU1adWFHZ0tkRWxHZFZHaklIcGRxcXJTS0xQOUJHd3JMT3RmMTBVZHkyT3ZhYnZiQ1d1RHMxdlBXTHFTMFl0NTlCeGN5TkpSQ2lQU0tYS2oxbGhGTWwyM3NWN21mZnpWamNHTTVVcGlUeDV2RkVhSVV1bmJiWjlTTEZlZlhkWGNDMVFwN1k4VlFaaHBDZ1I3NDlWYStoQk5vbnFZblFTVk95dVhHWU16VUhnV0NsalB0ZXcrUEQ5OC9mblQvWnQ0L01QZFdDN2s5NzhaMy96d25mNzY0WjlIbTZxenpnYjFrKzIrK2JlVDF3SkZyUGI4NnlJYXNsWHI5cDl6NGRrdHlXZmtxM1hndHJMQ0sxZHdMbUs0M2JoM2pUQzJEOFQrdTZQTlhJWmtSeE9SV3FXaGZVbmRmL09YWDk4UFJkM2k0cGNMYlN5cEVBb0t2VmFuSmh0VlZZVmUyQkxWQjhGTnJPRDJBNWxVdlBDKzFRcm1MMVVXRlYxYldNek1ULyticUpmSmdTcEx3RElNcGc0MU5XQUFSUm1naHFZS1pOSEpYRWMxOUZlZnF3RmVoVEtMcTBGNHNVbmJlSkVNd05WVm1LMHdLS0pXTEdUS0VvR0tsSnVJNTlnTHVKZ2xxYUFycXRwR3BiQWpNeWtCaXlPWW9kMXRpSm4vc0tsamZiQnN1K0FXcHE1Yk0zYTdGTmJvazBhM3pETktaY3E5dTdkSmRTR2VaRFlUdEhHd0NZbXJpVTN1VjdIeFlSdkZKWmorM0ZYYXp5MENsQ0xpNi9tOStnVDMzQmpmZkRBQnFFWHFkdGcyQyswRHREeUUzVU1NcXZPaUptTUgxYXhFYW9vZVRXYmZqY044bWtmR0pHL3NPTnZkNktlN09yelhmLzBmdjlnTjMybVI0M1MvQzR6eCtOK0cvZnMvL3VidGYvamQ0M2QvZlArTE9CNmZIeDUyeDZlbnY5WVE5WXJ1bkZGc3U5djEvRzVMdk1YSmtWRXJTbEoreXVYTFY5RlJ3UFU3c1VHWWFzU0xqclJsMnBUc3Vhbk5UbEY2eVBIRHYvL2Z2ejQvKzNBcW5NT0pwQUowWHJ6WEh2Uk1xSUplckxIMXE5bkN1TzRjWEltT1pDSHBzREpsQlV2bU9EdWM5TXdBRTNVWE05REVDV1VNTmh3WXptZUoxbmxuVnplMG0yNFd0V0lLbmNVR2VCMnRnQ0hpTUs1WEFucXNaMmRtc1Y5NFE5dWR0NkJJajVRcHpRTVFRV2dNZzNoVVhHQ21lci83ZnA1ZEZCbFdYbWMvektHbXRRYkRDb1JOK2FaRUE4bm1hdHlxQ0syWVcxQ2dUWmFnaHRRbU03TXNSQkpPUjBwdDd2cG1XY2w4V2FqVzlnNVdhSDk2NW9KSVc5c2trR1FKOUk5SlNHZ1hSL1hVVm1iSkJFRWhvVUo2RzZXdDNzMmNVMVFKTlBFTDJxLzZNTEQzeUlDSTFOWWcrWktlUW9obzdwMTdHOXM0OVJSbEF1RnlrQ0k5M2crRVZoY2dQRkNFRkMxdDFsS2hTdmRhM0FGVGNRcVVGYVY2c2FmenpxYkRYMzMvekZIdVR4L3Y3c1JLSGV1SHIzNzE5Ny81K3F0Q2wyTCtGNGNmNXVsNys5dXZQNHJZMC9oZkg5NDh5NEh2YXRVLy9PYmtSZUkwN3ZROE1vS3FpTVdmMnZUY0Mrb21BSVhNV1RLdmVob1JhbFMva0FzVm1yY1V5bFJXa1o0b2ZSSndWV0dZZUtwd1MzTm5lZEYyMjdxS01lb1Vhb3FrRG9wRU5ETUkwdHp1V255YVExdlJGRURjL2FmMzVXZSt2Nmk3UEg2NDJCUUY0Vm9wd1dTWUZ4ZVdrZWRDZDVadHA3bHhhdkM2aEZpeEdtaWF6a1k4ZzBKelFKNE9yY2dTT1RHYnBNajdjSyt6UnpTOUFsUTBGSmlncFZqaWlXYVFVc0syQVZHNGFoaXZSVnZiZWhPcjZpMGcwSXJCeElQemJJZTlIRC92eEEyTXlqUzNRa0Jua0I0TTlYQnZnOTRpMjJZL3gzWUIyVkN4Tm8xbGt6RHFvam05ZWdUSFZsSjNLK25MK29VeFhDbDIxcGU2cjlWc3cyTGVqS1pYSGp5WHhWUGpTbThXOW0zR3BuMy95MjZpMlFxUnRsdDJyUDlPYzlNeXZDenRPK3VtakVhdUQ5bUE1dm03cUFkWmZlZ0JFNGlsb3BSdW9LU0lpbnVsU0lTR0RZYzNJNllvRVFMYnZkMFgwWE1RUHBmM3p3cWZzTnRCY2VBc3FIL1E5N3NQOC8zZG9KZnZKNVJuNSs3TkwvLzdmL21Wdnh0T3o3Q21aM2xCbzFzL1BXeXZFemMrMXMwOGozeVZCdDAzSW9Hcy8wT1VrWGtPWEtWS3EwMkhLMVJNeUtBeldxQlhOSm44V2dBZ0lDNlpJZHVIaytxbnkxQ25pR21tUDE5b2x1dkx0cC9CZGlBVklWcmF5VzFZSEx5eXlPWjFNN3lJL0QyRW1ZbFlMSFVURWhLdWJncElKdEVDZTdyWHdjT0Y0YlVHSFVGQVhLMlVrdU0xaXRrOGxHVEZ0dys4Yll3U2FVL1lTTkVGMS9MVVRDb1VDRkQ5QW9hZzNCMzhlSlRpN0NpdzdnbGloQWZuSUVLcUwwSEk2MnBsMGVBTDA3cTRlYlIxZ2xVMnpmM0JkY1V4Q0tqWUM2UCsyaHNqK3N5NnJYRmEvR2dhY0h1dWltNFNQM292eDRYaUxNdXhDeXpRdkx3eGRMRkwzV0Ircjk5WnZYNGtMdEthYmtKSmFXWjBRY2lDV05KSUpIaUlNQlBPOHVpNE5ObFZtNUdydE15a05FUG9zbW9rdzBNWVJCUXQrOTNUUkZPTTFQSE5JTnp0SjJoYzdOMUpNVCtqM00wMXNKTnozWGt0NytYai9QanVhM09lNnpROTIxZi82WmZmL0Y5Q0RBVjIrV0lJSnE5RVNkMkJ6OFZZbEtqeitQRk5TSWFuUTVVWmVwQ0xWMWVQcGxUckNaQ1JLeXR0Q2p2M29MZGRUMW9vMmcwTVpHSWRkYlRHTnFNRU9OcHBtcWRUWE9yczlYS0dSUlJyK1hQdHZraDlqQnJDYVNWNWhxdDJqUEo2SWt5VDB5UkhPWC9lM0p1cWxjRVVOVmY3b1F6dmlGSW9jQllSTTRxTFJOUXBuQlI2RUJFUjFTUWcxV1VjU2gxTm9UMVJ0NXRrcndaY3l3TUVXNGxZRzdLU0RnTUs1OUQ5M2U2KytLZW4wMjVmNlJRNlBVaUZ3c0xEUXhJUkV4RkY4MG5TRko2eDlTbzMzVVNIaW5YOEtCUkljOGN0b2FPVjBhRzNzdGlib2VYNlYxWmtYcDdmUnRnZ0lkZlhCTllCZlRLNittNW5OWFV0RVNCTjkzUTcwNUZydU4yMmdya0swdXl1RG9DNjRQejZpaW83OHRZYXBFczFDTUtaMFRUZVpqZHR0Y0ExNXpJZk83TUVZWkNaRUovUGx3Y0pFUzhIVnkrWXVIL3pLTWFBN3VFZWNkbUhoOFE4Vnh2OXU3ZmY3SDd6SGQrOW1ZOTFlbnQrK3VPLy9lRisrRDkrLzl2VFlNZm5OemRDbUZkeHNOSUtZRzNBdFJDUklDVGNZM1hHdnJyMmJjejh4Wk9Va3l2UEtXTUtRbHFha1hRT1ZkZi9BbHJRV1YzZFhhMk5sV1NtckhXdW1vZ0dDcCtmNXVNUDgzUHUvdzJHTE1GWGVSdzdzc1ZkdExRNHdveUp3QmVtY09qbEdqZHc0WTRnUnJyY21qODQyY3dpQlZCVHhTeXdibWdNSHpsRmVPYndTTXg1L3Vvc2RSeWNBNnhuMS9lQ0FYTGpweGJlK0l3NzBMRXoxQTFxKzRlM0IvLytEK2Z5VmYzOGtHbDZFWkV2ZGFQK0pET2t4VTZZbFZiSjlsaS9sYmpjblF5dHF1WTJFdVcxTEdRMDl2L1ZnYjArd1piSkIxZG1rZVo5YXRHN2ZhYTNKUHNrb3c5WFdzZGVxZHdlekNYWGpMZTNMb1hpTnh4dTNKaFdjbkVRelJSSjZhTjQzeWpwS0VFbFJNd0FGNUlCZ1VWSDR2YVBTNS81TFlWNm8xWks0MlBUTDA5RG1KRTZVdHl0Q25mSENodjFjb2VaeGV2ekxnU0M4ZTc1Y1NweC8vQVhrMXppVk11OUROL3Nmdk1ibnY3VHgva2tkd2RTOENQMzc1VXpLeFdna2JFRkdrRmh1TjhZajI2M0lLWUtOZ1ZSdEVFcWx5MFJsM2M2MWlkME0rTUVRbUFKdTBzNWdpN3lOSExFRUVnWkVrV29zMzkrOEErbnFBbHd5bmoxUG9kcW11TTJTSmFnb0xSSTUyN2V4cGZtNkwwdGlzWWpYZElsdWZYcE05Tm0yK2UrV3VzVkRIQ1l3RlRBY0E5dnV1VVFpL0NRT1R3a3JPWlIxOFNNQ3pxQkdWdndPNjdJQjZ2N25qbG5HWVpCTHgvczQvR1lHVjlRVUZ3OElqOUFFZEVvZVJKQnBBeVdvdHIyVUJ0NFNnNDROcEtNVGNsN2M0dGgrMFJSTTQzTkNkWk55WnFIUDZNOTFnYUEzWnlhalVDa3hHOTVvdlRaZ0c0Z3RCMmEweDI1V3pUT0V2TjlkWVMzYjlhTEpaMXlPNkx1bFVVZ3NGMC90VittdlRGWmFoQ2tGWU9NdWJLM1FMRW1jTVRLZWllMVgwU2hacERwcVFKbFh3anhDbU9JdWV1K3pCNnpqUzZWczR3aFpjZmo2ZDNqdnp3OC9PM3pnSFBZY1BMOVgvM3MvUHpENzU2c3pLZmgvaG5YZ2IwM1J2VEZsNVh0YmxXUmZQUTRuWlNvS1l2NWNnbWRjY2lTRFFUSjBxYTVWOW1HNjBucW9pQ3o1aU9Udm1ydWkrT21WekRWb0p0VUlNVEJBYWV6ZjFhYUNlQU05MlZ0VDRiN0V0TGhzeEFpWlZYNlFmbktwcXRGamk1NmptZ3RjMGlFQ3lVMGdZNnRNRjhaZmFUQUUvVlBRajE5NkRCaEVWSm1TZnV1aXhQQ21SU3E5bTJPSnZzSndDRFhaSURRTk1YWTJoTkxkNTJURG9ITWRaN2p2Qi9sZEJ4M2tidlRZSkFJWUE3M1lBYjdCTGNtMmdXT1JLelRsMDVkNWdaNTAxc05MdmdxckFkSW9HcW1pNDJ5N3dXM2FJTllFTXROWmRFMHVUMGpDeEp0dE1acmdOd2lMVnJuWHBZNUJNdjM1L29zRU53VWhkdnppNnM1VFMrb3BPV0FZNEdXYlZzV3lpS2tTVGx0czBwTENxNjJEOVZPQ1dwOGtBYUpvTERRSlNoRXVKVlM1QWkxdzk2bnNIa2V4anJ0OWpnNmQvdHpwYXJwZUQ3R29YaWRoLzB3bk05VGNEN2NWNVpoTi9sM2RXK24rZjVYeCtQVDQ3ekRsMVkvNjkwTXRyMjNvOWxoUXlTY1FuZU5LeURIaXhzNHMxd1ZCU2xNVDNNZ2x5elltM29ycXd4MU00Wm9BdUI3L0diSEFMYTNTMUdLQkNKbFRScFBVeWtIcDdPS1ZIZTNZQTg4Y0o5N2s4czZLWUUyaGNiNlZIOVZTcmxSU0VjYnIyaVBCaUFaR3RLdjNkUnFhaTZ1QWlLdzBsSnFXdytlemZZa2liTTlCV2lJcURDWWhsYkExQlRkcGZQdVdxbjJvb1JlN3I0bVQxS1A4QkQ3YXJySVlQRjhTRkJ0OXV3QjlRYlo2TzF0enFKMEtacTM5SVZXTmw4LzJvRnI2YzBHR3RkNms2TDZnamE1M25SQU1CQzJPVDJyVVpvdDBNNFZzcFVaU0pOdzNKd1JiaVRpTDJ4UXI4aUQ1Yld1ZUVPYzVDS3FrNGI1WG9aNXV2cStBUWhkUXlraHRkbmlLV3BsTktseVJkWjdJWkJRdGtHU3V3dUVkU0IyNWZoMDJVMVZpbDkrWnZwMG1aQVhuQXgzUExxWVhDcC85ZTQ0djkwOWY4OWFuLzN0VjcrL08zNTQvR3I2NCtmZG01K1Bwei8rOE4yWGF1Z05zSWdMY2FSRkthZThKTklnOHZvUWEwbnYxTkIwc3RJNzV4Y3JWMm1aaExiejI0V0xhcUZzUXB3VkZwSFUwMVlVQzdTQW1aa0NYSjZuYng5UTZER0hxdnU4MGtOYUZsWDdMRVExQWl3bGVyYVh0MWFueWFkNnhxcjBGRFBVUU5TbXJ1VkFRQWNQaVNxdUtweXJtQW5tWkdLZ3R6KzdocGhtWnhLbU1WMEVWZ0JJK2V4RFBldWR5K3dHUThuNEhkbERJU2lvVUtNNENLcG9kekRDWXNOZVhKNnlHUlptUlFTektWbEZLZFRVSDBBY1pvaGErOWRxTUFhNkRxVllUall5V1UxNkxtY0xDMk9JekpuZDE3eWtxL1dBMjhTSk5EaWdpMzRCc0xTczdyNmZ6Q2FRb1Rjei9qWldDTHFFWmhXOXNsMnpCc1BxcTg1a3dlWE80R0xXMjJCVGZZdmZ5TGpONWg3anRlWnlqYXpPa0hkTjJyV3FoTHUySlRUcElURFUxT0E2SktIa3UvQmdwc0tVTVR5ZVQwL1lEVEVQSWhubjFGSUc0RlY2YjBGQ0FrV3JvNXdPNWZEdWNyd2ZUOCs3Ky9FOC84dGZ2RHMrUDcrMTk0OG5VZkdqREhlN3B5Tmwvc1AwYmlmMmpmejNyOTcvOHo5KzgrWXY3dS81YjkvalYvL1BueTY3Yjc3OTlmL3lmMTR1YnJZV1BycXVGaVdGdkUzVkViSzlhNUZCa3BMaGN4S3ZydGt5ME5GbEtERWRMQzVxRWlZVU5XaWhBS2dSYWNYU3dYSzJNbkJXQ1JkSGNaL01NTThETGxNY3RCUUZaV0M0ZS9BT0luZHY1OVB1UEJXaER1QjQzTCtiRUNMd3ltQ05RRUhZWStobGhwNG54eUR3aUZDb3NBUWI2UUYvaG1TdzlxQlVaRkIwWm4vbDU2bVozT0oybEIrcVl4bUsxZ2FZOHBUVWFtSzFSTXVRUVRPUnFXRExEdWVvcXRDd1V5TGpXRktSd0p1cDRrM0p3OFY5MDk0MFZBRWxhbTFQUmU4SVVXMmxvYU5ZZ1lSQmJ5ak5LK29JSFVDUkhjV0xBN3hHUTYwTjhycVMyYUsvdWpTWTNZZ2wwU1lhWFM1VXJSZGsxK0dBV00yN0hYL1ZtN0JWSFBtYUZuK0JTTDQrb2VXTmNNRmFCNWV6RTFrQWZObHVlQTdmVkczcnMycndIYUc3eXdqM2dGNlZBQjN0R05ES0lKMTBOMGlONlRnZVJoNC9IdmNlaysrL252NzQ0ZVI0UEJ3dXlUKzJBU1VlUCsxMlg4Vlp4b1Bncng5UC8xcmYyNVBmN2ZtMi92N0QzLzcrTy83d25SM0lxeGlGMVlmYjVqZlJNcytvQWdrSlhYS3RnejlGQVoxY0pNdVcwOUJHMWd0Mlc2OHQ0RmticXdDanU0Z3h4dFN1NjZCZE1jV0JRcm1EaU5sc3Nac1pib1BHM1c1VTlVcDFrSm5PSXlMT05reG9mMWlISmx1NjhXMTFNN2o1QWd3c2J3bTNwR0ZyRXR0U3dDZ3BmMXBkOHV1LzZsREd3ODdVR1Q1ZHFzOHFxdUhhaURzeTdJUXNJb3BpS2tGZmZKV3Fxb05ObWxDRUlndUlkNnYyNDh1MVYxYUUycWlzdm5SL0ZDenlBMHJ5WWhRWnh5aHNyeXF1cUw0OXJITUYzclNkT1JjWGYxeXB0WnVxZWlFSTNoaUtWcHJRY3U2MVI5c3NjZUZzYnhubFduaEIyUm9HWTZWTTNocnpsd08zYVhGSitkSUp2LzFmNm9LcjFhQXVKS1RVOCtXcE5uaFdBZHJXZkMwVWphSEQ3bnljeXRpaDJsejc2NVpHQXdtZkF6UlRyNkhEaVBQbnp4YzFuSjUrOW9aUDN6L2ZsZFB6L1lNT1FYZkgyZVZVZDloUGZzSE9MN2o3NGF6dkplVFQ5MUlPRDgvMEFPY1oxaTdMVzFqZmhySzIwTHR5YnQ0WFFFRytxbksrZVozS3FOUlNNZzlEZVpHRllwRnk3dzFEUC9memFpcXFBd2dkVE0xRmlLSHNjOHlsYkZzYVZhSFpaSmc5THBQdGpZZmRZT29UYzhYYVdDK1lLVkVqWitlRWlDc3B3U2dwdGxSY204UytjQTMzZFRGYndvUjZDcEFsV1ZtZDNMS1Z3eEMyMis5TVJjSlA5UEFRVVlXYVpBWUpWQU5LcWcyRFVXSnF6MFFuUStEV2p5MUZ0UXhGeTNWM2VaVjlzNjFwdGMyMklLcFNyZjNjZFBGbGs4OThjcll3ZFcxRzVXMnJ1OW1MeHFKVVdsVkxWL2duZEk5dzErZ3R6dDhOTFZtYWZJK2J0bm85NWkyUFdhQXQwK2RLR3BSLzRsZ0lBR3h6NGtWTGNuczhGK1gybGFWTVhvSkM1U3FBWGJ1R0VwMmt4UlNnK0JJRXI1YTJWc3MxWXFTZ0o0bXB4Z1psMGpVWUFGeFMzYlBzcUhVdnFrYkc3ZzdueXpOM3RoOC9mL3paKy9MdTAyWEFPSmE3M2Y0eTF4cHhqQkg3RWtjYnh3SHo4d2ZzZlRqVmIrNGZQeHg5ZUl2encrVXNlNy9zQ0w0MmM0amxQY3MvZkFzZTRGTGcvTFFMV0xTTVdxa2xRS2dXVHV6cm9wYlFjUDJoUWZZZ0ptN1FZUmhnRm5RdGgwSUN4VFJnVnN6Z1NwcXhxc1k4QzJYVTBRUlFJd21ISVRMdXNpVjVOZVo0bWhtQ1JDSFU4aFh2VTVJdm5ON21peXZaeHhLQVJSY3lCQkNOZ2RRUlN0c3RTZ0tUVWFQT2dVYXl0SmE3cEtTN1NBeHF3d0J3YktYMkRJbEkvb2JTQkRPMERQc2hQektiM1hScy8zaTM2UGhNemxPbTZUZEhQYkZHWUNXQWdPNVNTa2QrYklwV1hhZGE2VndDYnFhM0t4eG9DenJzU1pEWTVEWmVENCtYVzJzZGhEU29PblBoOElvN29sdUZXd3pQRWxEZC9JM1I2UitiYldmL05pdTgrUVdubXkvUzZIdG1TRnNxZXFzTUxOMzhYVVhRQkRhVW1aRXFvWUFHS1JiT29WMUwyZTluTmRRZVljb3VRS1JYMVVFTDV2UHNHTXArTDZmUCsvdHhmM25tdzk0dkhoNG80YVBhZVliT2IvYWpTTVN1UVBEaCthdmQrUERwODNtU3Vocyt5VU05bHBDTk93cmJKSlNXMnBoVDg0WVFvUXIvcCt5RE9neWdkdzFPMXdjMHY4bUc4NzJCSndGU1RFVEw3akNvaHZ0eEtnZG5DSXFaWjZEQ2tualpHbEJIR1ZSZ0xEMmZCNlcwdlVKMENrZUNOSXNKZ0pJWDhIVVorTm8rdUc4VjFobHNCcEU2VmorL3JvLzlMZFZTUkZRTXRES1VTSmc2eEJ0SnorWTZlNlBKd3hSRG0wNGZoWlZCSXNWcUVrQVpZN1FlYVpHZi9rMjJ6OGIxeFFaZ1g3dXY4SWJ4aUVZZ1lwTlk1cmdjVmdLdjdValhBdG9YQ3V6VmhicUZIbkJORkduckpzVVZKUmNyZGlpeHJ3dmN0UlgyVGNYSVYyamhzWngxc3J0OEJOVEFkUW5OTDl6QWZDMG51RFVXdlBZeHIrN2xObUxOZDFkRUVQVDJBd3pCQ0ZWYytyTkNIY3lZU0JiejJpeGtpemE0M2R4Z3NEcGg0U3dLNkh3SzE4THpUc2M5aitmN0tuN0duVDhwNTR2c0JubCsveERISCtaZGdRWk44TzRjTnV3djg4YzdzL0RkUWUwak9sYU5YTnFSemRSL0dSQjJpcW9BRGFHV2NPYWZ4c0hxQ1lZYTlNVnVoTzF6QUZzK2RNL3FMY013N3NiOXNHT2NQejNKYmc1UzgwSkx0SXdtcVo5TUw0YllVTFJFUUxVRTZHQXhpTURFSFdONGwzTlpLUlpDbGdha3pONUd5QjhMT1lZQWtYTmQ4VlFjTVZiU3JuWnIrWXVyVzJIOUU3M3loeFAzTUdkaU1RTlZaVENvZEhSTjFOa0pSckRteENDQ3RYaDNNU1dqaEx4aEYvVmpHNDBiZ2g1SjNhRHdhSm03TlhlZHJvTEYxY3VyMHIvZmQ1VHV5azhDbHQ3bWgxdzkvR0lSRGF3VjFmYkFyOUVzVnpBdGRJeHVYOHpKRGU4KytrSzZoY3FiOVBBRFdYSFczQmhBVm9iZGw0Wlk1SnJDZHQxclJ5aWE5VTlibXgxWG0xV0tvbG1hbTBReVA5VlppYVdPZWxIbUxuY1cxTFN5enBXdzZOZi9QR0UveUZTcjdTL1BqKytpaGtrOXdiUlcxZEhPYm9ldjYzbXljRUQ5V1FSUjd6ay96WGljeXQzKzEvLzRlVG9kenhKWE5GdmNya0hSb1BNTUJyTUpaVUpSdnpEOXUvMVhuWXVnbEJRVXRsY2pmOEJZOW96OVdaRzFCa2d0eGZhSElyYmJIWUJUVkIvWlVneVgrV0NqaGRKcmFBbE80OUpVYWNaa3QvN1dwNnBGTHN2RFhVMGxJb29zdGlwdVNldXZGUkU1aWczUUZQQkVnOFJWMTNnTEIrcnZOc3dDcmRacTBxKzZzQi9wTkpCUklTektabys3azZoekZjeUJtVTZCUlBnc3BGaGhtQXJFQWhySzYxMWZCMXhFY3hXcnF0R1E4OTZObEtGWjdlZ29adHBiU2Q3bTZLYUdZWWxVeU9zcDcwb3FsZkNsNFY4b1g5emN1WGp4YWVLMmR1c2gxR2hoUmszdW4xMEQybDY5dlpEYXM5NG9JYzJIaTJZaFpQdlBZbUhlVExmYUJYenpRUVVYSWNJVnVKMlJrVTVEZnlxbk9veSt3cFBXSlZSSVdLdklNcE5LY1laNWVEVGRQcTgrVmFwUW9WY1hhQ1JpME8vckpEc2JacTgwSGg5UEdyb241MUZJRDJmb1ovLzVYeHorVEV6S3lnQUFJQUJKUkVGVThEdDMybENtODlQUDN4MGZxenkrRFIwT1VUL2pqejhNdTg4UDcvOVpjUFh4MVdWYW0xeVJzUTBsRWEzVWsweGQ0NkovL3pNSHVNNXFacHJMcGdiUDBJV0NzanBpcm5KcjFNcHVwN003NTFJR0s3Q0d3T21hZnpqRVNhK29WVVRKeTQ0UlNTVEtmZm1TZUZUckNOYis3RThnUjdBVU0xTUp6cHVjejZiOTVXcTBvTEJXUVZxakJCSk9nYmdIcVdyQ0d2dXo2V1JEbUR2SGdiV3NDbEhTblJhRUdUaEdEaEFhZTA2TU9wQ0NXdUJDc1pDa0tSZkJPSkNzUHFrRXc4M1VvSmhRWnpORFNRazJaaXRGSkZEY1VSQkJOVWgzN29yVDloYTFOdUdvc3lRWEo1WWw2K1hPeEVQY2hEcEdYNjBDWkFDR2pMMWVjS0hhN1p3NTRzN2ZKbEdoVGZyYVB2aGlUUXZjcEUzc0NUdXgvWmh4ZGR0RkJpVzIwK29wM2hQQU1zd0Zyb1NUS3NvaUlDNlpNNllsOFVHQkJwV0l4a3FyR3d2QmNrM21qWXRjbjYyV2tLV3JJMlVNRDRCd2hWR2lrVS82QklxTEF1NmtFcFdxWGZrMXRFaW1zVWFtV0NBeU9NNU1KVEVwQUNUS05NMG9ER1djSmpDZWkvSlUzcW85VnByYTgySHdwekxJdzJsMlBWLzg1MS9KOGZPZGNNQjBNa1Y1ZzRkRHZiUExENStIWVh5UDUwL1A1YXZMdTYvLzdWeHVIdVBMN0tMeFNPWmhLRG12Q1VKTlhZeU15bExkcnlPOHIxY0cvZThONGxWTVZHb1ZjMTk0L2c3THBXWDZkN1N2OTBKRXhSZzYya1h1eGlwYWp5Y3Y0MHlHcUJyQ1hhQW9Rc1RNL2JRYmFxWEdRTzRQREpzWlFVQmRyWmk0VDUrbkE0N3o0ZEdyRHNWaXZDdTFtSXlsRlhuWFhPR1hTaFNtUnpERWtyVE9VS2RrTWdESjRKRmw1MnpaTExFZGNFWWJlNFJFYzMzRUdqaS9Qc0lDMWQxTkFYTTI2eEJVZ0tnZHZrd0daa0REVmVjMkNCOUJUOFdlYU1nYVo5NlFUVlFyVmJxN3A4UHVONUVZMnFha3NjU1NiWDl1M203SHNaWFdkaXpZWWgvQTljeUpmSWw1V2ZwcVlrR3Z5UTNmTlN1RWxsVzV6c3dERkpZVnpieXlkVlpwNXBLcHJDL1hRNXRzTXl3ankxaFkzTTF1MEZOVFJac3pjTlZpYjRlVE8yRkZyTFYrOUoyTUJ6dnNyakkyNU1Oc0tLWXFxaHJSbk5IUnRES0FGZ2xoclNqaWNUb0pZTVhucDI4dWM0UU5zUHY5Rkcvay9CNHlZdGdYZXo3cTI1MThrcS9mbitUeGN0ejJlWTAwc3QzU3QxRTBFWTBQblhHNjRIdzFXY1NMQm5DdFRPaGxvNERWVzQ5Szc3MDM2VmRDUmxHSldTN3o0UlNQUHh3eFFvUmlZNWtsa1krT2REck1PUjMzM1c3b1BobUJpQlExRllaN3JUTTVWYXBCaUp6NGhrdlJxem5NRjdSa1RIcGp1bzBBMVVBSG9TK0pDMUkwVkkycGxWcTBzMmdpeW9ZMzltQXNNSjVyZEJGZEl1eUFva3FsRTB5Mlg2VDhTUmMyS2owTGQ3VmlLczI3VkhxNklybHRBMkhEUUFuSjN3RWRYYmFCdDJsWGwyOGlYUlpaRXJneFVDK3p2S3Voeitia2JPMllBV3J5Tm02ZTY4dE1hUlZkWC9ldFBSNU5Hd0pyOHhEWVVKeDA5U0dUelN4T1pwTGpWUjcxelFIK3NRbEhhcnFiVXJKTmJIMnprZDVLU0ZXb3R0QzlXNWhlSmpGcUczd3hnUjF4OVFKTW5yQ3gzQnFFVzNxS1ZRU0ZWTVo0ZjM2dTQyVW4wRUhtejdzNUpqczhQRitHY3FTVlU1eWNDTmw5ZFhjc2I4dmw3ZEg4MCtuNHllOWZTSHFhYnEyTmxucVlrS3o3QVVJb3Myd29kejl1Q0dhM1d6Zkp1MTVMWnJkVVNpenVXNS84TXJ2VUtTNVBUMmZxUVVEWVdLcGFFYUZuQko2a2g1TEFiajhXYkpKTlRVMGJBNktHekRWUXdNQXdEc0Z3YjJtYUc1M1FLNE9yZFN1UlBVTnpSN1lCZWk0UjlIN21GQ09jekQvTFZSTk0wWTBoZVZtcWJ4enJ6RTJXb3BTZENZTVhTc0lNd3B1UVVLRmxLRU9iTURzcFdvdFdnYXFCb3NaUUVWL0YwcVFBWnFwcU1FOVlqdlFwRUs3WVZkTDlHb3VvZGJYd1g2Rzl1MXYyRmhIU2tWRWJLU05Dc041UUx4bDlhNHpma2lSMjVUcmdpMnc4dHVKNmZlM2E4YzM5enBwd3k5ZE1aWHpWamJTdFJES2VEOW5sSVZSeEV6aXhPY0JWU05XVy9RS1JBZ1hkRXpYUGtGaFlIOWZmRmtBdzBoUGZIckVxbFJZUktlWTVnTWVRVEhFeFRoOEc5WlBwZUR4WjJabnQ0MWdMWW5iYmYrMlhzMzE3L3ZpN1AxeDJoOFhkZFdzenJlMEFtNWt0VEpLR3NZb1VNYnpja0g5aEFvU3JQYzVyeDdmYnZYTmdMZUg4TkJlbktKK24wN2tLZUlHUU9wbnBJS3hDYTF3SUQ2L1o5STlEQ2ZFRk1OeitmdCtzQkFwSkZCV0doMGpwWU9NdkNyRGFLZk1zeWJXdVNUcklOeklFYWpycU1OcDRxV1dLOURHdUg4WWdCVlVvMERLYzE3VjY2OExhaURpMGhUTWRCdFFRQ2E5VklPcHpwYWdHb0dYY2pTT0ZyQkVlN3U0WEhJSTJGSk9MbVd2cjBKT3locUNvcVpBWWhjY1VmdkhsRzlPWUNseGJpZHRRMU1WTTArVWdja051V1dxbjZ5QzdqWmpxcGhUZmRpeWJSOFBxZ05wcWg2NXE2NzRPU2xCaCt6eTFzS05OdS9ybHVjeG1GTFdPd3BjUkxqY2JxSUJpWTJGL0lSTWhObW1FZWMyeFdiTWI4UUZkVnI5KzZVaG5OVlZQMllzQlZpcHBBejFTY0V6TFJVRTRURndPOTdnY0hlUEpmdllBM3ltZzZwZHpmVE5PNStIZFYwYzhmVVg3L0Z4dWZqNHNpL21zSEpZRG5PdDk3V3M4QVBKVExtRExXRVYxY3RNUXZFS3ozYmpQR01GVEhVb2hsZTVTQmdaSmQ2b1dHd1pyaVUxNXdkZDU5dUM5bEtJaXRiMEc5TmFhVFRXWWdRVVpETUx3NmhRdDFrUGk4U01WOVBZR1hzWWRMVzIwcnp6ZmZ2dlZhQi94bVpjcjRFMzZueHYyUmMyMGZjN2FDN2hvL0txR0pqeDYzRXNOaUovVDkrZFJ2WDBMSzhOd1IyV0VzNFRQOHp5VFBtTXVRbE5UcUprWkd3a3l3NjBzTGpPTGhpb3pxUXZYU2p0a1dkKythTEVETDI4UHJ4UVZMMi9nRnJxOHJsTzJsVXUzMVY2cktZbXR3Ty9LWjZYTEEyVEpkRnY5d095emFBcWw3Mk56TFpoVE9TN3VhUWhmR3ZhRnVISXRYZlZPV05yei9pMURlaTJJUmdQZFR1bEg5eEJ4dHdXakdqa2c2czYzSUR0S1p5czNWck5Ld2xvTWhnSldJbWlIcUNHczAxQVU5UGwwRDVDbW9KU0R5RENXbzl2T0s2VWdkTEI2bUo4djVmNHdYdDcrM2Z2cFQvL3cvTzRWbVRkV2VmcXkwck9WWTAwQ1ViK0k0cmw1MElkczJyaE8rbU84dHB2cnl6UFNoVldWRExFeU5ETnVpTHRBeWpCbS81cXhRK1oxcnNFUUc5Q2V5SUpZTmUrblM1c2xzTEVMSW1xdGdyTGhTcngraEZ2ZHFTMGN1QVg5cUNObjhTMEVpOVBQL3Vvdjk4UG50Lyt2VnlUa1o4TXdhVGNHYnBSSVY4d0VrUUFaT293N0tRN01ySW1wak9qWmVSU0JRNnlRc1JjUjl4cjFmSm9sUEF4R3NXR2dGVlV0aHBKV052TjVzdEtXMEduUXZ6YmdwOVV3ZXU0NGJ1ZFlLMHBtaFladXhLTFJoVlJyWnlDYnFRbHVYZUpydHZkRzhNSlZ5dEZyRzkzcUpZVmk2KzFMa2xLdk5uVVIvV21qcit0d3ZyamR4eFdTQU5RMWFvTjVDV2V6U05sQXczSW9xZGlFZUd2SGx5aFVET29ad2JQR3dIZU5PN1dFbW1xUW9wQlpNcnBSaUtKUVRtYkZlSDQ4bFB5aDRxbFFkU2d1Y2ZFZExsVzlsbnVkeDZxSzZUdlIyTC83T01uOXF6OFhsOWR4bVN4cFc1VmxVSkZja3hsK1hNZ1JiTzVJNlR0NGZxRlpXZndvSWRieVhBSldQTGRQb1JFQytweUI1OW1ZZU5UcUF0M3RMTmdnOUtMZTdNWjF2cmdhS0VYQ0piOHNhblgzY3NOUC9PSWJiNVpTQ3MwdGVMYnhqS1ozY0huOFp0anQ3KzdLdno0ZTFhSnVrczVUTzIwcm5ZRzhya0VieHJaRmtGc1pVU21ReVhvRlJ5TFZrT0VWR0VwUmljbkdZZ2l4NCtQSlBjbnRETldUbGtHdFdHR0pTaEgxYVJyRzNLdjF2UXJrbXJCQ3N2dHp0Nnl0SzAvUDlvM203WU1JcjJxTnBhZXUzQTQyQ2E1cDlsYytER3p2ZjhqVitqYi80OTMvdGFLcUd1aHZ1UnphQStBR25mT0Y4UlcyMjMvMFdQcldZYS91anZhZ1dYL0FjTUpVeXRRNVFUMU1XQW1odVh1c3pKQllYN0k1VUNndEFoZUd1ZVVHbnVjWUJvVUd5akJvUFJLRFZ3bS92NXhNV1VmZG5ZL1R1M0tocXBlM2QvNjB1OFBUeC9Pa2J0Ly84WGNmM3Iwb2VhOUFXTGpwZG53SlA1TWxPL0hQbjE5ZUc4UmV4MWcyL1VEL2JHa2l1T1FjN0VIZERLcnNBTkJGb3NuMVBFSk1nUDJZUzZyK2xORDBtRmFLRmlXR3pKa1hxakxjYXltTDE2VFhIWm9DbGFYMGNvY0NIakRvR0pHbVRvYVV1SERVdVFjcmMzcjN5MC96M2U3TndieTZsaHhLUkVLZWlrcnRpcnZJdDFTNzVxYzl5a0F0d0hDUC9GTnBWT3Y4V2pIVVFHQWNTeHozbUFjYkRJT2FGVXJnN2w1WlQrZDZPVTNWSDMxRTlZRWVaaEF4d1hIbVhwNGNzeW85c3VhSnR1Z1ZCUUpxOExJTDBnV044b2oxT28zOEdDT1ErcG1tRWU0aGJjdjkyMDlqOS9HMktObk1RZTRKak5wYkVNdjFDcTRZVERtSWg1cmFPbkRXbFdjaFFySzJ5bGs3b3dvYUVXeHgzd3J2WXRlMmY3Wmw2UFJDVGJua0FZdUEzbkFxd2Z6VStBcENiR3VsUEozZWZEZFVDR2sycHljRUFaVkVySVFhaEx1NTVoNTJNTTR1QTEwR3pDd1RJVkNGUzNEWXkwbnFQTW84OGEyZVp1NFA0L2g0TEcrZkovMThmeGpxcE1WamNoMThMZy9ENll6RHMrMi91N3lkNDI5Kyt3UCt6di8rc3h6M1Q5OC92aGwrT0FSS3pKSmhpdHBWTVFrWUpFME5kQkdJcTJhMFluOVVoa2NySDI1bUk2dWRHbENRMEtJK096MWNFZ0pudVFWWHJoSE1qWHV1bUFYaVlnUE42S0xVU3RPWmlwQ2tlalRqL3p3Z2RJUnpsbUdrcUFlVlFqRkdPcWtkTWhVOVQ2T3g4QUtCZU1STzllSXFacWZ5NTJzSDNONDVFZWg2cWMyVDdmR2p2ajE5K3Y3eFFyVDFIb3BZanplUVF0SlZsUnY2QVdRenBxUzRZQnFTbVNTeDJaa3NLd3dKOGdTZHpReERDWlJScE1KSzRWdS9UT2ZUNVhLZVdZOGM5NGVCR2JCWlR3NUtkY1hMTm45enFhNjlqRFcrYml5QzRLd0NkTHY1STlKekI3d1kvVm16WnpYUTUwcHR1SllaNEJidkdwdEI3MnIzNzJzeExISXFyb0dPRFRQTUcxaFBUa1Z3NHlqZVVDcVhub1hZb3J6eWV4bERTRWYwOGRpbWxXOFBFSGI4WXFhS2dNSkFTV3NrYTFaS2JLRlhvaEk2V3EwdVZwVE80cExKZlRHNzdzcGdLSUFXY3pGQktlTytGc3gzS0pmU25HZGw5L3lNdXp1YllpOGY3aDZPMHdQLytaZS9kTVR6bjNZUGZ6ME8vL2dQdjl0L2RVazF4bWIyRWpkWlQ5RTFlNEhVdytNbm1OK3Zqb0hxU3R6K3N2M1FzWGtiUVNtbG1JSVlLYUJLU2hjaFlqbG9qeVlIckNwa2FCbjNSU2tSUzR4OFc5d3pLT0YwVjh0YnhGbTkxbHIvN0FGK0VTZkI4SVNhbTlubWdXNGYvL0ZYRDQ4ZmZ2dkRCU3BtUXhVRjRiVDB0U2dhYWFQaGFMbUl2cHN2WFVVazRCN3V2dDAzdHBlc3JhRXpOTXRVVVd4ZjYyZ0tnRE9zN01QZDU4czhueDZQNFpkNmtDQ0ROWmk4YVJXQ216MXRyNGJkOHQ3Vm0rRlROSUovTjlKb1RseHltTE53OEY5NnR5eGNwTWVPTHVhVWJudGNLVGVkdm9XWGF3aGhyTUd5UFJ5SlcrVGtBaWxkZXVQTlV5QWZMUGFpcU85cFFQbUZ2WktRcTFrRjJRRmZPZU9HZU9KT3BUdVFveVVXZHBsZjI4MDBDNU13QVBmS25zQXFpTkNpdFRyTW9KR0tQSTBRcjlYbU1vb1lxV2FUV0RMZ0tCanZwRXhuUFJSMWlVRlBKeDlzLzJ3SC9zQy8vUFNuYi83aXd6eDlQdHg5L3JESHZYMS93bkQ2c1AvMkQrVFZlOUZyMkxZS282djN4MWl6MitQVjlkR1hqaVpoaHVUQTRacEwvaG9sZ1FDZGtUbkJRb2dNdFM2K1k0QXdRTUtySTlWSElaUzRETHU3L1dndUVyNmlxbE4zWGtYY3ZYcnVUQ2t1YVNJb2YrN2dVcTUwQVpJWmlVMk1pZVdDRlR2KzArNHJlZno5Y1U1NmdhZVZJTHFqY0xua2VwRFNzcnJvZTFaVmlDTGkycURaYnlCdDN1dTgzd1VYdlJ5dEZOeVpBYlliaW8wRlVWM24wK2wwT2RVaHdrUFVKdXlnbFIxQmhtczhWR2JDWVlPNENSQmdIeTVJMzZNMEZUUVFmVkhWMUw2NHdZWWwvcjlqWmJjOExXNTBaMWd3Tmk5THQ5dWQ4TEpxbGc1d1hXYkdpNVlEeTc1cmsyZ0JYZzNWdURaejBkTVZzU1F1YUR2WnRXK20ySFdsK1dGUEtoWmJ3c1BxN3VnTzFab0ZoNXBCUTRBNWN2QVlxc282VnloOGlVMU5NeGpvVWhDY1o2YXppWXc0UGsrREQzdWQ1N09OQWdtVVl1NitjeG1uOEhqNzI5OCsvR1U5WTN5bzUza1hwLzlTOXovLy9xbityTkJGY0VVcnhVSWNTdFVWVmpTeTV4Z29YbVFYL2VnTjNPSEVQM2FBRlpvYVh5WjVNUVRSS1BBZXNheHpNaS9NYTFWSmZ4QVJOUVRqWU9vdGRiVFYrWVJxZUVEbzBXWk9rbDB1dE5pZnY0R3hmQzZ1Vm9EcytNUmVPaHhPLyszdCsvbGpRT1lhNmtJeE1WVWlvb05GYzQwRTdVby9TRXVZeCtMQnY1YjdTQU41cVhTVlZWWkdMaExtWjZpVngyRWNobDBwTTAxZ0dxTzhGNzhjTHgvbVV3MklQRm9JWEFyV2ttVFRjNjVqanF1Ri9RdnQ0OHFCWHRQSkVvUjUrOER1MkpOMFFpRFhVMTF0eWI2bnlpZmJheDZoV3drbnQvL2NwbFZycUZDdTVLeEdrdXh1VkxuU2dsemR4eTBsK2FVUm1KUzZycjk2V1U1dHRYYldUdEVrU2FxbWhxblY2Ylc1dGN3Z0ZnS1BJQlRRb2ZBeU9ZcnlFakNkSW9PTmlWS01BVXIxcVhJZUZTUjhaajNYTWdqSGVTb2lLRWF4SGFlUDcwYzQ5L2o0ODcvOXAvL3ZQN3pSOTUvTHZtcVIrdTIvZlk4Mys4dm40ckh0Q0Jyc3BydWxlMjVLc2pLa0FScm9Mdy93RjR0alFFSTg0aHJjOHZxOHE2MTdVaEtqb21ZNlI0UUhOS1hFQVNmZzlFajJpWGJUS3d4QlViVjU0K1ZUaVZsYVFGZ1NHU09xa2tIOTh6ZHdNbGszc2FQdDRGTFViS080cXU5MHVzd2NEdlA1ak1wWlNTOEdJR0srRk13bEJmK0tOVVZ2Q2VCWnZHdU1laWdyTm9jdE1tOEZ6cXdyblZBaW9NV3JDdXZGOXFQdlN5a1dvanJ1RHZWeXljRk5hQVNvcGE1Qk51dmRDTEpvNS9ZdVBYQVBsc2VDNDFnRmFlRG1Cb2F3WVZZM21sbHVrUzVjZXRJZWg4T21zMWhSdHE5STMzQUZBbTJ1cURiVlhPNVdybGQ1QTY1cmFrWlhidlZtY1l2TkZrcTIrSm1yNDRzK2NHZHFvZk9WRDJUbElTUzlXYmZacUVUZDQrOUlTVndoYVkxZ3BLWW9RNmxWVFUxanJzVjBnb0VVTlZIUUswbWZLK2tEZzBCTTkwVlJsTFBONFRPdERPSzJqK25UeHpkanlDaWYvZC9yZi8vaERVNVV3d3o0ZjNqK2w4ZmR3UkR6c3BDL3VZR3pHZGJtSm10R1FLbHJFZlRUTG1CSU9QMjFlT1diSG5oQldzQk11L2xlTDIxYUc5Rlc1QUlBZzltQXNBRWFWTm80bUVyNFZmWVhBWWhQamZTS0RnQWlHYldLL29RYkdMeE9FMU16cFVDbERGTEtzbzlFS1ErRDdrZWZacStYT2VyVVJDUStIV08yQVVCY3BubVpqV0RsQjJkaWdscDFSckdpRmh1eDBQcEJwWWpBbDVKZXFUYnNCZ280UGMySGNiY2JkNGNSWWdVK3oyWTJhSjBqUEZ4aXlKZnVPZ0FIUWhFRFJOQy81U3FiMGcwZDVVcjAyUGZBYXhOOEhmUUpiZkQybGZBVEc0NjA5Ri9jSHFEdC9oalh0VDRKc2JVVXlodnZlc2ZVQThsb3NrbHV1UXBPWDA0d2lHWWkydVpCcDhVRUpwcDR4Y2E0VndZSkphbWJ2aDBTRU5KWG5IRCt6cUZCQ29vSFZHQkZkUVRGaHFoV0trS0VkVEFOYWhFSjhhajV4UmJCYVpZUjVGQ2pGRjdtR3FwU2hRZ3BCejNOSC9EVmppQisrT3J0TCthbnU2ZUhjcy9qRk1IN2J5NVA1N3VEWGt2b2x2bm5pdWhMOTlCeUxRRkM2djlFb2plOXNqV1BQNUtqMUQ4S0lWQXJoaEN2VU1nMDE2QTNQQVdUU0NORDBBWnhLYWtNeHU1K2J5bHkzd1J5QWFEUHpIVi9TaXBnTmdLZzgvVVMrbnBhKzBJeHBxWU1WVmlKOVFEYnpMc2RocTlHVWpST3h6Z2ZUMU5HTVBpRnRaaXFjcDR1MGFiUXVrV2VpTWdoOG1DYXRSMGhWeEZKNkVJZFh6U0l3VUNFeUVpb3pveFBwdEJoTjM0ekhGQmlQdFZRSStmcE9OQ0ZveFJlRS9jNktyakx0bmpsbllLVXBiQ1A3djd0aUNoaEYxcmdsVHUwYzdOdnBzdnltdDF0ODgvNWxRTGtaZ3N0WGQ0ajFLekhGL2pmRmJoUzErU0l1QkdXeE1ZTDhkb0F0bm0xMFhSQXVlWmFDTkhSVU1ITTlSV0FxbGdEaFRQa05wdXpYQ09GQ2xDc1FMMEd5c3hjcmdoRERDRmFnblJuQ0VDb1FhYnpSVVhFNDNreVNNeXptemI3ZmRFeStuZG51ZmVMSEI3KzVlSCsreC91ZHZQK3pmM3o1d3QvNisvcjQyVStmb3NYL0pnVUlDMjlLUlJRWFpUTWdMUjBwSjkyQTR1d2dwS2dvUDQrZ3JkSDE5cWpZczRqS2g0VTB2VTh6YVNERkVaNnJuTlFNcGpNTkZKQ2g3STdIQ3hWYmI3S1FSUGoyeURTb1ZDSUduYlFva0lXNjJWeU94aldGc3ZhSnFiQmdCbFp6cGN3MHhDSEdsSElVSk9ndGsvSktGQjk4N0FyOStWOHJHL2Z5M1NaNW1tYXAzcThSRnllOW1LbDFGcVBDa1JzZHVzUUVzV0d4QmhqcG9UdFlyWmgyTmR3OFFBME5UUFJVK0R5eVJvb2h6ZjNPK1VVYXJnL0hVMVBvbWNiNys1SytFV29FblhDTG80UEk2dllhT2VRdFZadWk4MStwMXAvWjlPNEY2SEZJTUZkMHlZcExJT0RzNFczOXRKbVp0QXlieFpVUmRKWFZxYzNzZWI3dGh0Qmxpbnd3QnQrN0kzc0dCQWpoWDJ0VlpQeDNLZkppMXRJUlFnc1FSdmlhSm5YNmRwajEyWU1UZlZsRFE1UTJvVGJPMVMrR1dGcTUxZTFLWWlKRUdKdDJCVnRFQjZpcENDVWhSTGlhV0QyRERzaVZPQXo3UGlaaCtLbkNUaWZuL2VERC92NjVEcG85VG9QUTJHQTZzRndsM0RsYWY4Mnp1clZHV1ZVMUVvcHRuditzQnZEeC9rWG56Lzk1ZUY4TjlmbktMODhmbngrUE9KZ2MzMzJvbEVyaG82NVNWTUJPb05JR1dHWjVpZ1Uwa2cxZFVFRXhGdW5oSnZzS1duaTZZeG1Gb1Y0YXRVUzcxVjFZOWlBYWpGRllpUFVUZ2FGVnduaU1BN2lNNDBZbURHN2FyYWp3S3lvRkNJZ1doR3o3RGlOUllaYWFaT0VLQms2RnVqcHNwdlM1d1ZDR2RCUlIvRXpoMWR2WUh4SkFMOGR0aUkvVTlxdHhMWEF5akNNOTNmajRUNU02dWtjaU5OcHJNZkhjNzFNZ0pFUk1VYlFpdUlNQlNPaWNHWGVDSUFXN0NacHlBY1Z1UklPczZKY0J6WmRoRlNLampIUkw1Rk02bzlKd1d5UU55aTlpcFMwSkZxYTg5bEVSNXRsdEdvVE1RcEFoRkw3bDE4cndxOGV1MmpDSXk3Y3hUVm9FamVFdk5lbmd5MjducktaSGhOWFBYVmR2dFYxMEh5emNYSmx3bUFWbXEzcmRWeWJCU1ZqWGJBS1Vwb2lrTm9pdHhhcTJOYnNqM1Vta25yQzlvUDJ1Qi9ORWthdmNiZFFVNzFJUkpqUE15dk5NRDRVZ2RBT1Q4RVFSVlEwNTAwM2xHSUhKZXhpeGxvZHZ4Qk9NY3I4NFBYenpqSDl6WG5PSjdNYk1OdkQvL1lQSDg3RDNlUDUvbnlHWVRkTXpScmFtWkdlM0FOTElZQ3ZnTXdmOGU2OFdBdWtneTByRTMxMVRyRUpLRktWcU5INzRhQjVCRG9Zb2Rmd0swTmNhYUlpQnVxdzMrMGt4RU9nR2t2M2Rxc0hpMFJrMVRENWtTSFd6VlMwSmFMeHlsaW1xdHE1ZzZwV3JBeWpRa29aTkdMYzYwNmVuMFdtcCtmbko1eEJOVmhoblNrV0pGVGhqdEN0encwOUJtcXAvelF5bE5sVmkyNGttc2g3UUhVWXlCTDFsUDRYbFdEWkgzWm1YVUE5bnhWamlBbTBrRTdwaG9ab0lTSGh1ZGZYUm5GcVBSNWxXUnR2aG1qWCt5TDBpRzFzVVhheUFESi9iRnZZUXp4Nzd1NDEwR3B6Z0xQSE1PbWhKNTBuM2QxSERaZDZSV05NZWVXNnVGcm5jTjcrOExZUW5KTGxvYzJrdmxUalM3ZUE2OVNIaGRIZWViYkp1blhKa1h2UGZXSkRaSXZWS3Z2NTRweEQ1cWlqWDlSb0Q2ZGFVYVRJVEptajIvdUN3V0VBaVBGOE1LbXNuMzVSYXZWUmFmVHpjQ2MrSEtiZi9PbmRRZmZUUEZSSGVmTjN3OS8vMCtOd3Y1OW5LbEplUkYyaHZxSHNlL2tGOTdtQTk0bWZQTVRpbWoyN1B0dFdXbEdMZXN0dmxmYWROSmhVU0VRb0JxdE5Cd2cyNG1LWENzR1VQZ0E2anVNb0VaVlFRMHZtdTlMeVV1Z3VvS2plWGM2WGtBWjQrSFBqdHo1Y0pTWGpxVnY1bGJiemxIOE9KbldxR2MrN0c0VGxNT29nT2p5UDk3dmRFUFdpTnV4c04vdEpxOFEwanhLaXFuSk8wQ3lDS2VXeERBU1ExakpSTzV0NGJXQjdVRitXTnlRRlptU0FaQlFSY1NmUzlnWFQrYnpUSWJ4MXVySDRxcGh5Q1NmZEk3VG4wb2RjKzR3Mm4vMSttTGtDWm5HMWsyb0N4dVcvK2NxVStVWklzbUJ4ZGJGd3l3Mjhxay90RnQ4YjExQnpMSUFBWFE0d0Z6NE9CYXV0RXlzY2I4TXhrd0poSk9tdlpXUDAwVWtzMi9vVk04Qk5Ba2I2UG5TVkNrQWh5d0hPYUxNSU0wb1pMaE1qd2kvVjc3enV6YTJVNmxaS1FhVlVta2hFZ0FKRUJBTERzQnQxaWdIVDZlMm81MmxncUlTVytmaVAvL25mZmZ6WDg2L0wzY2VMWUtxNHEveHFmM2w2ZXFxRGFZMXFWMmFPdGVjSzNJUUFnSys3UHI1QXBDR0VydjBWN242M2RZNElhTzVSWUpJSzUzd3BNdHRGZGVkdzVtVmtJWXhBcnpRRnFwV3F5WGNtYTRXcDVkTWxQMnZzMkhpU3lmOVJLNmVwS3V3bjNNRFl5dmtXV3NXU3dsQWlIRUpoRFpZemJTaW14Y0FZSVZGMVB3d3l5Q2t1UllmOS9VQzN5K1NjanlmaEhMTm11QjVGeENPMzIwWFZWR25xQmlIVHJpWTlrUXBkRUw0bzd5RVJRcVFnS1VKblViTFdwZ1pQdWlXRitYcEZoRWF2WlBMYXI3VHdjTndPblpyYXZsK3JXellzdHFhQlJTb20xeTZsMS9KNWYrUWdpN0p4dG02cXVJRnJONzBxTTY1eWtCYkczTFZPdERmZWJUKzBTbUx6UVhXRkJsa3M4T3l1WktWR0R0dFg1d21YNzh0dW5NcTEyK1k1M3hWamx0WWpLUWtjaGxGWmE2V0dBRkluZUdXUjlDQ0tpSGdRYWdpTkMvWXFWZ3JVMVBUODV1NWhxdENkKzN4VW4vL3QvbTkrL2ZUMGNiK2ZUbExnYzluLzh2M2w2WGZ4SnhvaWRPd1ZSclE5dk9WVjZCVXN5YlJibjhqNENZa012ZEJvczRHRjV4OUw2c3phV29sUVhOU0VpL2VmeVc4dmhwckVVb0dMUktKMHlJQ0txb0lvRUlXYXBRenZCZG0xbWRramd5WFV5dVM2WTNYOWlTVjBXL2VzQnZBT2tFSkt4VlJEV09kS3RTRlJWbWFJR2lqRnVEdmNqZXF3c3RzalNsQ2tuaTl5ZVg0K1YvYWhyM2dBNGNZSXo2Q21EWlFISU0xc0FEem05VHdCREU4Mk5kQXNVZ3pOTlRlNlIxNkZQay9Ud1FvbGlOV2ZDMDNoZ2dwSUw2c1J2bVdLM3BqMSs3c28yeXdGYk5VUytmWG9VcnFYSGN6Vk9JSHJqYmlnZks1ZTc4M056R2JIbFZXTWNtT0t1Ulo4WkEyRHpmNnRHNTJvUy9BMEZtUk9OR2xsSDkvMjNYZkhTbklqUVVHaldtdS9aZHZJdkxRR3JVOE5yRDNodlZaeXJpaWtnbWE3blpwYVhDSmNLaFFsdzh5SmpHVU5tWk9WeUZsTkhDWXNiNll6QmprSFozLzQrcmQvZi9sZi8vTi9mVHo0MDBXR3NzYy8vdXdPZGZqNk1ENGRUN09QNmxjU2cyV054THFrZnkwL0lIN0tBWmFyL09ia3hxeVIyZXNEcmY4aW1rYXFSWENMbFdLbWc2SWxHb1NrVkR4UnhvUUt4Qkt1U3Rpd1M4RlRyUFN0RGk3cEJNMlVTV2dOMWVtbzQwOHhNMnhjeEd0MnBiYlhYR2lBRlRXWTdZc0VSVVVxWkdDRUlWaERZampzQjFjdDQ5NVlBRVU0L2Z6MDZkTjU4dHB1ZEkrc3lwOUV4akxBWmZMYXREVVpYYnc3N0N4cW5kc0x6NlJDQjhXSUdtR3FTL1lwcVladXVxUEVkTHhNT3gxNG9aZ3pjaG1mMVhkb3J1dDZSUFlTbHFCdDNkZlByN2FUNjUwbXNodzRqWTBYY05sZDQ4ZGI0SVhqdzVXVHRWejAyeStMWlFDVjArRG9YT1liQWxUMEFJYUdKMmEvZXhjNURucVdUQmV3SXRkWFdPNTM5SEJrQVlIZW1mSXE5a0xUUUMxQkVXWFN5dHJPT3hNWVU2V1MrbW1Oa09wRjVqclFWV2dZdFlqSGdSZW9naFFkR0FBWUpVTFZSRlZsNWtRUEh3ODgrckN2bDNLb1lwVW9jWDd6L3Y3Ly9wZHZENzg4enBmQ2VuelltZjNySi96aWw2ZmYvKzN2Zm5zVTVaeDhKaTZHamdBNllDeUVvdFp2WU9Jbk5jRDkxR3NtVEdvZmRXei9YaWRlNVB0Q0Y5TmRyM2tuQUFBZ0FFbEVRVlJGdzZrNm1BSXFWQTBSQmhqdUxrVVhxTENTL3o5bjc3WWtTWEtjYWVxdmF1YnVFWkdaZGVpdVBnSWdUak5EWW1RNG1Ga3VLYndZMlZuWk45ckgyY2ZZaTczYUIxalpuYU53U0E1SXNJRnVvaHQ5cU9xcVBFV0V1NW1xN29XWnVYdEVaaldhVXcyQkFDV2RtWkVSYm1acXF2Ly8vYWJ1RkFLRnJnemNLdGV5VkowdE82NmlwNFFNSW01cDFNdVBmL2k5VCtCRndOeEtQamNHczdJS3h5Z1h6T2dpS1ZpSUlBaGpkdUdjZzJWMTF5UWlJcDNRcnVocTVRMWJTcGF0cmdLb2xWbnN2V3NYTzJoTXFheTBnc1FqQ2YxVzhqZ2pxMHdLVFVNZGpLeUphMVZOcm1TeUF2cUFMSTNIa1RncW5LVG9YMEZDYU5WMFNiandlWDhxaVVyek1sc3BIdGJ5LzNwY3NodjdmUHloUVJObW52UWZhR0toL2RNNnArZWx0YmFEWXBaZk5Udmg2Z0pla2Z5T2t2MERXb2dRcHlLVFplRmo5aXVqaXVNWHdTWlcvdUYyeCtPcXltS2ZIUkhrREFOellCQk5sVzVhZ3c1S245dllMU0g0U0oxbU16ZFFZcG80aXFkb0pDeEJhbkVZellpSkhIMDRVaklseFVDalNwZjJtd0IxSUlicEx2bS9mTy9sUDd6N3p2TXYrNUJ1eHo2R2YvUG1ONS84N1dkeDJoMXV4eEE4Qi9jVEttZG1yaGpHNHVpUms1TVYvd1EzMG9QcFFxbWtsODZqazVNSHJtRmJyWGlzeUNwdWVHWXFpaUoxMXFMdkZ5RkpreFBGMkZMRXNTVEw0cXlaakdyR244WkQydjcwMy85NU9NRnhGSW5pYkJpZi9hMEVaSGpXa3BiR0pRdXBkcElkVG1HN0dWZ1FCdkVPenVTR2ljVFVYVlRZRk1QVE4xU3pjeEg3d0tydlhxZmhlQWcwRm8wMFU4ZXFMQmo4TUFsM2NaL1RwT2JPSmUvYlJ4QjNuRnNhRURJS0RFaVlOR1hFUS8wOU15RjBuVGhjTFdkMU8zQy92NDFiaVQ1bXNiR01YNng4SDJhd2FkSXl6Z0VCTUFnWGh4YzNxeDVJU3pwaXhUNHlNNnpwanEzS0NjdGQzVWpLeDV5N1VtOFhJWUU3aGVhSWJNS1hGdVJlOTJvcmJjZmxEdTV6c0RiVkpBYXZ5UWNudTZyUjJ1NUhGSjNjalVqcTVEL1hUN0VBUHNuNTdHUnBjMmlwN2ZNYXQwQTZtMmJyaHVGV3BMQUVkbTRPZlN1STRRcEU0Rko4bGVLbkVjKzZuRTE4QW1Eb2JMcHc0MGpUT0NrSmsyVkFvZ3M3V1NJSnpFem9wT2ZObDh6TU1ZMVBkekpPa1ErZHFQWHkrbmYwejY4KzJ6eXpGN2M1WHJ6NTR1bUh0eS8rNVgvOHYvK2ZtMThlUjVnR21MS1ErY0w3NTZMQ1FxeGttd3dtWWc1RXBnd2ZYVE1KVHZ3bXA5cjI5a2FwTWNpS0pMaEVCMlRua3FGSFJCUUFjbUdFY3RtMFhOTzBJR1RVZHhxVmlDVXB5RWhJekNWR0VDQ2FIQ0FhU3dUbmFJQnhQTjZQOVhwMmZ5bHdnQlFTVkxPem02dGxoc2VmL3M5L2Zua1RIQ3RRNm5kS1E1ZkUzSlZTQ0dBaWtTQWRReVNHdUNoODUwc2dpRUJCcElzeElrcU1FVUJJVXo1MkttT05oeHZJblN5RFdWUW9SOWVVYzhrc25YOEdQT2QySytCYUVib1RNYk9jdG05UWNOdFVUZHhVWXpCUGxGaGxvMk5pV1hCMUQvOVlQVW45OVA3NktBcTgzYkJXT1VubmdkRVA0QnkrdlBlbkFqMmNkTVRJNXNQMjlITGQ4dVQ0b1JnZnRUaW9YZUcxUHV6QkhlbFUrb1hGZHRoaTJNemRxdWJGUVZ5R3QwNlV4QU9mVW9KOURseGZUQVMxYlV0KzZNVFR5SUdia0szQWFBMGtCTXY1Z2dCTDBDR1Y5c0N0ZGxvWUFDV28vYisvOThlMy94QmZmTDRMa0kyUFg3ejdWODkvL0wvL2gvL2pQM2REM0V6N2x0UDdDS21xMW1jRnRPQldPTVBNOUUvOHM0aXR1V0V1VC81TVpjUmVmM0VJM1BLVSt5NmRtT3ljVEpXWkhGbTFxQUd6c3dTZlltMlhwWmFYNUc2ZU5Sdk1ISUdQSTEwOHlmbjFzNS8vNEdyRC9aTXdSMitBdnJOcjJoNE9kb0NKWjNZVEFNUXVSbUZCaUNFVXlxMFh2VzFWUHdKVXBIUWhzRWpKSk16RTVLWVVyUVNjUnAyTW1EUUZZbU5MVUUwMTE2emF4OTF5U21PTm0vWEFNQUtIUWlJV1dRc1cyZ0tlSVg3V2gxRHpjZHJ6Wk15TWlwOXd5elZSQWZPVHR6SlV6QUQwRlpSdUZmRjArcno0UEFrK2p5OSs2UDZ2SGJWNXVMZzZPT1lpMWg5cWFVNTFyWDZtcmE5M1lLdDdnbmd6L0xrL1lKR2ZhR2R4Wm1sdHRzUGF5eWRmMGd5eFdKTnpwWnpQNzQ4dGVidXoxNEhkRFdCeStOaEh6OVBRaWJTSU1ESjFNalZJWUVjdWNCNGRDTWJNZGdoU1p3RU1sdGo3My83eUYvdmZKc3FCK1NMY2ZHTTRmcjc5eTlmLzEyK1ptUTFoaWJnNTNlSEt2ZGV0MGdwTndHQTJvWC95Q202WE9CWXAyOWg2VkV5NU90ZnFiRUxnV2Izdk53bk1UbUF0cGhxRFpRaVlWTE9WMGJVamRGdzJTVE95c2cxWUtGY2h6VktVeHBrNjNPdnpuLytMZDE4TUJyZEFTL1lWL0hzMDFkbWEycDZyV1ZwWVFnZ0VrMG9TWFd6eFhIelR6TlIwM05YVlp6YWxsSE0yaUlOajdJS3FsWXFjQThEd2JHcXQ1K251NUtaWngyVFZ2RVFDci9kWDluTWZHWmlad0dJaTRpeHV4SDBuRU1ITUl5WnliZmNYdHpRM1dwZjBvck0yZ0syeXo1Zndzb2Y2SGNkQ2hsL1RYYzhlcS9vbUxualpNZ1cycy9WOXRxVmlzUkdlOEZKYUM2NjZxU3BTaHR6ZFkzWDJjbk9GUFBJODRrei83ak1xckVaYXpMKzZROUVzbjE2TlY1Vnh0bFpWMTQ2MlYzTTNpTjBBTUJsMU1TaWhLYVBMZk5NY1Bpa3hkL0I3Q2NGaFpDaWdEb0JoRGxJekllbm80aC9sei83MDcyNmZqaDE1dU5ERDdRZWJMNzc4MmI5NjhYOSs4eW9QdlQwSUcyeWRDV01DWUtRczVTN0g1TXovb3lkd25hajY0b2R2cmtVR3BEQVpDQ0JtVjg5SENtVWx1Sm1hcVp1NXNqaXhTRWhsUmcyUlRSOEU1cXJaMUFNenU4RmlGQ25nQ1JITm1icFJNei8vMDc5OG51MlFOQXhoaWQ5Ym1DdHZYYjNWdVFqR1RMWjJGbzdDSUpjNUFMdzJMYjNFSWpxTHpPSDJtTlUrWnVEb1NNUzhHZm93c3BtU2dhUmpGc3BHNHNVTFEyNXdEeUd3YytpbXVtMHpEQVRtS0dKMkloRXJzYWRPWUlsSk00Z2NjZE1ERWhpc3RjWVdLOWhvaG5DNWNpNVQzSFdwdldnWXNUWWlySE1LY0hJcytncUw5eEFlL1lCdXg0MEFzbmpQSHkzTm0zelAzdkk1TFpSTTFQQ1FtcFBTK2sybXVxWkQ4aU92RExTYWlzeWg0V2hSNlN2TkpraXEwRXZBcUM3dEIrSi90L0xSQUVSYXhTK0RxSEtnSkl6U3kwWUp5U1ZUWXhsa1Q4VGthVS9VY1EzZ1kySUoyUjNNa2UvZnYvdXZmL3pMMzc3c0loRDdTNTYrdnZ6eDNTYzZ2bmQ0WXdKTnZaOVI3S2hHVjdBd09TaUxzREF6U3kybi8wZFdjT09abTVuUTZRb3VtUTk1S1dvMEpWUFdqYVkwaldNcXUxb3R3a01NVHBrTVJEWU1RekJIMHVTR1JLR1FiRXlZeVMxbjV5Q2VFNkQ5aHovL294Ky9mK04rODd2N0gvN2kvQVIrK3lFOE4rM3EzSzdtTEhBUUVXRUlDNFJGbG5qcldUSWRMRENGRUNSSVFPQVFnZ3N4NWVRaUJFYTN2ZWlrUDVLbXpMenBOc1NkaldTWk01dG5LL3p5cTgxRmJ3ZElubm5DUlMvSHpHZUN1SG1mRVJjV0FydHp2NDBWVTlNK3MyQlp3U0lCd2tDUXRkZjNnZDhUSitxSU5tN0I3Tk5kRytDWEJKalRVdzFuVVlYMUJNWktWTEF1bWUwUnpPK1MvazUrUml5aHNIeGREWThydmplWlQxUm1lenlOSG1zWURaYlViMStWOFY0ZDdYTUowdTRKVWlkY2E3L3BESU4zcTdjWUpyWmFacWptQ0U5RlRHK1dJeGhHTHBxU21zVUFndVR4VnJyZTFZSGprZGs1NEZndWNMajkrTTBYNzM0Y1NRL0dIZlZQN2w2L2ZxY0xOMzg5NWVlczk3V2lmR0MxSWpjT0paK3JaTDR6ODZPWTdPK3hmcjJGUkxtZGJxVFZnR2xzc1BLSWtwdFBVemJEOU5RMVRlT1VoWXpBY0piQUlpTFpMU3NCN2lIQXMwL1Q1SUZ6YTFweVJiNVB3a3hPSWI3NThFLysxWTh1NlhENDl0V1huOUhsN25zM3NlYU56Y2tkYmxMRjJFRkNERUVZVllwSDgxWmRacEZpNGlKTVVpNi9FR1ptWnhjYmo5blZCRFJzdDVIaDA1N1VlZGh0Z0tqS0ppQ0NDWXhBYnNQRjgwMlNuTm5JbUZpTXFuVVZSUUp3MnNJcWRZRFZMSHZpYm9DclY5RlBsZm1WZDVqY05JZEMxNFkvOE1IUDlsMnNoa2huWVFObmhXN3IzRGl0Q2ZDZ1UrbVByMjdCaXpZRXF3VjhlcU54bjNmRWt5YVcwWm1SdlRJcHZTcDFkVTdaRTFUTzRZbDlNZEE2dmZCa1NvMDVWOWhuTTFQWkVGWnhFNzVLazJycnQvUVFXZ0J2VlpYVWI2Qmx5aEl6M0ozWVV1a2xtakRaQk9SSUxodmRVNHFVYzNhQlo2SWczSmU5Z0M1dWZmUFZTRStUVGoxbGp2THUzZGYzdTM5Mjk1OXpGNC9PTVQvb1lwVnRPWXVEeW5Xck5DOHJtZWFmdklEck8xaGl0L25CY04rNHNxWVlMQ0MxYVNLZjdyS0FOQnR4dGI4UWhTRGtabGxWRlVLUlNicm8wM2djUFFpNVZBaDd4U2xySUZPTDI5MDcvL1ovZW1ISDY1djB5Vy91OXVIcjM1dzNzV1pMeTl0L2dRWFdBU0tTRUlyWGwyWW8yckt2Z3dpRkpIME9UdlpOY0djR0NSQkRqT1FRZHBJNGJIYktjUkkybDVyY1Z0NndZYmNiajZUc3BXMWxoREpjTDAyd3NMQm95aW9KWkZaenZrRXNIWm01bVZaaURsTWlZdmRNVE9ZY1ZOYnB3cWRkNktKd0VEUnpMSzM3QmY3QVcxdjlRZnlnSi9oWUNWMUtaNjhYRU1KakJyQjVRVGRhamo5MmgvV1RPekZteGFVMjF6SWdyTENIMm13MC9QTXlneTVhaVBrZnI3dGJzeEUyNFJHWVNGZHZTOXVqU2h1NlBCRnN0TUxldTNJUVk0bnh0dTRNS1VqaGNoZlFpN2xLMkdLOHV3TmxWZWMrUWgyZ3p0U2NuTUp4UzEvS1I2OTM5eDQ2VDM0eDlpKyszSC84aTE5ZDMzQ2VMRHhTWXhRa2x0VmRVZ0J5MU9pbWxuYXdya1crbjdwRGFwYVhuaHZNaWhNQis4ckEwYXdDU3pReEV6aTRGcVk4b2NRalEwM05tYmtUa3E1VDB6eTVCWWE0bFFHWVNGay9ydTdoNHRuLzlzTm40NVJ2UDd2OWl0L2ZmL3Y1WDRXcWwyczJIRExVS3JoRUdjT1dhcGpKWEoyTFVKTElzeG1KZWVFZ1VVSjBwVmc1N2x6ck1pZ2JSd0dSVXJlSkloaWlUUXo1K2lhQnZIQ2l1MDNIdkU5OXlMSUo2bHRYWEdSbGQ2aUhXNSsydUgvV2Y3aDd0Ly85a3pmM1JKcFNVbFlhTnAyTTNWRndKSXpPN0VZc2xLbGpRaXlod1FCSWZYZ2EzMXdTa2pJbmhxTTRNQ0Z3OTZOaUdIbzJjcFBBcml5QUZROFpHVk9Ka2dJRDBrakJaUkliUzVPN2RubmRRNEhJdEFlQXVSNk9VcDJ6dGE4emI0MWN4NDVlclE5YXlYbnNNMGVubnNoY1ROa3o2bWFWVzF1bGk0N0ZoTUJuTUx4dWxkZm9oUzY0TGpESTZ1azQyd1ZuellLQjRNaXJ2MjhzS1NMeldKU29rTmJWcjgwQ0pvZEJFV0FFa1ZJQzVXa3FlSThBQjNySnB1cXhIKzl6SUJNT2xNMDVBQ0ZJRHN3VGhvKy9UUG01M09iK25weHM4akJSVG1IUXc3Z2w3bDUxUC9oaUYvMklqbXp3dS9mRC9mU0RYKzlmSFBXeXFLRVlNeld4VGQwaUVqSFl3U0pNakhMSFloaUttNzZ0VEcxbW1WVW9JMkVCYzhQWUhjeFdidWpMaWNTQ0V0Y0p5azRJaFcxSDk5bFZZb2pqcGRHbDNlbGc2dFY3eFlFMUhZNTc3M3JoQU1BbWg4cmdkWWpBUkdUcGlrbW1lOWVPeDZlLytQbkZGVi92Tm4venQ1dW5UKy91b3Q3L09vQndsaGpidWpMOGNEOUNvODZ0dDl6VmJNSlhPS0k1Y29NS0ZMME5MSlVKcENubk5LV3M1czZ4SDNvMlBTQ0VibUFCc1lzVFJYVWlOWFNhM2JzWDcyNmVYejdseklIOWNIMTkrUDNkNi8zZEpzcWtnUlBsVkRiOFJUK2tCQWVIQUdaMVI1ZHJzRVF6MHJUalRsUnp6cEZiKzJsZEhxNHRSMTdyOFVadW5ZOWVMR0U1ZnZvbGE1MWR2VTc2V3FqN3FBTzFsZFpNdERZR244TzVDZXVPRTVITHlzSzBIb0d4THczenhRODNBOTliSWx0ajFwMWNyczNjODNsbEFBY1ZKQTlUVmFDZnhCV1UzZC9KNFd6aVRvQXppNEc1Q2JZNUNDc0xFV2tXTjFYelpzOXhwblFncE13QlNVa2djRlVZalgxMFBSREVrcG1QZHpKWlJLWXdkdmw2ZW5iODR2anYvdTdUSjhOTko2c25Fak9uY3VrMWxORG9FaHhtUmRlTjAxc1Eza2FMQm4wZmp2UTZld3ZBczVSeThyQzFHQkt3N2U0clU4QUJOek03SnVjUUlnSUhnYXMrc0NNWGREUWQ3ZDBYSC83d25ZNzU4Q2JUTzFlQlFuL0lyNDhCMzNGWmZ5d3NCSGk4dDRKbGs4ZE1XNjFCeitaZ0lialY4SGJHZERRMVZTTkF1czFtNkhpRW1ua3BUY0FFQnBjU0N6R2JkMDkrOEpPckY4LzVLbktNbk83dkRyOS85ZGx2WHg3OU9FeUltVkt1TmNMTVVWY0lJQkxBNHN3aVNjanNUTnhZZzhFMDZ4SS91SHF1eThuVS9LK1Y0N2hBYmhlSHdQcDZnRE5UZ3RXRkpYWDkyaGw0MDA4eVd4YkJSOFZBMWdEeEZrWnpGamlPbGt4S2tEV3dEcXVzamFyM3FqQzg1a2hkNWFBdlc1ZmJDblZVQlRibExvNlZRbXhXcWpBNGNJdEdYTitlNTk4QlpRUU5FVTlnUVdYNlF3SWZpWWlER3ltcFdvdHdKdXZjRWtPVHM5MEpzd1pYelJDZnVvNE9DU0tlQ0xSL3RjMDVpcm9lTm9pMmwvZmV2SFA0Rm1DVHVjMTRPdU91a3NhWmRiYUtZWHc0cXZ2TzFmc1dIcFo3ZS9xckJxME1SSHgva0MzcDNiYS9TRHBTZjE4RDVaM2NsZFFtNTloM0VTSmRLTFJZT2dGY0J5cUt5ODJ6bi96c3ZSMnl5WFNYd250UExxL3Y3blY0M29jL1lHSit1SHpQZXU4emluaWVqNWFRM1BhK3dZdG92U1IzZ0FPY2hXeUVFeUJFSHJhWDJ5NlFDTE9JbDFEYWtxOXFxc3hGaEJPZWZ2aXo5OSsvc2szSnNYaEJsUGRmL2VhVDMzejJFcHJnek9MMXRxdFVqZFUxa1k3VlE5OXhUZ1k5blZmVytTQ3hvQ0I3WnNwMUxUUjRCVloySmVWeXE2a0JYdlBKVkI5d1AyMVdMWGRYOStiT2FlL1J1b0paSGExK2lncG94QTFxK253NmZmbndaYzQ4MHdVb055RUhaZzZsKzNwVVZHd1dyZFJ1bE80YVVHcHJONU5UbVNPZlF3NEwrNzN5SkpyV3hrK21MSE5mcktLMnhETlRuV0FvcktyM3BUUEttY3lyTExZbHVSSzVDM3YyVFhBeEsyNXhSN1FFWWFVZ09yMGhwbU1Jdm85M3d6djcxNXVQMy96cThLTlAwdVd4OW9HSlZrMGR4NUkzVlpIN3MwenNQS0RzMFpqc05zVC9ydDVRZ3hqd1NqUE5Jb0VHcEgwV1REa0VQNHhtMWFKalJDQjFCbmQ5RkJJSmdTditmTkhWRVlrcnlCM1BmdlNURnhzZWIvYzdZZDRaeE1kamQzblpQM1lDTjBNY3puSzV5dVRJejVjd2FpUjdHZTREekFzZUFrUXN1WGJlUVFRT3hNenUyY3FWa1pMMDIrMkdTZE5tT3lHVUxYK095d2E2Yk03TThjTWZmUGkwOXZtVWhDbGNYYjMvNDcvL3IzOTNteFNCMGQ4MGwzbUZpbkV4Nnh2TVloOTFENE9UcU5IWkNXd1VZb1NyMVBURHRhR2cwU3hBVGxvUjFsUWorSlpGMGZaYlg4K0hhRTBPbWNmaUQ4VHB5ejdKTTVTa3JmQlNBbGtqUHB6Rm1yWi9wVzBZRGRtckxROTN0WUhNaWxhdjR1clY2Mmgyd09SMHdya1djbWQzRWlwWWJ6NmJSOWZ1cU50NWNJZlhRTURGTGUwZ1NOa09RS0pta2wyWmpWZ3N1VXJSSGxicDRJUklnRnRrWitrNlR3WE82b1BudURXalJPZzVIWS9YVDNuMHJiL1paSk1CM3g3ODlYN1RqVm04WHV6YjVMNXBhaHFUb3dVQ2VhTmNuMFBQSDZCMlRpNUdTOXJrZzI2Z3QxaW1tZHNDQ1NJOTlxOE96ejhPMnp3T2dTdXFESzVlTnRGZU9FWTJEeHhDa0pPMG02YmxKc3ZHOU96OWpYSzYvYzJMRHkvemRIL3pTcDQ4MlkxZjcvL0FDWHhXWGRSVnRRN2xZaFlSNFhrTHJWQWM0c2JrQlF1SUtJY1NGMVNZOWViamxOWEpLVlBjN25iaWRpalF1TnpTenNqTkFRNEhKM1hJUnkrMlJDcFdScDVHcWNOVkRCTitsU0VoRUc2TnNwc3lVd0hqQzlCR3NtNm1MdXJncVBrY1ZHQVFBYmtKU3NoNFlXSzZGOXVaTFZOZWQyc3RuTE02ZGpFVkxLQU9yQjhIYjgvTTQ0blNXTU4wMENaQVM1RlhyWnpud2VMMTMvVDYvYkhlVVdzWjdVWlcrUzJHMC92TytyTEFCRklIYU9Va2J4Sk1jYk5xRWwzMnB3SThJQ2RiTk5xbmR5cHZBY3ZGT3lNSVJnYXdzNnJtN0RtWUc5akdVSXptNmpWSktqT2J1OWtJRG1LSkdkSGMySWVVWklBU21TT1ErdVNkOUJzZnA4NXZMMzcwdTEvdmZ2NnJsKy90dnIwNm5NM2cyd2lRVVJFTlJZU04xUUtHcjVJVzhQYVkzWWZSN3cvbDFtdDNjRW0wZm5uOTVKY2ZmZlMrWFAvNksyZWVncm9ENUxtT3B5VlUxbHZSSkN3bStHVUp3NUpKVXNoMCs4MFh2OXNQQTN4Nm5WNThjREY4ZTNzZjNxcjg4Y2QwSFErdndDSEdHSVBNZnZCeVNGTXQxQWlHNHRaVHBsSzlzSHRXOVpTdHVHMUN2OWx1MlBJdHBTa0RPYXZCbklUY25RUVpVYk4zVDk1N0tnWW55aEpBUk42QmFQUEJtL3V2czI2R3lNTnhzNTlHWWhDWGVUUG1iazN3UGN1V1ZLWG5kSm9NV3RvMm1uT29xTnJTd1NSM21KVGJYWFcvVTl0V1FJMXp1QXgxVzZwbWJRbWRuSzlpWk1Rb2NOcUNyei94ODJKbGsvQkd4RGdWV2Z2U2dWNnYzeHBUNm91aXlCWlVXczNCWlo4UkcrM09mdTZxcUt3V0tSWXpQNzlqNThyREQ0dlNxMFcvRkVXYmx6QUtyT2FrV1BMckllV1N4Wm1zTnJnS25sdlZYTHFjd0V4cUtYbFJ5VmNQQnN2UitpR2szSUZqOFpjbjFjd2tZY3dqSWNyTmJYelNKZC9kZExybjV4K2tONWRYdDJFM2l0UVNnUmNGNkVtM2JwMDkyYkpwVGdtRU9CZTNueWxPdjZOblZIMDhWcDRHQWtUNjNiTy8rRjkrMnNFK3VYdGRyYXhlTjhpYXhZQmlHNVlRbUhVT1BmQ1Y2VWFUUlhuOVRhOWYvZWJsN2I1ejBzUEJ1eWM3NmZvaFBNWWZvTWRVSFQ3TDhVOStRd2toQkpFNWRRM0xXTEJVMVlVWjdCclF5bE8zck1VY3plYmRzT2tqZ3k1dUE0aTd2a1NERzRVS3Fwa29kRTY3ZHk1QzBRSU45V0lWU0VtMno1NDlPVTY3b1EvRGVOY2Y5MGlVQ25HM3ZnSm00ekFlK2FKVHo4eGdQSndSS3JJdWNUZTFjK1ZjR2x3Mlc3UHIzRkJPcm5xMGtwek5wOU5KRTZzSXhuZ2REMzVhd3A0OEpHdmRSeTBCM2JnTStSeVBpOFBxMVliYzNFcllXV1BwRU51Q0pWZ25ZcHlLeTJyaXcyay91ZHBaUFRVdDlYbTVXUEQxREhmU0t2Qll2eml1UDAyOFBCbzhwK202RXhqN2JDeXNxZ0I1bmtiaUVNR01hT1hFRnBOdDNHdVh3R1JrQkpBbUNvRXBHVVdKZC9kK3FhLzlXVStrWDkrKzk2Ly93My8zRjcrbnl6Y044TTRMamQ4WEg4bXltYzFUQkg5UXRUNmlVL1czcnQ2VjloVW43YXhhQzMzKzRzLysvWThwQlpCbVozQ3V3UXZCbk1oTWxVb0VrWWh3dlQvNnVUbkcxQ1c4K3VyOWNEeHd1dTRGd3ZubW8yNUhZam0wTEJ6MkdhcFlkTjhyYkE1NVJWbVlxcHM1Qm1TbkVITlNCamdFWmdZTGs2VVJRUWpSdFhFZEIwM3F6RVNVeHpUb29SY0dCNjcwVWNnVU5zTjJwd2Z2ZDl1YlpDNE10NnhHZVZMenBFSTU1UDd3NHlzaWNrcWRnUndDUndJN25uMzBSNi9wUlFmS3UrUVl0K2tPRW9pRVhZcHdRMlU4Mk1XTDU3dlBzM0dIS05tY1FHWmdkaVBwUERCQ1JNcTU5SjJGU2hxNWdKd2dZU0lEY3lqemNEQmxEc0lWOHMxRnRWQVdxSnVURThXS2JhMktuMGFhOWxobEc2MDlvTFFTVWRadU5XamR2Q2dIaE5XL2F5NmE5c0hNamo4ekoyTEVpcWVYb29lakRDcGR3bFZvU21ud3JESnRLdEY0Wm9zUStUaFhDRTV1NUoyYllkRmdJaENSd2IyQ245ekpFYno1ajhraXVWbkpVd1lSZVNhQnU5RndVQVc3Qmdoak1neHB6S0c3NkRJWll0WmtQYk1sanlSRW1mcndyVTczVDNialVaeVJqMkczNTNCTU84bDV0SjBjNWZLZmZmM04rUDdPM2d6b09IODdIbjVtLysrbkJ2OUlCSWR2Ny9vbmg4cWxEMFRxWG5wRVdzVTg0bVlRcThtTzYyYVAwK245cHIzVGtNU0JoY3hMaThkMUVKQnJMcjd3RXRmRmdabGJnSkIxWGZEUk5PNnZsY2g0U240OFBOMU1oVFBJUExLUU96TlRzdEIxa0t6OVpyUnlCcnQ3WitXVFZaU0tFL2Vmdi9qZ3hldkRkSGo5N09Kdy9mcmlWKzl0WHgzZmZSSWVPc244WVpyWmVSbGRiR3pna01wRmxVR0J3QzR4MHFJQ0trU0V3dGlzamFVYVpXQTVhYTZ3U1lnZ1FFYXRVaGt5ZFhQS3FrWWN4WklUd3pLVnFuYnBKNEFKMUcyNm1NeFk0bVowN1V5WVE0Z3hCR25sa3F0MUYxc2VtWU9VOXA3VGNoTjFreG84SEdmR0tzNHFwMVhiR01zWExxcm8waHd1c2daK09EaW5aZkk4eTNTeEpDVzlaZXRmeHN4bkozVTdwb3ZaQmQ1c20xT04wV0dxMWlRL0FYYk0zNGV4b25oZzNWWHpPbDVhYnRwZ2FpRnU4NHZoZXJDdnVFRE4rMEJ6SWdMSVF5MENjdjNPWnBWd0VFZ3RJVHJFWGQxU1pGY0wyOXM4bVFTaURqQzM1SDNXWXd3R0hEWDBPTDdadXJwYnR0aFJWb2RuaU8wOWhyc0xTMDgvdlA3N0oveVQvdlp1dWp1aTIzNlkzN3pjTGM4empGRTc3S1VjTkNJRUJvblhpdnQ3akhmTDBqUXFrajFubTJrUGMwSmtpVzZwcys0eVlKdnkvZFhOM3c4dmVvL0hWM1loKzh4c1hBUnk1VG5PY0RkeTZiY2J6dW82NTMzTVF3aDNUVW1PdUhuMTdPcWRtNHZ0RTc3ajU4Ly80ZFd2ZUx1Vis4Y1dzUEYzTGVBeVNFTE1EZ21TclFBUGF0VWY0am8wRjBTa0xSNjBYZzhWSUpxT2h5bVhhVXdZdGtQZmFjNng3d0pnWEJZd1FLNU9UQzVrSVZZSUorYXBWVmt5NkM4dkxqeEFZcWU5YWs5cEFycXU2NEpvN1dRTGNiK1Y0NGdna2JRZFo2MWI2Q2JOeTFldmJ1c1NjalZoUUx2MFNiWFN0WHRuWTFweGtlM3p1ZFpDNnJJcklTSXJpOElNaWFPVG1mS0NZM3ZNWEZLK1Q1bkxNZ0ZPV3JGMzZvU2kvU25SbEh6V1EvVmxBZnN5UlR2cGZmbGFtVElMckNzSjNob012bDI4RjhXbU4yckhySVJwVSt0MmxYZFFhbkpxN2xJeUw3aklUSjZER0pHRTBiTlRGSEVKbHMxOW0rOUhqa0VDVVkrRHVrT2N6YWk3dkQ5b1JGYnA3Uzd2eEk2RXk5MkJ2bm4yYk5SOVBxamUzcno3OUtsNnpXbnptZjlUa0ZnQlpJK0pHUjV2QkMzcU15SHlQSS93UVVwaWNGUzFnamRKUHRkdUNUR1ppV2JGQlg5NU5Wem0zLzEvbjNxWDhpWXBPN2xyUXh5QVNJMVVLT3BSbUhNWllCSlZNN2FEM0hKT2t2WDI4M2QrL05GTm43YlBMbmFIMzI4MGp6Rk5mVGhIL3RlUi90dTNKSWFBd01GS2Ntc05ZYXRsZngweG5mZmx5YXlhVThxM253NkhzVVNxbzc5NmNya2RjcWJwY2pjY20yS1JXUnh1cm1STzZMWkpaRUgwbFpPYkNScWsyMTN4QllsTUJBa1JJV2VPc2R6SlMvNU0xN21rMnpRK2s4aVdEYWRZVFZkdXNhYjFkbTh0dEhNK1VGWU1TaFJhNVVLbWRGb05kOXdmTmNxM2Z3R3I4eGR6T0RCT0dVMHJEblQ1ZjNwcVJmSlNwekFwdk1ZekFlNUdVdDQxMGRrZmpMbHk0SlY1UVdxMkVsYjltaG4wZ1pscE54dU9iRzZRZ2EyVXpHdTFpT05VSXorZndMcnV0b1BJU3FrQU9DR0FIYkVzYXJoSjc4ZTgwMHpnRUE4OUFPYmczZVRKQ2NmdFJialhNQnlraTByY2RSMGRrOWdZSXFtbEkyMFN1cHRYL0VlL3ZyNStlWDA5N21pZ3UwbDNWemR6UFB1TUlGQndFQ2s5QVpUeG1pcWRoWUsvN2NtdmlsVzBEVkFyb0phdDdCQzF5Q3dEWmk2ZExPaHhQUGJkOGZvenVmdms1WGhGQjk4Y3pjQmt0YmNDQkM5bW5kZE1oNHVya0dmYTZhd0NLSW80NmRLWDcvM3duUi9BaGlmUEw3N040ZFdGSGcrdmQrRzdRSGJ1RHozK3ppTGNRaUc0Q0RzWXhHQUNRZ2pFc3dTMXpiRzRoRE9abXlyRVNoYkNNU21aR2UrZVBMdmNEQ25Sc04wT1hVV3RFTE5YMHJ2RFNicDVmTGtxY04yekdIakFoYUVrNFhHSlpoR3U3RlJuWm1LeFcvZlF5TERTb2oxTDBDcWxZalNUaG9pc2U5ZDhnS3lGR1ZVY3N0SUZlSXRBTFkvRnljNkh1VE5XbXlxK25qUHkrWWpPc1RTMmZZMmhYaHRzUzY0RzJLRVZETTROL08wMU9KYVlRRXhhWFV0bll5TS9LZVJyN3dOTFJRMnVKN011bytNMldqVzJNcXR0NWNxWnUycTlKMkFkWDE3bVRsSytVbzA2Z1lkSUlST2g4eHgyWWJwL25xRnU1b21ablN5N2RBWkxmbnZVWVQ5by96MEFBQ0FBU1VSQlZNem1rMGdZbGFKRXU1dElMUW9KT04rRTBQbk5kZmNrZi9YRlJHa2NEazkyc0ZGSGJpY3dXazhjRHBZZ0srK2RuN3VSSG9FUVlnYmljMU9la1lFcW00eWRRQVhzUXFXTFhybURVSkI2R28vN1Y3ei81bS9HVWJiUDQ5VGxVZFZFdUxJYXlvV25OQlAybmpvdUZCSzAvTU5HQ1FDTFVmcjJkei85NFkrdzJWckdzNS8vRHZRcTdGODlEWDcyd3BjWi9OdEthSzZjUFFFWkNRZEdDY0NtZ0M1R3JPSG5SRlNtUjlUbXNWeWVOQlpWYzFYbjdkTm5sLzAyMDAwM2JJYU9RdnZoVXpaaWtMTzVrOUFVSGp6dzVPU3VXZnFOc1hVK2FtYkxXUXBtb1NUL2dUa2JMT213NFdKdHpPS21WQU82R082V0djR0tYWlVLUjMvVnpQQ1pVamtUMGIxQmE2b1pjYjRHOGpuSi9RUTdYTFROYTVIYTJlT3l5aUphQzVyd2lPU0hGOHhValRIbEdueHFjNFFETGVhQ1I5QUFjNzczZWlqZDJKaSswb2ZXaG5NaGFpeFd5MUw3bFhGTitTcGJXdUpWMEZBMk9LdDdVNERWQ2FoTEVNOEI1VGJVSDZhdWwrdHNFTk1wRktxTTVZa3l4SExXOFhCN3RZMlVvRG1JNmNSaHVESTFVdzR1bUticjk0WjdlWEw5MTNSOUk1ZFhsdnVjYVlocGY3bktrMEhKWENIVTVFdFFiVUNlZFpieG5UNWdNQmYrY0wwVEY5ZE8wNDZWQThKSzRBZVlIYVJwR3FmQjA5R09QdlE3T1dJMzNaZ3ExZE9rWUcwY0FBc3U0UnpoVFZmRHV1Q2hpQWpZTTlLWG56NTdOM1hSU1crL3VkN2k4eS9mMEo4RVB4OUwxRHZ1ZHk3ZzJtVTBJdzVTT0pFT2xxcFRPMkdrT1FIU1pyTWdVbldGRVVjbmMwYThlUHJPUmJlemp2aTQ2MEJtNmhXaFVBOHBPSEhnRXFHRWt5bExnVzJ4OUlqc2I3bzBoYUFOVkZZMTkwQVFaNkorR3dDSjBBelBwY3F4NXRkVkQ3bUF0RkVKc1l1RDRhem9yU3BXTE03Z3VibFUraGRPRHhFNjgvSjNnczBTQTM1Z1hKd1o2V3RieU9vdm10Vyt2SUptMGtURmRIb2xQbk1WZjRWNU9lRWs1V3l0SzhLTXRDdXhvYk5HR2pWSXA4Ym5DSHkyNVZUUlZLRUlGa2JhQXFURmdzaWJSNnYxYlk1UWtJTmRBbHdKN0RrYnd6cWZra3VNaDhCUXlqNllFWk9xcWlOUEhtS3lOSUZrbDBicFpib3pIcTc4THZQWUJSQkg5VFRTanUyTnZuTjhNKzB3OXNjUlBHSFhMSTFBTmJTeTFCNWo5YTJ3dVgwdlAzRDlLRVFDdHkyNDdtRHNDcXR2YnRFUFdIWE1nSW5acHNNeEgzbWZ6SG9YbXlicHdFeW1LaldvdmRTYVlBbkN1Yi9hdW9yaHhBMUJ3dVJtcW1OaWZ2WEpPOXZocU5IdlB2ODF1djNmZnptRmQ0UFRXVE5sVlJuaGNZQURpa0NEU3dwRTVRTXB3UUhWdURwL0M2ZTRvYXZLaERXUkd0eThaMVlHZDl2ZGs0dnV3a1REY2R2eGxFSVJUWmlRdVZrdWhYUUlvUmJsNjY1U1ljc0x4N0NKZGkwU1lxWWh0NnRJSGVzT21TVGtFSVJJQkVtV3hvWnhWUTJycGlySXFlZk5hYW0ra2l6UGw2UlNPM205WmJTK2RsWCtQcERBejBmaXlqM00vZ0JWaCtVZzlnZWlQandzZzlEQ3ByM0tQRnVsUSs3ZXpkdU9ueWpxV3JpS3J5L2p2bTVpTGNTZU9vM2dkdXNnSXVLV0JqS0xrM3loeEM5L1NUcDNDOG9RWFlxN0RTcmkyVmpJY2paMmc1T2FkSnRSeE5pWldRM0U1cU1SOGtUVTdUcmNwLzVpZXozUm9OTUJjUmp5NkxnTE1KY3dESWQwMGFXbjczNFN4eStPSHo2OXU2VnR6Q052Y2pVemx4dFpDUXVaMVZUdU1EY0Q1YncyZ1g4WEUwNVlBSmhMZTU5UThUUkZFZGN1cm92YlJWalRPTm5FUVhNZnlORkp1dmRRQW9OY1k5M3RvenRMaUR4U3QrdGRaWnFET3FxdGtVR21LZWdZdXYzdlAzLzNoekhzdjd5Wkx1anovL2JKUngrLy9NZHdLc0F2RTMzRldpWlVDckZVcEdIa3VZUjJndDE1OENuRllsZU5KY0xjWVNaa1ZNd0Z6b2dKZG05UlF4NU4yRjFCbEtZY3ZVc3B3b2NQUDNxMkdaQXVYRzBRdmJKdTZCaENPWkZuSXlMZmpFUGtpMEJPTVl0NFN4QWdJc3VEQVFOdEx6bkZpMlBLWWpRWUFBbFZNTVNoRzhrb0RqMTBPNGlacGpKRkxsa2luZ2trTExIelBFREl3TnpYNWFOdDhGOUIyOUxhaThKTHdoMm9XUnRhNEZtaityVndNWklXNjFrLzRyQVk4SXYvMnVkODMxSjVVRzFETnJhR056MXg3V1pRYTZTVVM3Q1ZjUkphWHZDY1VyYmVLRUJJOVNYWHNGdHFxQjMyZVVSVkRNNnpsOGxjM1VoQVhDU1RSVkdGZWVrV3J2YXFlNGQxUnFvMHMzekI3aUJPbGxYZG9pV0FUYTgyK2F0cmo4REY3ZXY5RXhxSXhyaDk4MlozSjNBblBiSm15RmFUa25xMnROOXV0c2UwdmVodVg5c3paTDI0VGtUYlhUNjhVRlVOKzIvakY5OTBQQ28yWk5sQ3FMVUlrWUVOU3Q2endHc1pXTjM5TE1ZME9adTJlR3g3Q041MWdodmcxZ1VuWVJ2THJVbkZuSndFYnFyRXpGelZxRVRDWU5jdUFLWkdneVdoUEF5YzNZak5pRmdvODJDdVZveS9BTEVJVFhtMHpxYU9lVEpydVk4aWJBeVZmaG85Q1c0L2YvOUQrdWJONGZwYmk5YnYzZ0F2dytNRmc1OGlKbW9QYnEybFJYVzVhWWxYNHhKM29NdGVYa3ZOYkN5ZDluMnFHenJjekVXOHo1T1JjYi9wK3k2Q1pMUGI3YmFiUVptRndVck1jQzBKb1ZnRkNqaFdTbXd1RFlBWVk4alBFbEVmS1ZkZGdtUTBuWGJnSU15aCtyaHowLzQzS1dpTjRXaGlKVnRKQmx1ZmFqYVA0SEgvNXlrMTdPUjJpVldPQ2VqdGdwNFZWWEp0R3p3aDhqUnZlak84b0kxcXkzQURWY1pYVTN6cXpGcnBUSjU5K25vWDVXN0xkakJxS09rbEZxajZoZGVENnhPeitLcG1tUWZtNVVidVFsVXpuYkxWcXhFSnFSM05XRXlGV2FKQW5kMlp1K3FuWnduT1VHZDBVdVBTMVVKSWQxR0d0Q2NLb0t0Z2FSclFYYitRTi9kWDIvRlhkOTZuV3dramg4aHVhZjU4VzFMWEhEanFKMUFpc0FFTlZJTHZoSEFzRW9CNTZGQkdMNzdzWFU3RUprNnVhc2ZKUUkzbjJBY3hZL1dwU0QzY1VXWTNUSkFRZ2t6cUlSQ0ZESllTZndGM0JvcndsQkEwcDhrK0cxNWM3WC8vNlV0NTcrbVgreTZZZHQ4aldtVVZIWEdlTCtKTzdWQW9DcEw2L0tDSkFZQ3l2RXZMeDV5S1UwbUNITk54bkhJM1hGeHMrdzVzdHQzdE5rT3ZvZXVZV0RKRHN6bExSYmJJVzFhT0cwbUlmYlI4ME5UM3lOcDZqZ1NRaUVoMENTTGN4VkJDMkdwWmFLdHlGR1kxMjdYWkZhaFM0UW9rem1mYW83czgwT3FzUmpHTFZodytPL1ZXdldlOHZXRnk0ZytlK2Jid2xjK1l3TVpleGhWTFpsTWIrdFZ2TDdXS3R1bzhxYjluZVFOWFEyRS9BUTZjamJPOC9yQUNGaWlLM0JxTFhwOERQOVVzclVaa2MvUElGNWVwdTJkekZsTFBEaVp5dDVINzRUNEpPSFNCM0VXZFlwZW1ydUFhdTBsTUUzY1JkY3BLQmpuc3U0dk9qdVBRdTFyS0dWUGd1OTNWYmxSNThpZGZkMjl1N3BRN3pSYVo5ZVRDVjY1d1JNeHR2RkhDZCtyOGRzMGlleXVQRmJ4TUJXWU5nRm56YmMrcWdZSWVRczVweWd5S29XeXhYWUFTUk1zNmdEdUx3TlRnQ0YwUW9zeGRsNm5MVElTc1N4SjFCUjZ3bXFiak1RM1BqcDkrZW5ORjQwdUxJLy9wbjMrUGNMTzVIVGtET2JEa3VwVTN3SW5FcEUzQ3FpYXptZlBZWE5OVXBzSGc0RTRzUVZLR1RhT0U3V2JvSXR5bUVJTXcwOUJGZ2xDWW9CT2J4TkxlNWZpV3phWDAySmxqaURIRXZoNDhYR0l2SFVRaWtZTXdoTEhPK3ByL3FJUEpuS3VCWnRZajgwd3ZMeGRBYjcvWkE1NEdsa3p0MmhOdTBsdXNBQi9OWUkrMzZBVnd5bUJiWGN3V2lBY2JPM0daUWpSQkRUZTVUbTJXTndubUNGalRkYmVtR1MzU2pabThZaWUyNzFVVWNMVUVuL1RxbXNIcjFCYmxjNUd4ZE1EbU5vZzFVeVlIY0lLT0JDZlBlcW5jcDF2dEFJbE1Eck9zQ05NeENBaVFPQW1acWtvTW5NWXNNWHBtUFJ6dGdpaUZMYVU3SVlBNDZqZnBvOHVYMDdOeEREL25tenZOMTYvdk5TeUZzTlpkaFJubEFsQWplNzJOeVB3UHBCblVNRDN3NlFLdWo0Y0pWbEdJTFpmWkRLN1pnNXVISUhPTGhOU3ltcHNTQWpoR1dOYnNKY2xUSlBReXVUQUVjSjN2MmNKa3Ftclp5RFZOMTMrOUdlK3R5MSsvL0ljM1AvbUxYL3p4ajhMM1c3NitpQW94dzlXb0dLL2hJSFZacmtLWTh3bHExY0xNWEFuRkJVdUprckhvaHRoM01VVEtJaUVJczBqZmlaWGcwS1JGZjRWQWhQaUlUd1JFN2tGaUVLSFFiNDU5UDJUbmNnUDBVQ1M3Q2tnSUVBYVpxZmxEWnJDRklPRFlaTXR0NVVuOWdQbE1HSG15eWhkSC9OeklzbVhzaElWL3QyUko0MEgzK1d6MmppVWsxQmRYa3RjTHJUTUhLZTdpQ2k3MXViNnQxNXBTL3pJMXZaNnZ0TlVud1RjTENjaFBmNXJQOWRhSk1hcU12SnVBMGsrRkdyTnVCTDZvVWR3OVYzZWpFVHZEWGR4ZFhkVXlGeEdvT1pGUm1FeVR1UjQzVWxUb0dpSnB5aFJpZnp4TXNldW5NWUFPNlhnUnhiT25TT2J1b2QrOHVyc2ZPSTFEbks1ejdwNkF4ekdwTDNuUHN4ZC9RYUcwYmNtcy9BY0ZsZnkyOVZ2NklNeXJUbU9KODhZU1hMR21NYmlSKzBRTWRyTVl4WnFhM1cwYVU1RlBGM0cyc2JvVFNXY1d0b000a1RNVG9LenRjQXdDTnpWTndwWVQyNzE2MzQrMzF5OTMvL3hmLzluUE9ncmZiLzM2bktrQnJMQTZNNG1HWGNuRlJiVnBqckJ3b3poMHczWmZPeDRHQ0Z3TlRxRkxvYXhiaU1jUW80U2V1ejZvZVU3NzhUQ1N1RElUdXlNKzhzUVh0RkNNSVFTS3U2VFRyVTRrbFdES1RuVW1KeElob2ZqWXF1MXZkUWd5SkFoVlhNZ1NQRjlPckJMYVZhL2haUlI2UG1GYmI4Q0VjcVBDNHZ5WjRjcXJCVXoraUdwcmJjZnpFNnJWcXZWZkpKeFVaczVZVkpGTDM1K20rbk5samZSWkNBRnRzRVJMa1BmNkRRR3h3MVlYK3BObHZZZ2oyMWVmbXQxWGxBRXNKMkFSQ1NSeXl6bHJ0R0psM3hzaFFkZzBxd1BkSGdVN2xpU1NtNnR5a0dpdUJnbENybTVxMUkzN2lTN1pqcDZIbEZKMjMxeThjM2k1M2NqTjg2ZDMvL2liMiszVGk4TStzMGpyWlJScnRJUzRNSlFLamErK085L3ZFSzRMdG9qQUt4SmRtT0ZyTTBxRDN4R1ptZTFqakZCWENjRXkzSXljVEtkanpnQ1RGQkl6UTh3TUVzd1F0bEJpQ3lnWHV0WkRyellac0xpbFRFZlpiSFM2ejl0Zi9PVmZ2R05rK0g0bjhOTHB3SW9zVXBFcFhzT2tmYmF1TmhkT21WU1RPMWlNaS93WWkrYzgrc1QxUmljZW83Q0VQbXczblUvSDhYQTRIS3dMc0lwM0VGbzFudFlVS1N2NERvbjlkbnVoWXl6V0oxKzFRRDFHNW9CV2JUdHdubEJnVStpamxZR3ByUUhySUY2cHJuenVERDlFS0hrN2dSbk5QYmljYllzSUJQT0phRytWNGM1TTVvZW9OQ0lDMU1FTXFhNTA5cHJGczlBajU3VkVJR1JmV1RmbXBzdmNINnYxeFBKNkFHZGIrVjl0UmJCZWlRb1h2cWJqMUNyYnRvbXFsbXRjblJIdVdnVzF4Q0xHbEJLWUxFMVpFSU9JTW5IZzFEbmNOQ3VJT0Jvb1Q5NnA1VDA4Y1QrTmxLWWVSdkZPRFhxZll0NWVaQWI4azZjL3VQakIxNzkvK1EwZ29WaCtWajU4RmoreGRyak5ZN0xTL1BEdmJBT2hNYlVXelJ3M3hNZnF0dCtrdHFiWmpJSTRVV0FXaUxzbWlPcDQzSU00c25kZEtHaHlaMUoxSnJKTnJ5bXdCaXBYZFczdllpSEtDVk4yOEhTYmR5SHJ4ZnMvL1hmUGRrUkViNzcvSGZoVXE3VjBUNjFrZ0xvM3lObnNTQzc4YWlmTEtTV3JzWEJGdU1VT0loWjJiZmJ6MGlTUXNOMXQ3ZWgzU2RNa0VranJIWlBmdHJWTUthaVprQnBDdnhuNm84K3J6UW5NeENRQkVud2hJcDNJbGd1ZWlidFkzTzltZGFLcUt3ZDRYZFBXREF3blpLcEhuQjVjU3VtSE0rRlZzTkc1Z01aT205cE9Kd2JpSmFESUcxTVR5ekFLTFlxN3FyUUFva3hNREtCNGdyazFtczhvOUpnRjBDdmhrdVBFYWJIZ0FGYk56TFlSK0lyUCtWQmRWaVdqN2taRm84MmttbHdBaENESndHYWFNeGxDZ0lJNWlCcVJ1NnBsWndTSEo1TG9ZenIwYkJiNnNFSHVtSVcva3I3ejZYaXdpdy9lMTlmak50cWJtNHNubDNGUG5qVmxEcXVXZ3AvYzR4dm10MXpkMmRrQSs0Tm5jSU1hdFZFTUw2V29vOGdyYVVhSG02bkVLSWxFS21yWVI0b3BUY2Y5Rmh5WVF1UnlnV2JUbkUzTlBJaHB4elhlcnJWQ0FUTVFpUkNyU2lmVFljaEpudjN3My95U0F2bUk4RFNjWHZZSkRNd1FsL25LN2tTWjNOVGN4TTJxaUFFaEJsV214QjFQSHFHQWtJc1FCV2hxRjNvMmJNWWNvbzNIUVRoem9UKzVwZUdRK2VoRFpISUlzVzl0bjZlbklRU2lOQnkvdFJnam13RmgvL3gxa09pbnB4S3M2SXVaWEltREFkcHQ5eG5FMVE1QlJkd3ZaSm43d082cURtWXBySkRtR2tGd3VNSHpNVVFoSzhyQVpsUllYWmk5R25tYzFVb0cyOW1WdkV4ZjNiclNERU9qb09lNk5kVldXQm5yZ0NpdEZpNFdjOFhjWWhLZnVSZHJVWWQ3WStyVkdsZXNGQTE4cXR4c1BHcjAzbndHbU52a3ptYnRnNDgxUlZUbTZSSEVuV2srZWNrSndxVGtWZlBiRkF6YTBuVkFCSXAxaVZqejBMdXBWYVFBQ040ZER5cEZLR3RtSXRwejNCeU9QWFZzREQ4RzdTalRSbnRNQVVUY1RScVFFWTFjUS9DRGRnRlp3eE82ejczdGJmZ0k5emR5SllmOW01dWZQQnRpZDN2OThtNDdVQmZ1RHlUMU50UnVjMjZtTUNzNXNpVXdFWjRST0NlZHlxWUlmNlJCMmlKcWlzSFhoWXhDTG9wdXRwSy9WVGhRNWc0bU53aHJhVHA1dE14aUZMcmdtYm9PU0pySHhKZEVsbVB3UFl0QUtjaWRCMDZqcDBQWWltU3dkWEswbEN5b2k1dUxBR1JURnRhQnh4emx2Z3Z2L3EvL1lwQkVaQ0dRZm84eEVzNEluWXVFRkFBMndyR1BFcFZoeEFqdVJFYWVGd3I1cXZPTytWYlY0bmJxUStIRWJpNkJMUVJoR25iNXlYRWtGcWJBN002QjN4cDJYLzA1empHNDVtSXlJY2FzdFdCSWtLTGVMaDltczY3T044STJRWElDK0JIaWdqOFcvSHd1M1BFbGQzUmx1Q1ZpbXBPOGFaMDJ1RDU1aTIzalBJdTlrQ21YU3JXY2lseUY1MjJhYWFWS3BUWW1xcHJ4V3RyTWlGT3krV2VWdDV2WHRSVWVrQmtkSndKNWNpNGp3QldyRnMzZVdDSmtLNGpXMTNDNzJRZnRybW9HbTV2VlRobmRsYjQrVkpzOHFTbHhnV01WRVltNVV1YVFJM2ttOVBzY0llNDJUVElONFhBZE4zRTM3ZnYrMWVSZmV5UVQ2Y2ViVi9MeHA5VnJzWG9kY0dUdWlOemNpQmQ3aHJtYTBkdk8zclBKc0xzNVZUZmRnc2VDVzlWMFp3NE1DWkxLWTZSZUJlcFcxVFhHMnJDOVprclVtYWtweWVRczVpVDlkdWlDdUNOd0RFRkxNTFlEQXMzSkljVE14TVR4amk0L2ZKNm95eE50S2IvK1BuTmduSG41VHhoZlFkT0dja2FMdUFJek9kem5ncU1lUjJoZ3dLVWxWaVNKQmVRQUpxUFFzZmRkVjlKNzcrNlNCQXJHbkJXOWZGZHg0K1NJd2FmOWRReVR1enN6YXh2SE1HSU0xWGxIVElWTGRMby9WWUdSZ1pqWEc5VDhRZHBEY2ZpS3BudXloaGN6VTgzUU9XdFUrZXJ1ZlZJNm4vV2lTeFFEKytMTFB3MUIwN21QQ0pyeHJVU2szc0xOU2oyZmwvTFd1VWk5VGhMYTIwZGNWeHNacmVDWk00KytOUEZvemlCZkxnRldBM1NvNWdrdkd3TTdpbnVxTE9BU00xbHdwK1FlOG1SUGRuZEg0MENhaVpzOWlMM2VaVlNWaVRSMURuVVBwaWFpUkVxZWZFaDdUVU9VVExKaGZkTS83NXlOdS91YitMdysrampkS0wxUkNTbTBaMCtSS1dWdEVZeVBydDhUQ0hGcGFxNTZFa1Z0WWFVUHBHUUY2bURGcWg0a2lycVNtYzFmNUNYbTFiSzZKOEN5T2RTRHVRdHZMeTg3QWxrc2lRNXNEUnZCT1dWaktRbzdraUdOL1NVNDU3QUJ2ZnoxcCtFUDMzN25WTW41TWxodXJmV1E0VGhzY2taaEYxc0dDNXl6MjBvWVd3a3pNMEROWjlWZm1TaVZicWlSUkxHaGp5eHNKRU4zTkhjMUJOQndFZDdlNUhjemh3Y2ZMcDdlRGl5cjVKRFNONUlRaFV4YXBGd2J1OHgycmNYRzV5dTM4TmxuNmZ3b3hneW5LOXBueGJZVndWZ3BUWjNlTHZTUlJRVFNiZ1lybE4wNk1BRExUWFhPRTBiZFc5eVBORWZlMXk0MDJxb2pyRUR4VmVBNWR3UjVtWTNNRU4xbGRPaXRDQ1YyQjh4SlY2VisvVjlNUkpSUHZwcUszOGVzSVQycmFyNUlsWWpjT08xemg4NVNGTGd4K2xvOXpVby9QY3EyY3lQTlVYS2VrS2NJSSttQzJSU0h6Szl2bmovcFhENDgzSTYzbDUweGgxMk1yMyt2YWljZlZRQVpwR1VZWWU0Wm14TjhURHBYV2Q5OUFNK24raktOcVdZRE55TTNGd2FaRzNQUnA3ckVMcGpsUmpwd01Ma0Vjall5aDFtbTJqMHIxM0c1ZW5hRjdPcGRPZW1wZ0RyS2tqZUNtNVYydzFiazdzc25vQmpvOEhkLysra2ZibUxaK3RkYnJlRW0yWkdMOTE1c05QbVIzTkNIc2lUQjdNdm1mdDY0cmVlRkV3RUNMblppTGRwYWpqRUF5TXBCOXRNMHVXQ2cySDl3Y2NwZVBxMmhUYzNOalB0QnRDYlcyOEk2QjNNeHVob3YyV3RWTlV5d05XRVNwNWFnazRyeUVZM3N5Y0FITlpLdjZZU0ptTnk4R3YzbWNKWHp0bUM3Ky9KcWVMeUV3Qzlmd2dXR1Uzb3llSkF6VEFhQ01ORE42NjVjSnFUSmJ4cVk0cXhzYUFlMG5YaXZ5SmV1OWN5Wk55Ny8zNWVFcHFWZHJoVnpncVduZ2pVdVRtcDFiSFg3R1owOXM4UU1jZ2lISWFkczZtUkV6bkFLeUNRYlBRN3cyRTNIWS9ESmhDZ3dVcjdEOFBUSTQzVGticlBkMkxjMy9lUjl2SmcyblgxUm9JZ25MaEVBUUM1TEVGclBFRFdIVHZYSzlZZWtIRVRFd2tBRmQ2NHozTm5WeWMyRENCZmFta1BZdVBDVk9EQnpocWtDS0VIbDVIQXpTd1FXTGpXMlRjNmJpeXRWdHJTWlJyZ3FNeHNjekZsQUFLbXB1UnNzYjhNWC8yWDdSMExIVC8vTFgzMDlQUHRlSi9CSjRNaGNTUmRUclY2OC85NHVXRDZhcWttTWZXQnptNldVNUNqTm4zTFZiV2R2aGJSaWFjNlR1NnNqRnB0Y2J5SWM5cVJLMlBhYlp6OTQvclpKTzhoVnN5ZzhweW03cE5sV3NLeGZacXVSRjRBWTJ6TDZRNjN5aXFadXZpK3NMdjVNYnhOQm45RU81aE80bVVLd3lDamdzQlVSOGF5RUxyZjJsaGk4MUR1bldRQnpObUdKVDVnUjFQVy9BcmlrM3M4bWhsTFNDcHJ0cjExV2ZKMk5SQStwV05WMVZMWlpuT2cwVUhuUnE5ZlA5WXd0dWJzNDdUN2JYSHV3VkxxSTEydlQvV1lqblFGazZnZ2lFVTdxeHFrbVlIRHMzRWxDbDBtaU1TUWJpSWlGSkIvMDZkVit0K0ZyZmY0c0J0UERuWVhyQzR6M3loZDN0TllybDhTSjFtaUJ3NDNoWHU1UnJwT3VsYXNQcjBobi9HekhnN3NrMkozWlFJQXdDRGlxTXdPY3hJaENHR0lVSnRlY2lRa1EwcEw5aXM2ZG1kM0p6ZFVSNC9hQ3JPTk1kMW93TlBNK1hQTFQxWXpjWU1jTC8rYS92VE1NWC8vNlAvM3F6ZWJqN251TWtiQ1MrdEtTVHVDbC9XYTdwNXYrVWtZalZTUGhJVkpPcStacEMweXJXVm5ON3RhQ2V0bk5XeWExcVVMVWlDR3VVY2hTekQ1UmQvbjBnNCt1dnVPT2Jwb2xaejk4KytXWHQ1VEFRWmloVlFBbExNeFM5QlZGOGxtdE96UHFaVzRKTVRXQXczbmo3dTBvWUR4b1ltRk9ZK0FTVU53WVNxZkhwc3dQZW9PbnRGdTZWeXBrZWQvNWxPbzdKempJR21mYnFDamtsT3BLNTZWZTlBYUdzbWFwZmp6ZXg5Y2JBNU5YdThyNkxQUDVKRzlFa2RhOTVqT0pDeGZLYmFQWkU1T2JXcnRpbE9SdkJSQmRpY0ZRTlhNQVNpVmRod2NjcDBNWFREM3g1SjBiRWRSZDFLTWVwTU1XNC8xUjRnZmI5ell2RHg2T2U5cS91ZGMyZmlaWlFlMXFjN0plMitDbWFpQnkxWVVOL1pZZTVYcjhYZDFnSzY5S0dTNkFBN3lNYjRpc0VqY0tuWU81aTV6SVRJOGhRR3UxeDNDd0dRU3VaYVFjdWpoczNRZFdUL2VtS1ZGT21jakJXOWFVbmFrMk9iekxOSDMrbjk2RXp6Nzl6V0YzMWVYd3VLUnZ4WDF1L1NoeVoxOUU0aTBQT0Y1Y0JNU09sQndFNWw3ODRFU3VKNHluRm4xbmZrcVBxdlBMZXROV0pWRWpDSms2SlJFSmRDVEV6ZFZsditxZDRKVGtDemRYdmNQZFY3Lzk4dnFZaEFsUy9NbkZ4OG5NUEtOVG5mazB5OXJLZzFvUTdtMmlnTk1Rc2UvZ0FUczlzRzJkN0gwdGJ1bkJFeUoxMUJxYzVvTUtLSzFMK0NvVVpINmQ1WFZ4alJpc0xBd3FDQUpHYlU5UjVaSWh6ZXUyNlhES0FDVUFwZkd5L3J4UDA1dFJOZ2czbUZNK2E3NWhSUTZCTjdPd3p5ZHhlOEZpMVdPOXpoVXFQNEtObkNKR2xjalJOQk1ZbmpSYmk5UUJnM3lJZGpod2Q4aHl6S1BGb3pPenFuS1czc2ZEL2xLVFI5My80K1h3cEU4WjhmbnRBWEhheHhiMUpLdVRrMFBCVGhST0hFZzFhNnluODF3aStTb1FHUTdqMDNQWjNOaWFQbWgxU0Z0TmlqZTRxcHBMdVIvYU5ncFo1aHlFNGFTWVZMbEZ2d1BHcFNvM2RndXhvekIwWGFmRzRnekxhVXlZVWxsUlYydzVPMWY3amVNeVo5ejl6ZTgwdk1yYnE4dmRSVmp2TUFCSW1lUmsrdWtHbFA2NUpRVzR5ZnpCUXJtei9kNkdUZCtGQWp4akdWajcvVjVKcXN5RkUyd0MzNFBaY3c1T3JnWnltcnA5d0NIYzJhZ2QzR0lXMXo1YUtKZC9FZzBEbU5JWWpxOC8rdURKczAycDc1eXdhSzRyWEl6SmJEclExMTkrK3RsbzQ0WURVMjY5TnVZcFNneE1QaGlDakcvU3FPN1VJbXFNRE83bytwZzdsTGcxcVJVdjEyY3hGNVZKb1hXQ29VV0ZNc3NQRlN0cEM1Z1pYdFNpYnFVcHN5U2tGSWhaM2RTVUtaVDYzZWZJb3BPNVhkV1lMWFBnc2pxVWlObmN2UlJqamU5VGZML3R6bHVpWVdvM3VqeFJxWllDeFpNaWRCYmZWNXFTVGlTbTZtQlk1WGhJVlFWWWJkazB5WGd1WWNiZVpKeUtTcXl0ZVM4VFE5elVEWm1jaURaSG8vK2ZzcmQ3bGlRNXJ2ejh1RWRtVmQxNys3dW5ad1lZZkF4QUFMTTA3ajdJMWxheTFZdE1ra24vc2t3dmE5cVZWaUpwNUJJZ2RrR0FCQWhnQmh6TVIwOTMzNitxekF6M280ZUl5TXlxZTNzNG5BZU1XUSs2N3EycWpBZ1A5M04rSjlrNGxkWWVRZ2V4RzRYQ1pCckZUTkl1NzhkUVRRakFoMDF2M1NSWnduTllUQmtSSXdDR3hpRzJjcm01MkU3REJQbkZmL2ZCY0tiaHQwWStmUFBsNXB4ZVBMZVZPUmlrSWVpMXNjMW1VaDBFUW1vM1NJQXFWcFBJbCtaZWJXVjRkWVFZSWtkUWg5SlRDV2xobG9DSVIyd2lOS1YrZS9Hd2YvMzVEVFpqcDladFJhWk9ZRlJ4aGdGQ2MxQ1F4QTNDVU1OWklPVWNqN3JKVTdMZzFlWGxGMi9reGlCNTRyaVBzN3lmS0JEWHpqTzZ2SHYxK2JaN3hZZUh6S3RIaisrN0F5OUY0OG1Nc0xGamk2R1dLbEN6bXNsV1ZiV21TVFZTOGhRTUVhaW1VS2JVOVdNQnByRlFtTXV4STVnMWJHUjRoTE5wUkdERk9jODVncllweDNscUJ5S0Q0UDZ3djkzbmxLSUZvMUZDR1BGSUVORnQwdkRSbitSZi9QeGxXSnJXVndJcGZzd3V1Y1ZpM1dscG5HOGovaDM1WW5FUEFhdTFlVlpSSldpR29mTEFhNVZBekxMaTJsczZPaGxabjVSVkdlQVZyQmRZZFJleHBEakZvczB0NnBLakJDL2V1UlBvM01UQ0xHZG82VUd0UVUwMDMzR050b2N3QWJnUEF6Zm52OVVSYUh2S0p3K0JhQ1A2NjFRSzY0TFdiREZGSWxRSmFvSWpFQ0VSU1VKVHVGZ1NoUFdNb0hXeUg4NDNEMVZlVDNqME41Ly9qMy82cTg4dW5ueHl2ZDA5c0pkUHFRMlYwZ0FKSkIwaEVWRW9PbXdabnVWaVdSM2ZSLzllTmVGWG1qVnkxZFJiNWdFaUlzaUo4ZmpISDczNzRmYXp2L2o1Njl1ckRTSW03MUtmSUNoK1pJcW9lbFg4aUtyVVo1V1RRMkxjZGZuNi9NRnZQL3YwNWlvNllSbDQ4czNlYjIwVEdmREpjOEs0VWVTcHQwK25zejZQazM1REtlVWl1MXZHTS9VT2F4Q3FsVHVBbWlZRWM4ZVlDdU5RTFpVMUVwVnNVWnZROVlZRWhFZ1lDdmNuTzV2Q1hnRTNWUUVzZ2ZJMWZVS0dSd2d6K3JQdFlDWVM4M1lpWk54cXN2NzhySCs4K2YwWHY3dDVjUDU1bUVmTW5vWDVUdThscml1QUlpNk91M1BldDdXdjFsL282c0o2VkFHWHMydU9QMnMzWG5EbC96bnVUamU1UVhYenROdHcxQ3kvTnJKcUFiZHRYT1IxaGZvOE1DaTE0M0U2MHBHbVRWWmpoVExYcmFWOG81STJPRjRqalMrUzRqVnphTzJhTE1PQnFFMUxRMkR2MXdBQUlBQkpSRUZVQU1nMFJaQlRWVUtObGJGZEhtRkd5MlZDdUNUVFVxcEcwRUNLcGV4YjdJZStFNGhvaC8zd3BXelBIZytabTlzdmZ2Ymg4L1BKSDJEeVIrOWQ3aWVZNUdYNFdmaG5QbjhPRTZOZWEwcEswemZwQWJGeHhHTldzYzZ3dVpvNVNUSFg3LzZ2LzhPVGJ2UGJqei9mZnZicG1Vb2VpYjQzVVVXbk9wdGRER29nVkJsZU5FZWVVeHBocEEzN1gvNytGYkRyWXlMQ0FObmZqcTY3S1F6aElhcWsrTWpOZGp0ZVVSN3RubjdqQll4RkVGdTg4dVVSbzRvb2tJUnFGRTJtaUVoZFJGQkRxdU10Z3NvYStCenJXQTlHZU1uTzVnTENwVURVcUtwbUtlV1VjRGZ4WUwxMHd0M0JkRzd3eThFUkMxTVBBRjV2SC9ZYnpYbTZ2aHoxWWI3dFFoZXZBZ3IrY3lxb0c1VUttRnFPV2R5ckd3SFhrVGlybFl1RjJYNHEzdExGc3J1eUZ3bWlIbnk4UjF2TlpzNERFRzFRMWVZN2JWd2pjK2J2ek1CYVZNdVFMT1g0eGFKYjVtbDIxK3hIcW9GU3JmZTQzQUJLdWpOWHFnQmk4YWcxaCt5TWpDc1hYU2xmZlFnVTFLUVVEOEk5UjFYQ2FoazgxYU95SHU0TUVST0hTdXBDQk9ESVhvUWQ5Z05GVEJtdXV4aGZkeS9PbitURC92M3BOMS8rMmJPYjdYVDFSZnArOXcrM0xHelhlc3JVcW8yQmxXMVpHeVExdnM1R3VGYitON0VNdVJqeWpvdEJ0ZGgrNjZQM21YbjJvNGVYUDc5czZGWVJhTkxVL0NSUjZsSkJaOG9NcjI0S1M3ZkQ3V0RiUC83ZFYxZmRBelZNU2plbndFZU5BbGRXZzRQTWd3czBQYjI1N0o1OTU0TjMvaVVuY0hOZk5QVzhNeUpNRmNsTVFzV29nQ3JNMUpBWXhacWJKSzgvcEZ4REdpektBQ2lFRVlhWk5sd3RJdW9pYXBhU21IMzlBaVk5dTdLVEx1OTMrelJPaGZrUUZJRmEybTQzS2ZaVFR1bjhmRGprMEdyQ213dFlWV2FTRzlWNW5nc3V0Z1A4TTlZT3psYWpHUUJmRUR3bnZxVmxBYThXUzNrS2pxUzRpNjJ3MEo1VkJLVXFKT2JRTWk1aU1pK0R1aFZOc2hJNGFoNkUxNmN3NVA1bVdnUEF4M3hpUVk3SFhXVTE2Q0tCS1hmL3BROWYvZE9vRVBueS96RUlJcGk5S2hzTkdrRks3Mk9Rd2tKVWhoWUdxd2lqU05UcnlaWlVaY05Sc1VteW44VHpwdXVtVE5mSjZMNDkzMTJOWC9Vdm5zV1g0OVg1aThQZlBuNmUwcmNQdjNwOThlSGZSd0FGNWRNMlBGMFRHMVAxNjVieUF1QTNQSUhMZ3ArLzZkWDBBYUlNRUVtbjY5RzJjdjVuSDMzNjV1OWZvWU5QcWlKaW9oQXhVL0VwczdZbnpaUXNUVUtvcFM2LzNITjQvZkVmSG5WUEgrWXNFU2orbXpUczk0ZGhpQ2xESURuSDRUYk9INTlkWEc0Ky9OYTNmdmlEODI5K0FwK3NaWXNtcDFPekxwV2hscXFtd3FDVVZGeU1xa0NreG1jakVIWFBMV2IwQ0JlSk1DbXRCOVJSVXp1ZVZEV1NGWVBDMTVUUU9ZS0lMRnU3MlA0UkV0QTJKZ0xPa21SUnNRdng0VENselZXZFNkZlprUlJVZjdDZFV3dmI2TDdwNEQyTGdDdDcxajBkNTZPVEZhZ1F1WEpOSzgzeGNyZjAwd1c4QXV5STY2ejNTM04vYS9ib3poRkhSWmk3YkQ1a2pXTEI0dWJsT2hqOHhNYkk0OUZ1ZGV1c3BpWnpHZDVTV0VTclVHZmVmYXZRZ3lvRVBBOGxENzZNcE1LTG9qWlkwL2xtajJhbFpwaEVhVGtaVExDaEI3RTFEbmthY0VEZjNVNmRieEhhYjVrNXZUNjc2R1JEUDQvTHJ5US8rdmFmalgvNytkUEh0MFBKdTVySDhBV05hcVV3UTFkMVdCNEJFTjhFeDFFTzgwTDFRNlBTekpQbGVTUHQ1Tk8vZmZvRE1qM0NyUTFxdlU1TXRyR0FLRVMxc3dpNkZmbGhFV0RDSkljVUNON04xUDN1NTlQN2o3ckgvWTFZQjJFeUJYZUgzZTJiTVNJWFVLU2Jqem0wNitXZEQzLzQrTVg3RDlLLzVBb01MT2ROTStnUWFvWXFkeEpMaGpBekF4ZDhzWUdldGJaU2JLNGx5dWNSTEtxMnlhTndMY3NIaTliY2lNbzBrcSs5QkpPTVNPY2MzRlFFSmpFTEp1bloxUFE2SkoxUGw2KzdHdGFuSzNJTVc0dHBTVzkvZXcxOW9yeGIyLzF3N0VSWU1RMldoTW9HRnAvbFdXOWpZODFNckhrRVBOOWYyTUpIMmVhOU0zNXY3czZ0Z3JmWlVveHE1QW9GeXh4NlRZL0hMSm1WeFp1MDNuOGFTcnVlSWtUMVR5OFRiQ3JuYWJnZ3BrTmZGQTdsd1RHVGZVUTlhSjNoMmk3WUpYdWJaRmpLSmRzeXFVbU9WNC82YlRqOTF1VnNlejFLc092UEh1bytQWjZtVno3a2RJNnY3TjAwUEgzNXV3ZmZlL1Nyejk3LzZsWEdISU5CaGhZaFo2bm5oVnBKMllHM1dGVGVwa2hFM1d4bVdtaU5OS3NmdjAyNjNmOWk4K2I3VHpiQ2l6TkpuWWxhNmg3eWNJaEkwcFU4RXpXcUpRazRsU0VLbFNBNDdZYzRmUG54MWNQSE85dFkzNms1MFhVcTBldm12QmRPWFJDRXBWSW05US9mMzN6dzNZc25UOU8vcUltMTlyWkZTY00yb2FncW9sT1JVRFVUTVZWRDYwTG5VRWFlcHVLaXJtdWswaXliNUpKdHFNN3dKdG5TRXR4ZUs3QzNsOUMxTnlHQ1RXZVQ1K2JTSmhrUzRTbDFDZTdzNkdQMjlQaWE4eXgrMW9mRkVzYldhR1VFN3EwNDcvRWhyUTlPckx5SE5iemducUovWHFBa1RpRTdzWHBmYXlWY3FqL1ZxM1BRNi9aZmpzRGFINXlOZzVBSkMzMlFLNWdHNzNPYllSRmlIYjJKK2puYzJ3dEFiWUxJN09odVhuNjJYNStSeDA3VUZGSHNuVlM5ckplbEFxc01yQkl2QkJvUU5XWlhPRlVsc3I3Q0UwdWk2aE8zOGlZYmtiYVBId3pYM1JONU9SMGNyK0tzN3p2dHI4OC8vcXYzZi9UUlR6N1B0MkVvalpVU1h3Y3RXVWlvRDRvb2ZZYUdmcU9ySTJlRkhGYjdNZHVLRmhIQjlsYWZuMy8xbDcvOTN6NTZNbm40MVFQVFRMSHV3VGhHVnBvcEdLSldrVTlPTDNRUUswLzk0WS9QcDk5ODl2alJtMTY0TVExdWhLbFBkRW1kZFpGdk5zd3FxZHZ1azI1M2o5Ny8zdnY1K1hlZjdHUk1UYXFNdHA4S2hNWDRNZGNnS3RDYWpvV2VkZEtaVUpZY0FsdndnYXA0RUJSWTZucTZTeGtTV3FKMEV1Zjd5TTdxaXBlSVFFakNnV3JUc0VreVpXZ2ZsOE5EREYxUEZZUjY2SGJzYnBObW50bDA1d1QyOHR3UHBkbWV4NjdQWVdOR3Q4K2FVREtFMUZRenFLYkM3QkZROThiVktHTUxGWGZDT29NSEpBREp4VzFiTkt1bU02b2hGOUUrbTQ2OWxlaFJoY1pGc2hwU0tId0tXNTJFYTJGYXhYWWlxalhXWnQvcHZIeFhRZHNVVmtSUTgydm5DcW8rbGtKR0thMnJwSkVndXRJdndTa3dRRnU4d3NudTQzWDdzcmtQd1RVZnQ0SzJ5VlZJR2lrcTNTcEdRRnNZQ3ltMm4welRMbEVORUdBMGhUdTA4M0l2TmhqQ3MyeHEvWlpCVWpjSTBpUUdKb2FlZDY5ZW53OWZtU1dFVEcvRXRtcDJuUy8waXpmRDFmWmRmVFZrM1cwU1BUYmJHMy8zOWpmLytORy9mdnplei83MnlhT1hsdytyM0s5U1VtU3M5NktwZmlKT0NxeHhDOXR4ZkhlL3RuQVV0aG9oQ0NZUlJrQTJvYUFZTkloa0ZrUC9Mbmo0NHlPQ3lTNi9lRFNRZWRMK1hCVE10dHR1R1RrQzFxbEtzbkV5amtqSjRKNTRNUDk4KzVYdjB6Zzh0SzJGaFR3Z3pGUWhLUS9UN25tZXVsQjNiRGFiNjl3OSs3Ti85NE56NjNzUmRvbXJtdkhlUHNlc25hcnhvQ1VrQ2c2NHUzc3lXMUkrS3ZLdFZFVlJxMjdYMUNjOXZSNUNvU3ltYUFsUVUweGhDYm5KTHVjblhxMUxkbjgzV0lUMENMcHJaUEVJdElENmxlT3hkdHdNcmhKRkdhMnJ0MnVBbGxCaFJkVWtWeW1nM0IyVEhHbWtTNWZwaU0vWllqRndSSU5ZU0s0TFU0aW45Mlc4aFZpNU9pR3I0T0w0M3VZdEtXUE9JWDVMdCtxNHRYM3NrOFBjdmx1aWtJbDdTd2VzUVdrTGlLUEladGk0UjJCR3gvSGdxWFFOR1U2TlhGUXd4U1ZWZVo5UlVmTlJybGVDd3JHa2Q5dGV3czVvbkJ6VXlRLzlXZWVqV1Z6bWtMVDl6ZFVQZC85NGVIbzE4YUk3NUcxNC84NmJqMy94K250UGZqVDg5Sk52LytCbGdUMFVzSDdNb1RUTUxSaWE4YlUyQnB5MmZqaFQ4U0VpTXBXTVB5MXdkdFhuNzd4NDVYMjM5VDZtWHZMMGp0LzRwdXRpRE5MNjdWa1oyY0JNVFRxalM1aWFRanAxbDhuak51a3dKVlhWNm03VlpGYVNwTVI4ZS9aNkhEYjk3UmRmUFpWdi9lVGYvdXYzTmdjekVaTHAyTjJKdWJROEtsS3hZSEtpQ2pmYVRwejZwR3FtOVNxZ2pUYWlkWEtVY2thLzZYQVVvelhEWndBWFJRaGhNWVVaTThuUUtKcjdBZ2RRczdkV091SFpJOExWS1pHRFFIQTJBUkJBQ2FFcTZScENBb1VRZlB3RVU2QjlaeElyUlZSVjVPbUtQcW5BQ2NzOHdMUk9JOU01dEdvdVhhTjJRYmdLMzF6Y3dwekYwamlSTEI2N2FXWm55Q3g2WEtpTGpmcllCa2VRNVN2a2ZjeXQwODVyZzVuTjRVak5YWWpWZkhvT3FsZyt0TFdPaXhCcldZd2lJaktwVHVNQkcyOVlObnA0WVllb1M5UytBK21pQ2hWYWhLaEdGRFJqeUNFbHkreDBvb2QwRzF4SnZyR3REbWU5N0dObk9VK3YvdkRnQWtOL05aN2JFTnZOVlg3OFkvdjRGMzk0NTkvL3p3OS94eitjbGZmSlJHbnpYZ29GRTVvSGpVZmhtN2l2NlhoRSt5MjFiOVd3c2ZESFZhbndrSlRlKytDZHg5c1hmT0NneS83Tk5JMDA5WW1qU01lVU5DQUJNY0FVWFFLemhWcmhocWpuY1pvNmMrOUsxaGpVVEszclZNZ0p0SkFIKzkzQVhReTdCejk0K3NOLzg2KzJrcmVsTWM0a3A1aWtZN0h5TXZGYlJwY1FvWFFDZUVvT1M1QnEyQ3YwM2ZLK0dnWFJjbENUOGs2RHR2cVNuSkFnbFVGSXVHUjN6REkxQ3VJdDAvYnliRVgyS0Y5UWlKZHVWcGxqenNkdjgvaEFhNDdKaWFrZ0lKQXFiajh4U1JRd3dZbGlhZjNyTDRqT0JqVmJlNWQ0dERISzRodWZWU1IxNnJuU0Z1UE9nbFBCMmcvRU9mSnYvajFLOFJQcmc3elNXdDlpV3pqU3hXZ0w4Vmo5UEs3Q0pQd0k2UVhpNUFGZjhIbXltSlJGVUxaMExhbVBVS0tNKzJkRWJUU0pBRnhVS0gzT0FDUzBlSVU0cGw1RWs5N1F2ZXNzYlRpTSs2UTZiVEFacDh1ei92RHhnMGQ2ZWNIaGltbmJwMWRmYnA0L3V2Z2xQL25yZi9Wc2VKbm1Pd2c0NTFMTENsN3RkWmpJdHpRUjlYUUJDMmJ6WEFrRVVVQ0JnSWFJZGx2S0QzLzA0WGoxcWFkT1h1MmZ2cmQ1a0Y1K3hsQllrZ1QyVTVRQWVGVzFEaUUwS0NJbVNzbmRGU2dWSWhHdWdFSE5qQkdKY0hKejlpeXVPUFh2LytpSDMvbnhDODFaVTVFekl4MGxxYThmenJWckFkWDdKNlNKUWhqb0lGUTFkVkdvR1N0c1NVdU4xS0w2V0diNURKY1RGMHdwWVdMMkYrWlE0K1E2NWF3UW9JWVVRaVdtS2ZNdHM1eHk2aFpMZjNoMjl5aUp1Y3BsQVRjYjQvMEhYSjN4VFEwbjh2VnNvZFhZb0JMa1Y5NmxoWlhXN3B4Y0wrWTUwWUJ6Vmd6ZjV2TS9ybmdyelhMdXBxeUZKRlZ1c2JSVXlkWWorRWJkVlRtMjR4REhmdHFWbFBDb2k3TUlQRnFLTXhGU2d4SWhzbkZINzNYVFVoSDNpQWl5QVZIWVdBOVJITHJsVE5RVTlBaVA4TnM0MjFuNFVGb3JJeFAzdzZaN2VNQjQ0R2JjdjNnalhmNFNXKyttcnc3UHpzTzc2ZlBEdDc0OXZodyszajk3K2ZMSnZ0YkhNZGY2WENpd1ZLNFlDZkxQZmdtenZYQ1IxM1dtVFc2cmdObmg4dmtQZjN5ZWNUM1pkcnA1LzA4L09uK3NmL2o1eC92endYTjAvVWJwRGVJTlZVc2xhN1ZjQThOOVNpS3FYYkpnZUhFOWxyckxSSVNXK3VTMzZlelJqMzd5dmZmZjBXbmFhckdBUVZMRjdaL1l5aGg2ZWdLWDNtNjlCb2lFSUNLY0lhYldXK0Y4VVZVeG94OW5OSmpuN0tjMWRIVUZFMFhINFN4Z0pFUXdFT1VBSVFVYkhXK3V6Z2EzZTZCaktGTDM4bFF3M0wzcWZsWXgzRzJEaU9xRHdHSVhybmRnRlZXSlFaQndVb09jeUp0RkZwaHFHMU5qb2Uyd3pGUkVSRUpsL2RmWk5JK05GY2cxdVFMem45NWI4aEtyZjNGRzRxN0dUUXpxUW4rdXJ4TW4rRTE5K3dtOFFMd1dEVEY1RDBaL1RUWW8yTHNHVGFvVHJMbXRMbUpPYkpobnBHNHVvUVRNWkN6aGppcktjS2pJR0VGUFhYK29lUnZtdDVKNjVqTk9HZUZUSmpvT2FiZUpuTWZKTGw0K1BML2FuL2M1YmVMeU10bDQvbmg4ODl2cmg4OWVuNCtIemZubnR6T2FhRWwrWWd2blB1bjV2SFdNZDNvSm5zUGpSQ1dwTmxjcUVsUytzdTBIdTBOMy9uanE1V2IzMy8va1hTUjg3enQvOHlzYnNtL096c3dWb0lSSXFFQ3BGa0Voa2NJbGZKb29ZaWwxcVhUdkhVa1lXbWhqb0tidTRKdDNmL3o5OXg3OW9BK2tybmlyQVpGVTErK3NDT1JwNFZYUDBUb0RZNGdTVUpRRkhPRmlYZDlaUFlpczZVUWJQVnNKbGNnZXdBa29vZjNEckZBSmk0bG16QXBoZUhpNXN3cFN2bjMxdVQyNGZITHZSeDJlQStGWlo5RVBaN1pHYWFyVkV5YmFIN1ltMWp5dVVRWG9vSFVDTGphMGF1bkYwWW9tWm45dVdwTlY2dmNiUlRzblVuU0J1aTZtOWI1TW9WVzM2SFFCSDMzOG1PL09iYlkwZXdjRE03RUw4LzJHNVRtWloxRW5CQkFlMlNseFpQbU9sbG9uc3o3ejNpYVdWbU5UVzlwTG1HanI4a0xGUWxMOWNWWlpQTVBhWWdxb2VkUnVQYWRzMjIxaVFPRGNqdGtuZFo1NUtYWXkrejRmZkxlemZwTnZkcnRQSDI5ZTNwNzNtWHFlcnEvdzJDNmVmZWZYbjE0Ly9zNlhjdlBWd3g5Y0hocHVUMW9KWGZuWGFOMlZyOWR3M0NOdHJUcmdPak9iazgxQ2syb01nUjQwUSs1a2VQZnB0eWFHOUIrbWgvOWdXem5mamRmdTVTTEJJcVUwbERCSWlVSjVOVWJKV0NteXVjaDlnZTdBUVVDN3pkTVhENy8zNDIvMzB6T1pCTWhqWDgzczZTME5TOTR2cFN6eGwyVTgwNlE2bGxLbklRQkY2L05kbkdhbDh0UFpqSHpVMWRVU042TmFvNnVNbzFzbmt5WVZPcnltSkVCOGVQV3dmM0w1aEhmdDlXVUpnMUVrMVVHb3NSbHBGdDViSllDVWdsclZWRmY3YnhRMVkyenF5ZE90VVVMTHVJVno3NmYrM2RyTWFHZnVIT0c0aXZSb0w4RFRtMmlST3JSaWRkNUI3L1dWODJSKzNJcjV1b0RwaTQ4Q0FraWFPZnh2R1VIenVGdGR3bTFicUZ1TEVTZFBmdWFLaUN3clVid2dpcFd4OWkzbW9GRVphWENLbGRCa3FxV3NRcEhjeUIxVnI2ekJDQlVtb2UvRitiQk12MmlBWkEzSjAzQ1FYa1FwSFc5dTltY2I2NFkzNCs3Smw3YjFUNTk5LzdOODhkQysyRCs1SHM5ZlhGKzlqRWZ4M3ZSU3QzKzB3Z1FwVU5scTV1QkpENmFvVUhseVZlQVMveW9TdXRwZ3kzQkU2eGh3Q2Fzd0lCNm00ZnJDOEhwSXZjalRkNFY5dmszcE8vMnI1K25CeGZUSjN0Mlh4REF0OTFCQ21EMG8xcXViS2xEY2QwVW5RU29BVjRGYTEzLzBuUStmNzFUeXhISlc1K29zU0xvSSswc0pGbG03STNwSWdnalVQZWNvczEwd0VDcGlxYk84QmZxZVRBRlkwYldHOWpGTjVrNkl4SmdRRTB4c1pLWUJxbVhUbVZ3c1Q0QkhpRUg4VnRKd2tPUWVnenpRbkVqUzgzaXIzZG40MmFnZjNkSHdJcUM4R2NOOFNIR29lVDdoNGE1Z0VBNkxuTmxwWkRIUk1TWFE4NVNqeEpYbUlqblNLU1hKV1cwREYxVmdRaElwZUJTUmtPaEloeXBZc3JIRXFrRTkxMmM1MWUvZWl6YS96b0xxLzByTTZ6ZlBKM2Nwem8wYWMyeXBMQkxMT29hcGM5WTJueGV4MlRmRndpV1FrQ2pMamhSS1grdkUzRUl1V2RaMlc3RlI1OGt6TEt1Mjkzek50cHpIWTRJOHk3dFdUYnlqVk1QeWNuMzlZNjBsWnIxS0ZGNTNCeGNOSmNGQkxNWXMyQ0VpUjBvalEwcXVzVUlsSXB2Mm5IelBUYktFL2JVbXpmdGh1L0dBV2VjeEpFcmFIdkluRjQvU2JoaEdEVDU3Wi96ODRydWYzVjU4c0xtKzJWNGR0ZytmZnZuNnE5ZzllWFIxK2ZpbXd0YTk0alFuTEpVK0JJZ3FnNFlIaWhTLzdOSXBNdFVpZDgwQlNvU1NURzNHWUFrQ3FOVkFwYVFHRWUxdTNqbFhFem43NUVrY3JCY2s2cmxJUERqWEIxdll1WmdXRlVLdnFoeUNLcDRwN2tXL0lqVFZibmZXbXdsRHhRbXgxS1d5Snc5dmR2LzJKOGtTSXJncDdhUklQbHFDUkxwWE1ZbDdnakJuYW9UV2htejV0cXlncDJ1eE9UTU9jWFQzcXNIVlI1a0FxbFFyR21kcUdTcEVTVTZITTV0SUJFRU1IZk8xWDd6Ni9xeGFYQWR4QmlPOGlMcUVRUTl2WEdpbHFLcEZDTUlwd3NsVlJIdDNFU0J5TzB1MS9GeTZ1cmFFc0ZYbFdkWEc5ZjZMSll4ZXNMUmdGNUVhWjZTSExzbGd2TDk1RkV0K3lYRlIvUllWZXBObUxtWWhyUElMYzcyUGFwTk1MdVBlV3N0RXpiL2hVWThTZHk2NzY2RUV3YS9UeEs4bWFLMUxybVRsS1FwSmFDY1JlY3JlT2JXM2Njb0MzVEhHOWtwUjNFZXMwejVPTW9YMTNjV1VuV294OUtrTGlPZklvNGwwMk1naElabWtBK3pzL2RlWCtURSs3VjQ4K2VKbSsyaUhSL3NzY3ZoNDk3aDcwOURqb21TektoNjNGWGh2dFRuQm9FcTczbTE5d09ic1ppMTRMcVF6RkwrNmdGSWx2cVFrbVNZcWJ5RWhaa1d4cXNpYWlBUkhoWUZTQURVellVU085bGdwUkJFUzBtMTNiZE1zWGF5UWZTZXgvZURaRDAzTDVUU29FQ2V2SDJ4azhxMG0zTHVBY2M5ODdCUWRWSkUxcGxoMWQ3Umw4N2JCdVFvaFVUbDN4L0tCYU5NT2xtT0lYb1cxaklJR0x2YVVsR0k0VFBlcXpGbUNLZHdoeW9qd25GdW1FV3UvaDRGNkRrSTFKYzBqV1Jkd2E4YUVFM1NOMEJxQnd6a2x1UGx6VnBIUTgzckYwZnFWbzlLWmpWbjExaFhzOWIvb01qMzZSblRFdFo5M3Brd0taWm81N2lJOG1wZ0lWLzdreFFYWTZuZ2N2NGV5NnR2S0I5OTJKOFJ4YzM0ZXRDbURnVUFVWjZhNU1EeVBPVVhZSnNRMWg2cGhocU41T0JrcTFvQkdFTmZvVWppWjFFZVRUaUNPTGlJcmtwMUg1cVpYZHVPMEg5N1pmUUpOTWIzcEgyQzZ4cE5PUC9ueURKcjN6STA1b29oQ1IzbkxJQTFBalVVcGI5bUU5Q3c0VDRDSkJvL3lkRXRybExXOXNaNnBKWGdPaVJzRDBYWHdkcFhxd2l4TkVpTEtNdU8yMUhjaVpDNVpVU0l3czVCeENxVE5SbENhZkZrWjJTQVVqMGZ2dkhlZW9RR0J1WnBFVUI2SXNPc09YNlg3cnJwM0l2aDRMTnFaVTRNcVowMVZFbG9PZ2twcldKVkhvY3g1eE5jNkpCSHg4SndaVTBtWERCR1VsYVNhS0FJVU5KOHFQYlNrTTk5ekV0QzlKcGlYWVZyT3VZckdiSENJdTNzSmhnc2hZYW00aDB1bFdwOU5rL0FRS2RDZ1drZXNtVXFVUldnblIxS3JHWDgzcCtLc1pqa3J2Y05ibU5DY1U1Zi9KZXRYVm5GcXExQlFTa2hOdkZ4UTNuZStWcmFHOTV3VGRDZVVZZjMzVHZSYXgzaXdkYkxEa3BrTEVjSUxBTFJvRlFkaGlQWEpDWUZ1a0lkRGpxN2JEUFZ2bDJ5dGN2K2pSQ1NheERoQnhVQjMzNE9xTlRvSmlPaWRxbWJhZC9sMWZ2RDRKZmU3M2ZpRlBYemllK3hlZEkvLytrMCs3eTZqbTcxeXhGclpKNmN6TWdMcjRRTDYwUUVLMG1HeWJaK3ZVdVdhcnVWMkxiT1AxQVdRa0pLRWtKM0MwTnM4UHUreXBwVEpSSy9TQVUxZHI1SWpjNDVnVGd4NnJsOVJmUkF4VVMybEI5MEJqMTZjUzJydFRCVlNURVdtSk1PZi8rZjB6eHFhcXlObWhxUE56SlFHcUtLb0lZV0NBUk9OV2d2TjdkSVFCQkVueUxlaWI5VFNUQzhkZFlrSU9obFJvRHNsVkhFUU1jbUhlMC9nOEZ3SHlRaDZSSGdzVnY2bVZ5OCt0aXhxUWRmRDZGdzNzY0NJbWJGUTRSZkxFcDIzcXpuOFMyYlZGQmFZOU9xaXNaSnl6UDdhdDBqa1Y3MmdLb1g4Umt0NENVaVQyYUc3SExqa0tyNTB0WGNvVzNCVzYzMXpkcnpMaWtnd1QwdnUxUE5ZSTdwT2xFczZqeFZjbHRBTkVaRWRQVWlSUzZWUElUZy9HMi8yUTJ6UXJpNVNIbG1DTGtKbVNSc09oK2cxeFpTSnZTbFZzak9Vb0x0b2drdzBuSGV2WDc5OGFsZlBINHplVDUrTkY0L2o5ZlQwdXhlLyt1MUUwdTFJUXNOakFkQ2lmZ09MNkxmQmd6aTViSFJ5R1poU0t0b3pMVnlLMXZFcnBxSVYxTGNjU0xaSlFiVlVXaUh6NTlPRm1ZU2pxMHdmVTFVelJlZkpHV2pxSnduclZQSWcyd0E4QkluaDB1MHdtZTJlUHBGaDIyRGpwRWlDdkhuWUhYN3owLy92djZiNzNEMnJPK0RhT3lOTmRIOTBBZ05hOXY0U0E2cU50Rll2anVWOGcvbkprMnd3VGIxcFVDUkE4Y280R1VZUUVscVlRT1JtSkNTbTZTMU93bHlPWUJHWEtFYng2bDFMQXBPVXhJV01DTHBrVENucGtKSGdGY2MySjhZcUd0WW1TaW00V3VFTlk4a2o1UkZPaW1nZUI5K1h0alZXUHNLN0NzblZ3QTdmK0FRdXRSbVhsaThYalJkWDQ2aGxMTlhDSXRoOHdGaTd5d0pIaEsrbE1EK1diQzg1eC9jMlRlWU1uVmtoRFZGUmltaUJOVExSL1pCRisrMzU3czFWamszRkJsRUJyL0VCTU9IazZKSVBQdlFkYXFhUVU2WkpKaUJSWk9oZ0lmUit0NU9yTitOaGM1c2VubDF5S3g0Y0RyY1hULzc5UjcvNFhhUUdRQVFaOTJ5QlMrcGpUWnZWcGUzZVd4N1M3c1BINXpkLytEdzJrMERWRmtxTFZIMnVRb0l3YTlQOWdNYWt5YUVsRUhRMlY2c2l4aWlaUFp3bE9GUTFyZnJ4cEJyb05WSEdnWjJGNUtrY1pEaXpkTW4rN0d6V0JZSHFJUW5DaCtNblAvL3BQM3gxMTA3WWNMRkh0ZXBDZmoyaWxra2hDNkFsM2lpUHRJVlNvU3FDR28yOExxRVZXcFo3blV3R0FUQml5b2ttWk5Cenp0bFRkQ0plbXF6MzBIVENQZHhkVVZQTllIVkVBWVhHak9FU21rOHVxVGVpWnhDVmoxdTV2bFpuSUY3bm9EamlxZXQ4SzU1UlZzM1d2UzZpVWVlWk04bWpSc2JJdldDQTFVTEQycnI3enlxQ1F0YktteVc2dWNvVGRHVWNuTXQzM3BzMUFVQUtnV2htWGxLaXFYYnUyVTV3VWpvdjYxZG4vRjFERldaWTZXY2hXWjdHYkM3YVNSNHZ0MXZaK0RpTFNTbFc5QTJpU09iaDA5NDJBbzFKTklsSHNoQ2dvOUJkQ1VnVzZaUXhDUHZIdC92dDVvMC9PUFB0NDhQdDFkbjI5ck4vMm56cjR1bG5CM1FocXgzeXpwV1FzMldaUEdZeG1GbytiSC80ay8vcDJmYmovL2V2dmlnUHZLNzhLYk9LdnhTYnJSSlM1a05PdytVdXhDZnJWdmNMU0Q1a2JkYkxvbk9ZczZZaGltVHFmc1pwak96aUlwTEhNWVl1cGE3YmJCNDh2bmk4WmQ1U1JFTUN3akRJTU9Bdi91L2ZYR1k3ZThzQ0Z0N2RzKzZXVkNJaXBvMzNBb3FpM2FFWE8xeXdtZENQTmNnRnZqRUhZUlFSWG9Nd3dpWkd1THRQMFROUDB0M2ZtMlVVaVY0dFZ1ZnRnd1ZQVitkL0VJR0ZEK3lrVXdQenRGanRXUk9hU3ZNMDJ4SDVwbDN0VG43cVhFTGZvV2kzZ1RIbUdoVDNyOThqdGhTKzNqOTA4cUd2VEx0Y3JMNnRVbEtlOWxkWDJNeWxZcDhQenBncFhvc0puaXNKNkRkU1pMWnRyRUs4Q3FzYXlnaWhkZW9EbVlOZDcvdjk1VzNmMjJZanQrMjBoMWJBamFnS29zdmpvV1NRc090MG1EcFRRWWNzT0FnRjJ1VnNYZS9qRklmK2ZEOCtmUFhJUG43Mm9iMGN1SHNRaDkzWng3KytUT3ltSWl6QkRBbTZZK0M0RjZGQ0VTS3lmdXQvK2QvLzVFeWV2dm55OEthNFdHUmRYNVZ1c0dBVzNrRkVMSVl4WTdqZUJEMVBkZ1NQOXNtUlNZcEZDL05xRXgyRXFTVUZkdFFZWEl5VWlEeTY5V2ZiN2ZuRHN4ODhQZTlrRW5VVkFTVTBxQ0xEOWYvNVgzNFI1ekpPQ1VmZk04UktSRENPaFBna1UwTXBheDJnRnFXUzhpQmJSU3FlWWxUdUFoaFdvYUk1WVQ4UlFzbUhmcXZWY3F4aUIwbDczMG1lY3FmSW9UR3g2MlAvYk93dERBY1Joa3ZhT2pobzZtVHE0YkZrY29rRVZZYjl3Q0RNM0EyUXlNRXhMRWtVODJDZzNNZ3RrZnRJUmllMTF5bE14Z3AvS1Y1bkNzSnpxcTdJcXNnb2VXMU4wYVMxbCtIU25QcW9EdUNaR0ZkY1Q5STJzSVozUGVsMUVWTElFT1dQYlVXNlBsWmtvWm1Cc0JRdm1CbFdEWm1qbkRlQ2FweWNqUkhFeWwxbHRZM2xkUWFsbFRiTFdiNVY5dWhVSDhycFRzK0hzc0o4NFVoTlY2RUk1Y3N0UjBDcW80a080ZE13T1RvTEQwbG55YS9ZcDhpbG9jTnREQzdXMlZSWXBTR3EreWxCcHlEN2JyZzV0NDc3NmRHenI3b3A2Rm1TaWtJdGpkZDJEazAzbTdIRFp5L2YrL2FiR0s2MFA3K1luZzdYbjF6cCtWVGVSNlJBRkJ4K1JYTlViZnlzcUtNZ0FiQnFMM1NZYlorOGVIK3p6N3ZubTNGSVhZZklLU0ZUSTFzdnRra1VxRE1FWU81VUFUWHJ2bEo3YytiN01MQjJBQUFnQUVsRVFWUlRBaE02VThtS0tTWEp1T25PWDcyWm9yYlV6RFJHTitTQVRCbWJUaGlEMldhbkc4MTUzMkZydC9wa2VQWDR3Wm5pMlo5OE53bUlUc1JDZ0VFM1lubmN5Ty8rci8rRGlXTmhmTWs5TTdLMVVrbFdWdWNWN0l3VWJVU05abC9CaXI1U3J3ektDTkpIckpVNnE4ZWhNL0dzaEVoNGlIWEIwR2lCRGVYL1pvWnAvelljeHlSSmZZSnhEZ1lJcWhZbFlXalJra3FRVFVtdUVxU216YUN0S1ZmdmozR2FTTG1pQjhrSzN2NTF0TEI3UXBTV0tlSnNSZUthSFhrWDhNRzdJOHAxeHVnUkVITjk3SjhPTjQvTHFJQzAwTzU1ZnJ4VVd2TWNCWEhYN0RBUGlSYndPWGhjb2JDSlRtZE1wYTRveWdKVlJQa0tRQWFkVVc2RWlrd3lQS09yNm5pUGxnSVNuaVZrWU1vak9TVGJrQlBFZzJPeVRhODMrLzdSSTl5TzI0M200U3VZK0MwME05NFp2aHFmeVcxM3hCT3FYdEJRV3N0NU94b1RxcUJFSDBDaDZPWDZzK2NQZFpvbVNTTGFxd21tUlRsYUlucm9jU1NOVHlxbVlRbEJyRG9oRmE0bldpbHNTVXQrcU9UeDRFS0JCcWltZmRyMi9aUjZZNmgwWjQrNm16ZnYvZVNEN2MyanRxYkdxZXUza011em5YejZ1ei8vZi9iMS9hV1RwL2F1RDdLa2RCMzdRcXVlUjliaU9TdytXS3hjbzVyZEJUSE5GSXg1aEFuVklKTkplSFV0aFdpcU91ZzVWWWgwZ3NQMVc5WnZUQUp4U1YxZWdzTERsRlFCRmFxNUdzaTFSTWJEQUE5cWxhSXZFNWZTNnBMNXcxOUY5ZkdvejN5U0g0eTFxZjF0TWdkaStkK1RVbHZYUmZScS9kWURsTklBN21BRHhkZFhrNVg4a204VGdhek1JMmh3OWxKcXozZGRPWUlIM2JlQWx6RVNFQXNWdkdtaUd3bC9Kb25Nb1FoU0pMVlFLMXRrNVdNeWkyL01Jb3RxYW03ZEVDZUJIQVc2YVVKbWlBM1JpZmoxemNWRThja2hqQ0ZDMHdPNThuMjNrNm5yRWlZNWJOU3o5VjNjdkJ6a25ldmJ2cXJOR3Rpck9KbHRmcHFQYXg0QWlLajhQcldVUC91Nzh5ZjY2MS85Y1lRSHR1ZWFKNitQaFNxQWdGaDFOOCs5aTZTaXd0U0JJU3FoZFlDVlJMWHViMkdGbm1XV0ZCeW55UTBvNmc0ejBaUnNQeDZvdXgzcDZjSGppMjk5KzVIbUpyZjM3VlpFWW56Z2IvN3g3MzcveTQ5VnkwNlU3dDdoVGp3WWpkUEFKVU5BeXJnZzNDdXppc1ZlY3BRa3l0Ym5kZXFjbTkwZXlTWFB3YU1kOEZBVnVvZGpHWlNRRXU2Sk1kMm5FU2JkR2NpZDBZc3pVUVQwQkEzS0RObFhCVjBZNFRscktJeVU3RzI1UmJGZFZCNG1Xd3hDay9waU1RcXM2d3ZjTlJxZS91bUpFKzEwYUxQWURVOWlTbGRRek5YVWFLWlJMNit6REl1NDRuL2dhOHFENHdPK2x1RExPQW4zN1FKY0tjVk9MdE95RE1QWjBoM216ME9qVEUyVklRS1RMQVFzRlNaUWhDY1ZvUnUwR3BCdlNqS25Db05CVXlYQ3pUWlprTkowbUs1b21rZTNwRElkQXRFOXZmajhDenZmYmNXeE9VOUpTa3hneGo5OWZuWStSamZXUGFkS3J1ZE51RDZWczJZZFpid0thaE5PUXZYd01mY1BoNy83Nno5bUNLVS9UM3RYMUtzanFwUytJYTNhNTlTSmk0OHdpWm9OVVQ4Mk5WQzBBN1VoNGN6TWtFWUdCSWlLd29oczFrLzdZVE9tcnUrMjU4OWZ2THYxcWV2V1cyeE9NUG45VC8vK0ZaRW1scHQ1V2c4NVpuUE1mYVVnMTdFYzBHQmpQTTA4b2JsZVdpS3dxcDdLVXJmZUVOcEVYQUFaTTgzVUk4UlNraXdSVVpwN2RmeWNDQkcxN240emF6aHk3cytNbzJxMGVYVnAyTTh6b3ZKUGtCR1pic2tTSms1dHhmbDhsNnp6cUtNOElsVTVNdm9VUkZWVG13bFdWMXRaNHM5WDgyRnlocHZPWFBYV2l1S2lsOENkaG1HZFlMZlZoWVdiTXAvWW5FOWcxbkVSdjI3NWx0OHVaTDJBcTVXaVROV08rb3h4c2tHVlE3SW1wMVhPOUF4WjVhcS9jOFF6bW90c0xaNmJUaGxpbWlrWmlPeUNzZHJPWEVxeWp0R3ppS3BIK0tpaVowZ2RkQm9MUGxuTmsybVdQTDUrdnUxOVlMK2J2THZZY3I5Uk5lN3o5UENqODE5LythUzdTVEluOGJTNFpJRUFXWEg4Z0tPVXQ3VTVBd1JVL2N2aHEzVDd5VXZaak1sU3YwdTVnSTFMV3ExRkVhQ0l3RkpMQ0EvanlPbmdzdXJoVmxLUUN0UEdwVWg4azRpYXFVWlNDVVk1MGpYZ0tzbUVhU3Zwd1R2dnZIaW1LWW1ST1ZVQ3FjbDBTQ2x1Zi9yM3Z4KzI5dGtWckZNRm1YalNIK2JKRVFOWmQxbmFRd2trTXBnczFhZElIYXMrSjVZVDJBdVAzTmg2NnEwaUxDa0lXazdnS2dkQnBWSnlZVWRwTWxHK0pRS21LRFNjRWw2MGU0V0R6Q2dYR2hGaDFXaFRvT2FjdkhjeERhdWxZQm43RlBwWmVIQmhlZkFZdUNvenRQM2tyb3V2UDRHeE9vSFhTZWx6WDRHUSswOWd5UG9FWHMxNTUrcGtycDhYZlFiWHZ0L2owaHpIcjk5dUVMTUhFVE1jOG1nQjF5NDZxbmNiU2UrN3lUU3BVeW1sRzR1aE1YR2JLVk1sSVpNbUFYVUpjVHBIa0hSR0I0bk1RazBPRDJhSkhORFlWSXVvNWx4bVBPaDZseVNIcTdPemJ4MXVyOHlaOCtqN1FOZHoxSE0rZmZyaUgxK09YUmw2by83ZXJCdE9LUXJrQ0JYVU5DckZpSklvWm5Hei93TGpMYnN4NzZ6cnV0UjFVK2w0RXFodW9UcTlhQzhTRmpuek51ZGlkOUZseUFlU1NHMU1rbXJGN3NYK0xqUlRFZUIydXpVejI4WFRiMy93L1BFR0lqNkhad01VQ1gwZ3Q3Lzg5Vi9lcG9kMisrclZwaU9nd2JSMHJlcmpjZUo5YTgyblU0TVppcThCVmNXQ2xVWUpLLzBIUTFSODhrYi8wM1pkMDByNVNNcHdGWWlFVXl6VkdmdDhnazZ3aU9sd3VOZG14NGlKS25rcW5wZWlNVFpFVWNwUW9YVVFERlZMNmlKK1NPZ2dtdkxzdEsvNjVWYURIOGw4bXdBSHk1STd5UTgrMFVYY0VmKzM2KzhwS0Y3dkhLaDNMc0d5T3FTUG1WWTRhVmp6TGhEdmRQd2NxRWx5dGJzVkMvaTlkcUdMbERwT1QrREdNVy96TlZZUXlmeUR0QzdncGpPZGlkSWFVcm55a0xDU1dnMTZxQ3FraU9hWVRSaFV3azFWUStCSXpKSWxDWjFaSTRzNDJNRTlKeE5JZGQzbGRHQi9ubnhpSjlPTmJNNllMZmxrRDc3Y1g3d1kzOXcrbUtxZm00d2kwaXhxZUFtWlhXQ2xPMThtV0tpNEpWRTJmMHhRY3FRQ3dOUEZ0YWVLOGdwYTBGaXpNa21teUFjZlE0VnNpajRTQ29rY29rWHgzeUt2WkdSS1UwQzlES01qUzlxWVNwSWYvdW1USkhIb2tzbkUzdVl4cTByK3A1Lzk3Sit5N3c1WGJ5NWo3NXBVS3RUdW1EdXdsaG15K0l2SUZYV0hOWlNzUm5hM2V3VWFwMlNGSzY4RzZqeGxiM1BheGhodkw5U2IrSlJLem9wTFFmMHN0ME9SUTlmVGg1c2J1U2NKVDBpWnhCQmpsN3hCZGtSQkZ1VjNLQnJpU2FFcGtrMFlERjdZUDJXTW9sV1NtOXI4KzA2TGFsNi90YmpBL2U2Q2V4cFlQRjF6Uk1XK05zOUE0SjRWZk5TRUpsWTE4eW1sNDBpL2RZcGl1TE10SUZhKzR5YVBEUkFWUUFEbzhnTHpxeXFWQ0MxL085UlpVSXkydGk2UlpVd3pteW5LSTZGUlRhMGxXNW9rR1Y2YVJXQ29Jc0pFekFDNTFSUjBUYU1heEoxbjBNZ1F1WVdaV1pKclJKUVJVb250dTVoaWpNSFBrUHlRY2Y1dzJFdmNmbWxxL3ZGbjQ0UHpHNXNST0F2a3I1YlF1b1F3c3dhbXoxTndoSVM0MEh0UkgzTjZlTW5JYmpJWDNrdHVzMUxFMGV4SU1GRGNtYW5yNjBkWndPNXpNQk5aUXFBQ3FSOEp5eWdqcmMzWnhZVWc1TnZmZnk0SDZ5L0VzM1lTM3FGQjlQYi84Si8rK3ZENHlZME1oLzNrVXV2RjFOU3pLaXN4cnpSVnhqTFpVMkdVY1B0eUE5S3FRWFlZVW05WkpOVjNGNDdPb29hd2gwUjJBVVJWUVora3E3cDFodlp4MEg0L2VZS1FrVVA4Z0w2S095S0o1eW1nRzB5eEd6TytlbzhCY1d2S0R4b1lVL2JyaENrMlNaUWVFajZhdUZ0blV1VUJJV29nUFJJOWg2VTgrTERwakIwaVI0aG9hQW4xU0dwUVRWMEVWVVdpRHFGQ0Myb1RMcFZ3Q2NHNmEwQXB5bjA5V3NmcktYcUxEcDg1R2dzRmprZnBoRHhlT1p4YldWdzFrVlpNcnJXa0VuTWJmSjJDaUVvY0tQTmlYNStzM29TaUlsVjkxb29Pb2FqcENCV0d4NWxIUm9oRFRTVThzakg2blF3YkdFUnkwUXBxbEdwSHBIUXhKS0NWOFdrNWk4Q0hGTVd2cmVmVE1IaUJncm1JSm1HRWszM2VBOG4zR2s2S0QxdkJCcU50eHpIYmJtdWl5WlZ1eWh5aXBueWpLU1V6WmpucmI2NzN1Mi9EZVBhRC9lZVgzTis0UzVTNlc1SFpXaHRscnFWQ0Z4ZXgycytmaW5sYWMrbWgwa3AycXpralJPTldaTHJhUERZTG1JaG9OMjJjQVhFd0NKaXFRUUtXYk54dWhQdUh6N2FpRGQ0bjRPRWd2YnNvaGtMZ0NLV29xYmlrelMwWVVUbzh2WjF0Uk5OTlBQdDNHN2R0dUU2V1JGeTZVQ0VRdC9rUFAvdXIzMHhQTDY0bXB1bk5heDExaFBlYkx1a3A5K0Y0cjU4cjVobkJ0Zlo1WTVtRXJTRnJVa2VPL0JyU1JFTVl0bjlTNnJvdVdSdlhNc29iTG12R1pvRUNqOVZjUWdXWnN4U1F1cXFoSkdYTlRLOVdqdWFjOHpSTldTV3lJcWtMeUZXMVg4YkE0ZTNDZVJ6eDFmUU91RFB2aGR3MWI2M2ZzVGJNOHR1bFZzZFVNcHlPZUJmMUkyZUcxcEdoaUd1NTh1cEd2SnArZ2I0MGROYXZpMWp4UmlBc05rZW81bktOeGFFazBDT3JVY2d3azBBd0cyaEZZNGlqdUoxR0tXdy93SU9BZHM3NVFJZWxHS2RlUkRTRVU3MUsxWTFGZytWc082QXpRR0lMa2NnaFJESVZRRXdwTklpVW8yM1g5NXYrakNxYjhjMzJ4ZjdqVWFaUnRTYVBMOTV4OG1UU1Z2T1FHLzJyRmlPcmdkeVNsc253NGlJdkFvVUMvdGZBMGkwVlNtY1FGQUx5dW9BSzBXUTE5bnFkWXNuSWprUm53TVcwNzdxTkRyZmp3KzkycWZSZmVucEZlb1dyM0Y3LzUzLzRiNWZuNy9MTFhjWTBqRk5Pa250TE1pWGM0MnErNDBLWkc2VTE5QmNyVWZUQ3JxbmdQelR1RWhkMG5mQmsrTGJ1dnN5YVl3VzltcDVZQk83bEFtYWRyYUtWVi9MLzhOaFkxNW5XKzJKaDZvbEtpSEZlT0NXRXVDZ3o4MFlZQVV2REtrNkZRanJLQ1dGTkhZdlpHZzFaT3dsUDVyMm5DN2dHcGN4M1NmRHJkWkl0Yk94RXJNbTdSdnFWOHBKWVBMLzF4T1dzS3VkcStyTUU4OFZiZmdkZC9idFFITXQ1MWJtSG1pWVdlRE5US1pEVlJTaVp6Q2hBd0tYeERxelg3MkliSlZUUzVyQmMyN3RrTVVrTjZHa2ZaM0hzYWdGZ0JYQlFkbVRFaHBGOVVrUUJualY1cEthQ2xzYldZR2EzaDgrZlhzaisxYlVLUlRYQ3RaTEFtMmVpM1FKNWZQbGhpV2VONmdvdXd5RzB2bW9SbmpDUG5ndkNVQVdxWlRKV3N5SVo1WXBna2lmbmtkbExpTWdoa0hCYXVZcHFPeVExQlRZY3hyeURhZGVsYnFUbXd5amR4dHJyVW8waWtuT1hYdiszWC82SC9XQktPME5IaG92RmxORlo5c1Q3VHVCak04TTZ6WTRFdEo2SFN6MDVpNWVXdUhuT2ZKV1pISHV5WkkvbDFlSHU0VlBKb0p6L2ducEFxSjFGeEJIZXZaeG9rWE43ZnFKc0lPb3NXdERTYmFuSnpDS3dzR0xyaEpvbE15aU83RFVSTFNyK21Ma0hMSUlGbkhySVZ2UzhremRHTzFGRThTMUNqNk15WkJhT0VQZlhMQ3VNWEN1dWx5Tmt0U3V1MHB4WGxLdDFtTnFwS2FFZDcyWHJjQ0tjUVltcFJPbUphTUh0WktFZ1RPY2hYWDFmdXVZRzg2UUxLbXBONWhrNXArM0diS3BXa25aVHI4U1drbzJtcWhGak1LdDNFTG9xUENJckUrQVpobkR6VVBSSm1DTnRrNC8rcG51Q2wyK29ZVm9BcVd2M1Q3blB6YW5wN2Z2QTNaNUJJNTNOQlE2anVOYWhxaVFWV3E5ZHMzTlBGV0RrYVRqa3lSdnVxM3p4N2psbjdrZnBhb0FPaGRDa3duT1ZsRFJpS2xHQXZzRVEySjV0K3NyUEgxS0NpRXhJSFQvNTZaLy82dkxSRXpsYzdjNnpNdnNVR3NGRGtnNnBDUXIwR0hWeEF2QkdWWkN4aGRTMldNaEdnTkJWWDJWdVhCK3QzOVAyOXJGclVTSThTcmhaaUVKQ0VMWEpndEFFRDhvZFBWaTQrNjI1cVNiUit1VzRpRUUxc0RxQkJaQU8za2xOZUVzS0ttZUZCbGRkM0dqQmRvVlBqNXAyUGE5b3dVblk1dHVPMVdNeWZqT3k4R3ZTQ08rM1BmQStmTTBLV3RUU1dJc25lbG5BdWlBcXk4R01PTm94ZVNMYzhaYnJHeTRROTdGMnFjZXVONGpxb0Y2Nm5oNGg3RHFiMWFkTHhjTDY4T2tLK2xqVStSU3JqaGVKaVNuMTdwWHpXMWVac0tycHF3UFh1c21ka1dLWVBGVFV6R3QwanJ2MlhSN0ZNM05zdWtscDNhN3YwOHZQbi9RUHIyK0cwSzVEYWoyQ3Vpb2pUbWllTWdNSEYvZGMxU1J4TmxXeFpvL1RTMUFSV0ttRkJTQlJFOWRaOVdYaDA5Uk9BUzFDTkVhZUJzRStJMFVMbnFOWU11RldhTmhUbUhibm15NnA1a1AvM2p2dmZZQWlkNmNsY1ZkUUliLzhEMy81cGI3cnR6QWJiczhvNDlYMUlZdVJRK3AzNlQ2Zi9OMC9XQzYwV2tjT1VvZGRXUE8rVjlnR0x2eWw1UVErMGtJZm44QUdFbWEySWdjRUdReWphS0xmVjFPUzRTNWVBWUhCRWlBcFpVeU5KV09sd3J4VnUrQlVqbTR1NTJrVFpicTd3OXEyY25JQXR4UDR6a2ZFRThsaWUyc3VSNnJ2K3NCODNRTGxmSTdmNSt5UCtRREZpWE4zUG9CRDJzNWZvNnRiWE9nY2pzTWpwSS9jWXhrVmQ0ZkpWR0lTOGhSblhRZDNvcXRicnBIdzBXbVZ4VmZBS3l2QnFaWUkwOVZXRzR4bzRhTWg0aTRwWnl2aGEzUFYwS3diR29Yem1EeEhVTU5MOUlaWm9md2hKZGN1U1lUYWRKaW16Vm12eURsNE9JczMvZE9OL0g2aVNvanFTcUl2UWpZZTlGMlZPV1p4d2d6WXJibmxHc1d4ck5ET296emRCZ2xmbXU4MFV0UVVZcHNPUkYvazkxSmttWWdjR1ZvUlBJM2VVZmd5TUJtSkZLbEx5Q1BIUjA4LytQR3pQcUV4UWloWmpiMzgvbS8reXk5ZjlSYzhIUFNzQjdQQ3h6RnNBQmhPdVovSVFia1RvZEgwT05VYWNFU1N3WkdDc20xYlhEZXhlT2ZaNWJIY3Zwd2haaEZrSllmTWZIRXJnSjJqa3JOR3BydXFLbFRoeFVQc3lXc203TXk5S0wvNmxOMDlJbEM0amRZdWprMm5HSkpINkR5b2xubXNPUytZVldkclBRYTlEL1pHWVh1ZGVsV3JaZ0JadVlkWFlucVdnZExNdXJvMzA2aXBPMlpaUjlTWStYYVBKcVdRd0lTUXFPajFWam9Kanovd3RXQ2ptQTlRNUJnNVZNU3pRY1N6aDZYRW5CMHFMcFRnSlZQSEtjUUF0WlpmWFBzZ05ab01FSm16czZMRzg1cVlrS3FUSUNiUFV4OFRvUUpIVTFob1JHaVZYbXJOQ3haU05DSWpSQkp5OXRGc3k4alkzUGJiOFhZQ3JPOGpEOU00bkozZFhNYjJ3Y1dRRFJPdG0vdjdaWHZtZ25JK250RFhDcVdWbld2dVNsRjBDMVJUSDBHbndsQXdmSkNtakN5QmVjSzA3VUh0VkFWa1pZeUNyb0J0T3VSQXpNMEtDakZscEdUYmROaDBwdFE0KytERDc3MFE5MVI0M0JFUU14NCsvL1N2Ly9MejdpSEdTN1c0U21lN3JFTFBrZ2JSelc1bmNSL1U3cDUyeDRJdzFrcjJvUndaWWhmSzhla0p1L1EwN3ViMDhFaFU1VkVWUDdYV1lEMHBRNDhqK1ZibkZCa0l6eFBGV1BSdEpwbHhFbk5FaUV4VG5qeDdJQmhVczFZOHQ1ellFTS9tS1ZZOFhSekIza1J3bitHSUo4RHp0aWpiQXZabWxzYmQyV3dybmJuT0NuZ0xXS2ZaQ0d2M1ZMUUcwOWhSODVwTi9GTW11MjNOMTNXMmJpK3RCQnRZNmFsWWdmd3lsQjVoZkxFN1N3eTF2WnFCNUUwNk40anJDTFYyeUtNdGgwcHV3UEh2VFlwb2FERjNPclhhT0V2eVFOUTZ4MnVLQmtSQ29USVJLZ0dxRUpGcElrazFjcVF1K2NSK3c3VHJnOEJMMjFpMzNTUjVlYlBGSDI2dSt5SEV0QlFNWElINTd5N2d4ZjgrODl1T3gveE5FNm1xbHZwcGt0RGl4NCttTnk0c0wwQWhBVk02dFZDdVdBSGhwSm4xN01WWjZxT3lLWVhRQTJvYjIzMW5kM0d4N1RzYnZ2dDhLeDRkR2NxU2VBVmUvL3huZjNsNTJIVFpTeDYzN0NlRWpzTXd5VG5UeGNNdDh1SUhua2ZVVVprK1Mxb3poS2k1WVFpYXBrNVp1SytrcVpsS1l4RFhPUWFnU1J3VWFIZnJoaUZ2TnpmamRtTUNaakdEeUpRT2VhUENIZFZjYmNqZEpzYmdlSmFIYlpLUVhJbDEzYmpWL2NYbWRwcFM2SEhhbzhKZG1XVUxRNFNXWmdtbjNDZFVBb2laSHJZOXhrQ2ZZb0tJajRURjdmN0JZNmhWWUg4VUp0NWNKcXBDMUtMZGRhb0N2YUMrRmtVNDU2TDR1RHB0OTZvNllXVVhFUUxWbUJzK3JmWkVKVnlzWHJMbSt4WlM0cEpEWHBlNUNFWDZ1a2JIbG9CUTcycGtCQUY0TFlaVEVkdlB4YjBXaGtLMFRLZEJTaWpGdERLOGt5SHVnU3c1aDBrZVE5UFZjSk1zZFhZclluMlhiT1FJVHRDcnZoZTZkOUYxQ0pnVkwwcVJWSmVTVklWUkRqVU51bXVLUE5LUzJwUkRFb0dZVE5ORUwrd08wWDRuRWRkUWczZ0lWQ0lRaUVBQzNlamEyMzZBYkhiOVlmTDRySC8zK2V1OVhJeXZObHYyNTIrZWpkZDRjcmI3TklkdmVtWHhXM2todVpiWllobElvQzNNWXVqVnFtK1BHbGsrYTdvWndnaDJSTWI1VmtNbEdJeXRCTVJWeTJ3b3BjbEVKbXk2N1hqOVRxZUVxZEFqeWUwT28wTGkwWFIrOGZycXNOTW9EdUlNQ2RYSWczV3dKMDlmdlBmZzZabTFHWWNxUGFtNElvbWJmUG9mLzlOdkp0R2N3VkNmQWtuWWl3K1Q5VHB1Y1BiREo2OWVKaTVEQ2psVzVaNmNBT1JKVnRBUnJmRGVNcnpBTTZHcXpJditvVHlLeXRLNzh3S1AxZlYxTE1wRkhsSktYeEZZeW5GaUFTSVllWm9DUlFpQUJtK1dHVzlWVjBBbzZObk0zS0E2U1VqR1praEZZbC9pQVp2Z3FrV2h5Vnc5WTlWMzRyR0Rsek9yQnJOVllRNW9hSmxTSmRZampseEpaWTU3Y2lGdWRYV2RBb0RIWHZyMTNYVlZDcmZBQ0dxMTVNM3ozWkpIVzhOTmhUS1VPMGNSUG9xalo0Um5pcGZvVmR4Z3pxeVBISXhFMFcza1BIcTRhdElwS0pZU25tdXYwMzY4VFZFQ1JTV1hRTU1tME1tTFpHOWxPYTI1VVJwbGlBZjNDQmdnWGdHSVZFaEFncFlaVUVVTDA4b1JBcnJUVElWVlRhTGE5WEY0K2VSaGQ1TTB5VWlrUjlldnJyWlA5TUgzYmw1ZkR0NWtBR1UyR0R3ZDAvR2ZCWTF3bnVlVmRxeDdVS3dFOHdDQ2lCcHhnQnJncHp6WTVOUFVtU2trZXZFd09RenNlK1RnaEtDWEZwSnlZdXI2MjV2KzBmTnZ2WGkwVGNJY2F2VkhKdWJvSUc3ODhyZC8vaGVmV1UrSzA3MGpESWdzRVVOR1NzZ3lEZG9QS1JvbC9QZ0p4UjJHVWptQTlSNDV4bHZYYngxSUZPbFc2UnJwaWxOZUZMR1Z0YmthbGRUbVpwVXRWZi9FRUFxUjVYWXJRcy9UTkxreTNBdFFIQzN4Yy9YSUoyRkFQVlROUWxWRlBDYkxKVlkzMXFqbjFuY3VaUGhvMHZ5RlIzaFU5d2RPekF6emVQWVVmazAyTDZ6dzZLS0Y0d0J4d1dJRzRPby9uaGp6VC96Q1hDQTJZRkgyQUFWYklLVnNLTitFdHhaR2xicHB1SHVFNUxaNXF5b2d1bGVoQjBWY0xDRlB2YW1FdUhTZVBkeDFMMU5QS004U1BDUGx6bk5LRm02czRqZHA4NkNZQVFhTVlDaGd6a0E0RlhTbnFOYmVVczJGcTkrL2gxTFIwclNkb2dnZ0ZLcTBKSkVCVFp2cGJIekQ1NTJGU001R2ZjZHRjdUQyQlV6cFNXTXVDZWwrRkZDTGI0d3ZFaXdLZVN0bTZwU3FtekJUWmlBdHlNaG1BenlHdmRJTXdwUnpFaDh5TjJtOGNZVEt5cklsNkpqMDJmYytlTGFwbmIrbDFrZEhGK0ZYdi9ycHJ6OTlPZXFXeFZKYk5Kbk1uS2IvbjdOMzY3RXN5Njd6NXBoenJiMzNPUkdSbVhYcDZ1cXFKcHNYaVNZcFE3Umt5SUFBUHdqd20rRS80Ui9sZitBbnY5Z1BmdVNMQmFoTjBCUkpzU1ZURks5aVg2b3JxeXB2RVhITzNudXRPWWNlMXRybm5JaU1hamFVQ1JSUXlFUm1aSngxbVd2T01iNXh2NHBsV2NlYnE4L3FmYUpjcnNCVDIvUzlGL0NtNUk0bjlGUjRhcjY1elpFZzdxTG9qSm9UQlN3Z1o2YjR3NFhNT0RjblpkUWNFclVzOWJIUElzSjdQNkhEMjg4ajNJc3MwY3dLVWV0RVg0cUdoTUJTQ3lEZlVrZFBjb3plZDlZTk5IdngrcjlvZWZRa1VTSGFHNVFYTzVpWEZQaFRzUGVGdkx6OXZzQVR2WVlUS3FjM3dmZ0xVd3Q1S1FTQklNQ0kzbm1IdDZjM2dsdVR0N2NhdW9IK3Z2UEluTkp0M2MwNk9aQkVlUFIxcG0yMHAybndVbHcxL1p6cGFoUVlxMGZZQ0ZJSGczRFY2RFgwV1ZtQ3M2WXBXbEl1T1ZTUFpJa01ZYlJ1YlQvdEkzb1RXOUVDMjBDUUdxU214TUpxYVFqM29Ka3FPT3pMbTNLZDF5aFJWZlZxK0VUZjNyNTc4K09rUGN4dWUrS2NFazBmYk45Zmx2VzFYU0xqMEVyNnhySUd2YVZpZCtLU2E3VXNsVjRPUEdLOFVxRlQvUGIxVWFiMTNSdlBUWFdsRURqeW9LcDNWNS84NFB0N1lWV1ZKcVRlUGxJaXhhdFhmL3luZjNiL2ZNOTMzUm1ocGJOdFV6M09heVFaNHBQUFB2Z1lmNTgyUHJBOERLdDlraDc2TFpURTdkSHo1QVpXbG5VVk0vSkNpRUFSMXlaV05WTWhMMXdkYmJ4NEFwUmJxS2dBcDRERFN5aWVOQkJtTStSdjhxOVRRRUcvcDEyMFgyelI0TkVVcE13TmY0ZnRLZFNsMytjVTJHYm4yaEN5RjRid2M4L2dndTY4SmR5ZlpGQW5sekF2bW55bkFsdWZsRlNlSmRZWHJKQnZ1UytJVFMyREV4bm9GRHJmQk9YZEFVeHBhWXBrTU5xK3hkSlZzZHBybmhiUlNMRlNOWXV2bzVtNGp1bTJsald5V2duM3FsQXRzMmUxL1BXMEg1T0NpNWdGRmM2SGxkY3A0ZU44Z01GSVNZczRMQ2xadkUwUDJvOGhQRUlBWWxCbGVPOUVpNGFUUTFaZEZnd3ByUjRneE10MFRGZkhJMjhTcTVoeWVUWGxUejY2LzhtNzIzRXlaWFJsL3RaNDRDL0h6SDlpeldzVGUyUFRad1FnMFlLbXp1aEdSb2ptaEFqV3VjN0RkNjZ0Qk9yZFQ3OTRxL0h1OWwyTVJrbk5HN3hpMnRHWlB2bEhuNDBTNnc1ZEU3eHhIWll5cGNPUC91UVBEOFZ1STdRR1ljcmVTVkhRMXlXQ3NadSsrN0hkOFpoNkpjZHpjQldldExhMk9iWTgxVWpHVTF0NzI4RG9XeWpZRElNWEtvN1FCblI5TExKc04zRG5KTG9IUmRYb1JUTXUwejZqaHpMMEtKYnVlQXNHVGlwWWluUndPTGFMWUpVT1Q1T3U4dWZaV3hMaGlFWXN1Z0RrYnJ5S2RzZ3B6MkFwRVVMN3R0T0xHcnA3UUhHaWJvbGNtaGE2LzBjZmFMdDdDZGs4T3hjVTMvZkdTbWRDOFlWd3IwK3k0OVR4a3RLeitWb3gzZjVmSWxxSHZuZDgreEpOREdkM21IQ3RRUVhsbUYxbzBUcVZFVkVsd2tOdDBqVVdHVzNPTmxtVVZSVmV1aWNIemQ3QWkwbWNFdTBZTVJFZ0NTUW5GMUZORHA0Z1FXY3hLUlZxeWlxT3pidm1RVFhOcGF3cmRQQjJ5dktEUmE2dTV6SmZBMlpKbFlmWXZYaFIzdzR0WjE0M2JydEFPK3ZoWE9IOWNyVE5KbFBLVE1rTXVoWW4xRkowbVlwdFpoRnRkNGlTNE9yS21MK2hmNVROWkhuNXhadGxlU2ZGaDJ5RmJlU2NhbFA2ZnY3WlI3cEszcldJeGhNOWpCekg0MS85K3ovNVQxL3RydXZkYW1NZ1NJa3RMVS9LV2tNQnlHQ3NYN05sSXpWTkhNOURrZmR1VTdDZlFmSkx2NEY3RTZ2N1RiZDFjRnAzcVhjWFdqTkE5SUUrZ3poeEpraEdPQnhSTFYvQzFFaXZwYXdSREs4NFNRZTJuQVUvUFNreTE3VnlrMUUwSG1qNDFqTGxHWDlGaG9PRUdoaDZtVk11NzNlVStMQmNPSEVuTzU5YTZpWFZvT3ZFSHlvKytON29uU2Z3SEM1TDV3ZVA0TmltMFpzZXVqdU5uZUZidnl5RVVzNGVkckxGZWtwck1yVUsxL3NHSGxRaG9uelgzVnRJV1NwMUtzVVZqRGtFbVNwTzFSYUpTYVVMOWRtSWhRUUdSYXllMUFoOXJQUnExN3RLQUxTZ0tBU3JUVzFNRGpPS2IwcXl4a1NTRUkydXk0SWlJTFRrQXRaSVpuNklZU2RyRFJmZ1B0KzRUdXR4SG5PQ2FGYjZ2ZXM2UksyRTZZVVhWRGZXLzRVRzk1ZStnamxFU3FiYTg5SG9LZ0lsTERXdnpla1R0akpQOWI3bUNoN3U1cmZwWnZCdnZueFYrTHI0ZE4zREo3b3YyKzlyZnZiOUQ1TjdWZ2tDaHJZc0JTS0g5UHJQL3ZBdjN2aE9sNnI3OWtBVWlUYnRnZkN3cnBKVnpmRFdybVlNYVp2eTZ5V3cvcjBlRmtYMGJGdDR3bmVEUzNqYTFyMFRFYWtLVmFVNzVVSTdTYkVlcGRJS1lia2NaL0tzU20zOGd5Z3hhNVNUOWFsdFJJYlhVanlSRVlHTmg4eE4rTlMvbWp6dDVPQTFyTWRES29SRTY3RDBFNlhkbyswWlZrT2dLbUhyQTQ0QUFDQUFTVVJCVkJKMkNWWG0rWTBRWjRmVEJUYWphVW5QVGF4V21KK1pOVUp0TnFjTEpPWER5VEFmallZdjkrL2xEMitRYlY2T0FCclNxNmtUbzMrVlpWdGF2UXNUdlZ5dVhSMHp5OGJIYWJiQnRUMFBvdVl4amo1TmlVaUpkU2xtU2xaUFFIUHRVOE1keWRhalk3clpoNENsZWhKaXc1OWNsQWE2dlVsZzRpSXE0c2lzRVNLaUZoRnUvUm1KWmxCdDVnYzk5eEd5MEFVUlptbVptU2RoQktENjVmZHUzaDZuSy90U0ozZzFXMjZtZHkrcjcyY0JWRXJkTjk0S0tMREErNUtHcHppaUxTdVoyNHNKQkdGcXFtb3dzK29za2R1aVZBdDRXNGJ0dGFCMVhmMklWQ3lXTjRkYkdZYnkxU3NtTzk3R0J6Zm0wU0FBUUJYVWVYbWVyNmRrRTZRTVo1SW5SRVFPZi9uRFAvNUtqZUorWENRbGRTY0FjVXNEV0RuWEtpa3JkbkxuaS9BNmJYcUY2QXA1RTRpNE1wMWpBMEFLV2g4TUFqVVZpa1pUaTFhVkNFSmNXeEhaSU9wMkFuSXd1Vk1scXFRc0FVTkZVeTE3MWJ5RzFtTDBRZFpRRFp1K3JqZDFNRlpUTjlMZEkyck5tckxsMlpNS0w1SzBHVkdydTdSUFZVRUVKQ1JIUktoYVFPaENqaDk4TlBudHoxN09JYWt5SW9zWEhSTFhGSlZLejcyOGNETU5UemFZaE1CMCt5aWJWemJnRmdZbHFNSzJ4am9Kb0xINVdzTlpreDA2SThvMjV0UkpPcTBBR2FrYlBxZ2t0UzE1QmgrdXFINFRYM2FoZWFaeXRhZkZscU80VFRYckVraU0xVklMWEl5QWl0ZWVBazh4UFJsY3dtdFV0V1NxVW1NdGFaZmtSbFdDVUNzeVRTc3hlblZDa2loWWtYS0lqaHFVV1V5VGdGQUxMN2V6WEpsSlhRWDdYU3d5anBzb1hVdHhTSGhDYTBoN05HVklLZ0VMWjlHTVVtdVVwSENtWEJqaEZFbFVqVldIbXNJSitOc00xZXhIdFZTSTQySE1XR0tRNDNpbzJFbVY1K1h1MlE2SXNicHpXWXBtZFJkYTh3YTJuSWtXVlMwWG80MFRWQWUycFZteE0wTDdzVGlVRURpdHFOSHJzWlpsaFZYZDlWYW5lamlnRUJPS2duNy9hUlVEWHY2NnZIazVlN0VhaDlrbUxqRzVWNDJEN1hkWDF6c3M3NzQ4RE92ZHpZZlBUUUF3aTNqQVZHb000bHBlL2g5Zi92aU5haWtVb1VYVXdZdFlCZ2ZxY0NWM2Q5OThQazdQMzc2MGU2Z3YwM1JJcDZmYkV6QzBYL0JTNE9WcithSmRleTZxd1FmRFUyMnBnUDVZZkswOVQxUUVVR3RkU1R6NnM3eld1WHFWUU9qNWVqb2x3UGIxSFR6YndYaEsxcmk1MlNjWmRQcHJoQ3NzTGUwMVhwa0dLMExicnNsSG1PVW1WQ2RQS3RMK1ltVVFER0lUSVNQUWJCRnVhaUlTd3pZRTdsbkQzQ3JzTXhpdUdmMml5YVh3S0svM0lrbWhmeXdYYmtPZWRYSmJHR0x2RTdYdllFaTA5bWR0Z3dmeG1yMjZoOGpJY0hmb0RGVWc4NGJ1cTN2YzU1UUdEUjk5OFJDUmRGd2xQSTJ1YVJ5YXowNE1pUHVVRVNIUUNETHFPa2pVVWtPK1V3Nno2REFlRG91WlJZbWVWN241aytMRUdXejl3SlJkM1NuN3NpS0xGMFF3SktVUUVZWEFDWmhva2xLS1UxUXRnaXBwRXpGNUkxTnBpL1FwMWFqaWxIb3RBTjFaaEgxVFFRa2x0ZDNvQVg1Ym1Yek9UZW5oRXYzUVUxTEV5KzZUL1ZHdWYrcWpyalZLYXEyZzg0ZlUwY3VVS09YZXlwcVB0M2REU3ZYQTNWQ3E1cnJ3M25LKy90NnZmbWVTdytGKy84VTNyMHErR1h2NzU1QUhFVHJTNG1aZi84a1AvOTN4S0lPMnFRcEZPTmZXQThLdzIrdDhmL2ZaRDE2TXFKeE5BZ1crcGw5bXFQM2VvN2ZIR3J4dnVudmN4Q0tid1pUVUdxRXFJUmVEbUk0dGtpMTNVYTByK2JZUloxZExWb243WlMzTTVpY1BEcUtMSk01ZlZXakxXRG9GSWdFaWFjcUJQYXRTd2dYbUlrSXZNOU1JT25Sem1XN2FpZEJHc2p5N1NTKzAyaUoweFFsL0tsQUUxQlNDeWd5aGI3TXgzWGJkU2ZyWWw0aWZMOWtMdUNzZlYzS25MQS9LUlJqaEZ0cHlSZ0dKTlI4SEcwKzUvL1FTVGlMRVkvWmFIWWIyeTZmWnVzeFJsclY0UE4vdGhrR1gramQxZFppcWxRclZYQ2N5bk1HNWtVNGk1OGhxZ2xSQ1FZbTNRRW81M0pjU0hKNk5LU3JTZ01nTitBOXZhdElXT1NnTlk5TWtucWFpbFZPbFdvb28wZHdBM2o5T0N4VldoYWtCckZVQnVxUWtBaE1KcnFNbFozTVVKcE5pM2RNYndsanZEdDZIQjdKOWdvUW9HcERxMjJrS0p5VHZSa0VCM2VrU0N2N0tQL2wxdm53VHo0YWh2ak5tMDE2V1BmREVVcWJkTGkyZWhtcmw3dFdZMC9oNmZiR3Z3NDNmcmtQZWZmanMreDkvbUVSMkg5VG5WM0p2My90azdIdEdqU0l1S3FPOC9iTi85Nk8vS0tHWnBSUjJ6NEdMaUd0SzQvVnpQZHpkM2UrdWYzQno5MmE0QzBFbzY1cUk5N2ltLzVCQ2hTZjg3SW44aHZkaGJ0c0czamFxZUlpSzl3blJPZENoUnlnTFZFM1BGMStjc2FsUnZkelhXaEdid1pOOW50bFNrUmpjNGtpM1B5MU9kTW1GcVVSZDdvUmU2emJSOThVNWJpVGd6UW5RYjN0WSsxSzI2TlJMTHB5Y2IrQ21qeWNjUmtPUGY5aU9EZFVMTzhkRHpkVDVibTFGT2g5SEtKejUwVGlQZW5scFlqMnJKZnE4T01KWnlHalhocEJldTBnMGVOZDR6T3FOTUlOTVJuandxM1pvMnBSNS8yYTl2dytGQ1BMZzB6Z05ab29nUFVTZVJXaVNXcE1sRTQrZ3UwSG9peVFiSi9BZ1VkMFRKZ212SHFPS3FIWnpZaytoNzhnMENxaXMzbVFMSlFDMVNZK3NIcjVxQnNWSmhraEVsUUJTVHZYbzNxS0dMWWdrRFBGa2lhUlZSOXJuZ2ZjU2xTa2xTaHB6SE5lOWFoOUE4Ui91dEo0UHlXM0kzempORWlKT2dxclgvOTMvY0xWOCt1cUw3NW5jZnFtclFwV09oNHRDS0pMeVlORHhPaWVVT1JnTVg3UEN2ZWhIdi9tOVR6KytNVG1XTk9ydzZUUitQUDdnSSt2OW9rbm9SQkpaWHY1L3YvL1hubmZ1c1VhSUF4RkNKa1lORFB1cjYzRzllM2VvNys3dHVtYXJJUmd5Sk5JajN1a3Zld052ZWRmNjdiK05KeFhPaFdIOGNnRENvRWoxYUVSWmRNUGx0dTIzMnBMaGtIV0ppQWp0d2d0UzJoU3AwZGpEcFJsWEVIdzhoejhzTW5pOWU3ZlJLVTFDNk1zNmhrQzFPWjlrcTJRM0VMZ21PN1gxTHh6K0d3SXIrdEJGUUhpTHhwVUo5QkExSWR1WS84TCtzMUVRY2VGcWlqTVQ2MzNMN3drTmR5N1RUampQZmd0ajg1ZEs2MS9WMXBJakdFSDNKdi95a0ZXYjdzRzdYZEc4bGxKcUxERExLYW1Vdy8yeExNc0gwOFFpMDI1T1NadzFYSk1xUlloeHQ4dU1JaExPV24wSk02ZGRSOFFLaUNDWnl4S2hVaFpNRTVDR3JPRTd0S2drQ2k5Q2Q5RG1PaUZjZFlnZ2hsU1h4ZXNzcXFaNklUZzQ2QUNJNW9QMG5qSkZyZmJrbkVyUVhXMDM1aEtsVkpwUThvN0hCWjJoUnoyUndoNVVhdDh5ZkcvWFVxQlJWTmw1NWdUczJTU1ZWOE9Vd3crNmZMTk9MYTBIRjVSV0NBVHpNdHZxbWlkRFhUUGpOZmFLTWI2NXF4LysxdTk5dXJjQ3lZTks0ZlJSL256YXA1TzZKbFlkUk5iRG4vN1JuLytVVTEzRFBlVGhUa2pUOVg3QzhkV1gzMVQxd3hJWXI5LzBSTlkyMy8rdnVvRXZTOEJ6N3VuREs3Z0ZhSjE0elJGYkpoQlBOTFplUFRmNFZkdVFsMDVFZ1RCY1loUFV4alpoUW13NzJEMThxeWkzREtTVDJWZHZYKyttZXY5MlRtRm1aalFTb0dzMkVVMkt1dGxVK2lOSmJZdGo3OUh1ajBnbDZCc1lsNWFyWnY1Z1FKREN2UUhLTDFqNEova1BlcnU5bi9ydk02ck85L09qa05EVDM3ZFpHOWhaYlJKZEZNbnFJVnJvRVF4eGlKZEtNVld3ZUNUM0lHdDRlUFVJdVlHWnduM1ZzbmdhYVVOeVZvYXVkNGNDT3ZiUHJnWUVENWFYZTQzK1JLVm9vb0tTVGFMNG9uSWxTR1BFaWltckZHQkIzdTF5dUVOSkdFcWZQRzlOazBRYXhRaDZhWDB5bXdaMlJieEhCRTBpaUN3K2x6eGQxVUt6SUNXZ0VDUmhxRUpvY0YvTG1DZFpXS1BHa2pBK2UzSFVlcEZVM2pWMXNxVlUva00zY0VOSWJ4cDJDU3JNZi9MeGJ6OS9XMjZxN3ovZ2wrNDliL1JDa2RnNitlNmxoa0FrNXZ0bENnK1ovZmhCSnIvemozN25Cd05MZ3RCQU1MRGIyemxUQTU2U3lOZGYvZXNmL2Mxc083OE5RRFE4bXR0Q3BDalNlTDNmK2VIZE4xOGRkUEJYWDM4MGZqL2tkYWxnUkNSZVpBYjg4cmV3bkdLY3R4MnFqMFllcDVUM3ZrOURGT0hVeDNWTno3YnJwMW80eitpZHZnRWlvTkEyRC9aTkVYamF6OEVJVnpnNnRMTVJmczhwZmZVVmQrdmRYZW5Sd2V3U0M4bW8yckVjdk9UYWpKWk5HTks1bHBmRWpDM3VoOEZ1MG1iUU90VDhydjNoRWRIaVptby93YXdyc3RwbHI0aExzTmNEUC8zRFYxbGNVaFEyQ25Ick9tOW02QTIyMkNkSTRZV0t3dXI5TkkxYVFrYng2dTZSYWcxRzhkS1lkUWlOb0xzdlNkWVlNa1kvaW82R0RJMWtyRlY5WGdXWVVwSzFWbXBJeWduS0JOUlF2Vk1GQTdaeUdYZlpXV3ZLcUhTTkZRakV2WmtJVXZMVEtMenRsRUZjcVNhN05jVG9YZ2diMjQwdDRqWGVFVnJDT1VLOFlweWUzYzh3aERSdXJTWjRWWUJNNUxvZUpPVTg1bFhWWTlhOWpVTnlZUjhNYktrYzduakNSdmk0NU5tdWpYTmFEWVZVcTYrKy9EeVhPMEhOKzJHdHU1N09vS2RicjhtMGRKZXNKZGZLL2QxOEhTVWZhNTVzdVByOHM5LzgxWUhWRThXTEpVdXQ1dk5tOFNmTndNUGYvZWp2ZnZpRzQ3cUFxVGxvUzk1SVhoajNWN3ZrNitIZGJRR2lmUDJ6eno3K2xMZnJPb2U0eDM5RkUrdUJtd1BCOTlxb0Y1STZubnhCSVFxRzRGSnpUWW8wZWNCR1oyaXFWVDQ4VVRybFB4aUlzSTA5djEzZzBYNUJ0K1kzZ2tRUDhJYklzTDY1Vys1ODhnaVBjTytCd0xTb2FIZ3lJcnIvaHhRWk5FSG9WSG1NQVdyT2hGRFFDUTFOS2xGand3b2RVellJc0RCRVZiV2U0VzdZc0ZSOVlxY25XeUV2c2dHZXVCVXVOL0RaQW4xaXJ2VUFxSzFzQ1krQTFLZ3VJc2pkNWhPczdpRmNxeE9zVlVRMXBhUUhWVVF0VlV3MVN1VzYxbnk5MXpydmh1ZHA0RExGT2grWnNxa21JdUdEVWh3TWR5cVh4ZWlXVldpMmxOaXBxaTNRYWJDMTdKZHlqS0lVUzRwczJJajdXeldoR2lSRGpKWEo2QXdKNTFwZTJURGtaUGFKUnh4OXhURm5MVlErcTZ0QW05cFFBSVAzMFQxTTFudTNGM2xLVmFKZ0ZrazU1V1B2Z3JNYlFVMGFIVXQrWVJQcjByVEppNmsvZE5TZi85RW4xM0VjbGp6ZXZaNmYxNlpmVTc5QWZnRk4vQk94TGxIbnVUSmk1VWUvL3Z4d3NOLzdsZS9wR3RsdTk1bzZ1YStUaGlFQ3A4bnk5bS8vN1IvODVZZE1WaUlscVlYSmJMTjN4ekRzYnE1U1hlcTZNaHNsTDdkM3o3UFc3TTJ2a1RaRFhKd0ovcjBvd0NhcTd5aWR6c0ZpRUUyVkVEVTB6YUZaU2g2NDdVdWxJSnNiTllSa3RiUzZZNnpRbERUcWdLWTduQU5tN3BWb3ZTUlB1dFlCenVvWklXcE5BTW02VUh3VnJKVlFKWHAwc3lSNktTNG15U1FVb1E1MVg2SWdxMWluN3FrWmxBVlRyUXFSSnVOdkRhZHZwcXQ5Z3FHc25zeEZHNGdwWjVnVVpuZ0tGMVdJMXhLYVVyOVJ5VnljYWhJcmErUzlScWlBdFhpT0txSXByVG1ac0VnZ3drVWJmZlIwV2hFRUNCZTJXSy96cUYyNU5hWDZ0N0hYUmRGdFlEMURvdnVIdTlLTXdXU3NMaHF0TWw2V2NCZFRpb1c3UUZpOWx2Nm9jaGZZcEpaTTNCR1ZGTE5sYlNmSkxIbktDUHBkbXN4cnliVUdWR3IxbWtyWlBiUGlHTFNzQTMwSnhMeUxJeVdOS2xjbzM2U3N4MmYxYSs1U3liZCtYVzlqZXNIQ05YWTNVTHBtbjBjUFVRbTZtSWpXV3BoVHJOalRhNjFBanNNN3pYa2FFL0x1UmN4ekhPY1lkTDFuR21yTm1FVlpSRGluekVLWXJiejViSGw1ZHlQbWI5Y1BybU9SK2ErT3gyTUZhVWdtWmZTRFhlT3dVeWM4OE5obXAyeEQ0dFRzd2x2RmhyUmRLSkNBbHR2SzNadDdtTWxVdnZ4eWVGWk5BdGFTTHR2REN6QkkxUDIwbDBMNElWN2xqNlJHL09idjNyd3V2L2I5eno5QWtjUzZZek5Jc3NsMFF4d216a0crL0l1LytQTy92ditnVGo2SFZCSVc3bTJXWVJGK3RiL1p4WnU3K1daOGZyOGdzUTR2Zi9ZYkxMOVZEa3ZpUWE3UzVvL0VnOHFXZk94WHZaQWFvSWVDTmVPK0NpelpFMTJ3YmZMaEZFZ000U1ZnSisyelNyaUg2UVUvdUN1dUw2cmtmcVcyUmsxNHdFOG1ISTlvSEN1cXV4UDJSRCszMy95TWFBSkwxWTA3U2FuVktTb2FKcW9relpwZHpMdWE2R2lxNFdTSkVJaTNlU2JKTzNkUmcyUm9SR2w4VkNGbHpXYU1aYkZTb24rc0VEcHhqbDJsT01WYTNNdUdYbm9BaWVWRE1NQWxnKzNDQmYxQUV0MjB4MHAxdEJPcUJsdjJpSmZpb1ZLOWVrdnNiSGtmN2tWQmQzU2o0L1lYVEJRV0NtOXRGQXlpVTJFWWt0NjZqa3I2VWMyV3FBNElodEhTYWlhMUxIRVRlVW9XSzVkbEhmS1ZmSVZKaTQ4M2RmRWhZVDUra3RTcXgyWkNPNkdGeEVHM2dMS2xoV21pc0VEdWRkaU5jTzdIVUYzZUxRRng1cHh1dzRtVVRFUVFNTjNkdnZMcmo0Nythbm9XTDErdisvTFI3cHUvZW9kcnJhWDRtalBuNlpQNTdmQkJiUWZna3hQZ0owMUp4TGszQldCNUYyOXpIZ2RiaVB0NWlhdk5yN2JKOXFHUlFPeDJZeGhFUEx4U3NxMXJ5YzkwbnpWQ3lEanNWRVNxRStFdXlDcDcxQmhFL3ZNZi92QW5hMDJOWHRIZW1oQlNxZ0RJUUo1MnVQdnExZUh6cTFBSWVaZkxsMTk5TU9pbndWWDJ0SFNTakY2MnhmdWI3NzEvWUROTUtOckVzNFUxU1hHWXZNK00zWkJXZEFmbzQrS1ZEWHpkK3MvdHdYdFdOZ2VCbm9kOGN0cDBTNEJJRkE4UGI2NVdFUkZXcHdpOW5KbDVlT2pGUFprZ054VDladlp0RC9id0lCUlNEUWF2U0lBQ3FoRU5xMFlkNEpWWUNVWDdlaGxCVm8vbStVbVFDcE1tZVZJMWh6ZEZWZFFTVU0wNW5lSnAxYVRCV1VPb25TSjVKampqUElGOFdDMWZ5Q2t2b2sxUC9TK3diZURZRE9hTTZyVnJQR1pmYTZqcHpJWXFxZ0lZSVI1QjBtUHFqK2p0NzZzUldCV1N4OTF1eU1uZWxyVklHckxXbWllTjlYNmFVQ05sNjdid0lTVmxEVm9lOHFqSDVTYkpzUDlnejd0MTBadVBmVjNEak92S0w2NzNJQ1NmNW9iYUVDSWFFcUtHVml3R0FpYU1hc0s2Ukt6TFFmTXVjYXd6eUZwU052R09sV3JIWWNySHV6Uk54K0hPOFdJdWI1OGZEK3Z6OHRXUHIyMllMS250Ym8vZW5MbEJub0xKMzFNaVBSSEkzcGdpVzdQcW1hbXpyallVNUVpN2FWdFoxajJRMWp0Z0xldXIwVVFpQmh2V040TWZjR0QxSWpMZnVhbldzcTQ4cnVLeGYvNXJvL2tvdHovNmszLy9IOHV6WEErSWlJZEdFNHFsck5kVEhGNysvRjBaeWtqMWtLVGw5Y3ViWit2M01YOWRFNWkyN3FZK25BQzliNW5rQ1J6VWdvNjd5MU44TFNGQmUvVE1PTkVvbzRhQWJqMnB0ME0rdzRQU3VIcmRhU3hRQ2M4bnhPZldwV3BMdkxLUGtVNlN1TllQOWk2NmFKTmY4ajBpZ2FvS1FxM0lLYUtZTGZCYkFkWHUvQlVDWnNrZ0VlSUlVQlcrRmxnbHJMTlIzZDNaVGxTUnd5Q2xsb3grd3V0K25UM1NrRmMwVmI2VG9XWldoYzJwc3QxQTBWb0IxTkRBVTNoWmViU0Z5Y3VwKzBtSHpXaU42QWJpcWFzMGEwZ2pZVWNjdzUwUldIdTN1alhPU1crNlFrU1BVOTIraERrRWxwSXVVQmZOK1M0OFFQRU01bVExZktrUk9ZL2Ewa0Nnc1ZEemZyaFBxQ0h6M0NxT2I1WWNCZE93dktuWFYvYnVMdDE4dlN6VFlCM0FHbHNZb3BMYWVBb3BtbHg3alJaWm13bDZWTCtsVFZQaTRDYXlyaGdTQkJIRk4vZk5lbk4xZUxlT3c3VDQ5WlVlSTFKOTlaKy9rZDNxWVVPS2VMNlhPM2xtaDRFTnovTnRkc0ducithdXZsTzFDbEhFR3RlaCtiaDZwTDVjdWxPa1lkaFY1SGc0K09LaTV1NGlrVDZaN3U3ZkhENjhEWlRaZWJpZm9mQjFyZVd1cHJyZWZOZC83YnNqWC82Yi8rZUx3M0NGNDlHRnpTbTJMVkpqdyt2dTZ0dFhydzY2UHd3UUlXMVFQMzc5MlhQZWZQejI3WkdwcHFjYnpPOTNwWGhxdGtkRW9LTWRxcHZ3eVNIVWlTZmJIRWRSQ1RPbGI0eVZHZ0pJMUUxblo2b3E3VnFsa0MydU41cnYyeUNWNXlzWnA3RFgxZ09QaUFaRnUveXlONHVkOVUwUWJiMmZmajFuMVZOZVh3Q1JMR2NUVjZNTFNGM1hkYTQ1TWVpV0ZDVzhsdXFoUVRFSWZkRHF1Y0sxc1k2REVaSVlTMHFhS0ZLY1JmUFlucllNeGhaVjFFTmpsUG9MQ2RPOFNQQytVRkdlcGg1ZHlDS0tJS0t1NndtOXlLZ3N2clJybGJVMzJlMWtpSGFZNFpUQWNQcCtKWUhsbk9hNkxGWHlzTzlIeFIwMEZvMndWU1FobGtiL1ZYM254VEZkVFFGZktvU296dVZRRjN1K0t6K0pwSE5vV3BqSG0xalRnUEROek5ZNmt2MVJJd3hEaTFodnNBVjZpQ0psemZDb014Z2lOckNzRkRHTllIU0NwY2FRL0w1bUhJZm5WNlhtcXkraUxOLzk3ZTkvRnk5LytxYkdQTC9PejlLYVlPcjBiMnZUZnRzR1B1R1V6RlFhSFJ4N05hZ2hXWi9DUjdBalRGdEJYZGJabDlXanpuTWRMRStmN3ZtVHYzajl3Y3UvS3ZNY1dOZmNZUW80eUJqTDFkM3hYd3o0MGYvN0gxNjZZcjZmMDY3dzdEMFZCbXN6eTl0Nis4MmJHV05hdmJvSTFFTU9QLzlzOVBUc08xOGZna2k0Q0pwOWZBTy9OOXB0a3hKdnlLRzJNYk9aUXUwOXZPbzJEbktDNFlFU1pnamYzbHhvZnQ1elVLc0NLdDVmbWtGMjZtSy95ZEQyWDV3NEZ0VHRJRkI0VFVTaUJoNW10VFRwSTRod2QwYjEyTEkwd2UwOTNPVll6ZFRaVnI5V1N0Q3FyNnVRZEVkUU1ZZlhXcHdhaElGUksxemNTTXRKb3NhY3Nva2ZFSGxzVlUxNEp6VkR4TThLdjBEMEtxYXRSVDJUOEI1bEhQSWlxZk9jeUNBOFJTMndUVTFGeUxwdVVzVDJuK0tCMW1ZOGg4RnNnL05vYlBLenZtSWpISWt3NGlaWnFLVGNBbDg5NXRIY0ZUS0lEWVBPOTd2cU5BaG5oUm1paURVb1J5NUxGUm5Ia0xCaHJTamZ2TDNlRFRoeWR0ZXB4UW94ZWdIVTZnQ2w5dVlkVktiVkFjUTZTcE53SmhOSXJOVXRwMUZDVmxVMWtra1ZoQ3BybGF0UnlvNkZlNnlDOU5FLy9xZS9lY05uYjE0Znk5M0xWMy95a3krbWE1SGR4alQ2bHYzN1ZIdjZoUDlXVmJ2S0tRcnlXSUFjU2FhUTgyQmdlOGVRbEdtd1dzdTY0dDI3ZFRmdHB1bVQrTm03MS9NZHZWUlI1Umdob2xBckVJbjEzZjM4VS8xUGYvbzZDMnRVallOMUhaRklLMCtMRFphVHlwdTd1NktJT2NVYXFzQXFRN3orNXVNc3UrKzhxN2VoQ1h5Y0pMRGR3SThtRzEya2pQQmFFeERjd2dRTTlJUW5idXh0ZzhHZENGR3BOZXVXV21IdXBiaWxzNTZJRUlxMVZkYWxUZ3hHTUVSQmR3K1gySW9oc3ZWZHo1VTZBdklvbGUzQ0h5a1JUZFcva2V0YUNLeEtzOE9xdWJMQ1lBenhrQWhLQk1IaUlaQVFIaG5oM3VGc0xaallWVXFWNU5sSWVrTUdTMklOaVBaRUZ5OXRCaEtoTURNSVhXeDdZNTJld050ci9VSFcrZ09pemlrVDYrUkh4d2tBSElRdzBQekFMZWFSTmRwUzZGeFZVb1FlenE0NTJlUXlGekFrTjRDTU1OYnE5R3FkOURDTktKYU1oQm5DYTEyTGkzaU1TRGxueFN5bVU1SjQ0OVdwUTM1MmUzajJZcjFiMGxyWHhMcXVkMlVwVjFjVEwzcFlqQWhSTlhOM1ZrYUlLb3NqU2ZVY3BETnFoVUkwd1IwcHVXdHFFRFdCV3N0dW9Gc3lwdjNibC9Pbkg4Ynl2ZC80bmU5cDVJa2ZmaWZKOHMzYjMvdmpQM3JwbmhMOTZUSG41Z1RodDkzQS9RMTh4SmpVZHRkTEdNc3FOblZaaXJsdStsaUhVcWJCeEd1dE9oK3JKWW5iNytxeUlONmFpRWJBVnBJd3BVdXRhdXZiNmYvL3k2bGlrRFhDSnM3enZsbUdWZHpkblF6QVRLcmNWeHVxdThRS1M1U3FWZVgyMWJJVHUvazhmbjViMHdsOS9jZ0w4ekNaOWhMbXgzREtsbUpuRVl4YWV4c2FmTWhzaXRaaG9SUFNYc05wRzMzbXdyS0twYzNSMU5WdTF0cGI1eklnT3JzcGFuaGpIWGQ0VFhNYlNnTzdtNUFtY29rZmJPd3hhSU9pTkJmZGxnQWdZRFgzSUdGZGhnMUdTSkswbWdlRHZCTlIxUnFFR3NQcjNJZjhLMm1PWU92ZzFKWEp3eEoxVVBlQXBneFd3bXlFTWlCMEZkQ3JxNG1JQ1JyYkNGMUsrVUJPaitaSFBRUFJ2NDNQZlVvVTZIWjlRS1QxNVVKU1FFaFRaNFNJb1haSGhYdDRDREI0VU9nOW1QajhPZ3hOSnJBMFJtMTBXWlZrWTdMSWtUQ3BGNUNyWWFvdVprWW00VHhyU3JFT2FZajVmdFVFbHFpMzZ6Uzl2ZmRKcHF6bE9PeHpydXU3TldCbk1aWUlHYXFhckZTc0xZWlVTNjJtQmwwSVdCWXU0WlVpbHF1SGdoeWtTaldnUndnU21ybXVlVHBTM2tqNjdObHZUZnMxc2R6bENBL1lpK2UvL1QvKy9yLys2dHBPYkFpKzczUG5BKyt5bkdKMlR5NDBBSFg2OUVYZVBYdkdlVDI4L0dJZW00dWx4YkJ0SVAwSWJ2R2xrbGlkTEh4OUs2L3ZrUmRxaHF5ZUhBS3BnRW90T3VyeG1MMGkzMVFYUHlBTnViUkRKc0FvN3BSa3lSQ2xpZzFlbUhXRnBTUkw1QWlaWDkxZForYm45L2R6VGFVenlQejBmb2NDakxRWm9ydW5nNkx3UnExV0F5VXhHTzQxM1gzOWtURkdPTldMNW1XMG1HL2ZITlphcWxNMUNUU3E3TDd4d25IUVNNMCs2WlZwbEZwdU9kU2tQaXpqc3BvWjUxRUVZcUlCUkNuT1pTZ0pSMk5pSFVDcWR3T2lXS0lMcEpyV2d0RWlTZFdHTzFFVkVXL3pHNGFCVVYxV0FTeDc4ZDVlbDNBTUl3c0diU3RFUXNXR3lVdW8xRktPS1FuZG1TVGFuZER6N05mKzhBbUl4VUpUU0FsWFBEdldQUHA2VktFQ3JBS0ZOczlVVTRoR0ZSSGxvQ2J1b3FQMFhEdWNHc3FYQVJlblVVYklLZmUrcjdUbVdhMU4yazBWbzFmc2pyWFdvTWpxSGtJUEFheXhzQ0xDZ3hYdCs3SjJWbWVjaDJvUUVabWdFSloxbGdBVnVoS2hGTm1uRkY2cUNFMFFYRU9nbHBLRkYycWVCaFdSSlpnSmhNT1NKTDAxVGE1eVBPSXFPOGM5NXpsUFY2d0NhOUk2aWc1MXN0QnJ2ZDh2MXI3YTdCQklFYk00bU5rQ3BQQWFWL044SElkVTVqYXVsVlE1cU5za3hkWENodlg2dXpmVDFZZWZkRnFHT3AxQ2o3c1hQL2hmZnVjdi8rUGZmLzdtZmwwbDZZeUgwUVd1Nm94a3JzbkNZU1ZDa3RabDZOTjNWWUh0OXRuVDUvL3kxejYrOXVGd2lKLzgvYy8remJEbXVLZXVQYUZkR1VIa3JMTkdIT29IcHZYcTVuYjk2UDV3bkg4eVh1Zlp3MFdTbHhxRXBXYnFpQVVRTDBOaUtXdDFVL1hROW1Ka3JRRmZiSCtOSkFRME5FMnlycDVpcmhuSjlVYlMvczFmZjZScTR3ZUh3ekU5YlVSUVBKWFhjRkl4ZDdpYmlNanR5NTg4dzNQbGdXcXN5RmJYOVhCM04zdlRNNGE0eXpESThvakJDS0Y3S1VraldMT3JpMjU1WEQxTGpOdDZqaDVVMFg5dWRFanhpR0IwTDNCN2R1bzJ6dUlKVitFaTRoRk13dVNxVms5WlIycG1yaW5VZ3lJUll0TW9jNHVBWGxZeW9HVE1uWDZydlZRSG1uMVBLU0dDSG9JWGNseGNTRW1yQ0ZTVEJvZ1FpcEdJWUNEZ2dLajNKQlZlU0duNWhGMW1zMUYzbjlSRjJtR3ZvZG01amYzK1NGR2FZcndsdC9lSUdKN20xeWRnZExkVDJDVjlyM1hUQWlKSUlRMmcxcVNqaUhDNlUyb2J4eE5RTXpNVmtXeDV6SzA1UnBxcGVBQVdYaXNVWnU1U1RIZDVKRy92bTFnSkRhTWUwa2dHMER5VUdraGtDQkpDWU01V2UrU0dwZ3duSkdxRXRYRnUrNlJnZG9CcHlHR1owckMvdXI3ZUN5TnE5NmtSd3F1N2RmZ1h2L1BwSC96OTFhOE1YOTJYbWg2MVdrMjhDWHZwSVNMTVhsc0cyNW0rcjJESUo3LzdyLzdaaXhFMTdYMzQ5QWQvKytwdklYcHlkN1BwS2czQXVxNkJOSXdHQ3NUcm9WYU93NEI3YVRrTTBjbkNMVUZFUUxRVWNyV045TlNXVnltdWtvY2hzYTA1OUxGZG0yWEFEZ21wcnErLytyZ2ttVjY4dlV2ZkpwWjhFckdKYzZoUloweFI3My8rUFBra0dtMER1OFpoUHM2SDFwb2dKUnc1eS9xZVp6amNhNUVCMndLR3NsR1QybHV3a2NvWnJmN2VvcGpQS2E4aDRkRkdPdWRmYWxFcmNVR3lPVzJISG45NW9VRTNWYVhsVUszaEZDTHZSczRxUWwrWGVRZ2dHRndhUzl6VFprMFh1a1EwamZNcE4wdkVxNGlMRFRNRkthbHNPWFVEQXV4cFVxMjZiWExLRTBDUWVMckgwbDJGeHRONEVJOVNraHEzdUVkQkpPOVdrT2daRXQwSVNaaGFMQUFBSUFCSlJFRlU1QTFjdEhYQm9XaEV4WFoxNEJRbjRoM2RIWDJrYUFJd1FtcWNlRWhDVXBKcVNnWTRrcWFrL2VNS29TVjRxWkhwTmRTYUE5ZXIyZTRaRWtwZExZdHFTeVBzMlRNaWxzY3FZdTA1UWdZbGE4K3A2Mkd5Y0VrQ3d1Z0IxUWJiVkZWSnlkekd1am9zajFNU1lmaTVVZ200Vis1ZS9QUHYvcDlmdjh0WHQvSGk5cEZtR0pKSFM4a0NJTDMyNElWRzUyc0tCNWdCOXVLZi9QZmZhVHZQWlArRC9LTWZsL1lFOTY2OE5FWUxRQysxaXFZRXJ6UVRYNnVrYVZBOW9JbDllL0JGSjhjS1hEU3lBVU5wanBuR1RRbnhHanJtUEF5MVZGby9JREtqOWpnakFTQis5OVhIRUIzMlUwcnlWT2pmazFqWmk2a0g0b1Q5dGZWcmZYdHRBbmN3aHVuNWdGTEY2NG41MWljSDc0ZllCeU1rbTVvYVZWZVJxS0Z0VldMTEc2SXpQQURwd3FIK0FaNFMxTEZoTWdJTUlxSVp5UzdTcmxWVkxBU0ZwSHV0RCtCdzBnZkw3cUdhc3BKMGlTaExiVEZkRElhMHFNalNJVGZlaExrdHd3dUVkOEZLb2hJYzg5SnVtT1NpVzFBTk9xaTQzOWZuNEpvdG9lSGJ1cVJkbTlMckVqeHFialhtUjFEazRnbldyUW9hcFNWZ3lqYnZsVk1NZDV1YnQveDBVK3RkMVViMUFRcGdwdFlVNVJKUzBGNkZ1ZnNqVFpPQ0VWVk42TjRlOU1JT0FpbGVHVlJWYlZ1VU10dTR1N0haelN5MWU2UmpTalFvZ08yNEpxR1VkaVdhTlM4U3RDSEtXallnQUpTUUxZOVVWV041WnJIWW9DWDJ1NXdVa1pvYVdEZHV6bUhjSDM0KzdIN2pmLzNSSC96NU84cmRRd01KSWJ0bnovY0pZc21rM0wrNXZZOVdIZlZsVGhWTEptbjQrTmMrbE5rZ29UT1E5M3ZUbmttdzlTOTZDMmt3b2FNV0hJOHg1YVQ3UmZaanJEWGNXM2hCanpib2dBZUdCSm1TV2hzVmlEUnRVVGpTZUQwYVRzcEJBVFJGYkdvZnpaTE1qNi9tZlFhR1p4K25weHB3VDByTU52MWZ2K3UyVUxtRi92WnZvTmd0UlRBOHUvbmVmbEpvQzJSb0l6T05XakU4NW5ZMGc3ZU5XeGZheVZvY1RZelFEUE1CMWhvTVYyWG5RQWVqMVZIZC9ZUStUUW93bE5UdXRXOWVlZkFjbEhEcTJsNG1RSGpBdEo4eFNOa3FUVmVwcGJybXRsK2I4RjQ4b3ZJVTI2aU5RbnVLZ1d6S0RhcEZ1RlFSY2E4VVVCdWh2QjI2amhhN2xQcHJON1pMbEpETFFHOWNnQVJCU01nV2dpZVhEb2VUWDNOejBGUVBhWnBlVlFYRmhTRmRRTmI3elFxRldGT2NOY3U5SlZNeW9nbE8yN1dqWmlrcFNvK2hyMUExMnpLY0tFbTF4eFcwZGxMTDVvT29sNGdJcnREVW83VkYzUFYybVcrdUpsdE9DT3YrRnJOZU1rMitORzJicEcwK3p2UG4yOHRaTlZSdDViZVltcUdXdlNEYm1BVFQxWkNuL2FBZ1hVNW5Qek5sdCtmeDhLdWZmYmUrVVhuYngyOG43clk5Ky9YdlA5ZlZmYi9UOHZZblg5eFdta1NFZGtZTFFzenllUFdEWDdVMmJKVng5V0gzWEtWRG16cTd3L3UwNUdxeThKaVBjbGdpNVdHVWlDSE5oK1hlYTNUZ3VObER0cnkzM0xUY21vK3RWK0dSaC8wK3M1UUliZllmV0VpT0hONk1kaUZGeXYxWFAvdmtRM2o2ZUhwcUEvTXBnOUxwYURyeit3Z1JNZlhidGNJK25GZU1OOGhIVllNMUt3Z3AyaHZLbThiNS9QU0xpRnBEYTIwbmxMY3U4ZlpEbXorOXNXRjZFRis3WnFVQi9yajVmbm5hd1NMQnJUdkxUV0FjMHVTREttWVdsc3FGVERxWVZFT29KcUhKNEdTdTRhWFNobnFDaXJnejRreWVQMXVCVHpFcEtzS1ZhRlEyQUFpbndJd3RORXZhWGRidTRXNG9QSGw4Q1g3THMrVk01b0RxMlRQRGphMjFQY3FqU3p3RkdoTGFESThuWTNYL09BRVZnNG1haW9vS3dxaVN6THI5U3hJYTFFME5CaFZrQnFsUWlxZ1pOaFpQQzRBTE11RWk1aFdVV3F1TGlxaWFJcHFCQUNEZzk4NGJTM05JYSs5dGNhYTlRa0Vhdkt6dUVERTJtQmxKbHoxSmFJaDRsWVNBYUlvUVU2cUtnT1hWY0hXbHppRWxCTE9sb0RmVFIzK1RwVktSQmVuSEgvMnVqYi8vK3ZueG9lVmFwbysrLyt0WGRTbkg2LzNBbS9DZjE2cXFkWXNXaFVDUTB1NzVpeXVKUVYyWFVjY3FrckU1NlhzTzg2YXR6MG5vckVVV2gwTHpJbkF1OTNlM3BDb290UmxiMkpVTUxYdFVWTElpdklZNEl4Z2hrcWNSVVpZQ1VhRzdRZ1F3YURReG5jRkIxT05YejhoRjBuWDZGdVlHdmszOVRaNW9xZWlLSm1TSXZKbUxyYnFmcm9UT0x2Um8rZ0ZIemxMZXcyYXhsdVdRMW1ZUVVoVnRiMkF5MmxBM0d2RTVXbHJqdG9HNWxkQU5ETk1mdm93VDVlUGNiN3RJT052Zy9DY25uMGd6Qjl2UVhBNWlBSm5FUzJrRVlIWVNQSzJKdUU2ZERldENNTzNiYU5PR1dFc3FqZ1JURlhjaVhEY0RQN1FST2FoU0JZS2V3VWx1L21nK3RYMmxOejFPV1loOElMQnM1NXBGSy9TRG9vSFdVQSt2ZnFMdU1RQVZoY0pnMEFRcWxVaWJHZ1pVc1lCMXVtVldVY0xaTnJDb0JUVlpaNUdvd3BwRnJmbWIxVFQxV3FEV1NvWFF0dHppNGlyUVlUSXU3MlNIMUsrVDgzV2dSa1V3N2UwWUJTTFVYTDEySTV4WVEyTElNSHVieWF0Nm9lWkFoQXhtTlFiMSs5U0ZGYXlJeHE2bWRrV0tSTDNIN29QRHV4Zi90SHp6dzl2MFNLVHcvUG56c1I1bmlzOWx5TmZQWHRUVlUrdFB0UnZZVlRWUE43c2tOY2t5U0VRU1dmMWtzdG1hV0Qxa3RCWlcwWlNxS2xqV2lCUWw1c09iQXJOa0VpSnFTUmx0KzdmdmhJZkVDR1V0WkJFS1lhSlhPNDBvQmMyQXNtR2RvR0lVTVZxaUdNRFhkODRDV2RPMzVyTDlnaVpXcjUwSUlZczNRV05kaXJwbWZCaVZISENTLzRxN0RZTXNUMlN5MUhVZUZpalVZS2x0cnJPUXUydU52SjBEWGZjckoveGJKMkp0L3VFK1VnZDd4T0NHWFc1RWl2WkVPLy8rYlFNTFVsNmFTMThzUWhMTERJVXFPL2FJbEJTK3hadzFva1RUUVlUMXY3ZjJaTWlzR0JDMEh1eEFSNHVJblU1Z1NRWTArcmJlMG16ZUN5bDg3OERVaTNpSEJ5S3RVMWRjS08wUUJCaXVGSWJYZW9xcTd2SmpoY0pVWWIzeGJFU1E0b0JKNnBHaklOa3l6clVuVUNpRzFqeWl0cURjMXB5Q29qYmZzK1ZtUkk0RVJWSUpiNTFxT0VNRWxLcXlMaEhEZm1zSW5GWVpWQXhSVXNycXBjV2Vta2RTbFdnVEw1SWlWMXhGTllLR0lFVXBYaFVwNXpWcVBWNVBNVTRwcFlaTEl6UUZWRVhJRWpyc2ZMMnY5dlBwbi8wMy85Zi8vdlVqM3ZuVkxpM0x1Nks3VW53eXNadDNpSXNEcGovUTh1N0ZsUUJpWnVJQ1FXNytyUXZKYm05c3JDc3BhUmpETEZpTGE2NXpLZXNod2ZKb2pXU2ZFQ2lkZ3BIWXVpeW1ERFBuMnBzVHUvM29sWlFjN2ZzY1BLWDVRRlNrTXFLQy92SzdkNk9hMU9SbmlUeTJSSHNoUTRVWE5yY21vUFN1akdoS3FRWk9TNFZKUytGdFFCYS9HU0trSjd5M0RhZFo2dUdnejc2RVZCY3dCcXNoREtEVVFkZDRnVFUwYW5XbS9UNHhST0hRS0VtMHpNZWE3bDJ5bEhFM0xPdXVqcnFpTjVRNXV4RTZzM0JNSURRSUtWVjAxYXdrQ0NDcHdsclQzMjB0eUlUUm13OWlrYktHeXF3TVVSV0dKWjNkaGQ3cS9kWUMwa2J1YVcvdFZscXhKU1hYdG1HNmhWZWdwaXBLd2wxelNrMlpyS1pWVk1GYTJ3Rk1xWWxqQXF1YmFRalVzWkh3MFIvWW05QlNUdm0vclhuZEt6ZjNWalozSVZGdFRrdmVIRXN0TWpSQmxydW5yUmdNVllvZ0E5YWdkcTB4NEdoUHNyUmhDVnVuR21wbXpZK1IybDJVbWszV1ZTRlJRbnZPeGhDYXg4RzRRbGlyS0V3WlR0U1dXOFdVQnpLTjRCcFZsckxyaHo0Mm1tWnl3bDBzYkxuM3ZSL1ZVSmNpdWIyRG9CR0JKTlZ2aDJlM1JWVVphYks1U0VKS2NsUTl1QzdEaTF6OGFuODE2VnBhOVM1VkxBcE5xZ2hYa21xN0tMZlgvK3JULysycjEvbzg1aUZ4MVdIaEI3c1J5OXUzVlpmOXBBdjUvUGsza01RYUd1b2ltbnphalVsbG5RUXVzUTZ5ZWc1THQ3WTdGZ3R2WjUyRW15WVZEeGx5ekRHT3NydERySHRCcGdCMVhldUlZYkIxVlFvRHBMRVQxVU9haUdnYzVucW9BWUVsU3pwaDlkVkZmZU9nSXBxQ3pVU0FDTGpDazYzMWkyZmZuNm9QNlNrUlBVK0JFY0RqdUZHZTJVR3RkQXFGVndmRXBYbVFBN2dnV3JtSGU3aUxZRk1UaW9qSVhRbm5kSFY5cVAzb2hLOGxrbTRxdHMwS29lR1NMWTZWQU9OaE5DUjVpYkpvVjVrSDNiVk5SSUt0K2FNbkRoNTdoSmJDVEUrUGtSYnBHWEl1bFlFbStHaWt4QTR4TzFXdndEblJDUmUwS3ZUWGZqaTBONTlFZVRMUnRSRU5vNktIaG9zOGRJSjBGTVJESHNtajl2TlRiRzRoZVZ4cVFJQ0lhQ2ZIbHNiY1hxSklhS1dlOUp6RkMxMkRBb0xONkpHNlM2c0hYS0QySlBMVW90QWJreE1HVTAycGFWaEVyY0dCKzVYZUpCZFFRY3BwSFlmbHNNeTN2OUVwRVZ2MzNUdWh4RlBvU2htY2plZmM1a3pDUWxHQk1oWW5WeFdTU2JSYnJRUTJoNjZXZHRjbFNjNWcydFM3MWFXS1NXMlBjOHA0S1BrWSsvLzJmL3EvWDF0WkczODZhT1BOWGtOTU1TUkUwR01hdEFtcWVvbXRVSVZDM2g0bkZUV1JJY1NrTnJqaXRnbEVwQTN5QUdzdWYyZlFja294ZWhIZFBXY2Q5Mk9DNXJtdHNNRGxhMVFsM2hHK3JvSFU1dXM5NFlzbjVoWUUxRFlRa1EweXp0Q1lZbDV5aWZUMEJqNGxYMGtQQkhuL04wanJDYk8wckpKa2pNcjU4TzdqZHZHR241SUUyc0x6MklTTzdRQmExYXJuYWJ3dmFBWVhxV3NKMFhNb1NuUHNJOXhnbkN1QnFMcU5YYlkyTER6VWZlUERrUXlIQjRtaHN5eHFlMnRKOXpGS2p6VlQweE5TcmoycEpVS0NEOTFYRWF4OVVCSW4wdWIyRnZTTlN2VXdMc21VSGt3QmJFTGt4aW5yTTJoRUlWTnE1THdteG5wUHUvbytKUlI4dkg4M0VPNFdZVjBLVmRGS3JJYi82ak5hYmZ4cWExMW9QRlJYdDhScDlOaTIxaVJwZk5EWWVNSFltazRoQXJNVVFWZ3lRRTJqVnJRVFFMdVBBdEdtUHVKUTFXU0s2VHJlSFpXcnBvNmQ3QWQ3enlTeEZFbGNVblVLTFBxd2wrRlFoUUJSWEZBMG8xYXFVWkEwVnBvOUw2aExUY2Q5bmQwZzR1MHpDdFdJYWxGcmQ3dGUzOGxOZWYzaWUvL3pmL2l4MFpOVUF5aHAyaytENmZOa2thMjZyM2svcFRYaWZLNlpxWnBCNWlJYW1qczE2emk3bnlMMXRnK2lLZXBOTmVnK3o4VXNHVUdQTk8xZUhNY2R5cUtEZDZlSlFpNEoxSGdWWGc0TGMxSk50aVZab2VPU1JFVDcyS2szNWx1SUdVUGs5dXZuMmZtdEcxZ281MHpOUjg4MGJoam1mcWlrdEVQNm5HVXUrY045VGlZUjJwT2JJV29NVmRXVnJPNEJhMEFnRG5vVVI1U0NiSzJSMS9wVUczeTB0WTY4T3FUMzhTQVJRTC9uQkNUZEtSN3FsZG9BNTF1N2VyTTdVZEF5SDJTVHdtOGJKdnEvQW14VzdPNUs3ZUZpd05ZcmJxR09KMGJ1T1o0YjNiMm41MGpsdHRaaEhnR04zakNMQ1BSeFV2dUhlMFF2MHFXUGh4KzBuZCs3Z00vOTZFZGIrRFN2Yi85cTJOWjNZNXU0TkdWYnEyLzBOQU4rbkxqVTVrdnRLUTJvUktOaXEvZVAzM2dLRmtmcUtZNHcwd3FJUjRoaTA3SzNMZG1KSSszN1FRK1JQRjRWNkd5Ukc0aStmZEhSTVRaSnhBWXBGTG9vdmVhdEQ5SVVidFJna3NMRTZ0N0V2VmtRbHEvWGdsSWc0MkhaWFNjUEZWRUdrTUtYSWw1cTc4UWZ5MVI0NU81WC8rWGYvVFR0YXcyRFVHekl3elRvYnRBbGE2M2xlTmlQSm5IaDRER0ZtaUxLVEs2RHV0aGlLVzd2VHBWdFQ2WHZtSDJEQm9Pczk0ZGxwSVFmeStManRaWmwydm5ydXFiY043NTJTMzAvQlhEZ01lNnFJV21iazdNUitiY2hqd1NDMGQzZnJidldtaDd6Y2ZqT0RWVFRQeHl5eUVjN3VKZTJtektuT25jcDUzK2VzQzdZalRJbEx4Y2tpVlBROTBiSTJUWXdWRnorQzJOdnR5dFprbVRuMlRKejN6c2l6c21UV1Q5ZFBkT2NHYzV3Umh5UVE0SWlSUXE2RndUb1RoZDZGcjJBSGtWWGVnTkJkNElFOEU2QVFGNUlISkxvK2UzcDdxcXN6RHcvRWJHM3U5blNoZm1PaUpOVjNXUUNWZWhHVldYazJiSGQzZHhzclcrMXMxaFJFUWtQMGFKczh4WTBtTGIzM3VkaXNNTWJVMkZrNitoaUo0d2NmVjREWURlUEhDN0tyYXUzd1Vyb21JM0hkZjBpa2RLUng1Z0lmT2hkdHZaMUdXT1JHQlJCSGZxdzRMQTJYUldKdUhBc0daNSt5UFNOcW9JNVR4MTlJalZOZ1FodWJaZ2NmN3NOQ0I4bE5ENjNmTW9XWm55WnU5SEFDSmUwWm9nUFlhb0dDVlhsYlVUTXpRSzJWSzFLR1o3T0JzbWpaeXZCZVZOZ1FNRHhVNHlqb3Rod252VE5JVHZLTGpDbzZHSXZlcisvRXo2Sld0ekVjbG9heWFTMkZYdGJmT3JZS01SRDhXVVNFWndLaXpxcWVBaEZkTlZpSlNBVUUyalI1YmcrdDRuTnRuUS9qWE1QWHlQTldhSVRIbFhYdi8zWmYvUC8vdFg1elZJdUxOUTZWUzN3cVdycHVzcE5uczFXbVFpRThlRzduMVlDVGF4TWZQbTc3NlpZelRsTUFiYytINGFMV2JUdUlVSmZleE1VMDNwLzcvN2NSRWZzNUZBWmJRY05lSHhKNGZWNE03T3VKTGQ1U2Q5c290dXhsS2NPdFoyT3kwNmkvS2hKY3BNOThHcGl1NDBhM1VaZ1E0aEhtZDQrdkwzYjBXRjZudUlVMXhCYit2aFZ3a3hORGFOemluVmg2VDNVRU1sdUV6Vzduc0FiRTdwUGlucjM4T1ZzNHJnRTQzSzcwNHFsY01odVBWWFlnbDlFSW51U0E4MUJVV1BpRkhTcjUzS25qMkZNVExmTEpuWlZvVzRZa1hHbTVBWThsR2dYZDdKa0pFTGFnRGwwUklseUNkbldQQUZrNnpjWVRrSVFldTFmalJ5Vi84UUpqTS9HZmJHVjBrakhKRFEzakV5ZFN2Z0ZWQkdmaGFkdHY4cFl3QnVjektDcXVNWkY2b2lVcUJtU0U2SjVzZ1lrQ0RONGFxWUdFVi9McUZRc1hBd2lzeis3eitKRjlXWTRKdEFOM3RRYnJaUXllWGZ2V2phRlhjM3pHNWdJN2tTMWhJalk1TDZhZ081V0lXcmU2dVRubmJDUDJjTzVjRzIrbmg4alVVTHpETzYrakdmK3diLzQxOTgxVTVWQVJiVG5oUkRTbTJ1d3Q5NTZ2TGIza3lTOWZmeWIzLzJwaWRRdWhmSFhmL0Y4aHg0U2ZyV2RaTWZBdmJlR3FZNDZUN3k3dzExNmtUSWZkajQxN1F5SkxUOVdOdHE4dFZYcVZMU2srQ1d5eVNXWGpUYUd4SEtMSFJoYktxcko4M09wNjI5YXdCY0x6SFgwZnV2MEhaR1FBQnFNUzkxOTdaZ1ZCZkZHbXZjK29tRnhoWmxocXhxM3QvQjBsTko2U0hpdmlyZzBYYTZTelNHbzYyWDN4ZHQzdXhJQkhUT3NjUXFQY05ETjZiQTFsa2pKV0drSXczVFVJQmRHTlFBbGE2bEZrV2Q1WkRhMk1MWW9GYzJ0TW9uRUYwczk5REpYenRKN096U1RWeWNxUXZaUUJhZ1NFakNNTG5KbTgxMEN3b1BkTWxGelc3L2J1djNQYldKdE5WaGtWM1BMRlpWc05rc1VVYzExbVF1cnk0V0VjTHVHcWFQNEJ5L1NVNE1JYjY2ckZ6a0p3d2xoejdyY3pHV0Rwbk9MWTgxRE8xSlBSUU1MMlk2dXVNL0FrM0UxUWQ1dkV0c2Y5SExmMVJyRkVqT0VNWXNUTlMreXNpQlVqVVRkbDk3ZGlvcVVTWVhlNDkyZFBkZUpQanJwWFhnK241NlBqNUc1bkEvcWNvZUQ0T2tmLzNmLys4dk9WUWlnbngvUFMzaXJyV2tFZUZyT3E4dHRFSGhHbTN2LzlCL3VUN3Y1VUZmOUdOLyszMzk5cUd4T0NRU3BJUkdqcnliZTFtNjc2bGtIUmV1OWFWRE5sRnBLblhhZDZDTWJhQ09xa0NKcU95bFRNUnZ5M29GVkdkckpmRHMwTGlrWE9UR0VDR1Y5ZjlqWEh5QjFobWpuK3RZTWZ5U3VXRFZzUm1ZSVJQcFUvRnowN3QyN0I5T3F2c3JSWk1OTWhGQkZWYzBTekI2UmR5MFJhdSthVXNuZUthQkJmRE16WFBQUmhlYmg4NXY3WFRVNnNhM0xhM0M5dS9TZTg4MjhsSWRlZWsxSVg5V280VWYyaU9ZQk9aZDhVVVhqSnVBejU3c1gxU1VVZmJ6dUhKNmRNYjdaOU1SRGw1M2Q1RHhEWFdFUklCTklqNHdpMVl4NTJBUXdLYThZeTNaVFkrRUhOdXdmRDdWOTVRa1JDcFZpNGlvMHlVNXRTT1loRzNXRXNPbnJWdHZXamI2eGdBVTNrQnM0U0IvWFpBZzJOVTFoMmFBTGE0RjY5djRBb1BpbC9TRFFRQTVqZ0tiR3JyT3BrQ0ZYU1ZuV3QwQ0lSSGM3ZkJoajZIeks0N0loYWt1VmlJcW1VQWJxZkRpK2RHaVJzOHhWeFh2Y3Z6c2U3Y0VvVEhWZjlPZFBUOTgvN1NPY1VQV0ZFNCtZMTEvOXlYLzdiLy9kOUduTzhXaUxhS2VUYVovWjNHdzluMXZjSGxiZ1NOOTYvcmw4M0wzNTNTKzEvK3JUWC80YitlcmNxcFhBa01OSERDMDR3NXVqbGhCMmExMTZiOTFvdFpaUmN4NFdXZURoL2NaNlQxSlFUVVZMSFVjc0tKRUhBYSt6M2RIMENodGdZUkhCV1ZlLy8rWk9pdDZtZjRpd0ZVaW4yV2JrajgzZUlBcElLQU83Q1dHclNyUTFNTVd4eXZkLy9jMFg2OHZoSWM2MXl1N2VWKytlYzFKMnI3SEt6dXF6MVIyYjBlQk9sT04wZUZxNittNFJpaTMxV2NQbmFhMzBNRFlxb2VpTnVvYjZweSsrbW1jVlF4ZE1seXRuNDJ6cmtPU3BldVlaMEdFU0pWZTVCekVpRVJYZU9nQlBhUHhVMyszZ2xocis4TzZTVWs0VXpYSld6THRBeVRwRVh3TWpsUWM0aERwcTQyVmtaRzlMbm9FR0ZUaFFzNFF0S3Q2alpHOUhtcGx5RGR5SmlMSjNOVXZwa0d3dDMwcysrWVVvL1dvcEswTWkzTVI5TTdTQktoSDBUaW1SNGlCY2IzVFlydmNDRmZFaE5nMWUrVzNabDhndHNFaUVRQzB5bHQwdmlUZWVxVUdsOTRBWmR1emN1RnFFV1ZCMEE0WXpuS1VXZ2hBdkU1dmIvSXl5M3hWdk9RSUFZTWFJaUozRXFVV3BYejhkTzBNc3VtaUVWRENvd3FhbjBCbXVoNk5ZZStsdTliNEh6SWl1VXozVVkvZjloTFdTb3VKTDYxdy9mdi94M0FzRnBrVjdBLzJNNkcvLy9FLy9oLy8xTDJaQjlhVk02K2tYNVcwODJlRmppY1dONjZkams1SzdzcG9LdmNsY3JEL3o0ZGZMSC8zZU40ZXUzM3o2TUltOE9YZFJlTXVtb1JvOERBdzl6UE8zUzV6dDhkdjV6dW9aQkZ0ajRhY0hiMmRVdlgvVXc5TjdQandKeEYxTDZ5NXFwYTRTb3BCdXF0NmFwRUlPS09rRER3RkNRNFZyR2loMFV3alk1TXZUSWo5b1l1R1N4dldqLzJETHc5TjhqVEpGR3RGZVBuNTlMNzJaS1V6bW5hd1hpQmtrbURQWmpVWXo3bDZON2lIUVVvdW05MEFaOG9NQmlzckl4dndNUVRabU9PUGZEK29neXdjU3VtZkRNZHNoNmo0VVdBQ3c3TjdXT0x6N1EydFB4NEZaUzYzR1NDYk9MTXhMQm5Sa2h5MDI5dEhGakFpS0NpK0luOEdLamJMNUprWU1sT2s0d2piN1IyNm02WHhSRVVibTNtNWNqdCtXbExHTmpFWURUbk11Uzk1UXRGTUlndUhiRWVRVjRLYXF3T2pFYjFWMEd3MFAxVXdreVE2Z3R5SVM5RTNwUm1wNEFLb3JVUUJ5dWZWVkpGR0ZGRW9YUmVveWMyMTdWNUI5MlVWYm52YUgvWm9QaDhPdUZJRWFhSFRYcVdCZGV6V29Dd2J0RTZBeUdnVG5xWnpPTmxFZG1uRDE2SUlpRXhjejZWMkU2OEo1K3Y3NDZmSFVxWnVvZG5Hb0JHWDM2V3Y5UnovN1ZWR2hpa0tQSC9mVWNHRjRCNDlQbjA0MERhWlRtU0pXYTd6RS9idmpwNi8rK1gvNWhacmk3UmRmZk9vN3YzU3RWRzR1bHpwWkFPSGVYTlJNUWU5Y3psWFpXOVN2OS9mTlBxcjY4N21wMm1RTW1rTWhiaUtxeFZKdGVJdlB2TFpYYnJxeFk4TVVFWGFpUFgxNTkyTjJRc0dQcGhWdUNzZHg4NlFFbWZXVHRFOS85NU12dVM2SGlxcTZOdnExRXFZSGxOMEhOWWRiVGczRFhjcmtZb2IwdzRDZStqNjVjZHlBVVBIV1BSSmZ4UjlnTDdjYzB6RUJrL1JPYjNleVd4SWxJTkRlNTMwN2ZQbTF0aUtMRDdwV0Rwc3dGSVc1OERVZ3BLZHM4eUpEcnFsS2hDbEYwK3RKeWxiN1gzSjdhV2xydytqS2FBekF1MnA2OUx0U1JqZzFMdUcvV2RkU2ZsUmZtUnRDWEg1ZUZhRmZaSllSdzBkOVhadFgrOVdOZE9NeTdib2xmVzg3Q1lCR3lRVXgyc0ZsMHdORmQxclJnQ25jWS93bThQRjV2TkdMNTU5Vmg5WlVWTkVpNkEyOTdFWlF1bWltVkdtblZaSFdkYW95MFZkTGcxanFYeGxTVk54RnRkM3BxVmZ0dXhVNzY2RXFkQ2tSbFl2TjVxMUdXMXMwL2R2blQwdldVVmxaTkZvc1RqMTlXKzJyYnl5bll3cDU3dkNIWWxMYUV1anYzMysvd0FiN0hoVENPNmZKanZMTkgveXJmL1VWSFJUYkhmYm4xOWlzeEUySVFNM1luTEd5Qjh6U2dlL3JhWnBVT3FlN24zNzUvZWtaOTM1KzZuT2QzK3lYeDc0ekJkY0dYRzc4VGhYTGIrcGluTnJnemRlYzJjM1YwcUhyaDYvZi9hZ2ZXSDVEM0NodlZCNGIvUzVBRVgvNjlWT2pyM3NUR0haclEraFloR0NFQ0YxVW93ZTliTHdNNzkybFRHc0xibm5KSSsxaUxJV2JnTy9UeTJFMENXOXRkNG1adTZpQ2VZWGkzdndGUURNMGQwVElhTHkwY0RudHBtaWQydW05NXdzcEVLQU9oM3U2YVBOUEZKZWtVRWlWN05LQ1NYd1B6ZFU5ZW5URVRZd3FOOTQyVEFhWE1zVVVRbllsYWVtZE05elVQSGl0a01iblFaaFhIQ3JVNVZXRUhMSktGbndXbW5ZcnZyb005OGZ0VmltRVVpVW9ucjNzRUFQNllMajI3TFNnNXl4RG1JQkJqcE0rNFJLRExpT1NiaVdKaURwODAwb1hsYmF1cGU3cWpFYmM0RjBBNlVMQ2VremhPaDlPNXpZa0xvWHU0VUV6VTNFU3FIZHJiNG9RcmU0NVVBenZ4cEFHNmJJMDJQcnJEOTk3b0NScU5OOTVNM2lVWG1UOStPYWYvWDhmSDZHQW1xN3lzZUxOL21ESDgzazl2dit3c0NCQ3dXeHpVRlNqMS8zYlAvdm5mN1o3bm11MHFZWFZsQjYvL2w0QUVTMStYcHRBbURmSHdRNXBqanBYMnYzOTNUS0RaVGNmeS8xaC8zYjM4Y2tQYjNSZGdoenhxY0h3YlhoMTJjRDVXZmJuYlJQVFMra2ZubjQ0QndaL0k2eDRGR3VKaGRaMGIwa3pxc2p5OGZuVWhSR0lFS3NGWVhKejdwTk15V2p1SmhESlZrbTRqMTdETmg5Mytld0VqcERvejAvNzVyY2tDeEhERU8xdm1zNlJIN2pkSUIyWFVUQ3Z5NURpTTcrMzZmaGR1Ly82b1FibzdPNlo2MExlOERkNytOaWZidVJXMmQ1THFRSUpBMUdUWFozRzJKdG0wNWJuRytQU1J5c1F4UmhmWGU2Z3lTUlF2SXBVa2QrSUc2ZGNRVU55ZFR1UGtiaGNITzAzTlJPdjZhaXZRMjlrODIxaVhJOGhBS2JtM2lIc2tjU09jL29KdFFHR0VWMGFvcVduak9lR29uelJsU0tBREJjak9keFVVV0NIUTVGRlZTK1YxS2hOZ29XT1dGRHJmQnl5dWxDQkJpQmhadWdCSHZGR1BzUWNWRktEdldneGhJZUFIY29QSW5INi9wY2ZVYWNpQXVQRnZTNmt0L1ZqZVlydi91VHZQUjFVUVppSzhRVnlmMjh0VG8vUFIxUlpveE53VlFtcTFsclp2djZ6Zi9yMVYrM3BVUHJIc2l3djNFL2xXM21WdFo2aFlZQ3lyVEx0NWpCRmRBL3hvUGphUktkNzBiMmNaTDczeVhpSC9YNmUrM3F1RDErMHRmbW9taWtNSjdEMStITEQ1WTNwVzY0Y2g2elpBK3JINStWSEZqQXB2ekhOTFdXUzEzQlRpUkNxS3M5UEgrOTNpRjVjZ1ZxcjZSaFBoa0RDUTBTVGFzUlJMRTYxbVBUbE5DbkZxb1NLQjdSN0l1L2pLcWNPamNXZTkyc1B1UVg4Sm5DV2x4UmtiaFgwVmpyTGR2RU9ldlBJN0JtU3hVL1EvcktzWlRkcGpMeGNiaTVKYmdSNXhMampNZ3VFZk5tMmJoV2daRXJza1hYNm1xMFp3VzEzT0lmRkNqV0UyV1U4SmdNWEJoZUZCR0pFZWZBQy9wUWZoSEhkUm5zUHB2MDJIc00xdE9SYW9teFN2ZTJPcXJlQ2pMRjhnaUZsNkxmTzJXV1djMS9XTHFwRG1DRmRJS3JBeVdBR29GcUJsRm43MlBFMHB4YVg0ajM5Z0NwYlB5TkVoRERaaHk5YTZZZUI1TDRnMFZWaHRRVElMdldlejYxcjBSRU5WQ2dlS1JYb1ozdjMwSmVwRmZNTzZ4Vm1aU1E1UjVmK3VOTlB2M3JmNTQ1WTNlYlNjRTJVWlBUbDlCV243LzcrMy8rUCs4U1B5MDYwdjFTdjg2ZDJQSzVsYXMzT1E4Y3RJbXEyOHBzLyt1TS8vdnJRL1VGK2VleW5PRCsrV0szeUtvSklnUkdiWE1HeTI4L2gyZkdKQ0lFdlM1dW5POVZaVG43NE9zemY5SzRGcDArUDdldTN1OVBMTWFRS1ZVQjZCR0NidG9LWG1sUndzMm8vUTZleHYzejRNVHVoUUg1ekNiMXQrem5WakZDNEE5RSt2Yi8vR2g0RlFLbTdhYm9HVkN1OEJ6cEV4R3JoSmN4TW9BamZXYmdnbXRFREp0MnVuOC9jUlhpZkFBQWdBRWxFUVZRUnlTbCtmbm5UbkdSY0R1QU1KNE1xcjJzWTZReEdSRUJpUE1kaExFb05Pc25pWGRHcEI2T29rRDNEZGVGRFh0VEd3dE5NV3N0WUZPUllRVlJUQTJ5NkxXQVdWWlh3c0NGOXhxWUNHYldQamxDVHFpYXhIVmFpcVU4SHhFYUMvUlo5dnEzSTMzQUZsb2lOdVJ0YjdzdzIvbE5jazJjMnREZHVFUis0b2YxUm5CRWhYVlVpdXAvVURPeHNpSFVKcTl0TWFCcTdWeE1LVEJXMXFwUjUza0oyRkVDazhobzN5VHZ3c2FlY3paUTZGd3VKeGF0VkhZWVdDRU9GYXhYWXRHcmZUUzluMXJkNlhGQ2t1MjRodis1cVpsVEtVdC9ZMmUvTHV1eFVpb0xVVXF0MEtiRzhMS2ZsdzZjMjdZOXNGUGg2b1NVRW9lcjkzdlk3NDcvODY1OURSVFJUQ1cyZXA0ZjM2emtNMVV5b2xMQlNxTFJxKzUvODZULzhadmY4ZGplMXgyK2Y0eGR0cGU2S3ZnSS9xaWpFRUJTWlZkUkFQelVVMCtpRmlHaHIyNWRpMUdoZXZ4RHRxeDlieE12Nzg1c3Y1OU9IeDZpQTJIQlhFNllNeGVzN2R1SWd0dVhNaThBcTAzdE83MzhjYW9mZkh1NmRpZDJSZDV6UnFEMCtQbit4aFJ5VWFacVdjWm5PWEdEQ2pRSXJkUjN5d2ZQcU1DdFc0TjI5THlwQjZBM1orWnJZQVBiV1BQZ3FhNlQzaElQZjFnYkllTlNJeU1FSVNkWmkzRkxObkJRN3JyT3VyQlVNMFcyemxBc1dpcU1NRGRGY3dCRWFtb3BFTVZWVHRaUktpRnFLS3hYQ21BUlpPT0FpZ0NJalNSZEMwckJsUW5OckJJLzZDRU1qOTU5S1dkODRkWmRpd2EvZyttdmRmWVhCODRvZXZMYnJOemxJQmpzNCtXeUdXSnVMS3J5dDNXcng3akp5eVllb0lIcnMzVjJvZHF5VGhKVHAzVUQwaUVDUk4rS2g3Qm93TG9hSUFtc1JJOG91NWdLeDNhUXczVnB3SXNJMS8zRDk1VTNoUzUvcXZidWFlSi9Tbnl6YU9tWXpUT3BuenV1eFdEbUhqRWhKbEdueURzUHlHTjkvdTh3N2VSRVBxK2JyWWZ5MEZvU0pzcjdVVDNlLyt0bnYvSnVSNCt4aVpYOTNmN2d2UVppRWlUczhYTTBrV0d2OTQzL3kwL2o0emMvZTNqMSt0UHZUejMvWit2eDJYK3g2QWhNWUtGVVJpb0VSZlcybmRiYXFqQm5tVFlLbTZEU3NuYlZnallpbDgzaXlMM2J4OU9HMG45SFRJU2JodHprUk55MlJBUXovTE5ONDNKbmJZMGxhWVdRYk5WRVR5ckRMbjFRM0dUUFViUE9BV1p4VkxCaFM2SWFGTS83eTl3N25YLzlzLy9oRkVuS2k5SXowRTFsai85Smhyc29Ub3BCZ28rcXF6Y3NTSlVPYlMvaDhXQjUxWjBYN3VQNWtrNnFMbUVyMzJmekFWZWZ4ZWxiWHFVVDNET0RWeE1TRUI0VGhDakdSaUFoMmdhb0ZwZ0psS0JiVW9MTFBXRDdVTC9RbFRYNE0wUE5VR0piVmdxelBBdUlRMVRLZUl6RlZrS3hqNG1Jd3dPaWF1TkNMeTI4VFNwY01NTkxYKzJOaStFV0VSUlZ4Y3dLUE9XNHlYbkd4Q28xRksxTGRNMWMxTWwybWo3QkxoQXRpdEtWNXEyamJ1bHdCQmJNcDdHc3I5UENJNkt2MzdpNjFHTHV6VkRhV0l0NkhhM0pGRHFuUHBpQWdlM0V5MXBlWGFWS3gzVFMzSmtVWmU0RXBMbTBTUXBMeE1jK1RtWnF0WlRjTDJYYmlMY1FzbjFWMGF3Slo1VzE1ZXV4bDdpOTM5M2JxT3h0VGZlaCthcjJ6RkJFVW52VW5DMmhzOHgzTXhCZlRxWHVWbC9mdlk2bUtUQ0tURUMyTXBCTXNXc1FCZWZucGN0OGVqbjh6UFR4L3ZNTnk1MUphL080aHVpM2ZsOW5SZXdzb1RSMnppdTMvcTYvdWp2TlBmKzlkK2VUNy90ZC84MzVhZTJuSEtPY2pkVm5GVFlTaWF0WkRZTFVjdjU2aXZjeFQwMC92N2hmaU9HbVpUdWNJa1dqVVpvYXFhRkllWGo3cTd5R21iNy9yRTl0Y0JDRWVaREVGb2NNZ0FsRkVLRFRjYzVBNVpBSmVwWEZDUndGRm5sdVIzM3JjeWc5M0JMMG9GbE9oNDhqRDVwZC8rL2ZxSjl4ditlQ2RyMkUyTGVDaVpwdCt2MVlEdzN2M3BFbU1lbE11SGNyTElGaUZ0bjlJSlEvMGMxZE9NQmdJNHNhbHhPR1JseEYzTkNSR1VBQkdVSlRSaTlBYnBDSWQraFFsQmkwQUFHd3owaU1Sd1RZNnpIVXFKc0lMbWlaMUYxUWRpcWp0MmRSUkxJZThqdkRRRVZHalEvWG9lWjhWM2NaSHhDMFZaZEE3aGdwN3pMWWxMb1JkdnFiTnZoSmJ2UlpPSjZtSVN1L2l2VFBhdWphUDgzZzBTZWhWellrdTVHeUdRRDRVU1FMQUpxUkNLSG4yRHRvNkxhVFdXc29LSGFua3lKRHlJUXF1V2E3NHlkcjVHQThQTVVTNnVEaWg4aXJ5UmJXbjFUR3ZLRHN0d2phdWJLRTFlaVNod3dWRlo2TWdaRklFMmZ1THgrTEhwM1ZRQXE5SjE3emtvd2lGM2xmVDk4Ly84bi84WDE3T0hxb25KWXBDMGZ1NmhucTJiTXhRdXRqaDdkZGY3aUQ3TDc1NW1OMldYMzczdUJTdGptandpOXhzdkZ4VU1kSWIxbU43czdOT0FVT00wMDY4aWNoczNycWlXSWlFcU8yaG5DRHg2WG1obWlKUFU2R3BLbElDREZVaGsyUjR5VHF4c1pMR2l6MzBSbHNBZy95bXBwWEk1M2FHUEJ0eG1kNTRhRG94Zi9YbFYzS2Mzd2hWU05YZzVjMUxtOHFtS1J5L1ZZNitHRDBvZ05MSmdQMncvNjJFMlA3aGJUVkVYTjE3Tnk4bWdxR1I5cXRSM1BNbWZXNVQrMTMwbVVHSVNJUDR1aFJVRlhpNkx5NnJES1phY09raGs3aTRlVml0UUFEZFhEWHBzY1Zsd0o3SzY4c1ppSlQ4WGtINVNpY0h6UmJrRFcvZ1VwcU5Zd3dYeGNVb24xT2N3Y0RWM1RVWWFac0Y3OUtXNWc4MDdHUVdOWmJ3MG5qeGRWMDdJeUNtMVhRVlVrelZvL2NFOFRHNlF6Y2ljQ1pQV2U0WkFuWTZRdGY2ckZycWJqKzVsbUk2YmhHS2pic3JqT2JvN09ndmZhMUVONzFKa1FSczZ5WGNnNDhMNnN1a1ZZQ3BENk5JVkl2bVFVRGNwVmFkRFJLU0V0bndaWVdmamk4dElvUE5ZMUErTHhmK3pKOFE2aXF0bEpjam50cTBBQzY5elhQM1FGL08ycnBPMFR0VmxkUGg0ZUZ3UDJ2MDh2YmRqclY5LzFkUGgyL3F5U3A1YmhidWNRME9HNEx2Y0cvSDUzVzYzNSs3MEoxYStteCtQbHZkV2ZSdVZZc0hoV3BWRkxPdjY3ZlBxeFExRzlNQW1LYnRSb2NUNnJJejg1S2pOcndKb2lRc3JTWGg1WWQ3OVkvT0wxNU52WGdkMEloQzFlbXNMOTgvZmxWUGo3dGk3ajN4NmtPYno2QmcxOHdnMGN1d0dMb0hvU3k1eExlWnhuVktlWG5oUFdSK3VKOU1KYnhjRGVtZmlmMXhReUpJTnY5bEVCcnA4eHgybzRnaHdTOFNyV1dtREFDRUtnUXhiRDhEMXBadkl3VW1IU2ltcHFHVzhzamJoRXFDN1dLUUo1UVEzK2FrZkkyelRVVTY2QUpOWUJuR0FzbWpWd2ZlR0pmaHo2YUd6YTB2ajMxZVVwSzNlZnRuM1B2ZjBJT01vTHN3M0QvRnhsQU5WVld0WXdMZnZIc0EyUGZXZzhGWkFCQVNBRkZpaE5nS3Fpb2g5R2FsdHhoR2o0eDUzYTdQT2x4SGxJQy83VXY5YXEvckRlWWhqLzZ4Z0YrMDNBWFhwV3VsOTdJMW1BbmFGSTNuV25LOEE2SlVGODE5TE1MNjZlVmxJVHd6enpkUHpLVmJQd0prZ2xOLzNILzE4dSsrLzFqdlA2NDdZUk1MUVpXKzl1S2hMVVd5VnVhM1h4MlV5MXZWYVpJZTl1R1h6ei81THg2VzkwK1BwL1BhTllOcXR0TWdzL2VjS0UyYmxIbnFpN00zZ1dtZHlEcE5jK0lpMUNUSVFHR1BpdVBMeDQ5cnBKdUdIRFVvTHNRSVhpYjIzT0tPY2lmUENFTU5RUWx4Q3NQTEtBRi9ld0g5K2kxNEpZRFNFSkdJS01zdi8xeC81c2N2NThMZTFzdG85YXFUU3NLR3ZkSXM1RE5udUJBU1lzSWZJQVNDM0IybU1KT043dlhLR0R1OFUrQU5zM3BZWlVGZTJKalh3UEdiNGJSN1FmZUJUYjd0dE12MUljYXdWeGJWYXFicVkrN1JiakU0Tngya1BtWXJmUnlla1ZYbGRUYkx5M2xJTU5DVFl3OUxqSmVNWUZYWXhkaTVpZU5lLzd6amdFb0ZSbEo2ay9nZ3J4RXFjYlVraWpDaVMwVHY1MzdLcm9ZbWpsaFJJaUtreThJZWhBTHR4VXVSaUEwZ0FSV0VZN3VQekJBT0Rib0gyV3p5SXJJcFZTNWZJR2NJUlZWV1RJZTlMZXNoTFpRWFZlZFFjQXJDTWUyNFRDYnNrZmpwUVhFbzkrdHBGYW1BTjNwUUxiVDRadTFjbmw4YW1UZEhYcHhXRE0xWHFTVDdWWnZlbjUvdjd2N0p2L2tZcnFYMjJXM2VUZFBVMXlabGl2bFpyY0JxZVdPSGVaNTNkMU85MzdYSE5uMzNzVDM4d1ovc25nNlA3ei9FMlV2bXZJODZTRnc3TFVMTHJIVzNTbC9idVlkM1U5bnZKMjlGMVZTTFNEZ0ZQWUxvU3pjNWYvdkxGbHFMQ0VrUEVSMWowN2l3TXNiQmMvSEcrdGo1bkZBSjFKQlVFWlpMQk1CLzVoTDJRRnlYYi9aRXJRclZ2Ly96NkYrcHo3UFF6MHRxbFMvZ3hGZ1hiWEdKUXFTWUplQS9IenhISjQxOSt1d0V6aXBkWEsvZTJ4ODlZTGJ0d2k4QW5PR1ZIUlQyVFFLY1JIYW11UGw2TUNkK2xhUDVCTkl2aXNOY0xmTllOV2Fxc0d1aWdRNGpZOGx0S2k0UC9RYlBQbUlnOHZtbDJqS1NVQVhwcEE0a0pFU0lyWVRtWmhLNllWaGVyM1hLeFBodFV1NXJ0SXhjVCtSTWc5MFdjQVNGN3ZDMjl2TzZGcWhDaGVQSVVxYW94c2RtSytkbERkSHNid2dHYnljOHh3U3B4WUJBVVNGa1B5MXpZaWhOTXhCYmlseHdJUUlHUDd6ZDZhY1ZsVVBhSWxlcUJSUVM3MDR2b1R0UkYwRTBTY0cxVUVCcVVmZEVzYklIclpCaVhTaVE4UDc4dUd3emdkZ2s0SmU4bmRUSVVCWGw4WDRYajd1Zi9hdkR6OXQ4ajZXVWV0Z1h1cEphUUI3VWlHbS9lMVB1MzA2cWVwZ20vLzdUL2NQNThJZlRUK2JwVFMzOWxMVVF3d01lYWFHTy9CSFU2alNabi8xMGRnaEZaYiszUGs5QWhWWXd4Q1BDUGNRamNQNzQvY2U5bWFrUG8waVd6NUM0TUxNMm82WU9OY0U0aFVlZURsRVk2b0tRTXN5ZytNMVRvOWYveUFQR0c0a1hSU2VkYVgzdCt2aTN5eUh1WmhOcDYzYk5pVVRDaFc2RHZiR0dnNlBaNWN6V1dOSnk0bUtDM0Q1UHBiOGNIM1RJbitKell5eHpRNG1OVnVCcXFvTVBQWWpPQ3JvVXFxcFo5SXVTSzZWVVJ2VVJhQm9BUkFjOHRXdmV5UE9ESVRNMkU0T0pSSThMMi92aUkrQzQvVzVoS0p2Uk40OUJ2WnpZdXIxaDI1WkR3RDc3aWZRMkRlUFN4Skt0VWFmSy9OT09NaTV1YnNBYitIMVFGN1lGTE80azNYVTVMOTFkeGl4c2ZKSnBBdjJpbXlpRlRyTjloS3M2aGNnQmZXTDVSaG5VaFRCa2VKdXloNGRLdHVOdlIxYVFSZ0ZNVkdJNW5YaC9FQWFoVjZtOEtXRVFXS21ob0o0ZGhvd3JUa2c5d01CY09rSmdGQldIZDlZa3drUXNwN1ZiVVVLTklsRGZZaE51NFE2RXp2MkllL21PZnp6Ylg0WHlUZlQ3cjk0ZHBNMlkzbjB4eTM3bjYrTFR3OTFkdlgvUTFYRUhPWjc5d1grMnU5OVB5cm1aMGxzS0FNTVJBWVFJcGRlcGtPSFJ1NHY0Mm1tbVZsZ0JtKyt3MytXUVg1Mk0xRU9ZZjNwL1ZHVUNnNE4wUUcwRHZsdE9oTVR5UVZsQUNZYlUwZDIzQUlJb0VpdEVnUEtmMVlTKytaY2k5S3BkekZpdGVWS3JTOU81UEN2TkR3WGFtK1U5ZE11QjV4NnNwdGYzdERVblRLdkhJSWJqVXZIbERIZGpKNW5FOGVpYmpPbFdFOHJocUtBUGtsVXVZb3k4d09IQUZhaG9FR3B1cXJyZGdZdFFWTldMdUFZamxDR3A2YlN4VmRoSUFodmhQQVFzcVc4UzRWR3Z0dVdMTWl6U0IwZFNwRnhOQlJLYmdVTkVZbVIvKzVpRlRxcUFtc25XWlpaWFl6KzhEaHU5WmpYRUJYQzFpVVJmNVR4Zmp2Rk54aFB1WkxoalBTOWgxYURGaEhrdVNJUlZLZ1REUFVpbjdteDlXYWsrb0JNclZJVUJIYWVBQzBkcm1EQ0VIenYzc0ZKSGRNeGxvbFpJMWFMNkpoNmp2bmw3Znh5eTAyMWpVVklOeEF1ck5YaEVhSkhtZlI1UVBWRmpsOGxPdlZOVXBGSWtPbnQxb1FUOTFGTzR6QVNucUY4eXA2NTJXZ0RLTi9wKytVbHA1ZmVQeC9lbit1NWMzLzcwN2J1OW5mdCsvc092OWc5K2Z2eDRxbThmM25ZaDd2ZjMxbnBmMjd4OGlmbXVwbXpYdTl0MlV3MUtBS1Mwb3RYZDF3WEhoZ29sek5TVTRhTFRvYnlab3BPQzR0aVlpN2E4UFBiZFFDSWhJUW5RUWF0TGRLZG1hSnJBYk56dFlRT0ZiaHNaYVpTVVpjc0gyZGpRbStTamplNWpGcTR1V21yWDdtcFFlTGZNdkhlZHpqYmQ3MVZ3Y0p1VU0zUmx5Y2JmYUFKR2Iyc25YcVQwWlo1S1JnVEY2TjU2dUowcDYrUWdMTTYybjlrVkFhZ0hSVlZDbXQ0dmoxOHNuOHJVUk51OEZjdWpuRk9SUUZVWFk0ZUZxNGRhb0VBUjNydkxjRFozc25mWXFqcXVTMnFJQnBJYWE5ZXlTbVpaekluYU1SdHNMdU9nRG1vcHBNZVVhQ2RGVlJmMU5qamFrdTZ3OEswOGFOdzBoa25lYmxBRk9XSXQ4ME1Jc2xsVlZVakdoQWtDR3BSYTNHQUtSa21icmNTQWhQU1Vic1pXbnlaTUpHSlFjRTFIRmUrYlNRZzNSUlM5TFcyVlVzeDhybHdXbGxWeVg2b1NBYXBValhaY2RmcWQzejM4K3E4LzlVV2hCZ21mUmlqUTdLRndkNGJCbTg2ckNCeWlaWTN6Tk5WV3pZcEJPVjg3bm1JbS9tbGZvcnN3TW1BVGxpYkY3Q2xBcEp4ZXVwaXlvdm51cS9VRldqVGEycEJPS1BGNnA2ZVR6RjBjMUF5TGw3YjBJeVp6RHhTaGd1eGxYSUIxTkFUTU5IcW94YnI3eXRhN2FlMXYvOEJqSi9mMzc5NjkvV0l1WGIvODhrOS9CMnY3R0h2RmZLZ2lWdWU1M0sydCtFbkJ1N2xGWlg4NW5ZOWRlVnFmamxKNmp6cEtMdnFxREhkdk5qM0VUNzVmaThyZXVpeWY5bDhCdXpjK3JjZGFJa3hFMlJ3eDkvZC84NG1sMWFvaGhsVVVBakxSS1NaTXlpL3NiSldsckp5a2hXbzd2RWloeFZNbE95RitCMG9YSzBWK2E3NG9KTEV6dDNma2tXVEN2TTdMOEJRcTZxeWNxM3htbTRqUm10bXNTWmM5SWFLMzZHZlY3S05jeGpDcUJrRW15NU54cm9GK2V2eitkMXNNT050TlZKUGMyR2ZIY0NYOTFTWkRjTWpOWUJDeTNUVStEM3pLdTIzbGhwRlNqQVN6TkE4UlVGT0ZHcFNheG1FMUpZaVFqS3paYmx5cTZrcytvWXdhTjVXdWcybzV2QTRtRWV5am9VaWhJNUREQ01BZzBrRWhJbDVGZU1pVjVuaVZhRnloejV0RmxFUnVhMXZUK2lLZTNBeWNyUzFPcUJYZHM3ZE90aTVRczZLb2hiNEM3MytIMzlrZjczNzFINTRlVG90cFAwRTE0OHRHUmdaTWhaNHRoSWp0SklCR2R4Y3JPZElUZGd5REE0V2R5cDBKVEU0clMvcFlkTXpHZEFobW1sUzJGbHJEbytvVTRtY3JwalM0Q2lJa0hLVkVoT1E4V2lBUjY3b09FYmhlT0VFWkE1bmZueW8yOVczaWMwR3p3OTY0MUc4ZTN0Mi8yWnVjTVZrN0ZxbFRwU2hrSjFicVBCdEZkQXIxNStsUTZHMzVkam4zOVZ3c0xlT3F2RVQwRkJWWU5Ra3hwUU5DOXpVUU8wRTl2Sm5VeHZlaFp0ckQvZkVYMzYzbFpaY3Qwa2l4M01XZXhTRzh3bm10RmwzRFNHOGQ5aXMvVEIzVEd3YzFvRHFMMDIzNmtRWDgrYVdYdDNPS0VSekdkUGU2dXpOOFZiV2lWcXBpcXNBcnowR3FBNGFNQ0p1b0lydjhkRzlOQjVIazZvdTc4Y2ZUM2FwQTI5UDN5K3FadTdjbEh3RVgwd1Z6UWltandjRFVpVjdzajVkbEFMN08yTjJRckJFQ1k2WjVpVnF5VlRkd3hNQ3NEdGVYTUIzaHRnYWNraC9YbmV3alJzM2wwazhpekxSWlJRSzluUkRLT29KQU5aWGRvME1rdE11a0ZoQjR1bWx4azZ5NHVZYTNsUnZwekJxbWtSUzBVT2h5d2QwU1Y0c2xKY0w3ZW02TmFyVVdZVzlkMkxyQVVLYkpxcUcvTE4zLzZMdnYvOW4vOU4vL2IvL3o5OTk5T0RYVGZ1Q0Z4SkRBR3pXTXpEZ0pSOWRoMFpyWHRqWlJkUE1hT1E1TTR4U1VPZjZoZ0d0TWlDVEwzUUxZUkVpYnhBbWJncTA1b0wyeldER0xvQWxkdlpjeXRhUjhDaUFLYit0NW1YTDlhbHdVYTdsM1pYTk1sWUV4c3NvZzdsMnhMOTRlY1hoNDk4WDlZU2U5NHpDMXA2bjZFZ0t0U2xVcm1VMWhPNDNUcjZUdTJ2UEw2VmRjV25mTmhqRTJlaFpFelV4UXl5VFFVcmlJU0t6OTdESkI5ZkRGVnhvbmNZV0VRa3Z0eTdyKzNkOTh1Qyt0Z05Ub1BWUkZCeDFOY2pCQkVYQ3lYZDRCUS9mZy9QYVBwLzNwcjU1a09nbGdZc1hxak5CNlhjRDhUTzE4NlpyS2JTNDJZQU5nT081OEhtaW5MbVdhRGxEVEJNZThwaGVQdFRqYW13T3VSd2hFcVhwQnlJK0xkVWNPQ0hUQWhtc2wyTmZGZWJXOUQ0azNSMW8wcjdDK29JZDZnQkptVjJHV2lCZ1Zja051My9JTm5lNjlLNDNKYXlaSGpMeWs4YzN5ZjREYnJpSTVEcE9JTmNBK29zcWpSVkNpeFVSdTJGbXFtWHF4WXJnd0l1V3Nab2JoMGhFeU1XK1FwaG43bVo4VFlhUDd1RjBGTjZYcldNMlpFMzhCWXpLMlZ0WWxobnhqZEYxbWZ0N2FlV21HVW10UkxxS1Y0bVkyemROayt0Ymk1ZFM3bjg3di9rSDg2Ly96RjRjNHhzTlAzOVcvN2V2YUl5ZDhKTVdxT2cwcXpoWmR6VVZGUTBWTmxRdVhVcXBYTS9nQWNXWE92ZWk1S3BOSnkxY1hmTXYxaStxMDZ1UmJyQms5Q2hVWDJ6RkNWT2dJbFVvMkd6bnVhdHA3ajBDcXhVYjZKY1ZHcHpodUhQRXA2RE5UQmFCMWQzZ29iM2Y3K3pjN2E4SlN0SjliZmU4c2RhcDEwQzZrUkVpTjV4UFhaWHIrOUx3UTNteENCTlNwR20yTTV4WFFVTlVwQUpYMTJFS2pMNmV1VTYxV3Yvd0t5NmVzNVNHMDJmdnA4UmN2TnMzNWRvbzNBSXBNWE1TWUFSTkNkRzg4WWRaOXEvT0JQL245LzNxeXYvaS8vanduQTVCaW5kVXlsUFZId3MzNCtmKzdEQ2FnNXFNMUg1dmh2cC9Qb2RPN1djMUtOZFhYVTU3THhEN24zN0gxdHJvbjZkK0RSR2JlRFdNck4zUzZBc0tHUUtuVHJ1VFlDZGR1Ymk3Z0MxdjVJdUYzOTd3WjQ4YmtLNFVCQ2UrZjZRNUhDcUZqZEhlVjE1Z29VMU9Vbkd4aUk0ZTEwUWpYOEtXbFVwWGV0d1hjZmNKMXhBWTFOYy9RR3htMnZHYkptSS9STjRjR0JJR1F6SVBiRmlzR2kxMjNrMnlMSjA1ZHhWWS9pN3Q3dVB1V0tDcXhoWWFQbHRqb1VuZDZPNjg5OWlpbGFsQk5XdWV1em1XM201UjhLOHVKMU9sNXQvOS8vbzhQY25lM3VFN0ZySXFEd1l1VG9zNVl4VFFhbTNjdlpWTk9ORTdtL1lWdlNrQU5HcERRR0ZKL2lEUXpYOHM4VDB3UzNQYVRsZ0ZKdE43Y3ByN2FkSUJaWUJXTlJVdHhsY3NtcldhcE9SY0dDdWhVZzRCUW9HWmNhUUp4Z3RyR2w2eWFLU1ZxWmxEQVpUazdwdm5OdzhPYktuUjRLeDJVRDlPdTduYVQ3clNZU2xBam9ITCtFTzBKVDU4V2VVZnZXdnJTUmJjY2tGR1dlTVN3VGJWei83VDJJdUc5bDdxYjZ0MFhiL1c1U0xpd3dBTjFXbzUvOTEzWlNkK256WkZSQnVJQlE4Mlh2emtFMGFSOC9mc1B5OGVYenZ0Ly9FLythUTMrMjdwS0VWV0tXVU9CZUk4Zm5NQ1g2TjJyc2loZjhaSEhXellPY282Y1UyZmEwUTVTYTVtcWpaZnR0UXFYVVBWTUl0OHFWM2NmR2NLOENGWTVja3UyOEc1Vm9QY285ZTdMbjlacUZ4aW1JTmNucjVGRjEwcEpvaWZXVlJEdXZnVTFXTTRINDlYNnZTWVRNUU9UaWpZWitDMDFOVk8xZkw1aHcxTFloYXJpc2JDZFhNVlhGZkhlb3FmVVFUbU95U1huV0xRSWRLOWhtckxmQ2FENzFxRE9GeVdaSFJmaEZXQldiTEF2YllTaWhseXN5TGc4TGpMb1BWTGV4NHREWWlTcmo2Mlk0UkZjSTFwemxBb3pGWVp5UGJaNjkrWk5uV2VUQ0hOU3lnNWxlVHh4djZ1ZDZzOUg0YjIzMVFtNFp0MWdzNGxQMWpNakNXS2p0bGhOVmFNMVIxQ2c2cWt1RTQxUk9hbkN1OU5paTFUTTBrSTNsWXMzVnlnK09jVWJZODBlSTZBbVE3QW1GQlR4aktPQlFUcGgyU28wblc0Q3EwSklTeFluekxJTG9wckEzRjE0NjJUYjc2WlNRdEY3cTBIbjNXRS9UWk95cGdhWmhJbG9QOHZwazU1ZVdJOFJqRmhiRzA3K2JWWVFFUjJrbk5sN1c5cXhSMHFadFU1bGZ2TndzSllhckJSK3gvTGgrOU5kUGZxa0VQYVJacG5EQ1c2S25kSFVzR24vRC8vRjMvdjJGLy94bCszZDcvK0RTZE1YV2FnZ1JXbHFsR0Q1VVVIRWozVzBOazBtTnNWSXBDTmNWUkdJSm1xbFZNaG5vWm1hVnloVlNkL3RFQlZSMVRSbGROa1EyejRrTGdjc29CbXZVK2ZEM1gyMWtla3dkUENiME9wQ0dVRCtOemJpaklTVTNsdVdYTnRMZ2x0WFVCN09uZDViVTBaMkdXQTJ3dXpWckpoQkIrUXpvQkxSQ0JMaVN6dEpQN05vTkZXSjNpTW9VS0c3RE9WSW11M0N5VUFlRlZZbXlKUkFVaW1qWUhDa042bGNHc2I1MGJvOWdJSGJzaEd6NFp2eWJLelk1cDd6cXkzVCt4STd2b0dteWZCZ1kvUkF5UmdNQ1haMm0rL2YzdS9OaWlFdkh5Z2hSOXNwYW44VXF6c2g4VFFTS0J5aTJTYllxVmRCblhhK3JLZ09Cd0xpTkVpaFJZUjdvMjU5dG93emtnQURwY2c2RGVKTjFqUWJnNENrR3NseU9LSDI1akRMUkVaUGVLVVlvQktCMG9WVWc4SEVXd0JoQ3JWYURBbWVkcUdQVWxxMG1KcU50Z2xTZlRJdkh2UXp2bk91czY2cmk1clZTWEUvRTFWOTNCZEpNMG9yOGw1M093bllDb20ycnQ0Q1F0QmxtOVVQK2VxcTQ5M1VqTTBqSU9Xd3I2VnFObndCMVRoLy9PVkw0c1lWRXU1Uzhyd0szVVEvRytiM1pYcjM3dkNUaDkwZnpHdGJ2L25xd09XMDJxR3RDaFVIV01CR3d2NlQrY0NPVzlMRkp1Q0xVUUdRZ0pvYjFYMlQvS1NSL0laZEZkczhQbTV3YmJXV0tyem9DUzVOTE85dVFrcFdtcXFoUkhoYjg2dmV1bi9ZN0N5NHFyQmtZOEdIczlDVjRyMTN1eW95WmRncFh2MndqV3RyRFRaQmtWY3JUUWFPWmxyY3hnanVVSW5lWE1QRHo4ZXpvaldaQ3FtcTRlNElGdzNmb2djejVZOWtGd2diWVlCVmhrMlJiWUZNS1NmcEtsVDBrczZHSkZ5b0dWNzlHanNYc0pVUTJGSWszYThHbWN1QUh0ZitmTjRZQndwUDZ4UnBXR1RYM2Y3dHc2NnM0blN6N0F1Sis1dVQreXAzdi9QSkxKWkZ5Z2JTM1hvWGpxcGV1aHltaU9VVStqaXVGaGFoMEJsbjlLWjB6TnNVeWNOTTZOcEU1NTMySll2QUljSy8raDFSdVRSTWM3Vm1KNXFHZDBzT3RRMzFHaVFJYmFtL041aUh1MUlKSzNVcU1haGtScXEyNGpZaTdFeUhqMnZBQ3RmMWZGNlhaZjNMcDlPN3Uxa2FkWnFuYVpxNXJ6M010R1MzR3FJZ2FpM3Y3UjZUQVZHdEw1M3dNY0NMQVJIYWtsckNpaFFyT3hXN2hGUnByV1lqNlRoRVRlTDA5RjFZeEQ2dG1SNG9oSUpFRkY3eFJJRGdteS8rd1RmMnBwNE9oNitlKzAvdnBaMlByUjc4NUNOclFkMmRNQzFLOGhVenlhSEd1T2didDhWcllleGRVWk1KbmhoSHJlWlFRS3hPYk5qdjJFYmZPYnY1SXFEMXBWVmJuSFducmU1TUpKU0NJM3JoYWNvZ0NZYVQ0YlpyVDE4UHN3cWo5KzdCV1pvV0s3UE1jWDVUbTI3dHRkb2pCL1NocGk2RmhORzdkNHA0OTFDRnQ2WHhWS1M3bGVoZFRQdlN1aVM0SXRVL0prcWxkOFY1VjlGYm5WSVN4cEJxNHBTU0dhTnJkNWpCMjdyMHBUbHNqdVBKRG1VOTdXMXRLTEdnUy9YV3dLQnBvOVJTSkhUZU5RV2JoNWdWZEFEaXErdFVRSFhYcXQ0VThJQUZoVkFURlZPSVM4MkVVTWE0Z3ZzRmUybnR2QTRIbGE4dENEQkVXNGJPWmpJNVJjYlZTcHhVWS9RVlVtZk51MERRV2V2K2JnZG5BZFFRemxMYXNhbWVXSUxROXJXdlo2cUVhekxaYTYwSUxhVTY5OUZ3NE9Sck9Tekg2ZGhxRWF0TmMyZzFxYW9pT0xMdVpWVXp5ZFJ0ZzF0dFZkRnA1YXJvSmdYR1JsUjFkejJ0ZHJldVhhbWlLcGg2WjRuVzFPaDVuSnNoeENKT0o0anYxS3FWT3BXdW1pRVRkTEszWm8xRmlTbWk3T3pZKzN6WVJVZ3N1L3J0c1gvN2h0OCtmZno2SncrelBlTCs3dTZOeFowN0NxZ21hZ0pLbWFYVjNhT1lueVpuM2IzRCtlWGtzVDVMTk5JSHRJbGkzbmNhdHR1MzlYNTVGMTFocXFxbG1Lb3ZYbkJhK25uYWQ1blpORDcrKzdYdVpxVU13WHVadXFRSnJ3dE4wUjFXS1hWLytFZlQvVDNrdER2emEvMzE4Mk5aeEw3OG84ZFQ2WlJTVWRnaUFqOFdicGJNdHF2OWJVUnRiUUU4V3k1d0pzZERNUk5CajZWV0UrL2JuSmFYbkwzVWxwQ2ZRejA4QjBxYVlYMXFVRk1TOVlaTnVsM0p3OWZ6dVFlSEN1aTNlaTJFSWFFTWVpcm90Z1FVZm40MThJenVwak1FWmdVUzRrTDZOa0VxcWN2UUNESjZuNk0zNzJ1TFBQQmNLWFFyZXhYMmNBeTlEc29BQUNBQVNVUkJWSWxqRkVIcmc2TW1HdDBqQ25TQ0RMTi9qN2F1RmhHakNMcjBHSnlJYUJoNjBoOVB1cEVDU01EUkFkVkNqTXlyaTAwREZ6VDF1RjJQQnJVeEtMNHVXN1JkOW5PQlhabUtiaU5rVkVSZ21vNCtqdG9XbmVHQ0VERHl0NHJRb1JJS0R4Z1JhbWphU0VlNlE0VUtNRHZRdytCR2hDQTJYaGJEc1dtWnJsZXNpKy9QbzNjY2U2aXE4UlFVWnU0QU9NaXJXbFJqY0pVMFdxTlN6YXpVV291TkVsbmN3RjZxU3hRVjB5SnFvUXBSRTVkYStlbjlwMWE0TkljLzd3L3plYjYvbjdYcUFsSmhKcXBTU2xHWlhJenpRWHhkSUhMYVkybHJoQ3ROYlRBRktSU2Q3dmJkS1JGRUthdkhvSXlyWmhJbHVuc1RLK1ZrOXZLM1AzK3NOYmtIQUUxb2ljRUtjQnB3NDlwT09MejU1dDFPb1pQMFQyK2t2dWxlMnNITDZmNyswTkU4WUdYbjBWeHJTT0ZsNHZEYTdmSVp5UVdlSmFodEpZTXhRcUdpSVZZRGM2blZSTlJXNEJvMGt0cEk2K1JuUUFxNXBBTm1LcVdxcUNsNzlpS3dyYmloRnZUMStMVDJ6d2JVdUV4RUwvWUhwRnhqckVVVGdRa01JM0xzTXlJWUJLcVo0RlJnZGJ5cFdYZHAwVHg0UENZUmdSWmQyOXJDM1NXeWFNWGFoRkdVOU5iU0hjeHdSeEV5eVlaMFJtbFZTRmhCaUhod0JhSFZSc3FoTUlsS29hb0IxWTJBZjhFaGpVczdBQkZWVVFsQVlCVkVCR1BMcytVVitNMHQybkN6S1dvd3dsdWIwcmt4TU5DS095MGxGUm9Bek14UHN0dXBGSGJBd3RzQ1ZSV0VTUXpvZk1BeUJJTzlGVTJpWlhaa0F4STVGb0ZLS2RKNktXUG5saGgzcnlvcTRUbjJJRU5zTTQ1dVVia0NqUkVxTzhhWERMUFNNQkR3K1UyWjFVNFJhUEh6Q2tYUlVxY3lUWVhESEpJNng5VVg5UUlwVmFuYVFSRXhjYXU3OXovLytTbDRYcVQ3TTZhN1EvM3lvY1lpYzFOSWw2SlZ4TW84R1VzbnVzM29yVkRrRk5xUFM5QWhVR1VtNVFrUmF6RjI3d0YyS256cEROZWNtM3RiVGlkYm16ZXF4RExQai8vK0w1YXBGaEZMVUlUU2tQVFdrTVZnaE9vNnZYMTRlRGhNMGJDL1V6OGZaSzVsc1dOd2pYcDN0eWlERUdqWXJremFXeG15aXg4NEJ2RURGdFBXSVI3QnpKRjd0NCtjM0tVRmI1bFYzTElKQ05PcnllSmlkOVNCekxsSmlZRzNRZjI3b2JvRmtxZlFQUEVXeEdkRzRHdWEwamFHR2wwNkNFd0IwNEF3UGlmNm1aWlNhb25pdVZ4dHJKUmFhcmFmWmRPUFpaZnBRKzlCY2JvRW8vZVFFUEVPVzhVajNLMjY5T2kwczBwSExVb1JwVVkvS2tTc0ZCZjI3b0V6YkRpTGRJQnFJMGlGWWVqVUlpNUJyQmhEUXIwR2pBY0VWaldrNGFLZlRFQ25ETE56SHNRWTNYUFIzbG9QMFQzcDRTNlRBRmFMVFRBek5RdkxkYXdodTBQcGRVenEwNXFsUWhOTHdQcUZwNmtxakJEdkhReVhJc1NJV000NE5VUmpaRkI0WU5PRnFVam9UZWo3bUNKdDFFeG1vMFNZMzVWN21ERG9ydG1YTmZTVWpWSkJBYXpNeStvVlFLblRWS2RhWlp6QUNESTZFVEFGTmIvOVZNWmJMZEovL2ZOdkErNkxpYWl1dnV4M2E1TlFoTUxEWVJTUVhjeENwSzNucHI2d2U5TVB0VWd3aUpIcWFxUGJFT3VpWmZmbHV5bWt1N2V6STFOb0FIcGJYcDdxcVpQTlNpTmZ2djMyWEZVQkZLUzBjZ3ZORTVGRmkxQ3M3TjkrODI2S1dCcGs3UWNyb2dWUzVPbUR4R0p2di9EdkJKSWI4UDUrWHQ5LytzRUpIQUdHa3Jjd3c2dkRPSDB6RUkxTERTMmgwaVVpUkZOS3htdlE3ZEFlcE8vOEJvOUtzaGpvM1RvRy9Jb2V3cTcxaGlBdklvQnJUb1NkOHJsdmVTU3k0RlZLNjVnamhOQlZOTkVaY3MwbnhxdmlWRTJtSGxZQ3FDRFZGQ1haSnNsSmx1QWF3bGpXOVJrRVNHOGk2UWhWTTFYMlJxbzVQVHdrV0NjcFNicUVtZ2xpY1ZVb1NCdUJZaUVlbkFxNkRZSnZNbXhkaFFFSlFXeGpmM20xZ0MrNUVhSUM3YlJyRlo2OXNDUjJENEtQams2TUNLSTNsMW90VjJaazlsODFxS3FhbFY0bkk4bXBoczExY2FYM0VSVFdWUm1MbVNtRFU1SVl0UlRUMHFOSjlFNXBUdjMvNlhxVFpsbVNJMHZ2NkdEbUhzTWQzcENKVEJRS1FLRzZTZGFxTi96L3dpV0ZLNjdJRXBhd0c0VUNrRURtbSs0UUVlNW1wcXBjbUhuYysxNDNnUVVHd2ZBeUl0emRYUFdjNzBzV0JCdks0SDVTRGpNRGNUQ3hVNWRVT3JueEt6WDhobTZ3Yjc0VDcrRittZHdpckJqM0k3UTRpM0MwbmlRblRSSXRXSU5UeWptbEpEd3VZSFozaThZYUVITHFoK2NlTHlKVmE1OS9NVFVKNFNpSlkxbmxjdDVQVXllbUZRKzdzTEFLODVSUXkvbnB3ckcwcFJUbjZlWWdMM2RXSHA4bFpxRjArKzZITnlVOWlydDF5SGtBU1pPZ0xXZTZSSkxhdkU3MTczOCtpeERCMHlUdDJtUWJwWVNkUkswODczNDNaMXd3N1UxemxKU1ZZSEJ6VzhDVTM1M2pGeTlJMC8yYk8wb1RQWklwNHB2Sjh6ZDc0Q3ZQZER6cXVQdTV5VUFTQUFtbldVbFUzN3kvMnlWZjF6RERLTjUzbmtVUXV1enU2eWN3YnorNGtaUGVvSlMrVmUwd0tvRUJZdEZ2OTh1eGVZeTNIMnBnZzZVUGNpT0RhV3hoMlArN2c0WnhQNjFON1AwMUdNN1VJejk5THh2QkkrVFIxc3V5VENHRWFyWDJCM0o0TUlqQ3VUb25XSmlCbVhhSC95ejE0ME96UWdMbTZNaVRNTGhLWHhLelcrY2d1R3dFM3o2aEgwSndlZUZ5MGthUjc1NVFSTEM2OVdxREVUUHpTR3B0bjJ1TUxoYnp5OFh0L2RhS0d0MUI1dGR0TTR1S3NHamlzS0RKMDVMbnBTbUpOSS93MWdPUkxYcURram5jV2ZNK2pSSW93VnNZdGNSc0ZNNkRma0VJVWllM2NZRG5JSGlBMmhhTjN2YitkRzB0RVVEUWNBZHJINXR3SWpRakNhdHpIM054cHE3NWk5R0RzUmFTT1hKT09TZFZvVkg3RkRjaTlOb2RnU0hCbFBPUTlEbkZsdy9HaXhpeHR3aUI1WHk2RFZVVkwzWHhvb1ZJa3Fwb2dwZlR3OW10Rmx5V2tObHBBbVJvS0hxZHZpTjc1T2I3ZjNoem9rK2svWFZMUVVES09TUHE0b1Z5V2xkeG5QNzlwMVZDbEVQblZGYjNJV0xvZjNOcmx1L2UzNzRWTk5ialRqTmJXNGtsNEtVNjE2Q2t1MzFXVlQ2OC84MzNoK1Z5V1o5YjBwZEw2bi84RHJ3TnNiYXc2WlYxaWNGaFNuZnYzeDNtdWU0TzB5eDFlYlN5dHBmSGVveGNtN3plVXZYVlJuOG1tbThScU9Ba1E1ajJNcC9mVUY2OFVVYjlXNWJPbFZteEJUZmo1YStETzhQdUNzMzc1aFdhbVpoY0pMM0VPNnlQT3BrN2w4Y3NiQzJsT2tkNHdLMzVFTEZKZ0ZPaThOTkN6T1lRRmc4Q0ZNTmFQMkorb0w2aTdNOVZjRkJZRFJLL0hqU29wMCtFTnQ5dnZIWTVEWk9wdVBkZHMzY3pLTE5JTHlYMVMvaVZ1cGlabVd4OGljMDU5VlBsbFVvb3pBUVJWUldDTXNJcGFVeHM4MjA3czZSNldTdElLZS9VVzl2YTA4VHVrWTgzN09aZ0QwNnRPdFFudFFhclJPaThiUFRvaGRPVzB1NHpxZ1lpbHk1a2UyRUY5VEVaQVpEK081RGppTnRhYTZUVTQ4Y1JCQTFybkpJVUVGRzRyV3RvcHRqbFBHY1Y0ZGlPMEF4eEpsbkMySW5aQWVMazdLeFdiYjliUGljNzdad29valpOWElPRjRTNnRyS1U1TGQ1YzhweE15SzJlbGxKS3MvTktzd01aT2lsYXJlU3RqcnR2RlZVU1RZZnowU1hNU1ZQMm9Vc3lXODZvbktVMm54NC8vdjNaazA0VExNK0pTdmpJd1BjRVIvQitmM04zZXpoSjJ1OTJ3blB5dGU4bW82MGU3TTJkTmZPVTdnNkh1L2UzNi9yd1ZIRzR1UjZoWC9UQXpQUzZ0ZE92WUI3MkFHeXhpQUNEUEtEVDd2N2Q3V0hIVEp5MXhLRkVzMWNWR1BiQUlKcHZ6d1RwQ1pad0VMR1p4MUIrc1FwZXVkZzI4RkNuOHpBejRtdEI0VmJHcFc5bVUxdjdCRVRNVG9NNjhVM2d1Njk1MVoySWhZYzRQVHhjd1N5aUhnNksxdHE2TkNPUkpieS9kZmE5S0c0dDBtN1dPSy9oVE1TTm1ieTA5dTgzNmRLbUhwTmhJVFJLTENJODdJdkRRbEl4amVPWVIwOUFOeG5ubFhnOVdhZVg1RlhQcm9GZnJtNFd1eVphdGltMDJCQzB5YmlBQzFpak5kdVVHcGxGVlVWRWtvcFFLSVc3NnZ5UVJOSk5neVdxRWc3bGREZ21xNmhyc1FpMklBU24vYUhXNXNSd0RTRXd4NVN0Umh1QUhpSUdwS3RQWHlSYUFKR1I5TzdGUUpaY3VTdlhvSGNmdzk3QzEyYkJyVFpWanVyOVZaRzVGbVAwd1hrNDJscERsU2lucEtvc281YllReEFpMHFwM21xaU5pa1BqNUt2YzNxcXhPVU1ha3plYUQvUCs3bVptSmxoYlMzTnY2NlVnNzNLbGNLQmFhYTJWdFVyVU0xTE1iWWRhS3J5MVFRd05uVE43VUxBYWVhdDloNDlvNW1HK1h0UlpVTmV3cDEvTzRMU1RIS1FwMldBOVFvSWNqamhPdDdmSDVHZS80UGF3ejlGYWhDYTJSYm1aSTVpZFZLZEo1L3UzZTliNjgrVjU0Y1BkUWZ1WS9tWHE2OHpOaE91MGVYc2dBd3puMWh5VVNBQ1AwS0hscTNOaXpubThWdWxrYTNHQmRkNEFDQ0hlWE9MU0VDMVNjdTM3QmtnMVVKYUhLRnBxcmhFWnE2Ukx1SFJ4MEJ6UjFzdFM4MlB5eXVjZEZtTkwyWjE3TVVCcjQ2aW1DNk9Lb3FvSHd1cmlVVU9Vd3dBQkU5QUkzbng3MHFHVGhnandrcDNDUENSSFJGUVRRVVBxR2VYbU1YQWVhN1VRMkNnTGVLeXpyQzN2MDdGVzN0MUtQWXYyMnFJSUpmYjY5bkxSQ1JVUm5qTFZjdlNZOS9DZS9lWitVZzRRMWFlelN2UXVia1NnUVlCb3dTVE1pbEd5QTFrSFpzSWh4R2JSZDNLSjErZWFKamhPRExDVDlGS3dlM2RiT25LQU9Ld3B3V28xSjdoNUVMZXNHazI0NUNDNGNpcHRuNjNhN2lGMitIS21pU252RGsrWG1nNDdmM1E1M05hUHp4eVhKQmxHdWlOaWhSV2pjeWxHaVRNYWFmUFl1WWNESVVRT0ltMElKNEJjdzZEZC95YmtSZDJVbFJIajNYN0xNNVVJSmtJelBaYlBjZ3RKUkFGV0I3TzZOMHBSSzdoRk5NczVtbHZlN1NYcVVWV0lFS25iYWlKVWhhTHBpYXV6VUdPVkNJSVJYNGg1L1QvK1Q2cDVWNmx5c0lxbStmMS8rVjI5UEZlK1hiNmNwdHZ5eVMrUExVVU5abkRDK1FFVXk5cUlWc0VqSm1MSzVJMWJRUXRCY0Y1M0FhOHR0SEZOOHB5TDJOcEtZMDFjVmxsUGVhMCs3VzJWNXk4WFRrbWFoam5XeDFPYXdvd2xMSmlKOWRma0Y3ck52czc1L1krSDhsU25MTjRRVkh2enEyU1VkYS8rTDJsT1dCL0tMNG4zYVU5UCt2OEQ0TGplSURkWTY1WWI5aGRsVksreFFhYmp6VUZObVlSZDNlUFZlVzRrdVJET28wRG1QZjhjbW5OcVlFbUtpR2h1M2twdGhvbFpPaDh3d3hlT05aZzRVKzF4cENDK3RrejZFemFoNjl4cmtQRGtkQ0lKaHZ2VXlYR2plZGVudFdQSUF4QkZvLzRhTG5EcDNNcmViZFdlbytnVTFiRHVjaVAzMWhldnJ0NHMzeHlFTStsKzc3NDJDTFhXTXJXQVRPb3h6VE9ENUhLeEpha1dDSW1DcXEyMk5aMEFJZ2VERUd6YnM5YXJxeXAvM2VSNmVXMmgrQnIveStvYk1vdDd4Y08zejBXRTBmdk5CdTRaYlRQcldVU2ZPaXJidVBQdktWaFV3R3dTbk8rV1N6aFVjcjQ0TVpXTGFaN25HMlkydGRLbTI3dTVSYit3enU0a0xKU0FjSjFRYk1DdHhxalJ4bXY3ZUNwNkltK3FHL3A5T3lpOUhEYzRmRmhuMHY0V1hNWENHeUNKK3NpTGlkbTg5b1JWM3loTms1RElLQm5SYUdYdldJV0NmU2RSQjFtSk5LaHBid0ZXTTNKM2Fpa0l4SG4zVDk4ZEd4Ny91bWlVT0NMYTM1WlRreXpZSlpWZzJSbGJ0U0FTVFRudjl6bnpwWjdoNjJTOU5rRTY3eEtXVTVqeUxQQ0RvSlFTYkhXbFJhY2MxdFZhVDgvbktzeDRZN0ZQeTdLV3hpS0o0VVFrdTd1YmFiOC8zdDRsZjljdzUvS2huaVBOdnRyMmVmWFBVZTkvZUJCYjFzWGkrNG5MdWo0c2VqMkREaVRZUzhKdDZIUW9YdGw0T3g1bUs5SWlDT0JwdjUrenJzTERkaFlnTUxWWEZ6QUJJeERoc3Iya1ZpZTRRM2FwYTlINzFhWEpXM0VQWnUveDQyWWs0RW5XelZ5L3RlbDhuS3NkSk5FQUExUXMwTHBYSmJ6ZkxNQnhiWHE3Yld1ckx0enFhMDNuWUVlZlhBTlFHWXgyZ0tqNzA1ekNyUkhjd2lKQTgvRitBcytUY2l6MXRMcndDNVU1bWhNTGc0Rld5TE9BaUVTWmNxWFNuUXErdGV0aEw0aXVnQnRsQ0Z0OFRlM2JodXhma1RVQVNQSU8yYVBZQmdGR1JDeXNJZ3d3dzVzSGJGU0IrNVpjUjFMWGtNT05sU1UwWndJazVoQjVaNTlLTVV5NnE2bldaU21GVlhmcElPTFZpdDY5M1JNeG9WU1BubmxnY25odFVBMEtKeGF5OElGbHBnaW5NQkppQnJJSFNGTEhBN3dhc2x3REhZT0ExWUxuRzdNQ053OVR5dUdqdDBKRTBaQzdPOWhEWkZKSlU2Z3liOGh4UkNRV3BrQWMxS09pMnlBbFdDYzJabzZ5aFlHRElqanREdThuM3NWZi92NlpOTEQ3WXFlUHJSb2tpUitUTjRRZ1dqTVFxdWJEYmplbm5SY3I4S2JkZXhkNW5uTmNubk9pQTgydEJaTjNiYms0VElnalFHbGU3UFBUQXMxWmQxVnY2R0ZaUnZjLzZqenJkUGZqMituK3UvdTdBL3ZPM1pZUDRhY21rNkR4OVhBTW91QTMrVTllMDQ2ekFFdGJIcC9QK2sxdjRXbzAyRW9IVzNpNVgyRW1Ea2NRRGVKamtJZ3EyVnFva1pOWS9iWVNFYU5KelJFSU0rV3hlVnBxVUU4MEJsakVpVmpTanZZN1RXZ09yZ3d2ZnFLTVZDQlVhRU0vRU9IMUV6aUlreEtKZUhUb1FsaXdFbFdXa0Q3Zzh1RnErR3FNcFVMaFBzNi9SRUZoU25HRlVQYjdmTjhmajMrRXV3WDVmTmp2OTlTT3V4bjFjbmt1TFFLc1hDUlJXQXR0dEpnN3RXWVE4cGhqaklsZzFLeDFGU0p0TG1SdjA0QU11QWRidk5pWFgvdWFBMTloU1BvUFBvVTdNU25jaUNFVUhzNFJpVlUySDBTUHVsblhXSWEzRUVtaXpCRWU4MWkraHlTS0lHZzI1NXZsSE5WZ0tmTTBoKzEyQzVrWDVFVHR1ZW5OMnp1dU80cnc2c2lEWTdZeU5iY2dqWVlBeVRpNlJCcEVqQ0JtRlRiMVNEbHJaQmxNYlhyUnJIVzNVQWN3V1NNSXRVTE53OHpFQWRabVp1VEVERzhZY1hjU2ppQ0ZDRi9wblgyRjRnUmdwbXFqb0JMRTRFd09zSmM1V1RpRUJFd2duZGxhVGlpTEsvbjVZem4zclNaUjQ4bE9hMUE3TDBaQVlMNC9LSlAwVndGaVloVkh4R0dYSmR3alpDWXVKa3c2OFFYNjd1N29PdDNkMGZPS25aZjF0SWJtS2ZIbGVIOEhQVC9PQ0Rjd1kvOXVudC85OFBiN04yOFBTY21xZVRsZFdxTG42dnRxd3dGQUNJUTN2N216TDZmcC9WdXVmL3Y4NmUrUHBickdsUnI4aXFSMjdaeU9Za0kvZjVvWlNQcDZLR3p6NWxKNEt4Ylp5VG1zRVNIZ3IyZkZZR2FSMUNJbjVoN1RwT0E1V20xRitlRjVtYXAyUEUzYVQ3Zi9MSXJteEN2SGVubklZaVZLYko0Q0lteHRqYkVtcFIzbFk0Wm1EaWZVWmVYbHZCcUVDNHVDSkZvdktRUyswZVJTdE9XMEkzSXpHMjZrU0VRdzZWUWlqRlJCdjRtNUIrQU9sZm4yTmtzU1RIT3ljSXVaR3N5Nkp4c0FKUXJVWWxTSlU4N0NNbmdwRmlwYTNOd05WSVVTRThKdFpNWURSaXdNYjYvUTFhOFlSdnhDZUw5ZXdGNVpoRFZnWUJKMkM5bjJ2TVNoQkVya1lWNlgxWXpXbkhPRTBEVHN2SnNQSWhBdGdweVluTlBoR0c1ZXdFN3BNTDA1VlhwbzFZV3RJcWViV1ptY3VzZGVOZ1FZSzFNVGRXTUhFQW1Cb0Jkd2dyQ3lDS09SSkNFUFpiUnc1alRDQjNIOWU5K3Zjcmc1V0ZZWDlUVlF3S3J3cUd3aGliMk5NanF6U3E4SmJ0WEpNY1NLY1RMUmxNWkVBQkVnNVFnaWIxbHFhMExLSUlTRHpBSHd2UCtnRWtRdVVBMUQwaUNpdGhSZkhtc0lBdlA5cjNickdyRVNKSEdFa25JUUs2ZkRuY3pIUFVrQ3oyOS8rN3p3RkpydXZuOXphR1crdjBPSjJNbGpXeG9uWlZDOSs0Y0p1L1BQUlRnYVQvUCs3ZjI4LytFZjMzeDNuQmxPam5aNS9IeVd3NXRmUHRjM00yMVVTR0lTOTBLSCsrYzZ2M24vL0psT0h6NVdFdEkrZWI3MkJhL2s0ZGl1a3VzWjJxMDFoM1FJOVVzQnBwUjFUWWthNEozQzd3RjM4S3NqRXJGb2Jwam54QW9taGxQY1oyYTVFUC8wNDN2TjRkR2FPWFIvczArWkkwUVdSYlhMM2YxZkh0YWtDSDY1Z0RjbzFIaVM4bnlZSXUwdFF0aldOWjhraXNNYmV5Q2N1Mk9tZXlqd3FvMWs4RWd6QkdiV1cvQU9sMjN2VERTZXV1VGVITkhNS0lKME4zMi96eFpwbDQzRE9jLzF3S3UzMmlpUkcybld5a0VlSUExWWxaVDZBMXBrSlFWSGF3U0VVK1BVVStjUzE0d0xNNFZGTDZ6VHQzNWcrZ28zUGM3UUp0cmNnemhFQjVpVEcwaXk5cEYzc21yRnJWWUR4ZnhtRjB1Tk5PYStmYTVoRlZZQWhibEZ1TXh2b0x6NENvZzF0bHI1ZUtsbWF5MjNQRTBDblo2SWtMWEhwc3pEaWllZWc3bDZpNDVGQlNJNHJOc2FOdzRHVlZWNDYyeHA2WU9uMXdqcnNMNEJpZFRNWGZLOFVNcXREQ3l1Q0p0N1NHYXYvWnVpQkpFTytJenJ4bHc2bXhnQVUrV2taaXBFNFIxZk1qeEQ1R1locENCM00zL1lIeFBkL21wK2RvZFExcFlTT1lqYnV0YXlYc3J6cGZXOVlUcnN1ZG1xSFJvWkdVS2U4aTd2N24rMXovdWRCa0QxN1I4Ky9QMWhNUnkrZTNjM0xUd2xJZUZRYjAvbnBvbU05UGI3N3lMbTkvZFA0VHp2YjQ5M08rWDk5NzkrczAvcTRTZ2Yxb2ZueFhXbjYvTVhUdGt4TElnU2lIWjZtcnl1czE4Ky9BYzlyQ0pvOGZJRWptczdieXV3Y2J5ODd3TGhidFU3a2QyOVoxOEo4THFjejZsVFdUbmd0Wm54VjRHTEhrOGhvcVRVSmI0RVFFVm5ZNU5mdnB6MzV5RHhDQStTZkVvbWdMQUpXSE1wRDZjNjc5aDFCSit2MHpVZUNKVXdKd3BpNzFGM24ydE96UXpoWkhEdWtjSndoL1hheEhXWnhRaHZoVk1uaFFTRkRlM1BPS2gzaDBiVTF2UFBSUURlM1I1dkVnWGxMQlFla3BKZ2ZFeERpc1ptNGQ1NlV0UmFuN21JcWdZOGdsakVIUWlLaFRVSm1IMW9sWmpDZXFYdlcyeDl2eGwrUGNRS2dLVlhoN3NPUzJoYlVXbktjMkxpVWlGaTFUdDhtRkxlSFVKclVEZkJ3OTNERzB4TFEwcnMwVUFXT05UTWRDNEJXWjZqckp4VGRXOUdrbldlRWl3UWtFeHd3QjFPNURWRW1hNTJqZEcvRE8rMXlpNFRkWUJFeVNobk1nK29wQmNkVGovTGQ5Qkx4MTA1U3c0SGhRV3loWUVrbFFpd3FPTjZMUFJnWnZpcjVObUx4UjRBcWJZTlFxVGRiUlVCOG1DSlliQjBkeitWQytYRDhYSy9YRnBqUUVkWGdkYUhjcjQ4TDZXQ1BEVEJUWTg0dWZSSGlXc1FpUjV2djM5M2R6ek11eWtSRStJNytpUFY0c2czdC90a3hWWTFWN2ZMNDhmQzB5UkI4cHZiRkpCMy8vekxXbmgvZHpNbE50ZkRJU2xIV0xzOC82V3N4VlV4djNuNDhIeWJUQWZjbUR5aVh0d1dvL2JMbDUvK0VsOXM4aEtzM3lha0J0SGo1YWN5bkQzOUZBMnFEcEEzNTRISGNLL3JSYlBDRUF6VVpyMzJNR0JQSStBWE1KT0FjZFB4VW5tK3JDWktkQzVtcmZiK1U0QWw1U1FSZ0xJVjhzdFpRWGxpNTFmem5GY3hEbXdWcVo0RUQyQ3REZzV6cG5BNGQwRTFXYUNaaDc5ZUJHc1MrTURzZFgxbjlFTE4xcmd3OCtqZ3ZtaGVnNWp6NGNiQWxMT3RlN1FnV0YxcWx5eFVWWVl2aTVLSEdkaEZSUktIaGdnVFVZNXEvUUx1U1BhTG1tZU9MZGtDOGNHbGptOVQyLys5SVJMWUNxNDhmcmRDQW1aaVlPS2NVeUxpRnAydkZyMUtOUHNTN3F5SVFjY1F1QUhFMWlBaVRnNnl5cHFwcnVmbTlGaGJ1QnozdjRoa2NOb1hUYlBheGZiUlQ3SXR2TlZTZlE0UUMwRmRyMTNsRHNBbjZtVnZ1RHY1bEJJQmFVZnNSRjBRdmowYk9wdGd6RGdzQUcrZ0ZrMUtvWmhMY1JMcHlwck9Zd2dFa1h2djgva0d5Qml0Q09yVUNDWm03U1ArSUlIMkNabURnbE5tSS9lZVpJMmNxSkpkUGs3Rm1uU2tLMU80Sno5Zmx1Vjhtb2poUVpxSXBtblNDNDlKSVlIQU9oOStQOC9la09iS0JQZVVrckFLRWMwVGtjY3Fpd20xMCtOVFNKN2dLYi9UcHVTM3Y3Lzc4aVZ1N3ljNmNVeXFjVkdIMWVjUEgvYWlCS0RSZlBpMHJIUFRFVFpzRFcwOUZaZlF5MzljZnY1bHQxcTBna2twTERaN1htZStkbUYxZDJmd2xqb1BYUTFrUmpOMXdMR1B0TVEwWjRLd1Y1ZmtqeTYvQkk4dmhBSk9TQ3VMQlZlZVlsMXZhSm1KaHpaOVBWUHozZi95N3NQdURjMldQT3hTbnBkS011OG54akt4MWRQSHoxOGNlenpldjltUlM0S3owNlpQQ2xaeXF4R1krZngwQUlUYlpYbGNWL01JdEI2TWtqb3JpTGpBemRGZHYzMDcwekJsSmF5czFvSlNDU0tHQVZtWU9acDZyYzJxY2F1QldpTVQ1OTJPaXFlY1VFVFhYVjZhNVp1L2dpbVlDVUtsRXNNUTRCbmtUTTFJMFZSRlo0RllDNUJTQzFpRVJmTFZXR3RUa0twRXNBUklOVS9YTWtrUWMxaEl4NHRJV0hSRlFyOFJKWTlKbTA5T1BsbHdCQWxMcy9BcGtUdWI4d0dsR2svT0xCRTQwbUpKT0R5WUlweG02WHFtRklUbnM2cVZxb2U5WW5mTUZyZm5wMWJhdEdmL010bHFsRE1mZG5Nc21GSm1qbFpibEZaV281eHR2R1VxYTJzT0dER0NFRXdzSXN3c1FneWFkcG8wNVNrZFdtdk1NWVFQSW0xQVE5cEFtREdaM0t6bkNtdVRvQzZQTE9TTm9TM2NpOFhOeFJKV1RGWEZHNFZGSjlNeXdtTWpsekhNUXRNNWNtSm5zdG9zcExicHRMOTVXcE90SGtnd3lKUlJIazgzU3N2aUY4OWFWMG8xZDJ4Q05hSW9qZGR1d09Ba01oMk83K25oRkVVS3hDRnF0UDloYjgvVnFIMUpOMzZKdlo5TllyRmEwenlGRzY5MWQ2Nzg5S2UvWFBaRUJKcnVkYmVyVFE5eXZIK21tVStQL3JTK2N5dzRsSGo2NERJandocXhNSWw1d1VUanlOcGdxMDl5NGVhWGgwYzdQczdUOG15SEcvMGZsR3Bmc3NpdjJNU2RVTkVkOWNRc1BBYk41NXM4c3h0S2hYQXpybVA5dWtYb0hFVGhvS1VHMThabzdLQUl4N3FlcVlTMGZIODNCOU5qWS9Xbngvci9VTm9mWmdVbmNscytmYkpTRndMcWRVQSsvcmhxUm02dFBodGRKbVo5Q0JMeGRYbXFhOWRqanI4V1lTTGk0R0R4SVZsOStlc2w1b1p3ZDBRTEZtRk5rdVJhZm9aYjQ3RzZwRUdaNDU1VW83RHBhSmZWMmNISmxhdDdZNDNtNDM4L2tXUlI5aDU4WWpERU9sNTJyQ3pOdVRuNklkT0hBZVJsNEh5RmpPZ0FETVNHNzJRT2dsd2YwK3dVL2Z6STF2T29pVG14Vng2SDZpbGtDdUxhNlNKOTg4Zk1xYTlRcVJFalBPemgvWS9wZEVhdTNHUVhVV0pQcUd0b2tFNTVualNwVWxCS3V3aURvVGtsTWpEU2hydndBV01abjcwempkZmZrU1h6RmlLN3VYa1F3czE3dnJVZnVYbUFhQkhrcExDRyt2MHB4TlZhWVZWd2VBY1dFUnVKdDRJdUx1WjJsVlNNMFhiWUlIYU9vUjhuSmh0ZkdnakZlaFFnb3FjTnpRTDlUdU1oREVDcTF3Q0FSYWl0RnREZUEzVnoxN3U5NE0zNTdjZFBqK2NxeHNJa0htNGVMUk05S3FZb1QvL3g4QnpwY1BjMlpWTWxvclZhZS9qNTg3SlBVM0xKVTJJRU1YaVhkNHZwajcvLytWMDczdUxpLzFlWmRRMGxINitZeHNlYmMydXBFUkgxSGh3cGlIVTUvL0swbWgvWFM5emNIU2VOclRxMHFVeml0VkV3Um5NMUlLS2FNcEt5Q2x5dXJQYVZEc2VkQUY1S0VyT29ZNTU0RGRQM2RTcXRKYVJZY0RnRDRWSEw1UlFyc2UvZnZkdXZUS0pKVVphekVwOGZsV0NNUUh0K0ZvNGxxUlR2ZC9hWGdQUXdCcTNGbDhTYVBDQ0NXczVtblV5NElSeDdQNytIWGthNUg2TmhTcUpLNC9SY0xNZ1FOT1Z1RGpEdjZjM2FXbjhKNUg0RnNEQ3pzRWhZMXFyVHUzTkJlQzNzelpXaThVYUphUzB4UEZUemxJUmRRc1FBSHd2UGNLSUljdzVSZGhmeGJUUTQzdk8vMWtnN1hSTVFSQlFjcU5ldVF5ZkdpUnRERUpvU1hUa3lBS1hwME1xNnRvbTZES0VmL1lTN1U0ZTVmeVlXLy9NUDM5dWYvM3IyeXFaSk10ZW54NVhUYmk2U2MwNUNNNEUxWjRuV0FtakZXZFU5S01FREpNeGRLWUVTbzRUU2k5VVFGbVpPQXBLa2pLZ2VRV0Y5dXppRU92MGpBVkZRS09DNk05emxGWmdzR2d4SzNvU0V2TEUwUVQyZnFTWHZJd3NaT3JxTkZXWkV2UGs0bVlnblJuT0FHUUtoUzNNUHNDTmNpTUpicmEzNy9sakRyVFdld2l5QVdKamRvRUlXNFFoWHpmUHRyZGl0bmIvNytQbkw4bmxwaG16clh5M3kwWFlpaldUNTlQYy9SNnNFc1BUWWJkU3NXcDQvT2Fta3F3QUFJQUJKUkVGVW5oVnBrcERkUWNrZ3dtbmgvZTN1N1hlM2oyYXhTKzM4Yjg5dmZwTWI1MHRFQkVWWVByNEZLbnVuc2ZaVEZ5T3NQWDg0SjZwUExvZGYvY092YnZUNnNMME9kNForY0ZTeGpmcVlsRmhTYWtncXdnR3dEeGg3U2pvZGtyVzBScVB3c0hHMGZpMjQ2cTA1dDQ2TjZlR2hjS3V0Y05QNU1PZlFTT0sxaGM0Vlhob1FFaDd3RXNzT3paTlVadzZYbDZkd3RYQm9raG1yV3d4elROVFdyeC9mYU9ZOEVGRndzTmcxMWpLVTNLeEtidEYvQzBMaHdTb1V3WVRxeEJyaXBUbFlXSlJGNE43UGE4U1UxcFZaRGpOL09iRmVQajBCcU40Q1NvTzRVSTB5Q1l2bXJEeXdsOHdzMFlkZUhhZm9MVlFZVUsxYnd1MlZnbmtNMi9wUGNYc005elRONWcvdURTRHU2UVdBWWt0SjZBQXdtT3gyL3ZCaFBZNzVQU1A2bFVYaHhJRWtnbkRndi8wMGl5M1ZWVEJsVFh5WmZ2M3Vadm41MDY5SXMzRFFvUm1wb0xWU0hLMFY3aStMSkJSQnhDU0VYaHp3NkZiRHp1U0RpaENMYXFUOXBIUStwNTV2OThTc3drTUJ3MzV0S0Uzc3pqdldtTGo1NUZYTkdnc2hJRnpkVXR2UjVYUm0yMjBjaUhDQzkwYzA4UWErRHdqQUVwMUJNQ3lDSnZwb1cxNjYvOGVzTGt0cFlyV0NDUzdHeVNMTW1sRjRJQ1ZxNWhaTzJOM2U3MUZybStTWWI3ODdsNzgvZkQ0VnUzeDVDamtrbHdsd1g1Nys5TWQzVStMS25SczNsQnJ0NlNsdUpMSFo3bkNJMWgrWWwzVC9tOS8vYW9vRWEzNzU1Zm41US96RHZBU2IrWmdjNmEzMTdwVnVvc1hFTFZaUXVaRDYrdjZIMjkzNzMvMUdSOVgrcFhIdjdOempnMzAvTjNhaVRDeXFTRHlnM2RzT2ZxTG1rcHViTnladjBUVzNXMUc3WXlDQWNQVnVodHBRYXozc3l6S25jRXE2MWxwS3NhQXpxekFUUmV2ZUxldVJyeDZnNzRSQmVnMTJud0VXU1JQTUFiZXJLcGcySDRFN09Ycm4zZHJtOGJ1V0JEcU9zaU1sU1hTM2V3SFlPOXl0T1NzUktCa3ozSnZMRnE4UVRwcDJ6c0Y1WDZiZEU3ZHpnYXF3Q3JsN1piMDVDSWhUVWc1RWN5Y1c2VVVzb2tna1NtaklGcFNneVdIUlc2c2JKbWZUa1RLRG1BVGhMWHJpdjJOS3Q4SVZpTUJDTGdGaWlPajI2d1N4VW1tWTkvZUhUOExCNGU2Yi9tMFRCQW96T1FYZDFoUFB0eHdQUkNMZ3RLZjltK2xrZVE4U0VhRzVsUEIxV2FVMlNKQkVPQUxDTWhDWmcyQU5EZ3VRVUF4Z3VaQXlpU3BOT1pHNzk2M0FCaSsrdnVyUTlSOGxFZE95WHBLSVRrNVQ3WEt3NXFKUjNZTzVuaGNOQll2MGVJZHpSRFNpNEdCb1A0cUhCRlE3d2Fkcld5T1owTE9sU3BEaFZlK01nRmFsdFZJbDZSUzdWRGdDY0JPS2dJZ1VjeVBLVTdwN3U3TlR1Skh3YnVmeDYvT1hoODlQcGN6V0JiOExNWGxGV2xJbXlmTk1GRUdzdm5qOStaY3o1U2x6NWNQZHdhc1RLdnpkelkrLy9VSFFBTTdnTDk2ZTVISnNqYzM2MDRkcXpIZUdTS0tDR1B0UWhOUCs3VHVvOHRzZmY5QlNMNWV4Um5vQkpqczVPY1BaTjU5UjUrbzZpRm5BQStWOEhRaXp0OW9IRjByYml2RzFoVnZDbkFYRzBqUExEcExlZzJBeGxpVGsxWVhEUXFlSnl6cXowREQ0d3Bzem1xZHdqMEd3dUQ2QmhRenVWZ0FSbGFSaWhtZ0lhejBkM3AvQkRqTm02bWh5cythdjBQVzkyOUNzUnJDSFZVczVEVnhyWnhxMHNselcwcURzd2hCMmI3Vm91Qk81MU1NK0tiVUxXa1Fya2U2bDZSbktKc0pvNWlWMjkzTlo0MmFhbEhvbVBmb2oyRFhDblZYSk8xbUpsRVVFb0N0SzhJVjBSZDVGZE13SXNHRlFLSysvZTlxcWx0dURSVldEQkxBSWtNSkJYdVowbnlzemRVNmdSUkIxM3JRd05RbEVFS3RhV3hmaEtSQVdubWV2UDFXNis4MUhkMnVOc0ZwRXROYUtCUk5rcXQyN0s4eENDQXNRY1RBUlhQcy9KMkptUVpBU2krb3M3TVJKZk5RanZlYzV0dThpdG5SbDR5eFV6eCtKeUdYbmxRVkNZQ3BHbWR4YmlLK3JlNnZ4MGhrYnUxLzB6dHkybnVJQjN3RXpnMXVRNVhnc2VhWCtFZmVESVF0WmEyNnRCcXhWNXR3Y2lGVGhEUkVrMlJ6Sjh6d2ZEOW1JMmFLU3FMSysvU2Q3K052SHB3Y0thLzJpQzZ1UmlleXlWRFAyc3E0S2IvYmxyeDlwbjNZVGVQL3VMdFZvQWQzdmYvM2RQeHlqa1lZSGszdkQ4dkJ3WStiTjNRTnNVb0wyeGJvR2lvakJmU2VPOUM3ZVJxYkRqR3JsUXgwcitaY0xlQk54ZUZ4ZDFaMUkxSmtuWFdCaWZKVW9OUWg1SlhGS0ZFN2lFWERpVjlBeU14SXlzMzdQMjRUVmErdi84eloyMEpweVR0ckl5S001YUE0d2g3TzZUWWw0NmpKSHVyNEdqeWN3bW5QS0lzckVpRDVoRFpmTlJIek5OUTNDYWYvMytnS3MvNHpjdzRuVTk2ZlcxTDBwRUdpd3NGckxzaFlMRVFJb01ZVzMxdHo2NlVTUE54VlRkamIvL1BrSmVZb2xnemxBakdhbDVzZ2F0Y2s4WjZXZTU5eTZCc3pqRnUvQklnUVcyVTdLekM5ZTdLdVVhNnRsdkpKSHZYb2ZSbmZMZnJOY2M0OElFbzRkT0syRW1WVEZ5OUx2eGVCaHdRc0xZd1FKUGtsT3N6SS9FaE1rNitkODNFWHhGbUcxbW0zTzQzUUd3MEhpM0dsSlhjaXU0ZWlGZzVBUi9lc1pEbllXRWxHZFJKaFlwQTduQkkrZ3pNaVZicWNHWWpablZ0bXAxVHl0cFNkbFFkWkl0QlZqOWxwWnZLS3FOK1VxbzJuYTM2WmhuZXBMRWF5cGpsc2NnY1RaWVk5bjVUQVFoWXlFRVlkVkthVXNtc1FpelhsWkdqaWxzTFVnZ0NSZ3c3VC83bjUyNHc1VmtqVHAvUFo5ZnZyVlQ1Ly9YS3BvV00yRzhGYldHL2JtdXR2UFlIZDNaM3YrK1duYUt5UGs1dDFjS2hGay8rdGYzZDN0eVd3SE1PQzFJV3I5ZEp2ZG12ZVNnWmduSXRJSUQ1aDVWODJRQnFidmJwdElUVVJVUDcyMGtmeWJiYU52R0djT0gyenpjVEZjNWQ0QUNNWlRKbEJhVzJPdnJ2MlhOdHFmUWVDQjJxaEdBUjlndEFDWHpqUDJDdTIvcG1pbE9xZUZXSmhZem8wb1BFS05VdEs4RytIazZ3QzVxZ2VKYWdXbnBLeWRYWng2Vzh2SFEyd29Ld2dFZHJxQ3FNYlNtd0lPRGxJbTk5dUh4NWh5UHdZYW9sNjhlV3VnT1RSUlF6SW02bzgvZDNhanZFOW5tL0pVcDkyWDgrWHV1MHV4U0NucVJHUVdWbitvaXViNU1DVVZqaXZhSUFJa0lzQ0ozSXdsaTNReUpiOXFUUSt4Y3ZTYlo5L3FOZHI2bmVUWEpGWGZnRElJenVNck5MZEE5TkVMTVNEVFROVkoxMEYzM25KTGphSURBYnBzRC9ONm1oTXRGeEpSbVk3SCs2YzFINmVIVHc4akdDbHV6WHJRcFkrZ1JCQkJsQWFEc1hUVUlRM3Vnek4xdEJpejlDTzB6Z3F6T2xReExMRTF4WUpla0RBVXM2MUxtbTdlVHVXNXpablh5Q2xSVC9lUmFuV21NQmNpWTI5TjNRMFFGNFNPWDJqdDUzYUtnREM1VzZkM0JvTURmaTVDNFVRY0VnaEFPS0sxV3RiMU1SMzJjMzV6WDU3Y25TQmF3NXlKMUZtQ2R2dGYzWWxWUVJjRnFPTzNiOS9RWEJkNWUzcGVXYXJ2YXlSUmlnRHA4Zmk3UHh6Qzk2YUNrNTArblc2MG1RVk5FeTFCek9uKzkvOUk1R0NOV0pXOVhDelZ0WDY4UDFDaGJiYmtpR2drYXdTNWV4Z1RuRmhUTStaNm9jUGhZSjhlQ25Tb21HbkxwQ25DT1Jwc2U0M2NXRVBvTDB0b1JpUmVoOGtERWcxUmhUbWFrRHByRjRwZWVYTUZBWDA2a3piM1ZwQU1BRW1yeHd1UmNKUnFSbUhLb2RiSVY2U296R2dCaVdxRXN2T3ByWE9icFY1NEd1N2JmdGJDcmpCeVliQ21hRW5ES2RkU21nWGNrR0RFY0djSUE0SFVtbWh1YlhzZU03eVpUVnlyN0VCdmZuanowOTh1dGJJeTNJd0NGa3lTajlndEYrZkpiV0s0Z0xBeWMwRG4zZEtZMTlKMit1VlpmcnMzbDV1RHVVMzdzQ2JwR0RlbXVWVFN0NWt0Y2xzT3k2VVJ3VWtKVVMyb2s2bzVxVkpBSkR5RVdNUVk4T2pReGdnalp3WWlRYnVYanlyM1dpTlRMK0JtcGxZcUtCaGVnNVc5Q2ZlTGpvU1pEOTRnaWJDM1doRkszbDhreElZMWRSVm1ZQTJGMk1sTFhXYjJ3L3ZMNDNQTC9QaDVUV1RWR2dqWm0vV1ZZQ0NZU1ZtNks1STdvWDRhTThyTUhXOW5Ja3lrbkVsWVdXaFdKUWNoRDFLK01nQXpwTEZCMnhxb2JyTHppOTlkcG5OWjJqbG5MNnpteExMOGRQL20rRXl4TnRGWWlWcUNWNXQ3MVRCOHZQeWtIaU9NWEpGamFXQ05Ha3hCa3gzYm4vem12eTZVS0Voc29VbkNLSzBXejQ4V1MweDh1SDEvZDRxTEJjeXFaRkJJNHBSVHMzeDROMWt6RUhDUm96KytmZjhIayt6a1NYYjM2NldZbFJrdGxvc1lPSGIvK1Y5dWJ0aC9Sc0pKZnY3WGo0Yzk3NDVudThtWFJ1dFpmdnMvL2ZZZEorb2VLMzVVK2Z4TTkzSmEvN3o3WGJORWNDTk5aMElOUVpXd3pZRVN6b0p6VERNK1BjU2Yvdmt1MmJNZlh1cUVZN1lUWXp6WEIxdUIrTnJHdVpVZXR2L2FpTFFod3FOUDdsNDJTUDBCMlBWbEE5MERpbDdlQysvOWNrVmJLempXcmRJcHc2NEFPSUpmWGdBSEtKdzNLNE4yTUtLL2xCUytGaE52UmNqV3orN3MzdDNEWDljRW5EaVdPcjk1ZXplejd0dlR0b3dBemRjZWw0QzdKNWtRMXRoTU9DS3FNSE1pdWx6bzNjR0RFNUV3d2V0S3h6MDlQT3pXY25LOXZWZnBQL0ZUc05iUy9BVy9Sd0lDWkFpdXg1TDN5cUlNZW5HaWdzZTcrVlh4R21OaTVHUFAyZzBaSGkvL1BRMk1QNUZiSjBSWWtEY0RzVkFBUHBqcUhPNklnQkdyazlOdThuWDV3c3ZGOHQ2ZldvWVBEVjJYV1hFakZTYUhqQTl6V3k2M1BvenVLeHhpMFk2VEUyRVc3ZnNpb3Y3R1BNd1JHemp0RzJBM0t6c1RuUWp3eUlkeFp1dkVTd1BaNWVJbzdNUERHSUZ4NldLYnhvNlZWUDkvOUtIekNMaEpudjFMNzNLNHFVSVlWcjZrUnR4T0QzUE80bVZ0OHp5dDFrVTJuS0JDRkJaNmZIT3J3WUI3aU5TcTl6OVN4dk9uaFdLRlEyRzl2bXFCMUp4MnV5bFRoSER3Vkw5OFdXazMrMG1QQi84Y2R0TDNkMjl2WmhWRXA4Y0Y1WGMzcHcrM2ZubjYrR2JXQ05Ka3RxYVh0YTdERVVMOVdudXpsczhmL2xibmhHZVhOdzkvVlVkdkh2bDJCK1RPRFIwVnB1R0lwbXZzclh2bFh5ZzhIQjdjU1dKQkVjR3ZyZFFJZ01UTktZMTEwb3NBSk1LanY0TTRkL0VBQWRGNS9JaU9NMlIwN282UXMyeXh3ZjZIa1lCYjlRMTFOMGFiWDVYaEl4aG96WWhCcUsyWmY5V29KWXF3QUVmYy90TnZiOHJ0dVM2MFZSVFJGWmNJMUM3MUlrS0EzYXYwWWtUVklCRWxlaXJweC9ibDRzY0lSalJmYXBnVDZVa1QwLzRtaGZWVTZTV3BOOThDeXhRTUpYQVNIVHh5RENQaGxvN2NUc24wSXUzcVVKRHhSeHdCb1JBSzRnNGlsbjVzNmh0OHBhNUZOV3ZXV1FZV0NMT0EwTlZqNkxSTkZCSGdwaHhvZ0Z2QlVqM0lhM2p0UTVVd0gzc2JuWktpT1ErRTNmVzZHK05GZ1lCWXBYTnBWUkt6cUVnM0laRm9qSmQ1UjN4TE9Sb2xFeEtHMFpvRFlUU3RvNENpWVJIRzB0WUxTVEhCaUxvNjQxVndZY0E4dWErd3FCdkRtTWZqYWRyNWx5MUhBK2JVS3cwaHdTUnoza2s5SmRsVmoyQVJ1QVVUY1dFbkhHN2U3SnN4TllOTExISHo3ajFvK2V2UHo1ZUxSeERZdmZ2VEc2VDU3blpXanZYaUtBei8zRzRsVDBVWWJ0SHFtOE9QdjM2ejA2MitIT2ttZzdPYzl2WDg5TmZEcjQ5c3pyeDUyVGxnSGM1TUhCNU9ibXNMYXdGK3YzLysrYUg5L1k5NmZaVzZlZ05IMmhSWGRWalBUUFNQeVBuMWhHVVVXWW5kVkxvVFBhNGV2VzRTOUU2SzY4R3R6bXhHUklUUTBFaXhLbysxRkJHRmQ4RnczeXRTWCtEMW03SVFiVCtaUGdRaEJPVkxmNWZhMU4yQlZ3R1NqdUp3QjRYWDNzVDFyNnEyMXNoWjllYjd0N0l2N1MvUFBUcE9QS1FTL1kxUk9ya2NEdGxvKzJGYkU4YmxJTmtPSDAvVnZFVXJ0YWhjdnJpbXlySnl4am9iNE9hTnd6d1FSbjJpNVVrNnRKcVpyL2d2WXFiZ1RTdzZFR1d2WldiWHlVT1h4STM4TnJHTWRRSGNaWlR6MnJqWm1iV3VIdlZOa0VSTThHSElET29xWGFhQXVUSFI0Z0tLb0gwamVJUmI5S0RYRmk5T0tTZU5acHRIYjZ6Wm9TTkRMaXhNa3NRR05pTVJxNGowQmJWa2pmR1M5K3FKK2RVWDV5QnlLMlZsVHRSSzJDWmZjZlZvS2NXNVNxNzlsZGU5UDRXOVI3cm9KYXcyV3F2cWZWUU9SSWd6d2FzR013aHNsS1lzdStrNEVWZ1BiMnpLWEM1dHpjdlpRSXhBS055cmNZVHViKy9Dbkx3Z3I2dngzZmR2SkU0ZlAzdzRGWk11dXpjeVJGM1dDT3plM3FWUzhQanpVeVgzLy9yZnl0dFFYZFRiOU92M3FmMGhIVzZtQ0RJZ1NBSEtpUE9rKytjbDJpLzdpUS9oS3pGUHRRK2l4am1DdWlpQXZTMjFOYm5sbVI4Ky9kdWZUNWNueFZaNUhlM2VjZW5GaUdLTUw1cGVRem0yZXRJTGMvREZyOFErbGtnYmpjZGczbDJHSTd3MTZwOHMzVXBZb1dLZXBaUExpRWlUOURhRU1SekdSR0NWWUNLaDROaU95eFRFekRyMUtTUEhxMEVzTnFRTFVmZlBocnYxQy9PbFRoaEVFVjdoYW0ydHpXN2YvUExsNTNuZVFKZE13MUpITFBBQXR3aFNRakRjT2R6Q0N4R2o2YjNXTnNrdmY2c0dJZkdVWklVeEpsN1A2VGpKdnJWd2E2WnJ0YkJXNXY0YlZWRWRwdUQrQ2ZJMlczOGhycjQ4Z2E4KzBlSHFqQkdPSVNMdUlzeVhJZmY0UXJZRVZ4dnlzMzRWZzN3OGdYaDgxMjJFdnhnSWM2YkVnZVpXOXU3UkNud0VtaEFFa1Y2Z1lwQksrd1pIM0VpNGl4MTUwOEtGazdCdXNEdnU5eXNpRC9SYTJCaW5POU0zTktkb3JZQW4wTGxhWXcwNENDVENUb2tFeE95OVl1WUJ0eTdUR2h1SFFjOW1CbEdRdW5sZmhIYmI3NWNsR1ZqWmd5SHpQT3VVQlU0cytiQ29vSjB1NXp4bTJZQ0lvN1dVRXMvM3QvdUZoSTJZNjhQcDdoOS8vWWJMTDU4S3JVWEpPc0NQRGJSZWl2anUvZnNqemlJLy9iUk91WjcrK0NVZHFzeGs5Ly80bi83cHg1dVU0YzJHOUdCQWg1cE95OU9mU283bGJ5bCtMY25Ya0xUOXlCRVlIcU1nUWxoZW5rcW80RjgvL2ZMeDhjeFpYMkpZMnhYY3UyRGJLcGZHdWowQ0VRNlBsdzZKQjBBTlRPRUJhd1llRTk5eGlmQWdUd1Qza2dtRnYvQzArblhpVmcxdXhtNmRMZ3VaWmtFUXQvREczanFDU1RaUlNHeVpUd3BBSktDRE96R215aTluT2ljYUl0bisxNVlORlBMNnQ4SUVoNU0xWHFzZW5oNC9mSGpVbHpFd0Q5VXBzY01kWkFGTjRzYXdHZ0Zjb2dRWWRrUmNhcEkwb1ZtZ3RWWko5MWFlNnJ6Nzd1YnRrYkVXYjZWR3JCZG5DbVFQQXVtd1VIYmNBZk4yK0h2RnRhYnJwM1NsdXROckxlSDJyZlhUaW5tWGhjZDJ4cUZ4QytoTXp3aURtNEVISDNucnFQUlExMGlEOUdKV0E0V1puL3VFWU5Eays4dWtwaVRkY3RIREVwdUFHQUdzTEVsVXVRNE92ZlNpUGFkK2tpY2xBdHl3VGNLNWN5TEk2Q3NNR0hTWS8rWXBGTFh2RTNwV1haakJrMDVTSUJURElCdURpMC9nc2NIZmRxSWRVRDJzbEQxTmZmNzBuRmRCRmc5bW1lYWNGT2FVS09lSkNXN04ybEdUUkUvY0lVZzRKK1g5TVlkbGJUelY4OVBQNjl2MzN4L3c5SFFPMUdXL0VOQXJpZ2hicStEdzVuYWlwOVB5NVRPeW5oNCtrcmJtUmIvL2wvLzFEenZKYVZXVXB0TGhoQTdrUWluankvLzkvN2JjNHVtUE1kL2VKaTArUkFDZ3RoWFRBeHpXYkRZV2UvNzArTzgvZlpubnZZdnkrREZzcmg0R0hEMmIvcUtnaWxmZUE5RDFIWFliWVhXZFNSQkIyVGI3OFRoRGt6dXBkckZDUkpCMzdSbk13Y0ZFSEMwWTZNVjBacEk4cHdCTG9XanFab3p3TG1MSDlzTzhZZ0xnWnRkRXlTdFB3UWFFNDJFcVlSSW5XTS9RZjMycmR3TGkrYWY1M1M5Ly9OZlBFbTJLa2JYYVNtNmpEamZlNk16SWFyaTdvR2x3a21nbmJhWDRrWisvWEt5dFN5TXg4V0NTK3gvdUpWRE1RU1RVWkFybW5hdWJRNlJiS0FuY0J6MVhNb1dQamQxR3B0bjhUK05RM1VsVC9RejZndDlsQXJrWm9jK1ZZa01QOXJ0c2RDZ1doVm5JK0Y3OTZrYmdrUU1BTXdqRUxVZ1lKQzRkYWQxRzhJSUhtTUN4dVRmY3R3TWJBa2pFVEt5OVFkaVJ2UndCcEhIckVTSjNDOXUwM253TmhzYlhrNG1lOGRGWlRVbUlraWk3aDFSS1NwQXNsOGVGc3NmMmNTQjhCQm42RDZBM0NKa3lRS3plUFJlZ1NDdnljbDZ6RTJYcDRnelNMSWk2TE5KNE9xeWxlWS9qc2ZYQnFidk1hYUtndzgyT1NheG9ldjc3aDZmNzMvL1RzZFNQalI5Ky9ubE5QTTNrMFkrQWJzSE83RWFueDJlS2FKZFAvL0Y0dkh0N094OTMvK1czZnpqYVVvYUhtbXo4NlhzazZjUC8vci85amRwNWIzOVBkUGZkdlhaY1VQLzcrTHJnYnI1ZVZtdnI1ZnpwcngvOVRFSEpUR2w3SUk2UGtTS0dRUmJiRlRPdTM4MTNzdjJySVZUb3E0WHgyaUhxK0FxbEZkUzczUEZOMlNuTUF0d3BuVWlCdm5VbWRtSVJRSlFKTGNvcTE0YjI4QzYvd2dsVHROckdXaE9iWStiMUNEeTJBQW9qbXJ0N2F4WGZTS0FNYUg5Ny9zdmRkLy82YitrdDFXbHovZGsyTStyKzdTRWpkMEpZci91UlE1VnBDdXo0a3U2ZnBLRUtjRHJrZXZMRCs5bDJzcTR0K1dJSnducmE3U2xJNWRuSW9LcmQrVUxjZWlrSWhtdUJCRi8vcGw4QTlsY2MyRGF6NmQ4ZDB3Wks2TWFlRGxEcVVKR1FEbE14cDY0YjNBcjBJenM3WE9qKy83SDFaazJXSEZlMjNoN2NJK0lNT2RRQUZBQTJ3VzVlZHZlVnJGK3V5VXovLzBVUDEvUWlVMnVnYm5NQUNCQkFqVG1kS2NKOTc2V0g3UkhuWktGaElJd3dRMVZsbm94dzM4TmEzd0lDdVN3cmR4R0F1NlJBckZTRm1haURPNHVLczNCa1M4WkVIQXdDTzI4SUlnS3M0K1pTYUZJQWxCbzlSWmlZb3FBTmZEU2pVZDN4TEhFeWZtTVdKWE1sNXF4SnE4UENxc0c2MnF5ZU5EVTRIUk03QTU0SUxlU3dwWnM3Wnlhd0NsdnJEWWRKaHhPUVV0QjFxSXFEczNJOTNuZjVxZWoxVXpHSXBFQzNTTEJaZEwyNThSRzN0emRwb3VtNHlzZWY3dE1YLy93YmZ0emRyK1RoaC9janJxNGx1NUVraWJWOXRWR2grN2Y3RjJzZngvYy92dnptMi8veUwxOXNOZ2swY2cvdUNPNk80aEdhUXlQejZjLy8vci85ZHd6amZzTzdoNGVyMTI5ZVh2VTU0SzRNamZPYzNNM0s4ZWw0Zkh6NzdyR1lsYXVydzBNL2RNc2FDUzJiTTRKZkhFMElFU2wwekVTc0FtZjJpTGJpdVpyV3lWQTBUeHBoSzhabUxyR1dpNWNxYXpudTk2ZHV0T3F3d3BRU2dmdHlMT1pWY2o5a1ROeXZLdUJINjRybXhOSXBrVXExbkd1aHVxVVBYNzN5UkdVbDNzOFRLeUYydTdyOVZGaHlVdVZLa3FzWnM1dEJvc2QxVGtuWXF5VzIrTEpGRzN3eUFEWXVDUTdHN3NDcjNUb1I3UEFTd1FLbzdYUElremtMb1pMQUpPY2pRZHlFVlZQWGU5Rk9SdVVPeHpHL3ZqcnNOYTE2Y042ODNIYW53NDZIVlo0NnlUSSs3VllzRExmYW1SaW5ITTgxRTIzbnNmUE04dWs2MWE0TFh5MUpNbW1aSzgxRTAwM0ZQTENaSVV1RkFBNUJGbmRJRnpncTl4ellEamdMT3lXcGdDU2JqdG5kUWN2NGlWMUVwQ2xOaElrS0NiRXk5WE1yMFl3VVl3VFZJRGZlV1dWaGQvTUVPT1doNndZZEorbTd1ZDFOekt6Q1RTUFpSTGt3S0FCV2NtMXZyczZ4R29qazdra2lkR3NvS3BNUEtVODE5OFh5c0o5NHcxeTdiNmY5YXJlL25vamNMVWY0RGR4VjJZbFVnNVNwV2tYRURicFdFWEdTaDlYcDBGOVpPUXhaMGxEMmtxU2NrdG9oYVUvM1l6cjB3cTVNSzNZV2dzbXhzcGpKQzV0bzIwM0g5YjVzL2Z2djduRDcxVkI4ZjZkOGZQdVhueXEvZUVHdkUyVEFxdHVYZm5OOC9lQnZ4cnRIM0ZEdDhEamQvT0VQLzlOdnJsWURtOENTb2hJODJTT25rc2cxWWVydC9zLy94Ly81ZzlHUk5nZTYzZzEzVXgzM3E0SDdYc280ZWRsc3RFN09UMWJyNmVIVHc3djlZMkVoMy9oSjFsUTRQWi9qbzBGZ0w5QUtkSTZ3RER4amcrdTNvWFhiZk1ocHNxekNKQnAwaFF1a0RvbDIvZTU1bWdLUnBPdzFZTkRPWnNWRnlBbWF0S1greEIrZVNrVktVaWhDQ1dZM3c3TDVCUUVlc1hMTG5wZWZXMnJEYmdaM3N3dXNiSnNDVlVSMHhIUW9YZXEwOHlaQXFlMWppT2lYaU1Gd2MwclIwaEhjQ3FxR2oxWEFWTWJUaUw0L3J0ZENPVW1SRFF2WkNQZFJ6YlV3Y3dRL3hLVW56VC8zTERLaXRjU3hUb3FyY1VZNENvSDBQQ3pFczNoa0lSRFltaW1YNHVjVXY2d2xBaklMbVR2b0dPVXlWMnJwaFU3blJnbEUyZ1FlczZYVzIvL1R1UmYyRnFFNDQyeUZpVlRJU2Z1c0hTdEwrMTk0Y0cxMlZvQ0prOEpoYVBMSmVWTUNuQmZobkpwMEZGRGxxUktucEhVcXJvUTZNU1hiL0dIOC8ramx5S1JDVnRFeG5JTis1dFM4S2JUOGJsR2FzVUE2SVhQUDNTb25TUW5kWWF5cUU1VWQxeXI3cWtOa09yVWFsQ0xJaXJwQlV5K0RFaCt3Nm5lSC9lbjJpMWQ1WjhlSzZlNkh2OTNuN3BNTi9ZcEViaFRhYmF5TTFZcE1NcVNVeVBpNi8vM1gxNWw5NHNSTUxrQ3BFTGVuMm5XSkN4MmZqaC8rOHFjZjdrcy9OdG1nMStwUHF6NS9wWW82VmovZHZGNVRtZXJEYWJkL3VyOTdvdUtjeFpmWE1qVUhHK1ljd21aZ28rZjk1b1ZJR3Q0NEpqT0loeHBQVEZQRVQ0azc1REk1ejBsemQ5NFhObnFLcEdUc3RkYW9VaXNKdXpIbGxFSlMyNnh5UXViYVNlVW93OER0QnA1TllhMkhJd1djV1ZWWWZQbFdnbGJYWnIwWEp0dllRenFhWGNtWjJFWVRjeFlLeWNieURSWUR4ME1PTnlKYWFkSm12NEhCMmlja1ZOeVIreVNxWkpMVkoxSGw2dkNwT0l0VGFhZGcrRUVhcUp2NW1YMmZpVmtiT1RsQXg5NlVIVVFTWGtIMXowSWEyNU5LREZkemozaklHTURGZ2o5MjI4aktGVWFCUUhXaUtqRUlacklsYW5tbUFFdmIyMGJVRUhPYmNIQURKSUViTFJ2dU9HcVNTRllVMWNUZThSS25PQy9FSkVTcmNaQlc4NWJad0JKdGVqUlAzb3FDdHJNbDQ1eGxMR3lweTU2cVhWUE5Lam5yK0liZmZsQktMS3BzeU80a01MYUd4b2Eya3o1T2VYRW1VaEFQUkY1cHRXSVZ6c280bHBycjVNZlJxNmVLZm5RbVZRWkV6RDFrSThqcnE1eHpaTVV3VG5jZkR2THkyMy9RVHphNm56NysvSDVhMVRMMjEzM3VoelVtN3RkMXlsNTM2RGNiWXdXdnJ2Sk5WMC9hYWREdEFWYlVXZzUzaDNXVzZmajQ2ZFBIajcvY2pYQ1QxclA2NU5PRDV2eWRLQk9KNk5GZjZQSCs4SGk0ZjlydDk2ZWVOY2VDTE5yRXRFUml0Y2JSejA3QU9iZG1UbjVIN0lFWkY2SFNDSHNia1dxc3RseENIM1M1S0w2RXlmRThJbzNoZnlqK1FyTHZ0ZWFrSWpMM1RDSk1FSW1uZDBraVBNOXpXbks5cXVxOHdwOXowVnBYSEJGbDBkMnBpSWo0Y3hnVEdjeWRtRHVmRW50VGZjeEtGUURWWStUS2NJcUhSSklTb0xOb25rRlFhTkUrS1FOckZPNVdVcXFQTWYyMVVodGpHc1RVN09meHM1eEg2OVFXOSsxU0pDSW1uVGZ2cy9PWHNGaG9uaTI4MjFtbWdLa0Y2aWtrU00wR0d1K2g5NG1MQTdTeU1sVXpveG5UQ0JDSEtDeVVQM3d4dUl5Z2NDSWlybk13VmZDc1BTeWFqa2x6enBKemwwVTFBOXBlWUd0ek9ZMFpHRldBd01KWklTMWpVQmdPOWlXTkdreWdGTU5yQlFzVEt3RE9HYnZTbzZhY1ZxdHVQMzc3My83N1ExSk9LWEdRV0VGc2JFSWdqclNvYzRDVW9CMlhaaUkxYndkMjBrNkZUMU1sSnF0V1hYdW1xYnBDbVkyRjJZMkVtRnk3N1kyckVMbDd2N3M3dkgzbnQxOTk4d29IY3F1N3V4MzFkTUxoV0ZQZkQrVEdxZStLczU4bzEwTUNaMG1yM284ZlRpLzdJUm16TWdtVFc5ay9ITVk2SFQ1OWV2Zis0VFJPckRTV2JuNWdpVkROL0JoTzh0VGhxZnJqdTRlbjhUaFdRNGFxZUlYT1Q4QWNia2JuNkxMekFUKy92ODlaYW9JV3l0WDhxdTV3bUZzUkNGTlY1cy95V3VCbTlka1FLK0FuMVV5bHpjb29pWnVCZFo1NUt6bXpNRlVWQVdiRG5MVG5jVEZsWDZ4Smw4ZTd3WEREeDkvWU9ON3NWTXVTTldZN3hBNTNDQ0ZsVGdJM1pRTEJsc0dLUlZIUk1EdENsU1NSZ0hMVFRMVUJFMSt4TXBuNVUrN1gyM3lxVmtlTFJWbnMyOUpNS29rQlBUbUpMMHMzTEFIcVp3ekNQQVJjS3NGbER5KzRvUFBOQnhvemlZc2h3SkZuTEsyQXdCSzMxTkJjQUFBZ0FFbEVRVlRwbjhtZHNqSGc3aG8rN2VoSnhjUGZ6V2RtMFJ5cXhoZVFQYlMxWWpRVDFkd2M3TWFxL2RCMVNvSGthK0Z5Tk9QMlFpb3E3dTdoSDFCR25hbEZtR1d6c3djKzBoK1RLTGhPQlVyVjBHOXJIUTJtSkd6RDRlYS9IZjkzTk1YcHhRcTRaWEVzUkpud2FJa0lNNWhRTkUvZE5wVmlySWxsdXlzT2R5N1ZraVNmVmk0Y3hwSjRaS3VEdSsxMk5iYkI5dlRwN2RQajRlcmxiMTdtWSszSXA0OC9QYWJzWTJKS1NWbGtPdTZPcG9OWXlXbmQ2N3BmZFZtVG1oOHNyWFBXRm1xL0I4cmpwM3ZzN2orOXYzODhWS3JWV1dSZE1SdFV3bzY2RnU2N0lldFFIdDhmSHo0OG5lQmdUWUN3bWN1czI2Q0VaOVJEelBvcjVvdlRuUm9pOURLSkdZU3p3TU1kemwyM1Nhb2YzZEJ5K09hWElKaWpsejFieTlvRGl4TGNLb2xMY0lwaWlzcE02dHh1NEREazBIbVZjbjZCSTJQSUVSZ0JoVFQ5ZGVQazhwenE1S2hXYTdWemNtZFVORTRVVW5HbFl0UUl4bk5WTjBOUDR6NmNRZkp1VmtpWkxBenNqR1dPT3hHbkxNQmt0WjhPSnllQlYxT1BMMlBtV2RkWk84eUFzTWVKTlYrRW55ZU9uQmZaZlBhQThYOFN4emhqRkRqc3NTN3pqR3hKTDRRVEphNVdRSnFKR0lnTVNXbVpwajYzTEdmelNpQnFta2FrclFQQzdlUnVJV2FQOEdPWnNuU1NzR2k0aVNpMzdaZTBJWjNBM1Jaa2tJalAzSHdXSmNQeWc0cWJWMWdNVmlwVTRGWGRheUVtaVBEKzIrbitkLy9yNmJ2ZEpVY0c1dzV2dGwraTNlamFkditvS1RuM1RGYVRxS0tlVUVlUUtKRjB2WlVoQzFpNWtsZkVmQTVwYzczUlRPN01WTjcvOU41cXVucjVtNjFYSmkvN24zN2N1U09GYnRSUWovZWZEaTRwVmVxMDYxZFhYWjhCZHlWV1ZkRjJIdGRVY2ZqNVQrL0xoOGVIWTdXMDJtbnlFdkc3U3lhblZlQks4ckRLVEEvSHg5MytzSjh5YVVnVDRPNmlhVnBLNlBrcGFDZkFoYUF5bEVGdHFEUHJHRjE4UmltRWdsWWF0RVM3cSt0T09lOGZwNmJybXJlVXk1ZmZCQlpNY0JUamhDcFJqNGJ3Ti9VZGFoL05VNkJmZ25rRXpWclBoVE9kcStqUXFzeGNHU2FWK2VWdW0rS1k1VGhaaFlXcXVpMk9JVXpraHFaRUFrMnVtbE5LUGgrRVdNWnRjWjFZMEhxVTRSWEV6aUltd2k1SkdPNG5rQ1psOVhGL1NpdXBGU0JZcVlHZkUzSnBicjVBM1hCbGlkaHNvY1drVEN4Qm5CTUppU0htV2RKU05nUTNEcCtCMzBHTkx4TUtOaGMvWTkySWlGMUE1cEpScHNJTW0wb2QzZDJKZVZxcUNHbjV2ckVrOWhadmozYWFTVHRsek0wSlpoeERZMVltNG5xczVsc04xRmhNK2ZTaS94SnUydlVvMWtnMXBjTFJWeFVTWm5MVUpoZTFVTVh5RElBMkZUOVdWMUptVlNGRmY3cC85YjkwLzgrQzFJMlRZajZibXpVRXMwYzZxVkJic1BsVW1jZ3FKTEVVcFhyeW5GY0YzV3FMdWtwa25GRnRjcWg0aFhuZVhQY3ViTTQ4SFgvK3NPdVN2bmp6dXErT2FUemRmVHhtTFpOVVNsbEJjaHpOcTJtcXVrMm5QWGQ5bCt2SnVzRzd6ZmJGMWFBRUk2Vnl3UDd0OTMvODgzdDdHb3NLd0RWMVNVcXR1dXh4TmJQbjRiV2tKUFY0K25FOEhpWnp5U3prY1BWQVovaGNKNmZ6dUJrWGM1RkxaK3BGUlVYQnViZld0WUhCelUyREVha2ZNdmdMUHB3aWFxNDFOa0g5MDBYbUZWcG5GT2RFWnBRMXFiQW93S2xMdGJSbkNmTURLQ2c1MGdrdkxxWm9jcUp1akRoZk5tN3luTTlTU2VJOGJoZU1hdE1PeFZrQWVKVElKQVRXbkZURmxxaVpSWEZKRkZFbHpnQnBzMGw1S0c3SmxaVGRqRlNWeWdrSEJndkttTHdheU5rSURsWUpoMHVVZXl6Z2hxZGNMTllFZ29UMHZzR2RNSnVUNXE5bzNnVHplWEY2OXZLNHpOa2tJaUR4UmFyWTl2aTVsdHpKeUZtRTZqUVdEd01ORjVGV2o0a3JSSzNwMGVNYVpBcEhPYlBOKzJNekFHWUpwSnhZcnBuY3dQYUpjdCtzR1BJc1hubzVTR0t2WSthVlV4WnQ0ZVNWWTVWUmhZVWlUQ0I0L2NRaTRseFRxcVhxdWtMZ1Z1WG0vc1hxYnZqTjZYc3M1ME43ZWk4Z2dFRkRZMnJ6RHhBNGtkdFluV0JPSXFvNWlibmxWTVdjZXkwYlFXV0ZsQWtoVFhKSTF5dFE0VnFPVDd0RFRkcGZ2OW1xa2RmajZmR1FYMDBmalowa0o5ZDgxQTJsc2ZLWFYxOXRQdnl0WGsxS2h5ZmNabDdmWGw4bHR3NE81bkgvN3BjLy9lWDd0Nk9JcFlHUGgzMWZ4a2hRblY4OHlhdSt2N3BpdC9MNDZmM0Q1TldjSlZWeElpZE80Y2FzZXFGY1F3eEI0Z0h3b0VOSlFMbVVXVlJsSHZuM2hoUXBEWlFjVGlMaXRWUlFQYVhEU1lhVm5VNFRKWE1QZ3pxQnFub3BYbzlvT3djSmNieW9ZaExKaVVhWjZtb2lUalpLc2tHSkU4T2lMb1drb0ZybWJWaExTSTNCSkpDU3hwRmxLdGFDSWxUY1hCSnJmUHdOSlNCYW5CaWNkRzhHOGpMNjVibkVUTm5NUWFZZ2xzejFPSENJQ1JyQkZhcnhaQ2lydTRBNkR4dVBVaWo5MWF6cG1lRUVkMkdpV29rSzVqcEVtQUFMVTFqN0lNMG9OWkdmS1N1UjBaU1lpbW95czZ3d05VcE1vZ29TMWVqRlVVSGkxRVRBa1JVVFM3M0d6Q0xXZEpUTVhFRzVCVWk3cHFUQy9NREtEdWtQTElCekdpYk9xS2ZSdTQ2c0VmM2N4VVRWbkxUTmtrVEdpOFBRQVVZZ1ZrRWlPWGRacjl2b29hU3FuWkNubVNMYkRyaW95b21jd2FvSm8wSUlwUWxRSEFFRVlBem14Z1NYT2FkYXA2ZWo2SVRyL1g1RlQybW8zZzk4Mm0ydXJPYkQrR0k0NW41MHJReG5FY2JRdkRZR1VtRXlyVUlzRkV4Wko5cHZVTlpmOVUvbGZuM2FYeWZWL2FlUisreGtudGJYV3gwRnpDQjhXbWV3alh6Qyt1czNlU1JSWVgvNitlMjk0M0R6elIvZUVOZFJONmZINzZaK1JHZndtOWRhdXp4dW5uUkxvMnkrL3NlWHE5OWYvMStQZFVoakhSaThmYm50bEdrODdMd3JQLzN3NSs5L0hLY2pEeVZqQkJJVHN4SU1LZkJ4V0tYTjdXMW5KVS8zSDk3Zm42eW5NT3RLb3diRm5hZ2EyM3c1ejV1d1dIM24yRGhlVWhvdUxnayt1NWZPVnh5SG04RExTRDZlcXVFYytOTzhXOXl5dE16aWNBWlVFOFBjamxVU2lyRUZQMXJPbFIrMzJhdW9lRG14YU1vU1NmRUVoa0FEME14THEzNWUvL0psWis4c0RPc3FLbEttNDdQTG1aYWhYWnpUelJvejM4Qk1MR2hmQlZ0RHRjelhYcWdybk9GTVRyUExHYy9MR1BiTHRNYkZ6M3UrUXVQWkptWkkwcHoxSkFGS2o3RWRreEk1b3BIbUdiTy96TFB3TExNd3lGQ0FBZzFlRkhkNUtVc1FIY3RxT2hxbFJEMWJtY2E4ZnNSSnBEMFBJaUtzU2lDdDJtUmEvc3dQVGxSanpTOVpjczVKUlRUbEpNeFByQUlUS2hIR1FFa2tjaG1pdVdsN0JxQzdHTFEwR3lJemRKN1N6OFFRcXBBVmRvKzdxeEhzU0ZtSlU1U3pEQWRvZFpvSW1qd3hxNmFZYmdycmt0NHh1OXVYMUQ0NDliZjl5L0xUNFhxcnEyOSs2SExYZFFyaWxJZjFKdWQyY3cvRlFOUGhkRis3UHVmRW5ISDMvdVBkcnNlRXE5ZTNhKzZ6VE1lMzMvODhnWkt5WDczNjR1V2dxeXRKWlp5UzU1SnZ1c2VudTFLSFZkZGxsUmNEUWNTbkQ5ajk4dVBiOTAvdmovdGlIT2RpOHhZd0UxQUoydlZEV25XclRUZnQ5dmY3KzZjSnJMTTNhUDRSMjJJZWliajZkQ2xzT0tza0d4eVJMeHk0aTdEMlVpTFI1cDBzcWwzeG5SUDI0MVJKTHBKWjJxNVl4SW5DLzhVQWthcUtPMXRCRW9hTHM3STdkS21EMnBRWmtwS2dqR0ZXY3A5UkgrTE45SEllUkM5dnhrV05TWkZRNjlaUzZ1UjU4VG12ekVLSjU4eDZVZmUxdVhBclZSb0hjcmI5ekxhOUdVREhMUmNYbDdOMnZqZ2NhZVl3UnAzcEZNUU1wam1PaTdYTEF0V0lZcEEyZGhBaFo5S1lKcDlESTJkdjRMa05idkp6QlRPSndacUxTR0J1RHVwWW1JZ0ZaRWlaVVpLVUEyVzVPZTVHOTVOMURYUWZ0RkNWMUhaYTV4YzRQdU1LUS9nS05IZFpwRkRTVGlWZy9RQWJ1T1dreEcrRlpaZ2RoMzZpNWlaY0xDVU1Ka2R0RWxJUFhnUGZIQTlUR1FzTlExOUxKVEpxdTNFT1JjUS9wSU40VGpraUIyTHZGTGpjK1BPOFVmYm1zTnhVblhMZTBzK0R5ZnJGOXRXblRqV254S2l1L2VZcWRTVEVEb1liNm9tbDFuN1RrUlByK09Hdkh5dXZHSEw3OVp2TmRzdnBidi9oN2FPTE9rVFdOeS9XSUJiS1hMMU8vSEIvUTkvOXY5OTVUcmV2VndwUUxlNkgrMDkvMWNPUGYvN2xhVG9NYk5UeEtRb1hRd29rSUdWUVhtKzMvZHI5ZVA5NHQ3cy9IS2pyNU1MQy90dy9QYzlPZjNVRGgzRVhDTXhEQUo2Wm1LMnArM0dlbS9BOGZpRm02WlY5ZDJTdXhmR1pUbWdSRk9QWnV4UDdxRTdBa3VNQmFUZndyQ3ZnMWs1eEFDRUNBbnJoelduekhRbmRrclJjeVdjN2FBcmlCTU5Rcll4VDhjK2swQzFKb0gyL3NjWjZwcTNYOXEvem8rQnpwc01TbjltMlZQUFZqNHNiZURsSTJxbEZJQTNiUGlkaUZ0V1llak54QXNHTGxkV2NDaEdXL1JDQWtvZ0VxQnZpc3lyTzIrOTRFZk5IRGRYaGlqTDdOWnhJVTB2bWN4Q3loaHlqSnU0RXREN2svVmk5bVp4bWFVeGI1bDRJWDVZdHZCc0FwVXFCM1hCenJ3RGwyVkRQSG04bFhCQnRmSE43emg4UG5nVTF0Mk55cGlRdXAxNkNTOWRiSWxNcExqU0pRMVk1ZXdqNzhaWHM2d2xKakNEQ3VuekppMzk2OGFlMWRaWUhDK3V3Z2ZHYi9yak43dHh2aGgwT0pzTVFlY0VPZGl1Vm5HU0ZZWjJwRW85M1AzOGFVNTZ5ckY1OGVkdXRlbUIvOTNEb2l0V3BwRzY3NlFnMjd0anJFVnJ2NVQvZUgvL2pqdy9EU3RJdGtkbUREd1c3SDk3dDdWUytXRDgrM3FNU3FNTGFEa3pJcmJLSXBtRzdYblhxKy91N3gvMnhtT2ZVYWZYUGhqbzA5NzdhQ3EvMDZ3eXQyYkQvN0RXWjZ4Q2VoUjd6ZVNEdHYxYnlZcFhiMk9lWndZUkF4TlVCWm1tWmFFRDFrR1AxZEJxMnlTdGZ2dlpOa01ITUxNa0kzSytYb3JxOXdPZTFRZnprUkxBSXpDNU5EYk9RcjVwYkxSWFB0dEZnSWlGdnczRW1ZZ1hQN3gwV3oxM3JwK01WYm9FUDJvcGt2dndOK1R3ZXhyT0U3bGJlTUhOZUZFK3gzZFdsRUlaWEtpVnh1RHJnekF4WUN5bEo5Sm1TYklIYXplVVJ6K05wSVpMR21BS29FaXVMeXRRVU5iMUlPUlpPQW1nSHF3ZGE1NU94UEFSeUQzYU9CcGNMeVIzTlUyVWxjRlROS0F6WEhMMFJxcWpLYkZOSktsVTBLRHF6K0lhVzBIUVNFTlhMeW8vbWh1a2NTbkZuZlhZdXAwL2pjRHIxSzV5NEZrK3FrNE5oWXVpMStraEptalMwSVQxeEJpREU2YXhOMHg2THc4bGlkY0oxbFZtNzdaY3Y3dVdkcGk1NUZ5WUk0b0xxMEU3UmRTSTU0ZU83RDNWUXNuNzk0cXNYNjVTa2pIYy92NzAzaDFYSzZ5K3VNaXROeDY0YTN3N3ZQN3g3SjA5L2YraUhvbVdzQ1hZRWRuNDZyTDZ5eVRGKy9QakQzejg0VGpZcklHbGtRc3FyRHV1cmJmYnBjTGY3ZEgrb0xOQ3NHUDE4dzlMbjgxa1d5Vmt1c3BIQWk4S2h0V3FMRG1lKzZDN2RQc3NDenQxZHZMb3pFMGtCY1ZpQWx4TTJMaU52MDdKV3VKcUg5WWhzS2s0d0lrQWs5c1dMWERJbTNPNlVoaUJZcE9SdGhiUVFvaG9WV1FUOG45M0FJRlVBNGh3RzNHZWZRWHQzUUNCTEYyaWJNNUJxRm9FSnNjK1NOREF6NTdheGpuYWZNWU1sNU9MM2ZrYnhqQStSOWVKUWF5R2N5eG9vTW8rYXdnR1EyUDRHbnpXY1ZkNUtvRmFVemdpRzJZb1R3ckFZRk1hVXZkMzhEbWFJRS9FZ1BoWHJCak9UQkRLa3JzdW1DbkozYzU5Q3pOVkt0L01Ga05vNlVWUzZmalhra0x5VnlxeEptTGttRmVXMmZ3cjRpakUxeXV6NUVtOVg3ZmtGbnV0cHZrQVJ3NWs1MVVmSGhuWVRxcVgrSUdvVE9vS05heWFZVGVqemtSSVp6TnZFdkNrNFcwTVZacHVRYUFaM2hMbldhVHZhVmQ3ajZvNVczZlhONnpjYjRyUlNpZTh2QnRmaFg5WFZlaVdhMHFmOXdYcWV0bGRmL1BaM04zM09hdlh4M2ZzSFk1V2syNnZYTjUweWpydHN0TGxWdi8vTEE1VUhYdGR1TlZDRkgvM3ByZlBxeTY4MlhhcW4zZlpXajNjTzUvNFV1Q25hZFYzWHI2OVduQlAyOTUvMmQzVXF6b21UVUhIUzNqNjdYODhKS3BxSG9VOFhML0Q4Uk14WXBTYVZhSnlJaUpCcUNzV2xkR3ZqQVdNL21RTnNWUGw1T3VZYzJjVVNMN3ZNdDF1N0dndEVHV2hFZjVxZlQxNXlpdU5oeG96L1g4RFNGN1NLZUlHOTJRd3V0MEFCU1NNblpoVXJJdjZyQkRjd1F1bkFlbkhxTUYxY0RNeXhUbW5KMzBUTW5FS2x5WEYxUndENWhZT2FuQzQ2NHVYOTFhYUtpUTM2M09vRFRxd3FJRTF0OUFOeFpoVjJGazNDTkVjbitaSzBGbEpIdHJPM0FhMkF4VEsrQ0poaHlGMkZ3U3hpY0NSV2dpZ3pkRmpCcTFiZ211QmV6VXVkMlZsUmdOZ0ZBRUdFV1RUM3c2cFBLUklCbmVFbUlwd2txaGpoT0F2aUNteW0xaVZxckNscy9LSkFtUkYwMHBxb3htM0l0SHRyTDIrMytRa2tRL2RVVlJoV2loVlhJamNWa1pXS2liT0hYbE9WMnkzVUpwcHdJc3BMN3BlRHJZNFQ5ME9YbUI3cTBMMVk5eXRNNm9OWmFocHkxQnBLdWRYdE4xL214L3VUVjlSYU9yMTU4ZTIvZkwyaWxIRDY4UGVmSHlabktLOWVmdm5sRjYrU1dhRUp3cm1qL2QxSGtYSGQ4ZFdMNjJ6VjcxRWhXVDFSeWprcHArbHdlTGZYTUg2U0tOK3NOcXVjaHc3bDd2SFQvZU5Zb3JyajVFYVNsT3NTL1B2OEh0NmtmdWl6OHE5dTRMT1E0MnhBbllsTlRiZno3QytKeDhTTFZiQjVWU0hDK1FKZS9td1ZKN2haUW1QeFU2eFhpZ3g5SXRiR2o4YUZDMnJtSGpQQmdrc1RjSlhuTWtxNjBFZ3Zhb2NMZTcrSUdKRTZMeVBLeXpMa0xFR2pDeG5VK2FsYk1paUVYQkJSWXNRa3BPQ1daeG5qTVJjUmNwK2RJSXZ3NFVLRVNzUWl6czJoTjVjMExBd25xQ2FZUzF2NkFDSmhBeEJWa1pBYVhvUVU4bGtpVGM5eW5KZHpwNEhiWVF3NG01ZW1zVGhJU3V0YVQ1dzdjUXhLNDBtbHM3b0MzRXJ4M2dvQnRZYjBsR1EyVUVlOG03QnE2cnNrbEhMZnNaZktrcEt5Y0NaeVNFU3RvaGJMODZKK3BqV2h6ZEFBYzNkY2l1Tm5uVjhJRGVKN2VGd0pxT3ZKajhiYURlbWtTVlRJaTRHSjNMTlVZYlZwWldIeWdEYTYySnd4aW9YZHhzMndaU2pUOUg2NFN2cUNIaDVPdWw1bFRMU2xvc1Z5YmFZWUY4MWRkYno0N2IvOWszLzN4NmZIbzFQcGRMVzVldlhtQmJ2VTh2Yjd2LzY4bzhGOUVyMTk4K2FyVnp3VnRoTkxGaHYzaVRscHY5R3JWOWVqbGZLb3VybFpkYjY3OFNtdFZ6UmRmL053Zis5MDNEcUJXZlRGWnR1Ym9YemEzZDA5RmFKVm95dE1Scm5uYWN5ZlZjL3pDM3ZicmZvRXN6VGZZL1BSRjBPTW5GSnM4RmpiSjJDYWxOMEROT1VPYlhnclp4elR5azgxOG44d0JWL0NFZU5GTW5lbTZpbWU5dFExWUJIeXdZVzZQaDB3Q2s2NURLNkQ2c3BTMzJkTktNeEN5akJVNmRZWkxDeWF4Q1BUaDRtNmlRVkdYUWM0aVRZMWIzVEhUc1E2aXhPblkyWVk4VFJOaFZDeExNYThwRUZxQzM2R0IxeVBjNHRHWXdtYVdHU0pFcUtJREtrUGtVcmw2RXRiWXhIRzYvaGo0VUNrSkJOUWhkMmNPRHdYeXJVbEhBWXJCcVRrVEp5SVZWMG96SlNxV1loWjJFTmtJZHFpYldBMkgxS3BMUVUwV3RmUWJMblR4Y0VtYmU5bFp1WVpJUEk2Q1ZOV01qdXlCVnM2dlZRZlQrTTgyMzdReklEREdqbkgyaXRXRzJtajE2U2lTYlBBTldYcTRRNXpuaDhrRHlkOGNoZ2hrWXlhR1E3cUVRUUh0R1JRQkx1WW1SbEJHeFF6RXEwQUNjUFRjUnpHdTdyS1h6N2NwUjF2TmpRUmwxTFQvcGd3a25wWEtMdXZDMlVtaWUwQzVsNlltZUhWT1F4VDNnQm8rY21IUDFlUkY4TjcyYjN6VlNKSkdMRmFhYXBIV2RZelpGaGQ1NnR2dmhub1gvQnBnbTVVMTdmWGYvalhLL1JybEtkM2YzLy9WTVJxdXIxNjhmWFh0NXMrcFJHNlB0YU85c04vM1pmRDFWZWNycS84S0RqSURXL1hLZWZwNTJGN2kxMTNiZTlldk9aVDE5TkptWkJ2cnJjczRPbnU4VHRVYzhhQ3BCSUJUMHc5eU9OZ1pIS1huTWMrRTZVK1h6RXdyUFlmMHl5USt2VXdpODl5V3Y1VkM5MUt4SUI3dXBFN0RCWXN5Ri8veDh3a2dwQVlYYzdLM0czVGl4dmloMnFGRnVhME5IOXY3STNsblA0ejcxZkJrbEpTSXlFV1VXUEF6U3JQR1IydGNtcmVaSlFhV2JCK01ZWnZJVjhnSmhwNG1vYXV6ekc1QkxlL1Nkb0dleFpwV3ZzdzBySnJhazZLNXBVa0NvZE54VElFVzRwOG5nM3N2aml5b20rbENINHh5RVZEMkpKUld3UFJrTjE4SGp4ZlZnck5FbnhabTh3L0NTYUo5WENMdUd1akRXa0RCbU16SzNOc09uRGJCQ3F4cVNJcWN3cWNDREVuN1pJS2lTcUMzY290Wm9tY1cyTWtFaU1Cb0pxbEdQYWRreVF1ZXBRTDA1TUlMYjFaQTRKNmk1M2ZBb2ZqbytSc3RmRldMYXJLa0p2d0pNMnYwRTVUYmo5WVAyUGVJbWZFVEpqaEJETm82cXdDckY2VUJVSzRaQzFsRnRVUUNMNzg3ZnR5VEtXN3Zubno1VHJuTFBUd3VNODNqM3ZtL3VxTDY4MVZ0K2tUdE9OOExaM2l1TGtwangrZnF2YTBvcUw5NW5xZ1RvM0k3SUczT1NkTzYwUGVicUZkNzVMWG0zVytPdXdlZHcvM1Q4WWd1bEN3emNzZUJTbEUyR01oWWxsVDN0eGM1WHRZSHJxbll5S0tDMU0vZTNuNURGSTdTeVhvd2dYY1htQ3J4V29CSEtodWlOb1I0dXg2TVZkdTZaZ2VpcEtsLzNTelZTZHdKalpTOXJyWTZWaGpHOEhDQUxFbWtkbFBFWDhiV0pNR280bEZ4SnRrVWtTZExzcmZXVXc1ZVEyNHprVkxvS3BSbWlyUWxUR2xYcGpQbGlFV0YxSytVSksydHhnaGo0NkRwTjNBUEEvRDJnZGo3V1lzRWpQUUhNb2tsZ1dpSCtJV2J6MC80T1p6THpCdmRPSy9jWTlLNkt3SmFRRnlkUEVQYm9rWXo1YmlzNHBkRk9vQUtrdDE5eVNFRkdnYjBvaU1VaE5pWjNoUEJJZERQRkxVT3BMWjFza2ttam9WQm90UStJWmxQakN0Z1hpYkg0VFVxOE1nMHZoZS9sd0FSOCthQzZVSVRXNnpQK2VHL1JmeVR2MSt0KytsTzVXYXNySjVtUmdKN0thSks4SVZKaktmaWJKb3BHTUxGbE5RK0RTZXlPQ1RlNE8wVmRXaFY2akc4M2pPOHVMY0VVdE9LWUZmL3RQVDFadFh3OVh0ZG51N1lsS3kzZjEwKzQvOUUwM3A1dlVxYjRaVlI2RFV1Vzk3MU9HVy92WGgrKy9vNWF2aGQrT1l0dGZyckNoajlkTmUrYllUQnZENGFjSmtjb3UwdmVtbjhlUGpoMCtQcDlIeXpDZjc3T3B6aXBWTjM4eEQxNXVyNnkvZmJFVkwwYTM5NlpCYXpLTHJaKzl2eFBqeWNnWFBlbHhjMk4rSWlMeVdXZ3RWYnluRTZoS1BjdkNvbHlmUkRGWnJ5ZDJaRE04VUpTSENWeUFTRU9iV0lGK2NGM08yN2tLUFhmcW1SZTNxVFNHaHM4VnY3clFkSHN2VXRzczVNN05ZTkNkdDBUa0VrSlV4cDNSZVJRa2laM2FoWXd2ejRwZWQ2U0J6Q1QyUFNpWnlSMXRXeHN3NEF2SzZkdWUza1Q3SjBnUFBCMU9BZFJ1UU5TTEUwTWlqeEJ5QnpJdmRwSmtTMjFtREZ0Z1piVFBMMlRYZFlCNklVQm92ZHZKNGxicEFYYkVRUk5SUWhCbVd6SVZVR2NRZVBtOElzVEJ4Ylh6ZkpQRUNkNUhGSm9qSlhLd1JBQ2NKdTBscUttbzNobHhveTU5TllscCtGZ3REbzFiMzgyWURvb0pxbWJxQkFmYXBybk1Ib0l5aW9DUmdGZmhBNTFIZ2ZBbkhKeVBlQklVRU43aURFMVVCaTZia0o0aXV0dHRlS1ZJN3o5SkJKeFVIZFV6a01yeWlkYjUrOCtwbU5XRWNoYW1NSjcvUzFaN00wa3BiNWNNaVBQUnFtaGpsMHc0di8vRWZ0cmZIS1cxN20xQlBJN2phVTdjZkNFNzkvdDZ2VExvcjFuWGFmN3g3UER3ZFRWY1Nmc2l6aFBFQ2Z4d3BYa2tjM1hienpZdVgyNXRyTGRkVHladmREK1ZYZTJDY3E3NFFreEpkekkyZTNjQk5xV2htbzFkQ3RRb2lFNWU1bUp6L3kvbFh6aUdJc3kyT0NENVZGeUdZeHoyclRmU0RDOWQ5M01pcTdRSTdxeXlqTGhLSnk0NVlVODdMcUx5OVVZM3BSMG9XbWFYbkJBRFczSVV0anNHbnBCMm0waTlPcHFERXpVdmIrU1NaRHhZczRVOHRKWVFXalVJZzM2SkJjS2lrb0FtMFF5bXlQbVR4MmdxMVBSaU1KS25tSkV4T0xiTXNqc0w0YXJ3Rk04eXRQczArUWx4S3ovaUNyd0UreS9zcmt6Q3lyUnNDSmY3aHdacDA4OFJDNU9iV1ZLL3pENm0yOXl5TEVFbFNWbUVTMFRUMzNXM3BKMjMvMHo1MmRzMENyd2FFZ3VKQyszTEc0ODdEdDNuSFJkN2tiR0dWVXZKaWs2V04wOFRteGpsUFF0V1lpRkpLSWtqV3RhOTBIblV2K1l6TTdJRjJjemQzNmJCS3NCV25MbmN5UGhSS3czcEk0aXdpbUwxTVlEVVhNazdKSm9QcjVwdVNYbjk1bmJVZVBqaTQ3UFlUeVhEVllUaFZxUTIrUStyT3hTQit2UC9sVHovZC9QN2IxOXVTa0pOVU8vbFVOWFZXanZ1YlRwbWYzcitkcnJyVWF5MGZqZzhmZDF3clJKZ1NuRUMvN21SQm1saVlIL05LMDh2ZmZmM0Z6VkE4T3c3VmVEcnRIOU1NOS8vTVlqcEhSL1A1ZlRucm9oZTNJVWUwaWhkVWM2OFZSTGtWUTNNS3kzeWxxMkxtZmM4bG9ramN6S3pFVHU2TnRObytsUG1kbHhBc2hjc09mUDV6WjNrZno3NC9aaEdkSGZKelo4cmtOWGFqSER5WVpZOFdmRStYQ21JaTFaeURmb3BGQmQ0ZURKNTNiQ0N5YUxldzhIenN6Rk52dU9YWjJlcHU3bWhJaXFZVjRvRGx4Y2FTaUVGS1o2MGhpMXpZNGVLWnJLMWJuYmR4dUJ3aVhOekFXTUFwbCtGUUlGbCtidTEyVnZVNTFOTXRWcTdNN0RPSUJCeTFnN1JEVmx1NWxWZ2FZVitaV0dVV3NraDdKbEljdHR5eXM4a1hVMmhqWHNVNmxpN3NWUE1waTdsbFduYVljSXVCb0tFeXBLdG00aEg3THRReWF0dVptQUYzdDJVZGxhaEZ5N0xNS2VKdXRmb1V6RFhObkpKSzJZMHBEWDJXWm45MldQdlFFalM1RGxlMzJVQWl3NzlWM1E3a05TVW0zei8rY2k4RFRSc3Bta1FWT1FWUzJ5WTM2dVR4aDUvKy9lLzg3VysvU0ZiTHdSNFNvd3FZV2Z0YUpoY1pqKzhlYmJqdGlaOU9ENTgrSFNZTUpFS29hT0VhbjVmUXBMSFNvMkY3dTkxKzg4Ky9wWHg0TEp1a0NoL3J3OEZTcEZySzUycXNaM01RYWdTYnoveUdMZThHOEVwbXRaUWE3TW96OG81OTRjL0p1WWxlVG5jVzRhU3RUeU56WXZmK2ZHdEllM1p6Q3RDZFhPakM0b2N0cWZQb3hwcC8xRzNCeHM4MUxia0ptTjFic3YzYzZ6UXRLYmNjZyt5bUtTVnV1OFN6SExwVjY0VG9SK1llMkdJM0RtLzBmSTdKYmRBcXpNTnZ3d0pqYjRDb0pqbVpjMzNiT2xobndIcVljdHdpZWtEbWhyWnFMSnhhSGNMbDB1Ky9kQXFMS3Z2TXlWcmdHTEhUVG8wdDR4NzdPeVdDaXlPSGlLUlJJV09DRWYxLytMNjdwWXFhWDJBT3d2L0ZSUi9hU1Y5NmtSWVM0MFNxWitVZW5yWHd0R0RMNWh6a0Zrc2FpbDFuTUl1WlZTYUhRWXBrWWkrbkZZY0gzVWlFS0l0ejlHeXVUc0t5Ukx4NCs4cmd6bVptazRpNHN5WVNnR3dxdVJ2NnBMTG9sTnJubGxpU2R5KysvTW95czdCODRjUmNDMDFQeDNINjlMZi82TDc2U3VvcVAxVnpJdTE3dURuVGVOTDdZeTQvZmYveGo5MXZ2MWp4ZEVTWkRoUGx2SklNeVRtWm12dit3OThlOGxlU3kzNzhianpzVGk1YUJVS2sxSkJGL1BrZEhNTmNsVyt2WDkxY3ZYcmQrK25kTC9ReTdWSTVqbjc0TktWWkVlRy9lbjhoZkVHbWJCLzNzNVZ5N0NyNGpMd2c0bjVtRGZMbHVKUzU5Y2krSEFETXJDYWEwMndhY0JDc25MT1Btak5XSktVUStKK0JVZk5nU1hQbmpVNEZCaEF4RjgreW00UkF6aVRWZkNiaHpocG1BdHpGSFU1TU9obEVaa0h6YkZEaXVSb1RibkRLaHNHaTJucFhMSEZpRkVkRWU0RWJzSm8wWlJWTmFrM01KdTFhZDFubVl0R3JCK0dtc2FoVldrNmlUREtuSlFteENKZlBjcHpidjRnSkM1RTFwdjY1NVp4OUpia3BZa3lZdFVuVHhZRnMxVnhFUjNMRW9LcTFPTzd1Z1hqa0dTL2JYbUFZV0dwRVM4ejJyQUQvTlRBZk1YTUhkNUxFbGNXZGhGMHZ2K2pRNTh5VndHZVc5REI5TUpnWlhsaTltdWFTTXRodFdqZHlTSFZtWXUxTzRJWUVVbUlSVG0yYTducGhLNEc3NWp5VXFpdjFGbFd2dzgzNEJ4TUFBQ0FBU1VSQlZOQmwxVkM2RVByems5R1J2SGp6MjROcStJVkkzVlgvZG5vNjJzUC8rUGNYdzFlOVpqdTRqOFNkOU82VmlLYng0WWYzdHYvYno5T3IzLzd6YTB6bFZNaGdMam4xbVNTSlZ5Y3Z1NS8rOGwweGUvcnd5K01EazY0RWJzRUhVNmYvTk91TktPZlZkcnZwdmw3ZFhHMDZmbnl4MzkweFRtOVhkaHlWNmlyNWtwRVZSWTVXNzZKVEM4Q2RDNU5EU056OUxOWm5qaHhia2JyRnJodHNBZ3VLcXdhNjdLSXBVM2JKVWdGaTBaVGhMRUpTSjFlMm12dkRDQ0dRMkhZRFI5b0UxYzVyVnlza01TU0xkcXRVT3lQMUxMNE1jb1ZjT2o2eEptVUNpeHNsMEtpVEMwL0cxbTRvSVhJaHI5eFdxck95aU0yVEpESzR1UkhCSzV3NHFTVXhTcWdlbG51S1JQbloyZ2g0ZTdCUzROMUlRU0p3YTRvb2xGcWRHSzZJcEhsSktTdTU2OXhadDI2bEMyM2tZdkUwSWpmSm1aSTR4QW9sVVZYVnpPbzJ0V21SbThWamJ1REYrOFRFcmhCYXFrQVFFWEtJR21Ic2t1WUtoVFZOc1pWU2R3dTZGaW1EWUwyUkViRVVGamRvS2trWmpqaHdHbVdXUldSa0JhRHFSQVpwU1hDd210cDcwVGpRWGxnMG5OTmhhQlVZWnZSSE0rd0hxNlNKUURQUmFFamRBZkJxM2dTcVpsb3JIUEROVTcvWjBZc1ZSRWh5TXM0Z0VrRUd6SnloN21ETllyRVZJdkhUdm5hOVdpZFRaVFdCanR6dEU4Z2doM3RhcmE1ZmJrdFYxZmpJakNnSnd6c3IrWFdYRlIwN1YrbHRXZ0dQVDAvN3dsTFM5ZWJqLzczNnQ5VVQ1eCtQRStWcm81T0wxL0g5aDcvZHZkdE5WUDB3T1dHY1RsUkJZdFFOUGRkZEpaN3k0Vy9sbDcvOG5VNFBkM2NQaDlvemM4dzZTWWpDWlJjNU9lUUc0bFYxVmVJODlEZmYvTk52aGpxY0xOdCsySmI3K3drVjNYdDc2cjdSVDVkRHJHZXlmRFRXLzl6TmtvVDc3U0xEODZ4U0ltYUhXVlNCYmR3alM3VER6SEpDd0VqYkZ0bHJNU2UzSmloa0ZXWk5KQlNRU1RKT2NEZHpsbHFLdWJ0YlphbGQyMEp4RnQ4YnROZXVTNm9zemhCWlg1M1EwcXpPTm5SQnJGaWVVYjJNcVU1VG91cG01a1F3YVZQc3M0U1ppR1IyRDJHR0tDODY1L2lyRUxFRVBkcmhqbUsxVGJ4anlxMUpoY0RhTFAvTlJYSkdYVjNjUUV6TkRkY01HckxzZmx1SUdWazdKK0t4NS9uYThvdnIySnF5ZjNGdmd5OE1BMHc2djJqemhNdk5TVlNJSEVhdzJjbmZpWkFSbGowdU5ldmpLaTV2ZnhiSURDSkhNNW5SRE5pVWhyd0tQZXg4dEN5ZTlEYkc5Rm1Hd0tKd2hocmN6RU1XaXJPcHZMakR1dzNYNWwySkw4TWc4M3lEQXdxa0xMR3hyS1hXQk9xVWlGREhvYUVFVVRTbmNqcTVqYWNPcXJYMUlDN3FWWWNPdEhyNWpVNTBFb1VrZ3FUVDRaZUhjcndDaTNUWGI4cjkvN2o2dHJjUGo0ZVN0bXluM2c3N2g3dWYzLzIxSEF1VU9lZGhxSHNqWWxXdjlaUk9qREpPTmt3bkdkKzl1N3M3UER5Y29LdFpPbkRPUkpsN2pQamhuMXhZMHJEcWJyLzYzWC85blR4OTd6clk4Y2pIcCtOSWtyUHVkcWQ5R3V0blpnZk1nVkdMQ1IzTlVZelBqZkx0RFZhU2xNV1RNNHNLTnludjJkVGtOTzhqNE83bTJnSkVDT2FTd3BZZkQxSnhWcWVwYXlRWWRxOG1mVlZSemNPNjYxUlZLYzE0TGMrc01PZE9jbElWVHM2UXRKb2Vpenp6TXhxeFJTYnE3UFdlaWZSQ05vb1VxMVlCS3BZQWQ4OXlYcEcxZEVNK0h3ZzhDMWdXZUgwRmhOa2NBVzJqNHVaTWppU3FPYW5rSkdTdTJtcWNKVERVTDNZcHVDQzdON0lNYWRLbDRXODFOTUhkdEVGei9hejVia2IvNVdDYXUyRXNsZ2xhOW9Dc2tHVVloaGdSR0tYd0RyWk16VFlNRk9mUWlEV2dkVmIyYXV0YXZMbENadHZlL0RrM0YxUHdZMEUrUTliOERPRnZiL0hacmphYkpzRWtHZ29DbURXUzV4azRxU2p3NlVSWlQzWkcrNFdmWkU2RVYwcEprNERkQVBOeW1nZ2tQVHZJeXJScFNkS29HSWE5NjZwWHE2em5vMWpFa0c5ZXVOWGJWL2x4b2s2ZENLZHBmM2o3RTIrNXVyRHFGNmVISC8reXNwdEpWaTZTK2ZpcE85MjkvM0QvNGFGS2w1eHptbzRuMUlOdktoTUxseWNhVDlXbS9lbE5QVTJIaDNlUGQ5Tng5SlQ2SXovWHRPREN2TVlzV2xJM2RNUHR6WnV2dnZqaTkvK0lEeDgrUGgybVI3MGF5dkJDK2lIaGtmYkRhSjZlc1NMbmRnN0xaTDc5elZSZzd1WkluNzNCU1VXVGFIWmh5V0RON1kyVVpTd2JGQ1ZtZ2xmM09RRW9NWEdTSkFzNjBpS0pFQ3dxeEt5TzZWU2tKMmJwTjljM2ZjNmhrSnVsRGc2SUNwMFRzNW5FVkRmdXBTeWxLWUc4dWpxUnU1bTduWHZqcE95R1ZHRld5Y2xJNExXVWxmZ3pYNlBNV0ZjKzQrN245REVPbXlSTGZHdGhlQUZZR2JoaVVXYUNpcGc1YXo2anhtSWVkTDZEbHhPalNaNUk0aUNVQmE3ZmdHL1JqUHVjK1VybjFUdy90NE11OFFSdForQk5taEpMWVcrVk4zd3V4Q3U4bTFtaWdRREY3S1dWWm9wbzdCTVdsazQxTUtPUnVoTG5iMm5Nd1ZqSWlrL3RsNFlESk9SQ3kwbDFnWGFwRWpEYUtGTE1Rd0pHNHFERlF4NWpNenNkeDFwTE5hLzFyRE1IRVZpSUt6TnJWaFU0VTYzbTB3Uk5tdFFNN3BVU2hYcFZ6RFNsYnN1cjIzVUdWV21EL0N6RXcrMDNyN3JEcHlTcHQwb29WWTRmUDViNjhlRjYwMDFFUk9uNk56OSsydjM1L3MyWFgxNmZkcWQ2bk83M1R4OCtQQmF2cmJrejNkL3R0dHkrSmFubDAvM2R4UFUwM1IyZjlxZmpjVFRXRFlUS3ZEeFp2Ry9MMGo0K291czA5R2w0OWZwLy91Wld1aTdqOThjZjdrL1Qrb3VWM0VwS290aW1SOXNmeHZSc0s3RkVWd1pqb3BuMkZ4TTJmOFlUQnhQRGlvTklFeVF4QzZlTGJYRUwrZkNXS2oxdk12Rk01ZDlVUjZxaUtVTTMxemRabE16aG1jb0paTzVwYzNYVlpTVzQrS3lIeUREcTFrUHk1anAzVldKenowbE5Ma1JnOHg5bVhrczFQMWViekRBemdUZGdNUXZEYXFTYzhwTElJbnhwUVp5ZlBrY3p6Qk5WRCsxdWJiSWZBYWVraEVGWXlOdkpRYkNNV1hWNVJza1FFODlKZzh0dzRiTTAwVm5TSFRXNW5sTTA1a2Q3cWNJWEhuTWJLTk1sQ2JUTkJXbmUvRUZpUXk1WlJBM3VvSUI4R0VzU3VETVJhNnZwUTgvaFlHSTlPdWRPdkM0S2pGa3FlMTQzTUFDeWlJbmhJR3pJOHBQR0hKQzZqS3VXSzFCaHpnR1c1UWc1ODZaSEpYY1l3ODNpejNTTHlPQVpXY1JLeWlwSmhSTzhFc3pxVkhYbyt3NVd6U3AzQ1FKbVRlTGovbkNDREZmYlRXZnVLVkp1U04xMGRmdnlKZzgydXFpOG4vS2g2dUhUZTFkZHJaVEZtVUQ5MWF0Zkh0KytlLyt2djdsWmRlL3ZuZ28rSG5hblNpbFZRSklRaHRQYjE4TmdsQm5nbnVyajA5NW9QTlJmRGs5N0F5Q1NGRmF0WC9hZE9IUC9tS2lLS0d0SzE3bFQ1TnpwelpkRnZidk5ILzc0NGFCNkdJZlZJSnpVOHZENCtQNyttWkNEejFYTC9FamhiSHhuRWRIbmVHY0drMDlUclpVVFdhd0laNytublg5cHNQK0ZsMXc5Z3NPSVVKeHkyeEtuM0srR3ZwZjg5YzJWZ3RsTjFYWnYyWFdjWkgxN2U3M2Q5TW82NTNVUXVVWHY1bXhXeVppU0VxcDVLUVpXbHROeWlEZ1ppS3FiVmIrdyt4bkk2MlR3SUJOcEV5YTVzRUQ4akJRS3JYZzgvWUtJaGlkZlRJTFZ2ZFd3VGJ0TWtuTUtiUStyZ0FGS3dtdzRleE5uRVFnemtVdGJaYzM3cFl2WmFUaHljYTRVSTJ3OHJ0QmxYczRnRXAvUG1aa3pmUTZWSkdleUtGS0VsckV2QzhIQU9zQnJ5TmtqeXRHWnRNbWNpVmgxWkZxbTkweE1KOG5TMkVRaDE1NFRNUllDdzZYcUtoUWNMTUoyM2wwdlNaZFJDcmpNTGJFb3lGZzBka0JHQzNhRUNLamFWK0xoMVBWWkFQSmdwRkJ0S3QvVVZBWmlUQ0QzYWJUVlp0VmxkN2RTTkt1elNNcWRhSDNZK0hoVXBOVEJuQ0h6TGNXaXpLVzdlZlJxL21nRGxQdnJuOGJON1hYU2twMllRUHFxTzQ0RWVmY3RuOTYrZlpoOFo1UzFHRHAzRWZiNlZIMlRYM1JLTUFPTHA1WFYvY09uTW82bkNrbVIwTU96NG1FWkpTeGN0eW9wNTV6VFNwUnJQZTBQdUJJejArSFY2NzhmbFE0RDZpSDFxOEdQZDI4Ly9ITHNMdTJFNTM3czRnVmV1Tm0vWWdMTW93a3pJazNKS3lXR3l6a0RmSDY2SWlwRTYzT2pPNnQ0YVRsZWt2S1UrMDQxcjY0MmE2b2s2Rms0MmNRN1RMSzYyZ3g5Vm5JbUNJeklnZXJqNGZIdThWZ2NYb1FwS1RuUlpGT3Q5VndzTU1WWlRsUmFKWENtZFlGREwraHVEcmltcWduc0xyRjVhWHU1T1ZwRWlVRU9LTVdDSmJmYzFtUk1MQVNkUmNHa0tRdUZvb21KVW9YbUJQUDIvbXE3T1lSbTNiUFRCYmlNbCsydGgyNjBzYStRWXVGNFRoZDlWa0ZEY05FR3lRVXB4R2ZkU2FQamU5c1RzVEM1YU82dGdnUnMwY1c0ZUNYS2JlbkV6RHJIaUVwS1F1NjlKbllFb2l1R2EyMnA3dTZRYUJ2aVl5ZDNVeUl3dTE3Z0Vwc09ERXVkRnc2WUNGTlhVaVptY3lqQnp0Z3ZRQTM5VkU1ZFNrbkl3NEJOTUc0eUwwcmhtNmJxdFphcDJHbENHdnFrbGVEVHRCcVVCSnB5bC9wcU5TVlVPRWdGaTZ3dUNYQThETnoxZUR4Vld5WHBzL2pWRHhPL0dDYWpOSUtGQ2JmWmdhZFJmdGE2MnhVdkFoV3B4aVVQQ1k2a2Zici82LzVteFZRTCszSG5qL3ZEaDU4Zk5SbG5KaFp5QjRuS3hJVFBFbktZbVdtZGgxNVRVb0pSdFVNNkhHeGQ2dGpSRjc5L044RVAyVWJScms1Kzk3Y2ZuL2JvMHEvcy9zLzl3d3ZCeXNqYzNDNDEwd3dpU3NJaU9XYzNKV0czQ3dEakJZcm5Bc1hZSXVRbGVkRWlLaXlpa3F6RnBpU3o0b1dZcEJvVGh1M0JwK0tFT2luY2xWM0p5ZHpnT2oyOWYvdnhvWmhWSWNMQWJxelZtZUJlejRJTmJqZldqSXE5MkFOclVySGdVRGhWWmVYa01DWEJSWXU1MUozdFN4ZUN1NXNJNEM1QU5vZElaQUNGb1Y5VUdFczhwenBTbjYzVWRoUHBjMDRBenlDUlpXbzJ6MjBFRnp3ZXNDSTBNNHNTOWRuY2d5N1BKVmwreHhrS3pTQVhGNERJRnJPRVVFTE9URzdPU1lZd0c1cTRRYkpLYVRrOUVTYkY1Sng2UWFHTnNoVnZaSVN6TFptVGhkZXA4VW5pOHhabWpiZzdtVXRFNTB0TVNkdDF0SnhoWWlIbEFJL2srRllYbTBFbVNuemF0OFIxeG9wQ0dldHRVNjhTb1hPait6U05VeTFGTkNjbEl2WlM1Nnc4RVJscXlsc2JsU1VpNmR2blpMM1dlanFXVEh6YVpVMDNsSG8xa2RkVGY3WGU3U0RNckFLc1ZrTTlUcXFma2xmcENHbXFjRXNEcmwrdGhGSTZETmgvUEw3YXJtRUZlTHgvZkhnNjNEL3F6Y2lzVEc0aFRhakV6NmdUYzlRWDAxWFhaUlZpY3lhbk11N3U3cktDczMvMVQzOTlONGtkaFVXOUN0NzkvWDJkNmluUm1Va1VUMFVXWmxXeWtLNjVDNHN5Z1EwaVZ0bmJBeUF0WTZGb0lsMTFSQ1RrNXZySTR1YmdxZG16aGFET1JOVlpWY2lycUFwWVI2YTA3dW40OGU3cncrWm1HaUg5UUNkaVFYRW9rNldlVHVQaE9IRS8vdkwxSzZQVHlZMVlqTjFKeHJHYmRrOGZmM2w3YjdHb29XTldwbHFta3d1VE9wUUpaazRaWjNnc3pvSWxnQkw3V0FYdW5MaDZ3b2pKVjVhWjJRMjU3WkdwNUlUaXFvend5RHZBSW9uY0FtRm9LaEYveUVJUUZXK21ZV292OVBUL00vWm1UNUlreVptZkhtYnVIaEY1MXRYbllBNHNCTVFTSzVRVklmbk1QNTE4NFFNcEF0bGQyU1dBeGV4TVk2NnVyaXNyendoM005V1BEMnJtRVZrelBFcGtPbHRxc2pNekl0M00xRlMvNy9meElMWDJFNW9GVFR5dlRmN2s3bUNHYVNVaHM0R0JwRXdab2tKeE4wOUpWV0JsS1FhZTRSR1RUVWZsSTUvQWpseTZtTGx0SUlBVEUxSTQ4S2l5Sm1WeGNYQUM1cUhXQ2hIaVRQTlNoNmxvWXFJd0ViRVZHelpuTXMvT3JCSlVmbWVabUxnMHBGQy92RG1wRU1IQ3h4d3lyckJteFhNUXZtMldqdWkweGtQcWpSZnR3bmM0SlUyK1p5VjM4d0ZVaWUyUW1RKzRrLy9sa0NUaE03NGFyQnJjb2F4TW9yd01Na290aGN2QjUvMkNCemsvbjhUMlNjdGlhZEFxWHFuNjVmWE1aMWN2cHIwL2ZkcHVvVk1kcEZSaENITVdlZnp3NnNOOXVWQ2RSdldDaEVPWlgxN2pmUE9udzBpbVJLTnNuMjdQc2Q5NkFlekFYSmpCbVJaTjE5K2VTeldvMXFlSC9lY0xsbnE0dnovOGFYNHEyUEIrSUsvbzRYb2djZ0c1RStkYW5KTndLb3RPdTBsMzVMNHdFWnRCUmp5OWYvZnczZVNMU0g3NXpXL3ViWlBuTVR0bEhPNGVLN2FuT1dUNFVrVGRROC9qUUJXSVNDemxMdlZaNzk4ZUFsbjJBZ3BGVmJDaDBDUTlhQW9qdUJtRElOd1NBd240MDZmQ3kzMCsyM01hUjc4dHd5RURPZkdpU3N1K21LanNmL3JkOE1JSlZwMTVvVnFjeXI3TVQvdUgyNC8zbXpDM01vUVo1S2FxeWk1b1hWS3k5cjJsZCtLY09KQXV4c0xrd1lsbGdpUWhOKytQMGJHcVlZcGlGajFvdDFXd0RFWlhWbkdiMUVxSFY4WUZNUjV5Z0lCMjJZZXUyUzk4R21KelBFQjdoY3hycHh1QVU0SFphZXVQY1JyaGZES2xhWjJ5TDM2ZHJWWE5sSnN0VVlnWjVEQ1M3QVJqVUdWVnZqWW5oczJQT1FsUjBnRXprRlNjVVNTTlVqcTk3OGc2NVBVVmRHVWVNN3dweWZta1ZRa25PM0drcnBLeDZGU0VBN20xSENpNU9RaStTTEI3YXNwMWs4dHYvdjV3WHpmamNvaWNWU1p0Q0pncFp5R1lQUzJsem9jcU9VMURZaGZVQWxhMlNEQjNTa0o1eU9mZjNIbG1aOUZ0YWlGNExGRGYrOXUwT3h2eVZpT2V0UlF3SEp5Mis0YUI0bkgzVUt5aG4wN25GVFR2VXlZK1kzSVJ6VnJ1N3o1L3ZwdHJOVTdTMnc3dDF5MkVrWUxMWDJsZ1lVZk9PbXdHd2V3ZTJRcHVRQlhjZmZ6NCtWV2lLdW5zemF0YlpHWVc4MlY1T0pCeUduTDZTK3UzUDNmT3F4L0laWjBFeDczV1Y1eVJhTTZiVVpqaHRkaGc4VlNuZmxOcnlVVWhwTFJLYkNJaTNKcXZkUE83MTdha2ZQYjU2ZFBkWEdmL2FVeU9sTW1ZMmZaUGg4THA4T25YaDVmS1hrdGxNdFE5WURNdHBhQVVXelFrOWRHYlZvR3dRQUNqZmhOZUIyUHRNV01taVp1aHV6RmJnNSt4S3FyM3NEdndpU0czeFordVNFeTRReUluMTV2NE45aUhKMkVvM29la2ZCbzMzUk13Wk5WQk9JS2lzZlliMnRBOGhiSktLQklPZmY2Q3A5enRGZWlXTXpCN0IrazhxNjlYWHF2cjJuU0tLaHZPQkI0aStjd3BqU2xycVRNcGxwazRzMU1lUzZta3luQ0NnQm5xb1lwWk0xT0kxNHh4NW5iN2hxQTk0eTBQSm9Ea2NDQTlPeVRpb3RESUxqMDRLdWJWWkdZR0xDa1RFVkFZeTluMXd6emZ2TS9mWkc1c0pXTHkyTUYzcWx6TFV2YTEyTk1ld3pDZGJ4SklhbGxNRTFVRE81UDdRSlJWejNTMElWR2FkaGVwNXRtOHVrREk5L3RQNDkrOEtaS2NBSVhORHpMUW9weDJ0WnFEaFYxSG1WMGNrR2NNTk93LzFkMmd3cXhEY3VZZjV2djd1LzFzd3BLVVBSWS91aXFHUkt4NlEzVUxxOUFtRFZPaVVoN2R3WnFFcWtOSjhQanB4emNYRTRyaTRxOStjWE9mMUJONTNUL2MzVnVTZkxaTCtQTkFwSDdMQ2laWkMzQzBHdkYrMG01VlIxZkF1TmxkWG94SnVMck44MXppUVJONHozNzNGUXZ0VmJsM0phMmFFM0grSXg3KzdibmYxMDkvK3ZGbWh0elg3Q1lDSlpDWHVldzFrLzEwdndHaDFsRFhGbVMyNGk1SlpKd2s1N1JpaFJ1U0VnQkhzZ2lVak5FcHRlS2RsMGN1allGa2F4aWpXWkxjaFN6U3ZLVWFJZlNOanMzc0lYdHY3OE9KTlQxVWFuMElkQ1R6ZFZFOW4rUjFCaUtsazdiNUJFdExLL1VxdkliY3ZBTzBtaldlSlVRZVRYUmRJL0VGdE9PWk9TbjRtdEhNc2pndTBTcHVrbEo1eUlUN1VrbkpNRXBsVXVWWlJxRTYxeVFwSjdKbElvOEYzRkM1NjJ1TUxKcVZaMElkYmRJZXFMSkM5bFoyTEZyODY0bVNKVUFzQkdaSXFzdUN0SWpEd0tuNmZCalRpMjhPZFo3dkx6UVJpeHVJaWpLSkpOMHkxVnFYdVppWFpVazg3bllERThQTFlpbHpBSlo1V2ZKQUcxM0dMVmNhVXQ3c2RoblRYQTV6OVZBVEZSOUdMcWpxSUN5UGoya2psUk52OW1IVlVGcVdaYzdabW4xclphRFYrNmYzU1pOVVRwdE5xc3MvMW5reGxtUWlESGRQcEF6Mm1KUXpreGxZQmNTQXBid2RrZ2d0WlZuTUhFSUJIeVN1YkU4ZlAzeHpUY1hyOU9aWGI0dU5FRVo5K25BL1E4RjVtNDZ6d3VPN2ZUUy9Nd0lvVHM1dVp1NksxVVhTbEF5cTA5bjV4YWlKS256L01HQnAxanB6QjVGUm1lZkRZWTdCdkpWdUVEWTNkMklhN24vUTNXc2V5c2VmUHR6dFdUQU1TWmw4Y0RqRFdVQUp5NTR5TXhPcFBpVHlwQU1SUzhySy9sTENVSDVnTjNLVFpNbEp2T2VQUXlBY093Z3pzemIwbHpaYWgzRi80aGdWY0JsUHAyUnJLakY2bHlGa0ZEaUNndWdFc0JFUzh1T0tXaFZYek15MVlRSGJ2Wlg0MlVaNThvL1dNZTR6MVlaSVphSG82OUx6enRYYTNmMHpIOW9YRjZLMUF5eUp6RHp5RWptUyswU1YwNzVXekdYSk9RTThNc3BNWS9LRjhzaUhhdGlTcEVUR0ZUMDZGa2NjVVBNRWRvMWRLTDZPVGdWbVFtMnIyK24wT2V0SzZJNjhZNjl0ZEYrR1BKYzVxYkJaTWRGOEVOcC9QTnRjbnVWYjJ3K0RTRmdXa1hKT09hZkp6TXQrdnl4bXBZSjRzeDJWNEZhV1Nwb1lFaUk2bkYzSmhWcWx5Y0RPb3FTYU40dUFhN1hFb2t2NTlMMEhnb2pLMDc1c3pnWW41NVNpVXRJOHorNnNCLzZpZExXbEdvdklXVVZTbXVlN0NDK2lGRkV3RFZaOUhDUWFSeFFraVdxYU5sUDFaVm1xbjRLeUFTYlUvYWQzSDE5dVI3ZXkrZllYZHgvTmxFajk4T2hFVnFvbmZFSGhXZjI2a1hLQk5uWjNiV1NJdmpLNnoxUjlXWnlWZFFDRENzZHcxZHk4V2tnTGwwT2RQOStaSVRrQWE4V2p0ZnE2cEtmZlBPMkdpNmVuKy92SFJjUnlTcXpzd3M0dVROdDVBVVFWU1pOcVRtbElsSGVURHBKVW1YRVJPQ2xmdk14VzdvU3pTSVc3QlR3ampqTUZRWnZNcDhIa2VtbXJhSmNCR0xGS1AwSWhhMjVwYkFSSFNBMzFvQ0ZpOXBpR082aG5ISFprWk10djRMckt1VlpEdjdCUVlETFc5emVpSGZpNWxUTllVZTA4VHpEeTliZytuU0ZSVjMzZ2FDWGtaeVgwNnFJSHVjSnRXVUJuY0dNVnNjaDBsUDErSnRHRWlkbU5VaktHakNQN2tMZ1VHdk5tS1NVbGxua2RmNTJldmJScStQaDV2UFRKS1IyVEFXdVBjWHkrSDlWKzdTMXRWVW04MGliYmRraFMxbUlQKzU4dXoyckFXeWhhenlrTkthV2NuSzNNODJHWml4bHB6dHRKUWVTbEdFU0ZrVG1hSGhucGlwM0JDUVNyczlERW1uT3lHS3ZSMmMzSHoyY0tkZ0Q3aHdOa3F5VGtTU202TEhoWUJuT3JRM2haam1aMG1ETVJGck1EK1Z5SU5hNVNZVkpjeGV1ZDdMYW9NbkZLZWJzWnZOcHl3RndLcVhvb3V5UHdtWWoyMCsyZlhsNTlQeXdWNDR1ZnY5L1A3cVNxS0dDdldKYjBiRndFUGs0YVE2SHFDb29HZzVtNSsrcG02SG1oT3Q5K3ZMNGNob21wRU5lNXpQdTl3WHhmeXhKMmhXVjJ1MzlBcGNwc0RsRVJScy9jZ1EzMTR3M3h0amlKSXcvTXZqQWxMaUZUTWlXUXBNMFdLZWRoSFBPM1k0Sk9vMWc0WVFUa1ZLM0EvTERVQXZmRVdvcDVjSXFOdTI2MlJQcGJkSjZjQW52SlFvTDFQRkFWTzV5djRnMWV3ZFIwb3JPSUdDN21IcWxOVEF5SnBNSDQ2aDJZRVl0WmV5MnpFc1o2SUZ0ckZIYjV6R25NdDNRcEJmTXhpYjZWTENmbzIvVWdibUpQRUpFM29ZdDlnU0dWVG14RnJZdHBWak1qVFlIRXNZcWxXQjRtd1pNYnFRb1B1aUdoV3NuZ1NPTUFMKzVPTUVtcVRHc2Q0ZDJIUWEya0JoMjFiRzNybzJiNEQ2cmVpZzliSjQ2aE5tbmxTUWpDbksyNkRsVEFBbkVDalp5Mlo0ZW56MmNMYlhiTVJnSk93N1RUQUF4VXIyV1o1MlZacXFSeE0yMEhjV2FxeFZrNk5GNVNVa2s2TERvUlZKeFE5ckNTQkE0bkpYZWo3ZWYzUCsyMHFCUFZ3Nk1OTmdncjR0S2pUdlQyeC8xVVpsa0RDN3FseDhFaVNyaVBaeWtmR3JaaG41Uzg4WFRCSFNsRGtKUWxiUzh2WG83RGN2UCtZVitFYllWSWVrVnU2MUMxZnZqWDY0c3JrTnZ1dTNjUFA1azZ3K1lLSW1PY2hKdWRTbXI1bVBMWE5SR0xXUzNWU0x1cXRqMkVZbzgzdC9kREplTENzaHlXK1hDb2NMK3Y4Mkd1aHVUelREUVhybXhDRE5PVWVhVW9nalNCRXg4K00xaWhNcHdOVXB5RWk0akFWZmF1U3JxNXVNaDVIS1lwVzBybUJaek53WktvRXR4cXRjV1hCUWJQcm1wS25HREdCSThiYlBTRGpjR3BuY0NwM1ZLZDEzQVRUVndQRnlLdDNzYVJ6cktlRU5HcWdpQUNVQUxzVGdpNXZqU3A0Q2thZ3pONmE3VW45VVhKdjVLbkEwbm1wN3lacG56VWs0a3htYnQ1V3lZbklaRkhTMFNUTDNzVFpYMjVnTnRKaVNwZXEwNGJBUXlPbERRcjFWS1RrOEFKWkNVTkk1a244V1cvTHhtY3hrSGRLWXVpTE1Lc3FWSG13UkR2VGF6V2N1WmpOQTRkbmViTUNkVThkcjVWK1l1VDg5ZFA0bklBUUszV2hGSWNrdFRJTUpKZC92SlF2RlRaWHN6N1NISWJOMmRDTURmM2FxVVdxM0JQNDdqWkRKa2czQzdzekZRbDBOMkp4SkZIZUZZejlycDQwYVRWalFWU2paN3U2dGQveFVXZHlVcUJ1QWdMRldtMktmckRqMDhUMTZUUlJvc3dCMktRbWJHVEd3dkR3VHcwd0dGZ0dSMjVCOXUxbGJVWnAyRjg4ZDJycjJWKy8xanZIem5sRkRGMEFNRXROYlhMTk9uODRjUGR6cG1RTGwrOWVDaW8xZVluYTU2dnRCb2lJZ2FTUFpKbVZ1bDdhMW14TE1zOEwxRFg0QnZWQ0Q3amt2VFRmN245NzM1Kyt3a3N5LzNEcis4ZkxQbjlBOWs4eCtoNEtVNGlDN05CMlpsQ0NEQUFZQkZ4bThiWmRzTTBUbG5IM1diclhzMEJGNkh5T05PNFZFMmllYnFjRmlpZXJJd2JGUWVFaE5pc3JWOFhrRDg5elpSNHl0a2ZIOU44TUtGYXhXczFkOTVaOEpXZktnODBtNllzNWloektEOUF1a0NMNkZXVWJFUXVTa1NpZmtSRUNuRWs4aW9pMXBVZ2NiSUVYeEtCeUdtMnZYaEVUZDJjV0FMMjVkVHlscDNFekttbEI4QkpYSmxZRW1CV1E2UGd4cEprREg4UGkwTmNJck9tR1llSVQ0eUoxc2RmVGc0bXloRW13Z3V0RWpFbmdXU25QT2FzcFZUS1dVbXRES1BpTU9ySS9namFaU0t1MWM3cXZqcHZwa0h6SURZWEhrZXFOcVY5Vk9JdEdWTTluQlBDelhCOXJPRTRVUDBTNGFsTkV5NXNFSTBJNXNncjZvdmVVY0dpak1Xcndha2tPd3d2OXU5MExqa2J0TXpiWmZmNnZ6RFJPR3ptUGFwcEdqYWJVUWtrN0ZTOXpBK1B4WkNITkcxM3c1RFY5N1BuK1FtWEE0b0tTeEluc1N5OEZTYUZpd3BNeVZITlRhc1JvNVNQY3Zldi8vYks2T215L3ZSVDNoU3gzUWhrdW5yWXd3ZjYvQjh4UFBKV2hab2tSODBsZVowdCtpd2F1bEJ6Yi8xT2hwRkR4UWZNbGhYdWFTTlZSbjd6ZXFDTDc3NUtSUHk3ZC9lWDFVc1ZjWXV3UWtsUHcraVZ4OTFseFFYL3QvT1htN3FmTDgrK3VUdThuUWU2TFNudGEwcG5mL1UzQ2NmRGdZL2FKY0JiZzZKbFpubGdKOTFFWStQWHp0OVZyN2RzUDFsMTRQRHdWT3Bjck00bFhKMEVBMFJ0cVR2M3lwNGthZGh1YlJVZTViT3o2eGZuUThxcWVScXNEWTMzYnZYcGRuaDRXQ2pudE4xcVl6aWVFODNFeEUrMHdnamhaaERTM1JZT1pVMVVsMlZZWm1leXltNVdndy9KaE9xMkdObkJ0WW9YdDhPaGxsTEZ6UmNadFVLU0NoL1RYVTZUZkp2M2dKOTF1ZEF6ZVhFNkZ6K043QTJTZ1FqNjdZZVB2WjdWdlJuU1NRSzdtQUJyLzF0RUM3TzJXcUdhcytDb1JUMXhvUndaVTcwbFZLTnliNlRoNWt3Qm80aXdzUG5zbEhKaUdLazlXcUdLRHRRZ1ppZzlXaXkxQ3hETWlRV0YzQW1EZ3p3eTBOdHhHcU9pUGdhU280RWlhb1htN2l3a1dkMmRXMkphajF4ZEdXWEJ2MmxzU1FiVjZ2WlU1RzZRb2dOcTJaMTlYS3Jkdjl6SzRZa0xXeElXMVc0dmh0ZTZWSkNDSlk5RFVvRTVzM3RsVVhMUGZNUzhDVE5UY2lGU0ZaQVRyTGpWeWxUbTZnOS9vaCszdGgrZVB2NTRzMDNUMVpUSW5Db04yd1h5OU9QYjIzbjBVeTkwbTZmN0Y2RmNnVzVnS0N2bGlQN1pUdU95UHk4bU1sMWN2dm4yWitlT1lWUHQ5cWRQdkduUGhhWURrNExZUjFqYWJEYkRFNHA2SmdBQUlBQkpSRUZVUGhGUmVmZVBmNWV5STczNDVnZDJ6dU00M2V2RnQ5Ky8zSTZKZStyRjZXVTRGbkNEMlJrM3Q1K1p0YmI1Q1Q5Y1JhaDh1UHRoTmhEWGVka0lMZnVGZEdsWlhOWXloOHlNbUVRWUZqZkVtTjNTTUd4ZmZ2UDFxOTNJb2ltcEZpSllOWDhxeTZLK2VGbWMzZXN5TDBQQm1PeThsZ3BOMmpLL0FycWpTdHNJbkdZZkJyWnFwR1Z4UXJYQXZadFhJdks2RkowWEt3dWtlbG5jSGg0KzRWQ0pZVnd0NTFIck5yenBjVkdWQ0JYckw3bUJ3ZGJySnhPUmR1VkZVeGFkSm03SDZETW9kdGJ5ZnRjNUQwNkpCMzNXQkFUNHBGMkVSYldTaUNxenUxV25wbzMrQzJPaThBUmpiV0I1TzllT2VOQW8zWXhWQmU1T0tTbkQ1eVRMdmtoT0JBS0pPSWttY1Qrb2MwcE1VNjFPbkxXMTMyaXMxVDNhSW5TVXU4aHFRWDRXbVlKZ3lEc0JMa2xRaTRlSG9pV1g0cGcvN0wzbDAwUnpzbUNRWXRQN3hJc29GdUduOS9ubjU4blo1eVc3T0dWTnpSMGVWUEw1c0JpTFNCcW1hVWdNQjdFdEpsbmhDUHovMnQxWThjaGVBeWppS0NibGZvOExPMS9ldlJrRTczLy9pYWV6NngySHJxNFE4WkEvL29jUGo4R1EwbWNXSUNJLzlYOTEwaTB4QWFZaWhFTlc5a0o1bjY4dUx5N2Z2UGpWbTIveTQ4M3RERHA4ZXREc3hnbUFTOUtVV1J4ZUxaOWRESEtmc0NlOStmVzNMOGI5UEoxLy9mM3RnVVJTL3ZiaTYrKy8zajdkcEJQdU01OEFGam9YRHBHNTZCMEt0emE1ZmQxL1VyYnlkTDlIWks0OHFOYlF5b0ljeElrSUxqc0JTRFRIZ3dBSk9Da0VyR2s2T3h2clF3WTdrWUVKWHBiRmJKbkxZbVpqSmJNWjFlN1ZrTlVucjlCeHpFa1NhMG9pbW9hY1ZIYmRqWkt5d0FHcnhkeEtOWUpicVc0QXZLWkt1Ym9aR0RaWDlvZTd4UVdjUU1QOVFhNWZUak8zWG05d2dZNEhjTzhHQzdwR3VpV3ZjVnRSN3NBSmRPK29qT29UZ1VCSmVMUHI0T2o3OHJYdnc1MXk3ZHhZZjV3MFJQckZJdC90V2FyMzZTU2o0NUM3Vks5dEZHajlORjhETmVKN2p6SExBNkV1eFlRekN4R3JGbUZPbVNpN2t3aFJNU2NKWFNwRmZuWjREVThkUjJzOHd5azBrOW1pS3lyOVdJMXJmZERmRy9vUUp5eTIwSUYzKzFHZE1mRHN3OEF5bEh2bU5OZHkvMms0czNsK0dKaGNXRlAwZG1NaGtwZFNJVExvTUkwNUtadkQzUmFYTEhCeFBRa3FRSUFZaU4zaURtc09HT2p3N3NaL05uNVY3dTdlVEc4LzNvMVgxMWM3cXNRcENWRXB3K2J1WC83QkpHbHhYaGV3ZzhtdDI3V2FOQzNJSS9ISWdGVVZybU91Qjk1ZDBUZi81bGR2em5lYlYrTmdzejBkdFByMi9LN0FWTmpOZktkNXlPUjJSNndpVE50a0Q3VEQ0ZVA1UklkSnhxOSsvOEYwOXpxZmYvOFZlNVVwb2M5ejZZaEJEb0ZNbHcxekV3TjZueFFjSCtDdzFDZzdldzJ2V25JWVQ4U2lZV0FWSlBYQzArU3Nxc0xrWHQySktNSWNDRzdWZXFxcGVlZ3dheTJ1eVVYSWhyUXN0UlJYVG15a2dvRTVEZU9ZU0ZMT1dTVkp5aWsxSHpKQVp5U2EyTjI4MXJMMFdwTjlzT3FTc2hzVEhHYnc2b2tmNzRkUDArY0trenFkWFZ4dGN6c0RqdXhMUGcyck9EVUFkWDU4dTVKQ2NJekJQWnE3QXBBTlFGbkNxM05rWkxjRkhLamJpTmJqVUt1NmdWczhXaFpWZHZmRldjVnEvWExtS3lCSUV5MkNXNzdCbWdjb2plM2JFSjFDSktqZTFpakFTb1BYSWNmdmhpR3FpN3ZiMGZXSEFsS1YrQjZTbEJlTHU2djFFVklyU1FYUEZYMU5XeHJmMWdsS01DS1ZTaUM0ZUxjcStNbjcyOUU4ekk1NTBTVEZlWGVRcy8wSGVZbUQvbXp6VkdoejkzQTR6ODY3SVNjbHI1bGFDam9NU3FKakdzY2hDeEhGL28yVTJGZnNZQStCYlUyK2x2MEVBdFZGK2VFUGYvQS9ucE8rK3pBdVAzekdpNjgzeWFLSFRFajViUGo0bi83REgwZFYrRkg2R3NObGF4R25IVGJSc3dtSUtjZmJSdGNpYWJwOGRmSFgzL3p5bXpPRnoyNmxHaWRiNVBYdGh3ZFJkdVl4Nnc3TTVGWjVTTW4ybmpqT1pmN3dhaWRsem5KeHVadUhpKzhQL2tJL1BKMWRYcWNqdVAyMElnRFFVcUlsbWlQbWNQTTJ5d3VwVzgrZ01TY2VNdVVwc3c1SkhTd001QUN0eThNNFlLbVNDb3RFem1WeG8rcUN3cFdKMmZlMzIwemp4NU4wQWlaaUdiZXFxQ1pCdkVSbEp4ZGk0WlJTVXU1TTZBWVE4QktBWDFyQUNRcFBsQXA3UkhReEM2UnFSRndscm82Nk1JT1N6SS9qR2VQMk1GZDc4V2EwUXhwQ0NDclM4VTUvdG9EWHlrT09lalNtc09sMW9QUWFXOVQ4aXlEUGdYSmlZbUZueDlGUzEydm1KZzJKaGcvQmV3WUVrOWRpZ2FCYk5TTDBSYVY2RkZPcy9LTWVQbnd5SDBhRFhhc0lJdk9RelNubEZQMjFBTk9nZ3R5blNFbUJFQW03ZVFMRGpSUWhGMFV2RVB0WVRFSlh1SjZvRXZwSzlqVWRNT0w0cU1GNHZURnhudVdneDVXRG1BZ2pTYzZ5OEhEblY3czcybUJmZDVrdjlPSHBUcWpZT0ExREZvS0QwZEh0YVlMd05xVXhoMnFqbHJtU2FvUWplOFJ2dVR6RFVOR3FiYXlIbE83KytJTW56WmM4dlQzOGxGN3FPQVhCbmdHaU1kLzloLy90TnlpVjRDcDJGSFV6UEVTRlRSSjd2SExGZ1N6a1BBeG5aZnVyLy81WHJ6YmZiMEpnd3VabWN6RXh2bnp6ZHUvSkxXM090cVBNaDJXeGFwS3kyTXhrNDVoU1hlVHp6UVZMMWZITnI4bzdPOTg5MmY3OWg3elZuSTUzTnNHeGgwVnd0Z0FoeHduaXRYcGc2M0NpQ280Q2t2TzBuYWJOTnJPTXVSdTF0ZlVvRmplemFqNkRQRlJNTEd3TU5YWWlGVUs1MTNJN2VjNGFTMTZTWnBZOFRwTm1UU2FBcytNUXlHY0pBV2wwUE9BdEZkQWRQYXJrU1ZWRlZSTlRnTlVCQnlzWkp4Snl6eW1vUFVnTVlXSGpROUY5eGJDWnJLYVU0K0xMYkUxaXdjL1QzdGJXa3pUamErZmtlaHlHbm84Y2JUUWRLUk1mUFg1cjlBdmhtT1hRNHRoNnBCaE9JcW5hbGRDakY2U1J0UHdNallLVHpKdCt0VHRTNy9GRjdFYnRnbTVOWWdZcXpxTFNuRUdBUzh1OEFGaFlDQU04alBYQ1pwYlFVRDNXdnpnYU5adFA4aEZXWldpYzFFemlyUkFJaGo1RlQvRTA2ZVlrcllNWkRPeHljUnFsWko2WDdmVmNzODRIREcvSzRRblRVR2c3NUNRckw0K0JZanhrRXBsa1VCVW1ZN0o1TVU0U00wRmpzTERBUWM3TzN2Ym5QdmdqWGN3ZWIrOVVselQ3M1hDTHEza28xOXNSZVZBdzYzeDQ5OC8vK3o4ZnhFRVE1WG9jMzBsZ0VibkhPeDFCZkVURW5wU1F6blpudTcvNjkvL3UyMjF5OWdNbkwvTmk5blNvckdjNlhtMy84Y2RINk5uRlRzenE4bFNKd0c3a1hubE1ZNmI5bU9mYnV4MFcyYno0bGNoN1BIM2d1NC83RjBxZWpqMlgwK0VpUW1QRWhIN3JDZWM3ckl2dXZXWG9nV1RZdnZqcTZtL0gwWmZDV3BqTFVrbG1ncFY1cVZkMzl3ZVdXZ1htRHFVbDNPREIxeEdSaFFqejNaek9LYXVrYVp5RU5hVWttMkVVUjBvTE8xZ0U1OFdJUEJDbGpkQWU4YVZ0RisxaWVadkdhakpOUmNTdG1uc1RzaG14c25zZENZYWtzbWN4bytvdkZNTlZFVG4vL081eHVId3hRWVFGeElZdlVGUDhoV1c2ZGY5T0tQYkVqZmh4Y2htRXNYRFlJVmFvK3pPV0hVNGNYM0JuRTQrSUJqN0dBcktMRUxrUlNhcjBEUHg4d3JYOE16ZFpLMmFPbjh3RU5sRVdJcVEwY3ZYaUNBaW9GbEdHQVV5c0toNFVCSWRQUnFDV0RXeHVramx5REhqZGlJaGp5Y1ZPSktjMmNtWnVPQjl5cHBaMUlzR2J4QWw3bmxxMmFXd2lvWkNqeGVwWTU1em13KzdpL21IS29wcnM3WlRHM1REclRxS0QyYVhXWG95U3FHQ01kQ2tpSXRSS0lnd1hZZmVlUjlNb1BrdnJFQ1E0QWNRN0E5ZUs5T1REOHJ2M216cjRXSDY2dXQ3eDdueVRobEg4NXAvK2ozK2UwekpWVlJaZjhwby9IVUV3REhZU1AzbE00cm85RHBsb3VyNzY3cS8raDc4N0J4aVNsSUhsOFdCWWRMZFpwclB6L1BPemYvaE52bmgxUlhkUDg5M3RJMUppTWsrc1hsOUoxbXBibFdVL3dIaW81eS9PYjJpK3VhMDJiZk13cGRwMGU3VlZjRUV6TWRMV2RhOGhEM0N6cGRDQTFqVjNFZ0VKVTlYcTI1Lzk3VGZqbWFoc3pTeTVhU0l6czdvc1M3V0RwNmxXcCtLMWVuUmxRSnBwZ0JOclVzdEQwalRtOHpSTzQ2Q1NkUml6TUNVQlZDSTd5TTBEandRd1dKbkZhR2xjQzI5MFlXbWdLY1BNNHZ2RFNBUjM0Y0lLb2tnZ0FLWGtGUmtPR21Cd3lLaG52aXNrT24vejErWm1KaTMxTTBkRWs2V0lHcE1lbXNWTk5FbnJXbDI3cjQwejB4eUFyYjlWbVVoVldqNFNrNWlCU0tnRXJKTU5hREV5Y0phVXc5NXNMcjBqNWdhQTFZTG1ZUFpzTDhHUkY5b1dhZlpJaCtoeGE2bVYxNHYwNHB5Qm5BYTFCd0JtSkV3VnhNdkliTTY2Z2J1WnlFenNGbnRITlJvR21FdHloNEFjSkVTcTdxVEo0WlZWWkFrQlRQQnh3aDFPVElUQm9oK2VIQ3hTVElXOFdzT0MrS29TWmtLY2prVDFvQm56dlk4SkI5UDk5N2VmODh2eFRnWFk4ZTJ1bk8vS3crWjZtdklnNU1RTEVid2FuSk5LMHFBT3FTOWVTcGtmMHptVHcycTdyd3Z6NkdZR29vcGpwNDFBS0VZUFQ5T3VER1ZmMC82UW5oN2VucDJkYjRjM2ViUFpYWnlQTi8veC8veDl5WlZtTmtmeHdWbzNRNG9sTVZlTDVpa2haYmdSU2txYUJqWkswN2k1L3ZyRi8vaHYzZ3lLQUFnNHNIblM4cFN1UmROdXAvcHFJRjUwTTVhSHQrOWhzY1h4WEV3Mmt5ZVczVFFkOG8wOGJMWU1qSnZ0dGk3ak56K2VYMjczUDN5Vm1yNExPQjF0b1NtcEl6bUw0YUNsV0hFajFNQXVNVXNTSm1MYlhiNTZPVlI2SVV4dFZHeFdhMlNWa2ZoNzlQNjFES0txNEpSeVNyd0JnVVg0UHVVa21sUFNQT1NjUkRuTVJYREF3a1hCQm9leEU4aloyS1RGR0R5N3cvaUtLSXpib0hXemZIczkwcEZxZlF0dXA1K001Nk1UZTVJa05qL3NTeC9NRXA4Y2wzL0pLOERIZXVYRVdoRG9MKy9CWjZRY1k2Qys3Q0tBQkUzSTVXdkhMS0xwM0wvb0xhK1RHcVdvZ2s3ZGhLRFZEMytFV2JmbW1JZE1zNmt2ajVtTUxxeEN0clNBY0ZHcURqQlBPUkZFVXE5a3BiOTZaZ1dzY0hIbXJFUGJHTVRDdXcrSlMyaWZYMFYrOGpNT1lOdjAxNDJHbjgyMUVMaXg5U1EyRUJ0M3hYb2F0QWcrK3ViS1NVUmdZSkloN1hhYm5CSURIQUdJRmlrUUtRbXpoaTZ1R3NoTmFtUVZ0N3VJRVZNMzJXQmxrTVVGcUtEeTJSdmV6OFhxekxwSXZodkdRU1dQMisxdU44a1BINStxVjdRY0hLeDMzQzgwcmtEazVXMkljMVlaWDJ2aTNjLy8zYSt1cjhWRmVvbW04cWJ1azFaSlNPT1E4OVhMdE4zZy9ZZDM5OTZHanhZWUI1QlRtcWFFeC9xd3VmdzZhNVp4MG4yNlBGeWY3WC85c0R0UDFzWWhQUlFEM1B1V0xiZ3IraDRjMWdUbU1NUXdNMGhSaVFjdW45TXdYaFFtV0treEVpK0dCOEROZ1JmSDVITkpLU2t6cTZpczdaOXpqY0JvWTRrb1NqYVBvcE5iOWdIRXlja1lGSXIvMHpqSWJpTGdGbllXU2lnQ1JUYVJINk5jVmhQVmNTUWEzUktkSmtIMWxJZGsrelRjaHdDRmpveTUwMTcwYVdqMGlhV2dRK1JhSENpQlBMWDBNbWtwNVoyY2M3S0FoUXorSEtId0xBYjdpSmZucHVZOVNWZnNLOWlQaXVJMWNMRGpITW1JYTN1LytCakdtNWdjSGxJSFRiVzZxTkFvNU9DVVMrdHhhRnRVSmlwaXdnd1RVWlhTQkZRQ2NHcDlac0RSMHl2c3k2UThiNzdsK0lsNjBQaTYyemlGbTBLYllkdUoyU3NZNUZaOHl1T256ZVdQbjc3ZDNnV2VnUmlVcDdQdEtOcEVxSUJaY0taU1RzS21ZYjRzc0ZKOXBkK3VlMGx0RWpESCtpc0JFU2lSMCticlYrUGQ0Zkh4Wmk1SnFkYjVVWGhLV1lkeEhKYTdSeEdEMUlZNWFsSmNzTVJwc3BwY0RDSk1uRXh5SG5ZWGI4NHVodkhWZDYvT055cXhaVWFyV3BLd3p0WEhwSU55SGk2NDNyOTlmMWQwZGNNYU93MjczWFIyTWNsUzk4WG9lcnlHcGMzMTdzblBaOXovL2w4ZXYvNHFSWk9CVmhIK2tYcTZQdmZNVG5DRUY2L2pnUWNqZDA4NStYN1I2d1dmbVJsbXpxeWNCdUM4L2ZkRFd3QkdIZGdhemFlMWN5Rzg3b3FpSWtNTVV6ajFMaVYzVUZUOEFxUlpsSHN5bHA0ODZUaUpUYWp0V3RYUU0rVG9qdkhXVnU5WVdFVDdlRUlwWm1rekcva3htUE5abU1OUmdmV3N0ZnNNSGtZTkdLRGR1TlFqNDlHVDU5cFIxUzdSam5YbTh2eWdQdzB6YmxoWmVpNzJXU09jY1B6M3JyRnZaN0o0RUsyQkNMb0NJMnZEQVJPVFdTSnp6a05XaG51RnBqVVBWbU4wVGFhc0lpUmlKR1RGdUh2dTRTb2E5OVlWTWtlQ2NsU09uMElNMFlzT1g0bnZiWWpXRkdweTJ2NHhZbk12QjVjcExXZFhoOGRDNU01ZWN5b1FIVWR0N3lZQVdIVUhrZW80eHFGY25ZMElkVjdBWW9pa3k5Ymg5djdUdGNxQTE2NjBHUTFYdXJrdWo1OTRlYVRVczJUTjRDenFUdHFTdHhvWFBDN3hvdVFRb0gvRlZFMlVCaVVaenFhTFgvN3liNjZ1UjBlZTd2TEU4RG9HQ1lESktKOE5UNCtsMkREcWZITXJIOTkrTGxYWW1jRndTcWgxa1BQWGN4cmw4SEM3bnk2R2V2UHh6V1hSNGZyRjdlZW5Uei9jL1BncDV4OVNDWmQ2NC8wejhiTk9ZdS9XT0xtaGl3dENVZVVRa3ZGc3M3czRmL0Z5dTJRUjFVUTBVaVJmOUZDc0JVZTdsVGxvYWVmZzNFTTRBWEJiWGx5RjkyR1JsTnprUFMyYUNMMWYwMmIzNGVCRE9BV3hQZzhkcHhkdXAvQVJ0QkVnZ2J6QnJrSEhCUndhU3lPcDFRTHZMaXM1Z1U2Qm4xOE1icnAvN3N0QVptdDRuWFhqYVN0WitzYzE3Vzg5T1ZmT0IrVDA4R3IydkxhRm1NV2hYWjhkL04zU2VQTFRDWWpSYkk1ZEhuRkMzVWxDUnFyYVpDRzBrR2hTNWVwbUpEMy9DblFVNk1GckJZK2s2clZHcGhNZGxYaVJvdFZ6ejF2bDlHVkRyWXZWb2tuVjIyN29nSHlQcnhObUpXTmhoekREU2syakhNNHVYMW9weVNxV1pVeEZVczRxRWN1S2FMYUV0RkUwWlFMVXlZMUpiWDRxbk5qRDBjSkdESmlUQ2E5SkpxdGJCYURaUU01VXR6WGg4WFpmbnlMWWxnMVVxMEdTRGpvdlVmSUExS3dNVEtDVy94a2VJMHJteENRcHA4M1orYy8rcDMvL1MyR1lnUjV2YjZicjFBVVhSR0JLbXJmTHg3TDM4dW4vK3E4L3ZIKzNIeVpOdGFlc3N1cnU0dnhzSFAzVHpZZUhSYi8vaGgvK2VIMTJKV2wzL1lmM1A3Nzc3Y05CMDhPL1JoT0xPYUs4ZUIwWHVwd2toRE9JekQzd0VLMjJmQ295NWVIeXhmZVhMODdQTjFTenBKUzBKZENxOHFIOTkwTnpseGpZMlQyR0VnUmEya0pLUjc5dDNIaGJ5N2ZHcERtRUFpZU5tMzZNR2ZVWVVhdzVIRDBTcGxXUERVWHBkSlRydEFVTVdtdFhkZlBnQkRteFZXdVgweVlkSnVML0I2ZDh2OGt4UGM5czlDN0FvVzdyWTFxVDR3SHE3UWFoWXkwWkpZOC8yeWY2T1JyUm9oMEk5R3dqQWNXZE82enpzUVZDSXdlRkhlemRpTGhtZ25QTGhHRVFvVG9KdzFVd0Y5V0JpU2xwREZxQXRkVXVWSDJ1aUNhVHMvWWFnSVdsUDhXc2F3RVI3cGpUN1Evc29jbWowQnVHREtLM2c5Y3MxUDVXU0trZ2QxZVFxTmM5MTMzWmpxWkN6c3RoSERsUG16R3BaaENKd3hjdmhoYVpMZ3dTRm9FQXFQdlpKMjN0YnFaS1REQkVnWHNTa2RrZm1HamkrbUpXS1NsWEJobTdOVDJ4U0trWVdDRkdjQUpUUDRIQlZ2eFlRcE53Mm95T3RKMm04ZW9YZi9jcnBzb2k1bCsvKzczODRwcVFBK1pFNGthaU92ckhtNGUzdi92bmYvcmdsdW9Ua3lJZUJFNmIzY1dGSHNiRDQ4Mm5lNU02blozWG03Y3ZOaXJwYkxyL2J6L2ViQ2JGNC92a1RUNnlQbmlnTmRZNjdIWTlmbHBDdXFEQ0pLbzZUaGViZlAzcXErdXJRWWRCU1VSVmhZMkNGVGNlbldFT0I4MHhib2VIc3hoankydUFPV3ZZeVNSSzRvZ1hhU0Y3N0N6T0o1bWlZYVB1MDJydzNFcG1vMzd4aTJlL3RtWkFwV09EeDRHUTI0YkhPUmFJZ3dSbUF4eFVhNjFBY3d4UVF4NkY5UmRmakpPNjR1V1lqUkJuWXN1NXhkcGJqV2dqa2xNWFJOTlpPWnFhYThYSm50eUIyek1lcVVWQmlUN05OKzVOTENGRjI0RVlQV0FNYkJ3NkRpRzQwOGxETzRjY0xPeXBJcHlUV01XWUpaSVVpSjNabzlKc0QwU3R4VVdkWUhNWnB0cVYzS0c4azA1eWI5dzJTbDBHUktkU0pYZW9kdUhLeVEwRWVCNTZ3VVEydzcyUUdqaVpIWnhyMld5ZUJtVmhQK1FrTW94WlU4NW1xSFZaYWpXREpvNjQySGJ3QUw3TWg1cEdtWHR2cEFnekRFNGVNVkFuc2JySDZhbTYxVklYaWc0WnNURDJ3bVFnRWRTY3hhaTIrNTkwL0lXQVdha0hQQkhTOXFzekt6cU9vbGZmdnVRaVdRbkpobzNkNXZ2eDRncXg1WnFEUVdZM2YvamRIMy83OXNON0c3ZTBMRVlEbkp5RnBqUk1Bei90NS8xandaWjVJNDhUSHo1OXVFcVpkcSt2RkhsMDJQS1UvQ1JzSzFBZjNvTzhXckJjdEJZVURWY2t3aVNhWHREdXhTYWR2NzdseldpRVVFUTVPRWVIQnJWbGx0UlY4TnVZQUFTd0NzMHdFQ3NuN2xBbTZSUkhBVm5qR2hKN0t6MTF6WkE5RWgraUJBd0pZMldIdzUrbEJnSkFhWFdxZGQ5UC85RE81L2cxbFNwbENSNWpQTGx3UGdLWS8xeDRmQUlpYXBLTlpndnR1eURTaWFGSjJ1VmsvZTVBZHlVMHl4ZTFOUG0xU2NVcndEQWVEVVNRYmZWakptVDdmblR5RjYwSDJkTndLUG9TZ0xZWUF3TE5pUktobXJoVEdwaUh4RXVWY1Z0RHlRYVd0YVVkMlUrQWN4NEdJeXB6VFdvZHppUHE3a3FoUis0VlpJLy9QcWxKUWhmaWdYQnBGeGcrdVI3ekYrK3VGWVliaXJFSzI3S0k2akR0RTdFS2xVT2FRZzRwOEdwVzVrVnFOYWFJZnljMGt3UUJ5MXhjMUErYnRpOVdGb0hCaFNKRC9IaTdpZGRhbVVETlhxakQ2QThJSFpvU2c1MWNLNnFpVm02WCtYYnhnU1kyVDl4amF3WHA0dXVYUHJNT2hWNjgyZnBFbUkwR3NmSHk4UGJ0OWMvT1VwTU5Lek5qLy9pZi91V0hQLzY0cEF0MjhKUVBpd1NLVk00Yzh5Q0NlWkUzYjg1cEtlOGZ0OE44Ky9IYkhYaDY5ZTNYVDdZVXllU3BqOU9iNG9mN2JVbGFVOHMwckszSmpVaFVuU0U2YmNhcnkxZVQwQ0RmRGs4K0toWUxYUnRYWVFKRTZwR1E2bkJRb1RWbHRMSCtnOHhvSkdTUkViUXlheHBiNVJqQTF4UTNyUlJvVGJHVDlEMTJydVJoaFczcTRrNlJMWEV5VTJXbVNFRkNLOEZqMWlKd2R3TlFEQTd6VFNSaWVHdGV0bVEvaHpZZVo5OUFVbVJ3a2EyQ3VkVWxoTmJiUkxqeW4xRmtTUmh1SUs3dUVGUnJHQThRd0VsRFhTU2FGR1FrS2lJTTUyUkxab0pCbEZwclhWcmFrZldFNy9iZ3BpRFNzb1FXRGtXeTFZckVCSE5XMlRDTWxGbFZRVFh4V2FscFVsNWEvOEI3bm1rUTU5aVZLUWtIRUg3SEdleUxxeElHRlMva2xJSndSN1hiTFZkV1IrYy9Dd2xsZWdpc25KTUs0TVRXbmdPTDBCNWVBRlptZ3k4bDZiQjhtaVpmRER6K1NmWEJkdmZmM3NuNGtQTjh1ZHVvQXhWZWExME9aUUVSWlJFWGJ1V0pPNnVxemRnT3RhYTZFdDRpQWN0YitJb3hIZk5HT2wzU0ljWlM2aXY1dGNBOUNlcmtEbFkzSlJpeUZ5TldJcEJ4bkRnSDJWM2cvS0xjdnA4SFNha3lkTGZqaTIvLzl1elRQOHBtMUNJNkVHeVJ6KzgvbFduelFjOTNpVkRLVW5Rbk4vLzAyMy80K0c0L1hnbVNpSkFkeW4yZG95RlNsUjl2WktNeVh2L3N1L3owcCt1bngvdU1EdzljTHM5ZWYvdUxIM2FQb0tJbDZWRjczMDZDMklLMXRhdTI3V0FFWjJKaEVra3BiemJqb0dZdVZiQWNEaWtGSk11SUZCd2EyMzVnMmhkVDA5U2pCazViUkwybHdNZlB0MmRIWGhmUE0rU2ttcWFHKytsYzRVYjY5MkFxeGY5UmV4MGZOdlRJNitnTEdFRG8rb3p1QUNjUzdzYVNVODRGbjhSRUhhY2p2Z1owOFFrY3czdGlCVW03Q3F4Z3lpQmxBS2RuNlBwR0NKZzRxWjZFd3NSaHJ1UWcxcjRwUEllNUhnVWQzUlhWOUZBZFBNY0p4RUpDTTh0Sk1pQ0hGbEp6cXVhUlR0UmFmR0R1UTZFMWFvMklhSU9nQVIzQVFtRE93Z0ptTWVablVyQldCakJPcDhERVBKbXhzcHQyZ3RBNldtRDBvRzluMVZ3WHdDRWJtcG5VS2wyVzkxdmQ3d3F6R1Mva2ZSSmp5MUtyd1ZZWldLTnNvVkZZTkllZTVSaTAydlExNkR5ZmRXUjZ6T3dpSnRWU01PMCt4eUVpN2ExRVB4RFdacVVDeHN3YmZmRmlkelU5L3ZEazR1NitnVDljZmZ0M2YzdDl1YnorL2RQTlY2cExrVUhwL2Z2M0gzM1kzMlRJVUErSCtwa0U5ei84NTM5RlBiOFkydlNkTGRtNFBCME01TFBYQmZueWZFdmpxNWZYVmw3Y1BQSm1zeHQrek9kUEZUbVplYU5xblM3Z283Qm9QWUY3cTg0bGtpbEYwelJ0TnVPVTRVcStMS3lpMnZGdklpSWhyTFhJc21oZFdUNTZ2NTFYOVdBN3NZNFFOdkRwWUxRYnZVSE0wV1JvNFYyOHV1YU9KeTNXc0t5UUUxdjcrOXIrdmhmWXRZV2U5aE9naFpmZ0lPekVRd3BOZjdVL3c3SitvZWp3VmJ5TGR1VHk4Y1cweG9jb3IySit0QmhMTzczNXRicmFXMWloaUdwMzFzYnFKelpWZDBDa0M2YTdDZWdMNDdHMDhqUWtzSUg4QVRFaXM4cFJsVVc2WnhFZ0V5VlIxY1U4ZmxsdXhCRytBQU9MdG1xcy8xN1VvY3B1TGlNOG5HNmdGdXY1ckkxMzBtSHYvMlJtM2g0Y0xCNXd4QUR0OStDVXVMd3lxdEdZT0ErbEdPdm1jS0JSM2NyVjQ0ZnYxQzVvZERPdVhFc1ZJUVRCMk4xcjRJR2JYSWdwbXNudTBNRjlNVjZuRFcyaGNxc1llbkJYZzcraFNYSko4c0F3ZjNFTFp2Skljb3p0VFRyMmxoak1TWms0amVOMitQcnI2MHZjZkJ4UWlRR1Q1ZTdwOHE5L1NUejlUWDczRTUvbFlVdmw4LzQvZjNyY2JLY2tmM282YkpiN3B6by8zWHg0OStIemZwTW5wVm84R2FDc3NwbVQ3TTI0Smh6UzYxOSt0Yjk2ZWJuVGRFMlB1dDBNOVBRdjQ3WkN6ODRIcmtWVUlxRDM5RW5vKzN6bjUzV01mOCs3RzhmTlpqT04rVXdZSUhjaGkyQjdFU1lTZFkxdHpwZ1pMZ0ZDRkxCeDA1RGpHRnVMTlFMaDZGcjU4by9IY2MyMW8yUGFEMm1yaERFMmN2dGlBZmY5ZlMzbFczNHZIRjJKNHozOWd3Q3FTZDFGbFZqZ3RkU1IvdC8veE0vRnZhUmVZYW1waitOWVJGVFdpc0pQKzNCZDY5Vlp0T2piZ0t6VDR0Ylk0cG9EbC9QRnJaR2ZVVVRSbzRiajhXeFQzTWl0anhQTFJGV1ByYVpHMHdCUW5NUklXT0FOQVlNTzg0OWd6L2J0bG9vMGNKbFpFeE9DMm1nNFRWbzQ1WXRMSTJ6MGRoeFQxbVNOSWhRTHVIM2tScWVzakdVaG9sb2xXU1ZSZHRRRXRnWDFrYWV5UFRzOG1Qcm9Wb1hyTENoTGlaNktRQUJ2NHQvb1QvbzhnNVZMTWJIMVhXNmxNbmQ2Yit2dU1JNFRTQ0tHVGxJcnZmeGo4YmdLd3B1NmpqZ2tyZUc2blFCS2w2OHZ6dE9MNjJHMFpQT2NrekI3b3NMakNKNmhYL3ZiSDlQVm15dDY5NXUzR0gvKytsVzI4cy8zWmFqM2Q4dmo3YnQzajd5NWVoUjNMOFZuTDBnNXlkWTQrK3hlbE9UaUYzLy85ZWZyRnhsZTNIbEtRN21iSDg5MjMyWU1sLy96SDM3N2FkRnhUTHphdmI3SUNlNmhiWkVrUUFyaWxKS2VENXZOTUtTMHNUN0NqMHRmRVdGaUJWbmNnUVd0czgxQjUvSDQzeXA1bFBVT0ZMdkhFYWw4VkpJY3g0aThlZ1o2bTZxSkthSHJYUGN2TEdCUTg5SVFBUE1nV3JnREZBdmJzZXF5S3BGWGdwc29FNG5TLzg4L09DMWdqdnF0QmlzSmNmOXBVYTd3YmdIbVNQOWI0YVM5cGRZdE1vRERsVVhVU1gyOWVmQTZHMTdqNDlaY0IrSm9OaXI4UkNzTkFpWHRocjk0UjVVSVRzVXR1azRDOStEaEJSdW43OXZhUWV6VlFFTExFdW8raWpUQzdvK2lsVExhM284amNJVFIwMUNUTDY0YXI5NWg4VEg2NFV4c2pGckYzQ2dEWHMxSXJUZ3JmejRiNzNlNzk5TzRISXA2NUhWVkI2eEdNaVpjSXM4dVZPd0ttTmY5a3ptc0xwNjhDY1A4VkJkMFd2SXpyVFY5TXhHbFFmbnEvSEhQRkJXYmtCQlh1QmxMS2dqd3AxVG56Y3Z2M2lUZHBVTlJ6TVhUd0N4anpubmNLamdWMzMzejRmZWYwOW41WkE5UHYzenpzMnRsR0Q1K3VpK2ZQejY4V3hiZmV0MHpPT1drNVdPdDBESEw3T0JKRDh0U09WKytlZjN5MWFCazlmNk9vRHgvZmdBU0NqejFBQUFnQUVsRVFWVGV2WHd0VDh2dTc3ZkY3L1hpUEoxVWZVZWZKRC9MM3dheFV5YkptODBtbmVWcFVORXdJQk5KZy9YMVFRMmJDRURlV0RSb1k0Vm5HOFJ4dW5DY3hOQnp6dER4ODlIMXd1MTcyS2xLR0MxRnRnMTkvbElKZlF3N2R2ZndJSG9RR1NpTWU5UmxvNERSWEhNZUV5dlVuODJkLzl6d0l3MkRSYXZKNFFSNVFVeTZKblEzcVdYYitxWEZBUFVqTXlGeWp2dW91cC9BSmdSbmw2d3NpWXlLbVIrLzR6RkxTZGFGMnJZUDllaWV0YmUyY21QZUJydFBVdXZhaElqRm1pOFNNRVQwbUVVM2ppekVFZFpmK3dCU2JRWW5pSXAyam1TN1B1QkVlU1hQNHhiQ2JwK1kzVGgxcWt2RnNhblp3QytzSWxBQlcxbUt1OEtxS3UvUHhyc2lUNCtYV015THc2cElqWDZrQTA0Y0ZUVkJHTXBFakdMMThGUkxxU1ZzdXM1TTNKcFdUVEZHYUlOcmRCcm02ckt1aGNCcGMyMkhNQnF0Y1Nnd0U1VkRhMXdVbCszMTY1Y1hEcXB6bGtTY1J5MUU3RmJyVXFua0FkaThmdjNIZW5mKzZ2bzd2ZjdxV3BsSWYybHZiL1kzN3g1cUtVQzV2WDhodzVqTjVrSFlCWVpIVDV2TnBNU2kyL01NcjJmanpSOCtVMTcyQjMrNDhlMXV1YmtaSGcvVCtPcDd2N0hkWlpLaktuanQwM1JQUUV5R1NGUlVCaDJtN1diTW1yTVNFNHhsbGVUQks3Zk5sTXlGbkdRVklkZjJxNVJuY1pRbmZZWGUzSG0yQUU1TzRpZzRqMzJrMDN6M3ByQ0tUemcrRUE1ZkYzYS9HNGM1RG8ybWVMd0R5MXFYZXBTUlNrVFBOY2wvOFkvQXUyZFBxV211ZXlhU2NPUUFQd2ZQZElsVFRKYXN4M0pHNDBTOWVZeFhiSUJIdmxERTZwaFZ0NlB6Z1lXYncvWVVzQlVMMk1XRW85TUVCcEdTVllURkRoQmV4Y3N0b3Bna2NnSGRRd2hoa2VZbDdVdHphcThpUnAzS1krTkdCeW5oU0I4K2planhGVWJjbU5nQ3RpcFFGbGg3Yzh2UlcrMnhWWmlMa0NkM1oyRXFFYW5xTnBWNVU1LzA0VUlsSjdkSDRqb1ltWnFEUUJJejdoanRBQXdYVkMrbDFPVlFpL3N4NlFackdzd1JnY0FOcmIrMlZabTRQUEdTT0YwL0VKamRwTEdxR1RCTG9zUndGbUxLNXkrL2U3MkRvN0lvcWptUkcrZERTdlgyeDNldnE1QURGejkvaS9IcTFVWHlwUndtRWVMNzkzOTZ2NysvTGNQaDl1QmU2OU5HVU9kaTUzVXBjSzl6bFhTZXZZREhYWjRmcisrUy92amIrK255NDMyaHg4K2FYdWo5YjI1R3Z0THArdWR2UDlVaDhiR0VCVTcxODJzUFMvTXdERHJtY1RPTktpV3BFSmhObE9ETnRncW5Ja0lnRVd0anBNNUM3a0svY29xYmJpZnAyb2pwQ3hoLzNqVFN4b3c2MGhoYjJ0cEprd1RQQXFQWE1kSkpybGswZDJEdVFzZjQ3NllMQWRoSmlaV3BXa3JLWGhjZi9qOFhjRXN5WjVIanVVdk5obmxrcS9SS3BPazdzT3BYVnUyQUVFbEhzaDZsVm5FemRIZ2xLRnZ4dGUzZEpUWnhyMWh2dGYzOWxMV3AxRVZ6RkdCQkVJdXFuVkswUkJRaXZhcUpGQjl1L0h1QzlBMk9pVkNVeVoyWnJCQUlVUFRJeC9XUk9mVWZRVS9XTHpHeHVWT082MHVENjUwWStVRVVaRkVIek14WUZSNTdqNTBkSHQvYzNWd2VPQStVR1k5RWt6blZiWVNES1NTNklDN21UTVN1TFE2ekxoWWRhWndJU2RlN0wwNUhETWM0RXhCVmNHWGxYU1l3a1N1Y25SeUpBOUFZNXFXRXZMbis3dnRMcmxLaE9kV0haUzZWYXM3N1ljaUhkMisvZndrc0RJeS9zTFE1NDhPaGJqY3lDZkNQLy9XM04rVlE5ZmZ6WVFZclZTTXF0Tmt0REM5V0tnck5MaXFGQnlsM0Q4djUyeC92MHNYanJ4OFB2SzB6a3VmRDcyKy9lVDN1TDNZWE9uOTZTTFFta05ISldJUzVOb1RFa0llY2h5RnR4a25ncWdvRTFBR1ZpQXphRjZCRjhHSE1JNzFuWnF4b3FSUEgyekZkSGtCdit2Z3pqcVBFd1VOdS9ldTN4Zy9YMXBXZVc5WnZjNlNzM2V2aXp0eERoSmlvSUVUc0hjOXVwd24zdmJrUmw5QWFicElsa1RCU2U4S3Q5MzNYeDFQNno4dENvTXpDWUJWbkZtSlE0b2JrYjZXR04vSngwd3dIV0liTk9WeWF2QmRXSnF2UzVxSHRRdXprSldEU3pNeTJ2MHNJUzdxMDhqY2RFeGVKaVdocFh2cUZsQUZ1bHdNaWhiSEVISTJVR1ltWklmRlJoRnpETEF0MWdoRmhoRnZiZlp4RXBEOFg3aUxFOEptVXFUTHRtd2RTbTBOUFQ3a2xmZU5zRzIrY2I0QUJWSmpkVDN5TDRxNkVhazVXZUZKVTR3UXpTZVJHWWtzcXR0dmg5aEdmWnd6bVo5bjNwYmphd1Z5VVlkS3FCeVpTaWF0NWxUd3RDeXNrMVZwRmo4SG9kRXd5YU0wdHpzMVAwYVdycm9Ua3lHZVhueDZ0ZXFxc0FoUFpEK0lrMk92c1NlcWVlSHI5emJYdTkza2NEdk1aVlZDdW0vRWg3N3lLM1AvNHJ6cjRnVWJPRzg2SnlzT2oxNmZYMStuRGovL3J4dytIc2wvd3poeEptS29rSjhFOGkvZ0NJb3lTS1dYUllXQWR5cnMzVDNYWS8ybE96c3Y5YlBLd0lJL0RkalBrMzVUNjA0OUxUU2NZa0tObElBVDVLWW53bEhOS0tXZGhKNmRJSENWcExnNk9KbFFZdUdOSDg5TXZkcktDVDZaeHA3Y2pLcWQwOGphZTZTU0hFR0xRMGFQUUE3U0ltKzZxeGI2Y0xPRG9OY2Q5bDU1RndhOGJMWTZqV0RwKzlkYUhLbUFXYnJJTi9ObFU2MlM4MWFYN3dCckh3TlRaR3lmUzdlZm1FR2VDVi8rU2J2VmxMa1pielY0TENjRmNHaEdUdjFSa3IxZU4vNXUxTjNtU0k4blMvTjZpYXVidXNRQUlaQ0tYeXRxNnF6bWNSV1pPYytLTi96R0ZkNTRvUXZhSThOQXpRL1pXTFZXVldWVzVBUWdFSXR6ZHpGVGYrM2hRVlROemo0aXNwZ2d6czBRcUFXU0VoN3VwNnRQM3Z1LzM4YnFGdEx5alhJVkhUUkJEUy9weEhkc1ZmYW15RjQxanFSR2EyWS85N1BhZitFeVlWaHRvSjU5N3NYV1c3c21zUFFOZ0JsakpZSlk2WFNBcklvdk1PU3VjMkVuQVNvR1NJK2htSDNvYStoZTNCSTJCRFJOQTVvd2pvT1hJTGczTjZtWnlKek9qS1UyV00xRTJudlVsQytibzVOVlhLQ2hPTmU3WTdqWUhDRnNrTWplSUN0ak56ZUVaeHVIcTVjMmxRclp3azI3TEx6LzlnM2RtYkptRkxLWDBzT1Vza083MSsxc053KzJSOWJ2ZmRlbjc3Mi92N3RONGYvQXVPQnpPaEN6dU9VRzVqNWpHZlFFN2hCeWs2ME42ZUxpOVMrUDl5TWpUYUJMai9lWHUxYzAyRHgvK3NKY0hFajRKTjVzanE1ZzVhSWhkVU42RW9LS3hzSVJoUm5OTXdXa2J0bXRtbU5VSGlUbldFZ3gyZHA2YlJuTmJIMmRRdlVST0VHS0xRZ20xKzFwTDQvbjJURXl4dkp0eldXb25JT1lTRmxiYzRrVmZlVEsrYXI3aGFxU3ZYZFIyV1FKWVY1UE1aeGJ3ZkYvMXluR3FQazllU1ZEYkZaR1h2Y1JVUEtlbWVKTzVhZVd6eHF1OEJoVmw4dXlCbzV0UkZHYy9nL3ljaUR5MW1qZTRwRGhVanpKS21ZQmFEN2Q0OGxiUUY0ODFReHppRldsalRjNVpqUS9uVFVYUXVUOGE4MXlzTkoyYityVjZUTW9iYnJWeEx2QnM3cjZwbFZRUlhycG55cGtBQ0J3T0VRWVNkS3NmdE05M045Y2Zzb1dOTUh1Q3VYYndqQ0tQZ3pSWFZrbWhkTGZzZHB5eUZUSmdxUDBjbk81M00zbS96Q1Q0YkF4RzFGMWYzeDlGQ3FHek5CQ2NCODR3TjNCLzhjdlAzbXdjdS80S3V3MWZ5b2YzL3kxM0IxTFBVVG1EdU4rRURXLzU2cE9ZeC8zdGp3K2N4OG56aHcvYjRaREdpYnBMcGp3bVl2R0pVNTVTN0xwTm9FRXhPWXNBUk5wdjZEallNSTVaTk4rVFpkbTl2UHp5NHVyNlFsSis5LzM3UGw5YUNpMVRoMmNRYVRtQW84UXVSdVdnUlFsZlNrK3BrU3duYUVTR3pIcEFsbE5hSXNCWTFJTHNwUE5Sek8wWk9ibnpwbGJpeE9pVGFXeEI0S2lSZ3Q2a2pGNjZPaklMTm1hMkVyZUErSEtZbDYzZTV1YmNvdDFkZjEvVWJhUVRyWDdqbWJqMEpKSkRXdVhRbEFyMTJCVnU0dTdHaFo1RE9GdnhYa0pQaUlpa21iNTRkYnN0L3lLcTVNaVNPaWFEZHVLV1lVdnlRWFAxenIyQ2VwOXZjbzlaRXV0U09NWHdldVNWNUllVFVzaVpFd3lrck1Zc3hidGN4c0I4eHJHVnVzM2J1Vmx3M3RuTVdZUWRYdHI5YlI0dnlnSkFWVVl6U0RzSjZpaUo0TmxpOVhkbUIyWEt5YnV3dlVqRXgzRnorWGJxZWxPMkxPNmkwWm5KalppemNrc2dxTU9HblBNMFRPN0ViWVNFOVZ1MjB0QXNCL0JKSlZSTU5CZXYzajE0VkNFM1ZqYTFEQUl5T3dqaDZ1YjFWWXp4OHZXclQvVnFrOWsvL3JhL0oyZ0FSRUM2dTk3dUlvRko5VFA2N2phTjl3LzVlSVJtZjVlSGhPNzYwZ09QKzhGWjhvaWN6WVJpVkdIdDkyTVVTNm52Z29vOTVIc2FqcG1tMFRlOWJHNCt1WHh6K2FJWHVDZXhLWFlXdzhuNVd5RUR6TUs5aEtCU0pJd0twMXcwNUFVSHlxMU52YWhBckpaTzRheUVib0pEbVExcWk3Nk9xSmdSVU9mRVlOUW5CcFROZkRKTnVZMVY2Z2xzZFFHM3AwWnJVeXN2SnpBTFY5b281bkhQU1FuUDROT0Z1MXJRaHBweVVFUVYvRndOSFJxU3AwaW8ybnF2MDhnRnNMNHkyMWZVQW1WYmdrU3J2YkNGa2NwY2ZkY3owa2tFNnF4VUxFSXIvM0haRmhhTTYxTDROdDZ0cjZ3ZlVxSVFXN2pFckxKcVVxaU0wdEoxa2pwUVdrSnF5L3NGTE1HcUo2Y1YxbVBDMWlwdjgvYkZ4d1Y0emtheHgrZ1M4eU56aU5lb0pMaGxod0NlcDVGdjNsTVk5K0hGajRsQzVwRFo0YUxKdHl3T3F3NEdxdU56RUpDenBXSE1Vem1CSzE3MzhTNjhpc0krR1p5Mjd0WXh2cnErSFRVSVpSRFpkSm1OMkVFc1R0SmZ2UkxwYno3NTdMT3JyU2dsbU8wa1pRcWFXY2l3dlg1UkxpNktjWGZ6dyszSC9lMTdMUU9tandJT0Y5Y1hRMlJLbGxrd0NVUjYyZllNOU4zQnFBdHUyQVhKeDhueWdZYUhDZFA0NXZyRlpuZnpxcGNRd2pTNjdqNzFaUHRqQ0V0QTg1d3NUOExDb1pSVFVqWngxNkg4ZXZNSDF3Q2ZldnhXK2orak5IOVdpUk93Y3ZMV1c2WFAwNFdhYkVDSDh0KzZ0bXpPSnZYTEU3S3pUUFZWV1hYL1NuMGtjejM1bXRyVlR4WXdzSmpWUU92VDVsVDN0MXdjMnBtNUQxMVhsUmdpL0h3SkxmTmRzaWFBVnY4dkwzdDVDWkNoeHN1dk9tVkwyVnY5d2tVV1VmY3o0V0txYVZhckl1dmdBaHZESTdiUGFWRWdiVlMxc2tDalNWRXJpbytyL2EwbGtKWFBxR3c4MWxyYlZCTlFGMkRtdXZSY3RjM21OOXhYTFlWQ3VhYXFRWjhoeGFCQThKUW1TMzIwTXBpcGJHMHZZaXh1UFVVem1EbWlCK0YwLy9CSnpPTTRURnZPRUpQT2xlRnBFZ3NLQm90MklsTHg4Z1NDZThvMkRTTW1HTnlkUzNMVEFrTTVONWFoS1dIUGRMTTVYcjIrdmVWdUg3anJMM2xLa3pNSUVsdzV2cmo1NUl0WFgvM2l6Y3ROejh6T2tSNytuQ2lMR0JOWnBsQ0czc0xNRy9iYlAvN3c5bTNjOWJvLzdnOTkzd24zbWp3aE93RmtHanRJb0s1Z3VxWUVRZmJBak5IRkhkT1lzL0htNVp0UCt2NWl4OXZ4OThtN1Z5OC92WHAxZDc4LzlNc0M1aFlBUlBYUjlUckNjeVlTc2VMUEtYTUtvQ1Zleng5bmRRdlJ1RlowRmZJRlFJUitqc0xCVEs0bklzL1YyVlZSNkN3a0pmOHFsWnJJNWxsamFVU0YyakxLamR5SjA5c3FPMlEyRHE2YUt3dUk2YndjNW1YTXdDaUplZ3k0bkxvWG50SkdWK2liMURldDhaV0tQeFpMUk83cWhnVktoNnlCTVdlSHpqa1B6Q0lpQzdyQVMyUXhNd2ZQbnNzVmxjL241SHhpOEpkQzNBV0s4b2lhZDM1SlFiRzVCZ0l2YWR3b3QzZGtXUmk1WUxRTWE2NnZkelpyOEVrQjdUUnIyR0cxSnZjNkpmREZZUTVpNWYwWWhFTWVLajJFMmNGTTdvMktuZkpzUzRsTVk3cTYzbi9NTm0wRE1VTzZiQVNIa3hkYm8xU0liSE5oTzlKa1BvMFRlOFhKdEJzT3pyWS9QcFczOCtsVmppRVVYOTlsNjJnVDlPb21ISDgzdG9CZjJieDg4OHN2Zi9icTh6ZVhnYWJBOE1CMy8vVy83Z05KSG5md2JKNkh1MjRLVzJXbThQWGYvZCsvKytGZ1cwbjdoOUhqaTc0alZvd1paaG5rVHQybWM0aFBHYUd6Nlg0VW4zenlITm1Qekx3L1d0UzR1LzdzOHhzMkhqSysvZDVlL2V6eVJ2VFZ1N2Z2dngzREtrNitXdmZMeXJSNlZNRVp6c3pxbVpqRnRTN2crc2NsMHlvVWxua3R4Rmo1Y09lcFB1ZFo4bFVZYnlmOXBTcFNJRGdDd0FKM3JZcUxXT09oaTFoZFFFN09rQk42STgxMzBPYlpKR29hYXFCSU9abjROQnBzWlhBQ2lMcllkUUtiSFJMOGJCZTZxTVdMV3g2cmZYNGhiSytlaCtXQnoyUHVGQXNCYXlXTDVoVUdFMFFFRVJXQ0NKc25jckF1RzlJVHV3clBKM0JGRnF4UWZuTVljVVhpNG94S1FVck1nTHNDRFZ1RWRrNHlNK2xwbzdNS1NWb0JQV2Njd1VyUjdNMm8waGF3QUJJQzhHR1N2dTlzMG9MR3EyK2QxMVhybGpMVmNaaXIwR2g0SGU5ak9CNDdab0xFTURhZEo0dVFoRmhHYjdQUURUbWI1NVNWQmI1Mnd6M3hoaTFFc2Nma00zU1FxNXVIZy81NkkzVHhFZzlkS0JNMWVOaTkvdXJYWDE1ZFg3QlppS3BFYm4vM3YvNTJETXhwMkpuQlBEM2NndUxWVlMvOC9tLy85Mi92NzhNbjQzQzQzWGN2ZDEyZ3FWRGdzb0daeHlEOUppZXk4VWlYWWZob1dXM0tSeDlCWHN6MzhkWFY5cFBQUDk1Y1QwUEt3Mi9mamw5KytldFBkNzZGcHc0cFNFVVFoV1p0VXhJV1ltSkRGa2l6R3hheWhkWHhTYUdPTm8ya2s4N3F1V2FTTHJBNnpJcXNxV29yN015OXN0eWRtcm03TEthMGJtb1ZOMUoxL0VDY0VnbERDOU9VTVU5SUNNaWxvN3U0cW9wM2YrYnp5YU1Uck1WQktia1RGUVVqbGJSWGRpaDRSYlNzRFNKZUpJMkJRQkJaTk0vTDNMdm83OHFPQVNjV05yZE12WEkxQTVTeFRHM0RTUlRoK3EyRmFNTUZyR3ZhTXdEdWtSM3VGY1ZUQTJPSU9kWXVqSGdaWXdlSGtsdldlb1B3V3I4VWlLTzNXM01KVFdKcEJMK3l1Yld5RjFid3NDQXlMbHhjWXZJYXJTQk9ScUhXOVJrTGx4dHdDdFhVVS9Hb1ZLZjZaYU0yeHljUHQvYzNMNmI5QlNzTEMwK2dFcGttUGNrb2pPaVRLNlZ3c09nSHY3cjd6VFNvRHpkRUR4ZVgrYkRyOHBCQ1VCbXo5VjJuRWxWZ1lJNHdaNWhuUzJOV1pLZWk2V3d0RzZubW5IcGo0d0xlaG1TZVI0bXRWOU5JUVB6bWFwZzJuMnpINDBpOCt5Q1U0OGJ4OHZMNkYvLzUzNyttdXlsbnNiY3ZjQkduLysxLytiL2U5OGlRaTNFYittNTYrLzNOMUhXSGozejc3cC8rK2JmRDlnV25mSCt3aUNteWlHZzNIWFhNZlplUEpoeXhGK3pIOFdqRHBRVHJkVHlreVRaRDdpaTVwaS8rK2xkZnZwRDBjVGhTL3Y3ZDhmYm52LzdpWnovYlpIcVA2OTkvOC9FaWNER3ExZXdyYnIzSDBrOUNDNTgvS3gxbmx5RnE5bHpSRHM5SXcrS3RLY0theGQrTDFjS2RqNlM4L3NwWTZJcFBjcGpYdWtHc2hEVzhqdGpoZGNKRmJTWXh5WHE5THQ4QWp6RFBOcm1VVGhUNGNZcG53N25SbkRkTGZMS0Q4L3ByeitITG1JVllWa1BZVDJZV2haWXJJa0ZVaExpUXBJVllSTmxJSk1KY3ZJeFpaajNnSTdodEhZTVR1ZGM3S00rY3pCbUt0ZXJCVmlGcWlSWnB0VWxwWEhBRXVYdHR0NVZ2V2ZPN1M4ZXh6ZXR0M3RabVJWanQrODlFaCtvaUs1eGhEanZEd05kRjNWSERFbWU4TlpnSWxvVmtnay9tbnZQYlkxQWE3cStpVEpEZy9XYWJ3Tk93SlNvdXVQb1d1b01ZWnRteW05dEN5am45WjI3K1ZlVGZvemR5aVVmbDJGOG1EeGVCSTQ5cDJPZXRhb2ZQUC9uc3pWLy9oMS90RHZ2YnczYm5ILzRJM3YvRC8vSDNkL1BQbVVhQ3dROUhHNGU3Yjc5OWQzZllScDd5L1pDWmFlSklySnlIQjU0NGNxVHVVT2NOdDU0Wmh0em4wUnpFQStmRTNadWJOMjkrL3ZtclBoMU5EdE5vSFAvblY2K3ZyOWhZOGlGY2ZubDdERE1DWTNhd0xSMGZKcElhZURmZkVieCsvTks4ck14d0ZzZHEvUmFIaVRqQnNiTC9OY0VIblJuQW4rUFZuR2lqVDh5dnAvYkhSdWxZbVpwWHBYejEzSzNtdmo5WmhES1pCdzNDQkR6dWJxeUFqUFhXSzRUSzJqMzlnbGpaMmF0NEhuRHpuTTJsMkt2YS9helJKMFZWdFVSNHFoSXhXRVFpRzBrUXA5SUFuTkZSc3hLUldrWlRZV2M1T2NpTFpMRWFUZXBRQ0NVQ1pVVzZMdlFXOE1tdVdpWERvU2xnU09Gc1hMUFV1VWxEcmQwdFc2OXE4VlRVT1R1cWNKSnJMN3E2T21WbitUNWNITTFFQUp2RDlBcmlETVRzRXdzbHB0RkUzWDZJTzVmTjdhN3J4clJWZ29xQVZVV0RxZ2FadTEvdVJHNldVa3FXemVhS2NCMWd6M3p1UTZMbnlQM09JakZ1aU1Tb1U2TkpQdm1iRzBIR0Y3Lys2aGRmN1hqRHgwVDU3cHZmcCtQYjMvNWgzRW4xWHJsUG9Ed2ROc2YzUDc3NzhidDN2VzR1K21tYWtobUVKUU5NbnU0ZjREMVlsUXB1M2JKemxLNkQ1SEZJSklBcUliNytkNy81N09YcnF3NFBtWFIzZWZOemtyaTk2b2RiNzdxOWJuK0Z6ejRFNFdZNm56R2hpK1M3UU5tZWJQcTBQMkd5YWlPaEFhV2JiSG1kUDFMdmpHWHkvbWdGdGJLWGNXNkhvdE9kOUh6ZmJLSmc1cVhaZXBiZXg1Z0ZKdnhzVzdsOHlPWDhpMXFPdS9Od3NDWFB1aEJMV3QrZWhjOE0vL1BjU3FobCtUbTVlNHVTYlEzYWxoeFJLL0tTNEZKSnYrVVlFQmJWWWpYUUpUT0NlRFdnS2YrLzFvSnVkUmdPTDJOT1hwbEZxeU4yQlRxdjBzeldkSnBmL2xDTUtqdzFYR3dOc3BNVFNVd2JTT0NrMlY5UU9nM0xWM2xCMVE2ZlhUUWZhZ3F5Wk5ObVhpcXZHaUJoWk1DaldONnd4LzNMNjQvb01Hay9jYi9CVG95b0MzU1EyTVZRV3M4RmVlK0FaeHR5eWxha2JyUUtlMTFWalV1TWZUT0RuQndVODN2cU1HWTJOZ29jK2xmZHIvNm5yK3orNGU3TFgzMzU2WlhrdzM1TStmajFQLy9ML2pnT3V0VW1lbEVoK0hUNzU4M2RuNys3TzQ3eG90LzJickxwRG9jaFJRMmU0SlN5Tnh4NGR4eUZRaDUzQXU0Q2JKK05oR0dkeE0yTFgveWJmOXRkYkNYbGFicUVremp4Y2JxLy9mTWY4b3RmZlBMbVJsNzlqeFpZbU1ya3ZwNHF0Y1VrUkkvbVkrdVppek10Y1JrbklyUnlqbnZsbHJkc0E1K1RIOEJZaCtzdGJ5ai9WTk5vdWEwUzQwUkZVcU54NTRXeUdnczkwaXY5NUFwR2JZd1V1MFpWZGp4ZXdDVUhVVmRTeVBNU2VrR3JsME9sbHZwZUo2UEVQR1BnaXhLcnFrQmEyaU1ZTUtubnE0YWdaRWxBTERwM2U1ZGRkRzVFb2JrbEtzSzhNQ3dkTENqRHFYcnBZVm5aejFaTW50S1dhaFJTS3cweGNpbWZkQ2hucjdmVjI4d2NzMHRzRmRnRUxLMjV2SWl4S3V4SVZIbDYyQUJrN2k0ZzV4bytEWEoyc0dvZVV4QTN5NG91U3h5VHhNbERweGU3OUFwcDVFNmhvaVh3b3Q3YTNjMWh5Y2FjeS96bzBjWS9jNU9YWE5DRmFQVElCZGRYczdoclIwemRpMThOZi9YWFAwc2Zibi94NnJQWEcwcnAvWS9mN1BjZnYvczZEWk5Fbm5LYllvQ0Y4c09mSDlMSDI0K1Q5RmNoeUdUZXEyeTZmUktsN0NNemRKdnFLNHpIeVRtd0s3dGJya05VRFQxenVQNzhxMCt2UW9jSnBKdWdsTk00VHJaL2VQdjd0eSs3NjAvZlhIai9pa0tCa0xjRld4M2ZqRG1hd2Ztc0pLM25SVkdBZzdYMnJkc2oyWnBVWG9rUGNsTHZjVXVzbjU5NE8rMCsweGtnNUhUaklINmlsMWdYRzFmQVFpdnhueXE5VnlEMnA0NTRZaEZuVWFFQ1VSUitvcWF2bDkrMlV5eTN5a1hBMHB3Yk5mdW5ydVl5THhWdHBNa3FSbkdwL0ozR2ZxM3oyZnFUa0ZZS0hJcHV5d1ZZb1J4clJjeHJoaVlSZ2FkaWZBWTNhSEs1c2FPbUlNeFg5U2FQN3B5ZGhDVVJDN0ZUSU5RN01MZGNBNkc1dzgyemoyZ1dWNlBtZ3BidG84eVY1MVFrOTF6dndFS01zRUZPUmMzRlRoQm5WQnhza1Z4cUdKTTc0S095cFpHbWgwMmZjNVlRQXg4STJ2V1lMbHF2MU1GTWNERnpzNVNUWlY5ZnBSYmw1K2tKVEhUZUxUbFRCTmJiajJoQU5nNDN3Mlk4N2w3M0w3Y1htZzRwM1g3L2oxLy9NS1VIRmNXUW9CbkVCZHNQeDhIZTNVM1pTQUs2U0phRmN0ZHJQMW9lbVVpalJENk1PWGtrRW5IUHJtUmFOdHRwbXBKc2RwM1M5dVdiVHk5VUdjNGF1aUg0WVRvOERIOTRmM3YwMS8veFAvMTZ0OVhPcG1HK0Ewc2pYS3p0QjNPaGNUcDRxUk54ZnVvOG05M21pOWluRFMrcWtKYjV0T3UwSkxvM3R2a3A2K25waXkvV1JMZm1TcVZGWmlDbkFyTkhUS3RIWkkxV0M2dFVXQk0zT2RMWnowZTEwRDAxL0s1QTV1dTBvbnBHTG0zblVNS0NXKzFjSWlsWkpLaXF6RnFRa3BSQklnSmlkNWF1eG9JVk1oTXRxSUQ1VFMrQk5WeHMyV0x1c0JyYTR3WDRYSEU5TERRVFdKZ3FMcWFLdHlETjJWaXkzVmxjUlZXcXNZaWIySnlZclJnOUJHMk10SURzTUp0R21yYTg3Q1ZsdjFKTTF2R1lWR0ZROVhsWHFFeXY1Q1pkU25rVXRlVDlrQjZjekhiNzZVZ1JrR3ltWFZmWWFNWEZBaFp5VDU3TmNzbzEyV29XSmZtaWMxaEhCODBjNytjcXM2a0tZZ003d1prankvM0Z4WFc4Q1NFLzNONk5mLzUvZnZ1blcra3dCTTNtV3NNSnluNG1QdWFEVTJRSzNRVk5JemJrWXl5WW9KRzRaeEcxYVVybWJ0a1ZSakJoZGJhVTduV3pvUkM3eUx2ZEppaFp3YnJ3TmU3Zi9mbjI0Lzc5QWE5Ly9qZi81dWQ5OFcxcnFEbTNiWXkyakNkcjZSTnhybDJmNjhZRlhEYW51b0pDSTFTVUxuU2huN2FtNTN6UFdrN2dKUUZDZU5YMmYrNmFldDdwcmRkbW5rdm84NDlqa1h6K2RBWGRCSXl4M2lhOG9pcWUycUxvUkFxT3N3YmJ1cWV6d2tJMU00RVNsZ2NKNUtRZ1p0YWcxWWJZL2lmRUlqVVFTem9qS1FVeCt4cHpUNHZtbWVZbU1jcU83RXdGQjBzRTV5S1pJeUZ2dThjY0dqTWp3NFFrbE9tOEVST3BBQ1NxUEh1b1o5elBuTzZYS3lDT2xyMEtLT1FSQW9oaUhTaTN1L01nR0szcjhDQU1kNUZhcUJiYmxqUEJzc2ZRSlhPS1NBakhQTVF1Y2pmbVFTWGw4TVhEUndPcisrdzA4eEpMWTlrc3BWenA5dHgrTnNGYXFuUHFvM29LVmpoTFpWbEVpQkFjRWhsQ2ZlOURzdkVENGZqam43NTdlUCs3NzhjdUNybzhJWEkraEZxUUIyV1NRQnd6S2V2RkMwLzN4MjdUKzRIc2FFSDdBd0t4RURiSHliS2xaQmFFRFNrcWsrVnhzSXRYUFRLTEVmSTREQ2tVbjRvbkgwYSs2Rjd0Nk9xWHYzbWp4NTdaeDRINndBUlduc1c1czJMUFo2SFJPZUptMGQ0U2dVTWxSWlpidkJhY0F5L1lHRmRsV0NOaEUrZXF3YlN6Q0k1QWNHSWxueVdBcy9LTmFWMFNQMlptdFR2TTJ0SmMvQmFMbHJsOVduaHVKYXNEUklhODZZSm5zQW1rWklFMHFpWnhpMnVDZzJKejNGVC9iMTVjUWZPMGEvVnllQ0ptWXBXSlMyUTZtRHliVTQ0c0pDSFVCR0VTTHFFbGhRMUoybXRRcWdGU2tkTVFxdXFwUlQvWWJPZGpkcEFFQTFoWnBobTRXZThwcW9FSkJBMVNGSE5GOTFWUTA4UU1jeFhsaVZsRnZOb0JIWktUYU9ES0N3RlBWWm9aS2t5aldVMmtqSWhyM2hYTndXMDFmNWVkM00wTU1rSWtXKzR4Z1FOblpuY3JpaDQ0aVZqUXlVQ3lUWjdScWNRMGJzTkdaQnNPVituN3ozWVBWLzdRMmJnYm1Lc2pncGlSUnE3SnRxVWVrSlV3cVhiVnFjTFIxamhRWWpZV09JUWZhOTFMNDcwUVd0dzJkUHpRZjVqdzRmYUh0ei84Y0o5OHNNR2h5S05IeTk2MVhBekx6RDU1WWljTHNldW53OGNzaDlGNWNvbmtySVNNalIzQ3pvN1R0cE5KbkNSTnh2MFcrNGZSLytyRnRlN3Z4bWtqSFE0Zjl5TzBnN0F3SGZEcXlvSUczNzdlRVcwZXd2anRIOGNYcjRQVzNVcFhZSmIxSGZJbjI3WW50NHAxcjJBNXVFcml4UkxjM2doL2ZKN1RXUWNrWjZPaWs3SEhULzIxb2pPdTdqaG5WNXlmK0NMdDhxLzVHQlJXREVPRmNVMG53TENsZ2R1NnY3eldYSjZuQnpiU1NZVkwxNjUrWVhkWmRncFNuSEJhOVMxbzFxNmxJY1pBZG9nSVVlZ3dpeStYdWM5SzRjc0tXQUgvT3hIN2pMRU5Yc3B2cXhKRDQwYVE1dUx6WWxVSk1mUnVJQTdpdFhReXdBaU1VRzdscU5wcVhtaStjekJBK1JteEpoN05Lb21DOG5OM2djOU41M3JmS1BCTUp3ZkJZRGE0cEtuY0h6d3AyeVJ3TXFjUUJjZDl6Q0NmNmhaaGNLYTBOMUNFVzdaY3AxdkN6dWQzWGp3YTgzRUxXSGlpV1ltYStsd0VwMzF1RHpZQUFDQUFTVVJCVk14RDE0WHgyLzNkNy9mM2g4UDlpSnRjdkU5YThJVnNWU0xTdm5ZV2NOejJ1RDFrZU00T2NPUkFucERkSmhaaURTck1sM2xLMlVtditKank1bFgzZVI4VHE4QXlkSnVML2RhRW9Kdm9ZRlZWa0t2di8vakhmL3dUUHZ0RkNyb3V4Y0NQMmo0L2xYQjlPc3BZVHN6MSsxYjJiVzN3bFJtK0pVODFwRTZwbEV6THBPYlpQL2VUeE1pbmxCalA3Z0JWZjVLbjBLa1pTRnlZS1hPRkFjOE43Um9KWFFOVDFueWVKOXJhcXd0ZVRVc3NjYXBFUU00SjFCTVFkUG5rd2Q3cXZwcGtJd0puQ3VMWkN0WjBya0RXVW9VMlNkTlpSWTBzQmxnQjRCWlZPUXVadTdzS2c2WE95WnpjaVUwamlEVlNNaU5oeWZVbVhobDhrSnFDNkhYMDdFdEdUZnZwbUZhdExXQUZWQ2h6WS9maUVKcHJiZ0lWeVRtQnl4emIwRG1ZV1NQZ2xqTkpsR21NUkM0TTFuUTRkaGVRb0dhUkNxWnZDalRzYzdleG5IUGwxdGJVMElwRlhvU2xXUGNxVmdteTRFckNmNktiVlY2bmdJeG9ldmZ4bXovdnh5d3dGWE5XWmtJbVZXV3ZsNER5RGdpWUxCS0ZpemkrTlFRa05pWWxVU0d6S1IyNUU1SUFWYVlJVDFuNkVGT3kvdXJsN2dKcFNpVXBSSGZUTkFZM1loZjJ1R0Ztb2YxR3grUGhUMS8vN3J2djhlWFZ5NHNnZFR2MEdWNTJXcUx5VHozeHZCYlgxemZFenhjd09UR0xZMFd5VzYxZE9WV21uaGpJWjhISUV5Y3dQNzFlbmpwVzZheGFmODVmVkI1TGVFS1FLanlzenhqbTNLRmxiaTJ6Si9KSkFVckxTcUlsUnJTY2hlVk5BOGpOUUF4M1lTMzgrL0lvQzlyNFhJaElHYzRTUStUUlUyT0d6bXUyRE8zbVBsUzV0WXM0VzNRS1pjSEF5b3kweEV1NnUzdW82ZGhnVnJTSFR6MDdrNmZKU0VyenVCb2hXTGlNbDhydWdobUVVR1FhRHBUWVFTSUllU1ZtTDZ4UXFubUg3ZzZIdXk4bzVrWW5KUUVMMkRQY0hjTEV5cDV6TXExQkFaUTNQRTZTeHZlZmNmUVFRaDJPTU13eEpyQk1PZGxpaXdKT0plbVA3N3J0TjVtWkJJOEZPeTBtcmlZclU2ZlQ4ZmpENy83VVQrakVtVncwWkFhNXhpZ3lwZVlQcWQ5Y0xCSkk3ZU9SQXhNNGRLUXNjTzVCYVZJT0tPbWJiTWFxMm9janhldkxpMDZHTkl3VFNmR3oydkUrTWxFZ0plcUZuTjM1Y0x6OS9wdmZmcnZmL2ZKbnYvajU1NWRoSGxyU09rWDJWUFgwclBCaEhZalpwb3dLbGxYQUFsYnJxM1d4cVByV2VGWDBNdmhSQjR1WDBwYWVTMHBZMmVsT3oxczgvWkw5MmUyb1ZPRW00cDY3cm5LbXVVRUNWczI5bGR1UDUzN1ZZL3hzYWVBTG5YRjVadkt0bTVOSWhvQm5Dczk1ckRlVEc1bUlLbnVlc2lyN0dSaW0zTTlyRW9PQW5FaWtRbnZOc3BjSkM4TmhoaFlsU0tnTmIwSHhERE16dzZZOEZzb3RRS0dnQnlCZVNhenJmSUltK0trckZZMnB4dFdUTU44OForVFJBbEdDemVjdnIzU1hvZkIyS1dkM1Q1TmZrRElCRmpRSUVTeDZIZ0loWnc2VFV5Q3AvMldYcGl6QytXaUdPUzIwekREbm04YmpBcnBsVGxiMUR6OTFSV3NQT0VNSzZXTWFrNWtiRXJtTDF2dmRKbmFCc2s4ckRIWlROcmtkODYySUNJVk9BelBJbVFLVWtRSTVDcGNxVXhmQVpGTy9mWGtWeCtPWXpUbUtvZCsrZU5GalBCSUhDb0g3UUdia0UvN3BINzk5K3k3SHYvcnMxMS9kN0NKQ25sbEt2TGljbjVBNjhwblJabFpTbmk0QWxHanJKWEFkTFk1aXdjZzI1V0V6UDdVRmlIV1NObHF4S3ZUMHZPcnhBang5c09mdzdKUHVPZi9FZnVSbGtLeW94MkZweTYybVJXanl3eVkvYlJqdEovUW5qY1FoQkJkdjNJRHFPbmNRM014SW1FU0ZpTFZHeGErR3MrWHhTdTZxSkpUeTZLRlhtbG9FNGRJUmwxbUxRVXhXZW1IdUFuZFQ4NnI1dFpwY3BpMkFzL3hubkZ0VDNaRnptbGlvcUNDMXVwRU1FT2c4Qmx6TWlXMkp0clMrR1k1NHdoOHJIdDJLUkNyZGJxdmZlbG5neE9ESVFQbmVqanhNRUlvYU1ReGRJRGFUQW5IditiaTM0Qk81YWsyM2lkbWNlVHBtZUFtaldVcGxFTTBTMm1YalBjT0pWYUhOazVyM1pWWUtTc0toMjExY0JzbENEaDRFZ0lwZUIzVjNabS9oT1RXYlVSbHNoL0hRZ1p4RUk4QW9LRU1TcG15eklEY1FQSmwzWFJTejZmaVJKVVFWYkhZdnI3ZGQ1REhFb0JwSTJZMTQrdmhmL3Z2dlRPbjFWMzk5OWVtbjIvM1g3MExtcFIvQ1dMc0YvbExUcUxRaHdsa0p5bWQzWURDTFl3N1JiWHprK1FFbFhobmtIN1hFV3ZMM1QzV2ZucnREWTBiTHJPL3N6MytoaHFrajBUYm1aR1pkZkdjOEs4M21OdDBxbnZ2Umh0Y1NmRnMrVUpuMWlIc2xLcnRsSW14Q0RBeFNtaFBRcUgzOWV2QnBVSWJsNUNIMlBqWUhzVE05bWdBV3BBOVlsY2lZM1lURjRDTHFucmhsTFRwQXBHQVhFU0VySTJKbUp4Y3hZeEN6RkF3dnNaUUR4U3VFcDFMK2lvdXA1Z0JqNVUwc1FvWXkycXNiY3NHdkExUzcwSERINmNYRGErWVZBQWtlTFlHazA0bGMwNVFGSWpsNXI1bmcwTkI5bkNJbEpBYkJMV2VuS1J0WlRnRXN3cVU4cjVkZ25ENG1ERDQ3a09wRUU4QmpVOE42b0ZlMlhnZjMxK083S1RFWkMwWG0wUGR5eVdtYTZuMEJDNlFXRVJSNUdNSEZtWnBKY2s2WmVNdkdVVHlMaHBKbjUyYlpRVnVWNUppeWhINnoyL2J4eGZYTmRqb0dtSXNvRXcxcVdmbisrLzl5cTIvZVhGNWN2WlRETjlQM3YvdXU1UU5YRWo4WHd6d2V0MVg1Q1RmUGlTUnlKcmFYNlUwRFlZR0xmSmFrL0pLQW5ZMFJ3R0FJVHU3YUJmUGEyQnlZNmVKUHJPQkhFcy82Q1FsV0M0ak9laGI4VTBMS1VrbUtXNGljSnlFbkVTV1o0NzE0aHRtMTltVUwwbnhtaCtHVlJyd1JDMGlMQWxlY1lBWWd4aWh3NWZQZVF0TTJTK2c3ZG5kaWxUNE1JMU1UVTljN3lKTDFSa1JNV3NaNEJSd0tvVWh1NW80RHRhcENTcGdCRjhnT3BJVEFHSWdsY21ZNG9NVjRKQVFpS2UybHRlU1FpN3l5UmRlc3RuOXZZaDN5QmV1SFZUclZvdjllbHpWb2pIVmh6NU01OTV2YjZXalpwR09oUEZLblhxWjJOcGtxekJ6a25pMzdJV2NuV0pISGxGWk9RUk1SbmVubzVnMFlERWFvak1VcUhtTjZlZ0UzYmI5djBqaUJkeS91MUVETWtvbUQ3clloV042UGJFc1lYajJCNHlSUlJndHVJRUttbnNpbjBTVXloQ1Zsb1JMdkNKc1NSRldVM1hMSzE5M0YxZVdMNiszRjFTdCtiNVo3RVdXQndjM0Y5dSsvL0ZsLzg5a2wwalI4KyswZnYvK1FBaGRVTVdtdFdKMUxSWlFxME1YcUk1cXJnZC9MWUFpK0FPSGJITGZzZlZvOURkSk9CQWNydGE5VHZPRzFSd2oySmlaZ2IyQ2ZSVjhnSkxSQ1NiZnZ4N1RPY3ZKelh6SFAxTWdpSzIzUkxwWGtKV2ZkU0t3NHdmVzdaUWdKbTRzSVRHY2dIOEhKV2V0WXVCalo1djBDU3lqY1NZbFNRNE81R1Q0d1ZscG1seVkzWm5YUGtkVXRTUGtScE5YbnlCSWxoRjVzWk1DVm1OS1lHUkJ4K1B6RXhTcUZuS1VaV3BaeklDZGxzY3dCUGlYdnA1U3ptNE9WUEVPQ3NnQVp2WVBZakwxZ2JCM3VKYWpZalVNaHVvRkFQSlRmbjdIVld1QTU1ZFpMREszQnFlVlU4L0xnTzBHVjBtU2hHOTA0aEp5UDVid25senpJaFl4QmZES0pPcGF3TERvWWdhUHZKNDZjUGFjdWJDUWZKTDYrVHhjMzh0MzB4YWIzdSt2Ky9sSXBEOGNoazdzUldDRGtEaExNUXRmNTN0WU1hWEJhd0FTWlNZaU1RbWtaUW1iU0M3ZlJoelRRRmhITElVU0dkWjJrWTVCSk5IblhSekVmN0FoS0ZFeXFCSUtWWTJRRVp1bTZLUitpQ21YV1NYSGNUNXRONmdMdkR4bWRsWnZrWHBVeVN5U1l5K2J6cS9qR2g1Zlh1MDlmU2tpK2wxZmRydlBVWXhRSCs2UmZ5dTVsREZmSFAvekxOMy80TU9VSm9jNDNxZ3NkN2tVZFRqcGpTTXZTc2JvbDFVeWtwbmg4cEgzaU0zK1AxTGFITm5rRnJVVzh4TS9XeDJlLzBVNWl4a20zNmw4M0pacjdZNCtTbjA0M2dsVjN2TTVlNmt4OERaN241K2ZRVDVRSmM2blpCT0wxSU1wT0FhUnNHcHloYURlWkpnTVJrdUl0TE9kbFBld2NsUnlLdVhJcS9mSlpyektMSzlFVVJRQVUzcEdUbUhnOUpaWGNYY3A1d2ZYTEVoVzNSZW1aR1hnV3h6UitVc2xaYWlJOVdsTEJsaHdNbm9lL0ZVYm9NR1prTTJkQ3p0d3d2S1FoSGZwbzVLSWhLaURrQmpncjNFRks1WDM2c04yQW1DakdZRWNNL3U1ZEp5RmIyZ053MmVBOUN1cXBCV2kyNmdnL2ZjTWlPYlUyTEhOclBpa3A1OTlTY2lmZDVyNVB6T3dXTkFxbENjbFR5alhpMGtrcTVEam9oWU1GVWN6TkRjTEJrd2RSa3pRTmcwa0l3a1pTQ0tWQmxZUm84L0tYLzhOWDE1ZkRuOSttelZaMnNuK1FYZGp1TnNtT2FrTE1yRnY1alVSbXYvdlRmM3YvYmdSSENlM0JiSkk3clVkbGl3b0xiV1pSc2l0Sml5Wm5VVWp4TXl0cEVXS0FlWFk1cmQ4VFh2dTkrQ252RWE5ZElpc0pKNThxTzU4Wkx5MU5KakNkeU52UHhsV1BQdWg1YnJ0K2ZlMHlCRHdwc0R6L09yT1Vzc3A4cTY4eGVGbHVFM0ZnRWkzcEJ6WEF1elROcXRaVVExQWhMN1VFVDVhZHFPVHJ0a1MvSXBVVUlyakxhbE5jdjd3QUIwdUFNVml6NVJxa2l5eEJsV3M3R2tCMEtUc0JCd2txYk41RUgrWDZXR1NlTGxiN1ZuT3FYeWwwSUZncFcxZHhmK1lnVms4bHZJZzhPaG1ZT0pub05JU3JmYzZrY0pMS0dqRUtaUUZYYlBDZGEyQm1Uc0QwMFFlLy93NlNrNUlaV0FsNVpGR1dwWnZDNTJMN1o2R0VjbEpqQStzK2RjUCtMZGNUZFVCa0l5L1Q1QlRNT3hHMk1WbjIwa3dyNGk5Q2lPTFNYNFJMdDV5emNFeVR3UW5zbVNMSWpkeFp1MUNDRW9qRW9Ccmd2TDErL1l0Ly94Ky9ZT1RYLy9DdXo4RCttNi9EQlZuU2xMQVJNREhwcHUrbmxQUHc5VCsvRzJPVTBPOENadW1rc0JBaEZsQTlTK2t1emtOSGFRb3RFTEdvMUx6YnVjdjM2RWprSmIrMmxpU25VNTZacmZTc29JTlAvUXY4K0JkLzZscTd2Z1h4MlFEaGlTYmRuR0ZVYm9aejVRV2FJY3U4OXNzKzJkVGpVd0JCODErQm1LeHFqdGRkVVdFTklVUTJEckY5YlpsNzNDTEN3azRHTUZIT0JoYlJXTk1WNTZ2NVNvSk1LQ09QRTQ2ekY4K1lJdFpLMFdERTVBSjNZVXFpQWpkM0ZsRW11TElxdC81eW93YTI3WXRuSzZpVlVocTg3UFl0LzZHZVJqVXl4MXdDd1J6RUloN1VpTUFxRDY0cXh1SEY0WkN6NWRERGtTSGlvc1hONnprN2lWak9aQTY2czR5OWpTRytQMnczWGI4aEF1WDBjQ0FXbGFwMFhhSEJuanVCVDlrTjYxVEZXVjdDcTFuTEtnMm8yRnU2bCtQaGlCQzVJMHFXYy9aNkFXeVowS3hxOGZMbW9yUHhlRWh1YnA3Rk1wVVFKMURXR0RvbkpvY1RDOFZRdExPN1Q3NzY4aGUvdkdJNmRsZFg5K1B0VHQ3OXk0ZWJHNkpqTWxJTEVDV0hVRDRNNDNoOGYvZkNRT0RkVmVrbGNRRWZpWUFiU2RocnYzVVJWN2IxU0NTaVl2d1kwM2syYVZzN2pSN1A0ZmlVMFBILzF3TG1KN1FVVCttenprL01xc09hczFmcU9TaStFblBPeUFIOEt5cDN0SDVPRXpXVS85NjgyT0NGbkZoQ25FR2Z0R1lEMWsxTndGcTRXa1NzckNXMm9Pa1ptN1NUU1Z4YUNzWUoybmJ4QmpHekJtZWd6QVM4Mmh5WklWQjROaE5WcURDTENMbDdYTkR4czMyUVcxYU1DMUxySnRSdXBpK2NTNTZwbUFYelhKM2hoWkVMZ0ZoRTQ1QTRFSWJYTnJrWkt5RmI1cjZyYm5QS09SdUpTTUE0alVsVEV1RThaYjI2MjErSHppYWVCaGM3RGplc3NveDlsb25tWDlJTlBQcTRzTllZWVlhWXQ5NkdPU21aNGNYaGJuU0puVnZLNWloa0xSU0htWkRvU0ZGMGMzRzFtZGhHdGpSa0UxV3lLVVkyWTgzMVVtTGt6TUxzMjUwWWRkMG5OMjl1cnJkK3VPaENmdnVIWVkvOTNSRFRhR25NY3JFamp4b29XL2JwSVEySGtWK00yVDBqY0toV2I0a2NWSVE0THd1WWk4NnNNb2ZXbHAzVzVmdkpLK2dwQThlZldIZzhtd0Q1NlFWOGFpUGlSNys0V3NENGl5ZndMQU03bXhjdkozQnRmcmNWVE01VlJyYk1IWjZVV0o4Z09FNitibm5vYVFVK25RaGNZcjZJV1VNa1pCWW0wK1Y0WjJZaExYaE4wVGFSWkpVZ1prUFZWTFZUV0dwZGxKdXM0Z3hVMzZ4OW9vQkptM01ZdUVFUGxVREZld2h1MGxmUHJsSXN3QzNTeGxjZitQTFc4aHlaZXFKOXFnZDRmWkZ1RENaM0I1bVpPOGhoSVdhbzRLRS9USjR0S0lDY3BHTmxCekc1WndNSmsrUWpaYk9wa3dDWW9ROVpPNTJPM1hpdzJGKzkwQklnMXlpcHoxN0pIbW1kejhnd2RhUEMwZ3pGU2FwWGRna3c0KzNWMVhIVUdBYlB5Ym1HdjdsN0NlRVRWbWFOWFF3NVRaa0ZPWm1IR0lDUm83aURrRE1nUVp5SU5TalQ1cnBEdU5pOTZubVlwSS9XamYvMHQvK2tPOS9uL21xVDcrK1BhZlBabFFZaFF4NkhQTzN6ZUovNWlwT3JnR1BZVkRkTkJXU1R0b1FlTkUvZ1FxVnNwUk92Tm4vK0tlRVRyeXpuUkNkM0UxNFJyWjRyU2Zra2EybUZvY0JqdXpDZVBZRnBmWDk5VkVNdlZjSko5aHBNSzJ1R1dKeDUyVytlT1gzeDZJNi9rTm9Xa2hVeFNFQ2VMRldtazhCVUE4LzkyMEpYWUE0a1hFMEZ0WU1rb29BbE44Y0pmaFpuRjVOVDhuVkxSNHBTb2hGeUplMEVNcGRDMDBTTlJLUU1pTUNkdlJCWFFEVW92RjBOZUY0YnMyZTB4cndXMjhheUk4OU1iaStSdytoVDhreG14YmFjZVdJRlI0enZFd2R5am9tWTNDYUpaczdTSUtVd21JY1FJN3RQSUpNb1BYR2lhZGhtanQxbTErMExzMmZXemVNeGhPV1pxWDh4Q3NocDIyTU5OS3NWWWdXYUd4Uk9TcnZyZzd0YmRxeVZjMXdTYkVCUm1aV20rOFB4NkFCeWNjckNSNkJqU2tlNGt6QmNXRVNEU0wrN3ZPejYzWmJJSnQ1MmVxVGYvNS8vK0hZcnRIRzkrT0t6Zm05T2FkZ0d6NVBaZEJ6elB1VURNc3owWXNlamhSMkxpQktIQWkyanJtVVAxUUc5MUNkWFp3eVNNSzJJaDg4U0xsWTlYejc1K3duWHpqTm1pZk5EZTVtVjBQKzN2eXBBblpmRDg1RWZlWVZ5WmlLQ1ZTd1FNNVY0aXVXZWkyY2F6bmpVQ2FPbEMyMTFmVEl4dzNJZXV4Q0NLTWZzRXJweTIxejJ0VEs4RjVFd0VZc1dtUVBjeGluQlQyTS96N1lJektyVTVSWXNBQ21Eb0tyRDNGMHJDZ2FHazRCSmlVQU9DU1VhbHIxMHVHZlBSSE1KVkF4ZlBldTU2VGk0NHV0YUU3cW1OaGFRamhQVFJwQ3BwRUtCSExqZkJWREhTTExaSk8wM0U3T1FKMVp6YjQwVHdCMHVvUlB0am5rQUtFU09lZnJZSWFXNDZWV3lWM1ZLcVJBWXhFVC9LdW1lYzdPZG5ycmhWdXUzd2dMcmp1NWtSTnFsYnJjOVRBWXI4OVJ5ZHlFdERMQ0NGYlI0SUw0YlJ0M0Fram9CVkV3a1BkSWhTSXdCeVNKTGtNRHk0bUo3Y2JucHcvc1ErNHVPaGszKzdvOTBRN1IvRVpOKzlUZmQ4SEEzOEhCdi9mR1FMSStqUHhpTTRYZTUyMFlleHlCbFdqRjNpZXNjRlZZZjJzYXlzbm9mMGhyQXJ2Vkh0TE51OG1sdGl5VUZxWHJrV3RxVWVMSENLR2JGMVhMUHJuN2tHWW5TYW1Hc0FRREY3YVZvK1o3bks3MXlxK2NLQWcwQmVmSm5iUzJkSzFJSVpuSUt4ZU04ZG9iUUIzTFh3QUM0cXpSS3JrcG9YbjNnWmNSVDU2UHVvcEZwS0UxS2FBR3ZlWURsVERGSTNFUWhRdWFvbm9STmluU2tYVnBkV09IWnlvOWhUQ3lZVW5aekkwRXVrUzBBa1Z1TmtpbkwyRnJDVllrems4YWdObWZ0aURzYkVqRWtqQ0RXeUpKSldGVzFKUnpCcHlTcTJzR2RZRWFHMkt0TkxSMHBrdGZrTjRGNTV0WEZhcjR6Vkwwb3djMmtFandPbC8yN08rNmtjSVd5N2Q1ZHY1QlBkLytrbXQ5VGp4LzZpUS9wemNYYjhhTmYwb2U4d1RSQUNSeUhhWE9ocEpJdVpKeDh1a09LRzg3WGtZT3FLZy8xSkNtOGtaUHBRa3NHRVNaenhVSmNSVld5RmFVWXFueWFoVkg2RGR6MFlYTlRDd1hOb1RTTnUwL3U3OHdPV1FPYk9VeTdiaHBjQ1Y2eTBsa3hmTS8rb04xbWRPOGZpT3hvbXo1NTltaDVlM2k1NmZ2OTFIbjArM0FkODBNWExsNXUwMzNNZHJ4LzJNYnBkNytqclF1cGN3aTh1ZlpQSjAvZmZyRHhuc1BEM3RPWVV2WTg4dUZkZDBuVHBDSFVFN1ZOT3ZtY205eE1SQTNlTzU4c3RFQXcrTW01YlpNRHQyWVZuNE9qZURFUnpWOEI5WitGOS9IWTZQdm9jQVd2RnVJeVRsZ1RSQmlQa0F4UHpvc05WQ3U0V2hxcENKSkluYWVVVTFtWXp6dHZKMWtQZFJUcHVVU0lMajJFdHRhSVF4Q1JHZjV5MGh3VkZ1RkFKVWVscTcrc2J1NUVISXhMK09aZjdNbk1leDVtZ1VpSXVGSjFTMWF4d1BCeWczVFdZckFsSVFoY2ZDd0t1aEw4WFhCcmM5TENRaEhrcDlSbnRaTWxRRWxHWUxpRFluY2xRMG9sZWx6b1hYalZmVGQ4ZWZtUlJjbUc0WXY3M1diZ2pjSHppTWs5WndNSUxKRkVPcmRyWjAwSGt3amF2cERVbVRUdUpuN3l3SjFiam1zeTFLb3FQTC82OEVyYVR3c3FjSFd5eU82U0RnU2Y0SkFRSldyUTB2d1hZY3JrWG5CZm5zaHpLZzBnUzZ4cHpMcVY3V1VJY1ZRd1MvQkI0c3ZQZi83cDY4MUgvM0dZRHQwRittOSsvODFka3BRREk5anhlRTBYVzZLUFAvcm1RUFJ4eEdDZURDYng4L0hESCttU0VJcmN4T1lUUk91UElHaHkxcFhULzVUMXROREM2SW1XVmpONm5IQUJWNzhMWGdJNnoyWXg5WjlpRmVkbjVxeXJLT3RUMGR6YzZlTFZ1R3J0NW4zTzBFOE1ocUdFT1RETXdjSkJPekxuU3JpbkN1WVFOZ1kvcGVwWWIwc09JTmFHYzVvNVZnVkIzb1d3OENoNVlYZEppVGdUclZSSXFUVTFleXFoRGMxUy9MUW9uSEV5ZzU0bEZlVWlENmNITTVCeU1DSnlJeFVDc1FsMUxFUk9WdDJNYkpXTlhZcXhuSVZaaEtveWI1Ykw0Y2tlQ0tyeHZ6QjBtVUR1Y3JEWVQrWUVFaUVpVGtPTTZYWjZDRUdWalNrYkYzS0JUWjdjaXlrVzNHL0FGUE53SHpiOXBoKzhkOWxlOHFCYXkwU2ZXemFGbE1uUHd5ZE9mQXc4Vzd0eGZ2L2pwdlJqSXM3ek8xb2VKSVcrVFBuZzVPNFFDWUdqUUtRaVRZbWorR1NDdkhVVCtKU0w3RDJCbWNacHV4VUVUQ3lCRTIydnN1bnVxMS84L09hNjA0OS9ISWQ0ZlBpdC9QT0gyNlJzaVhpN2pROXZvMXhGSXI2UDQwanAzdWtCQkhPUzdzdjk3WGY2VlpjQ1ZoR3c2d2lmMHBaRkFaSVhNZjZwSDNZWklwMDBpUEY0dnNQbjY1dlhZdkdGeTBEblRhNUdzSGhtaTUyYlZPY0JDN3hvdkxCcVhJT2VmUERwVVR1dGdJYk5JQ1FFVndXM0EzbW1PSlkveEk4UVBUaHBxYmRoVGIwVXdrRkZCOGxCZVZaanJDeVpCVm5MTTZHeUpOa1QwWmdUU1ExRWNIbDhBR005QkdHY0hyL2x5Q2xTU0dJR2lWclY3VFlRUUdZVllrQUVJa0pNYnJOUm9mTHlpTWpaeWhXZHZIWHNuL1RSQW9tTDRWa0pSS3lpeDZHblRIRXFXYytPOFg1N01SME8yU0ZDRXFiZGxDLzVIWXlGSEo1VDhUMklLWGwyR3grMkhMcVljc2h3RTBOb0VMeGxwc3ZQYU54cnlCdWRmRmp5Yk8rQ2FTMzdrWlkyVVg4bHVGemJ3L3NzeEV3aUhDaElscUtqY0VoOG9jTTBpZ29UTW52T3hSSUs2NkpZUnBBaFR6bnJSWCs5K2VTTjNnMzZ4V2MzdXlqcC9zK2cvdjFvKzQ4bVBVMlRqZkxpeGZid3g4UDFpdzcwOFg2YnNrNERZNERBalR1NSt2VDc3KzgrNlNqa2ltRnNxM2hHTzNwbERNK3lwQUl2bDJWSXhxdFVoNmRxYUo3aDl5dVRBYTJHcXZVTUJtTzE3czRXTEQrRG1XMi80WS82V285S2dUVkQ5U2ZHdHVYUEtVaVluUjF1UkVKczZHSU5haStUK29hN3h2bEVhaFpvTU5XNUo0azNKYitpV092WkhRemhjdE91MmRZa3JXaG9CekJielVPcGt4ZzZBc3B3ZjRJMXZ5QmlsdkNabWcwOHA5K1ducE9JWHF2azVEa0wxUnFoZkFwaWRWNlNTVndVM0pNNU0zTUpLU25CTDFRNk9jUUFsLzcxT3QyWEZ4ZDBHNlNqNUFRWDRjQUVCWXM0bkpEdGlPbmVVdHdsVms0NVczcno3ZjVMLy9QMktGR2RVWksvQU1yQ1BoNXoydXcyRE9HY2M1NG1kVzNUQlo5ZEt2SzAvcXF3cXVibnpFOGZqcDhJRUtoMDA5bUZWUmR3a25DeGkvQXlZZ1dMaW1vQ0d6TkJ3azA0RGdkWEJUa1cxSjhoeDBDVXRkOWRwWHZwdHBjM201Ly81dnJ0MTdmQkI2VHBYLzQreGU3cW9ycy9za2dlcDdoN2RmWEpUZkFIUzdmWFByemZENEtlSEo0aFpFYkMvT0wxMjQ5M3V4aGF5OUI0d1lPM3FhbFRUYStkZTNMTFQ2K3JlVG12ZGkxL1FzY3huMjlZVHQ4RlRYdHlBcy8yMzNKNUJ1a0tRZmJVbU1qclF5TlAzTDlwdmgveFgxN0E5VHpSRW5KUHhmVW16QTZMMGdyajRqaDFycG1pcXhONENUOXJIclhTL2JEQ015L0dmamVZbVpOVW5YeGpTem14THZJZ0FoTTdsOUR3QWpoeE4xV0JvWFNMQlkvQkJDMzRuR2pOcDVxTmRNV21vNWpTbEhPQ3JtdVh5cnFTa3VZb0xCRHVLc1RhS2pqRlcxNWgyVkJLM3ZNTWlUdDdKUUNDc2dNa2s1ZHFHaFJFZ2lkbWNsaTJ5L3NmYnk5M1FCYUZKZDVJSk5tTnh0YkFlQ1FNWW9ZSFN2Zk1IaUpSM05xUldVVmluMDRWYnpQcTZFbEwySWtEK0VRWHdPZDB5aFh4c3paZDJ3bGM0NVdWMEwyNC9qaVY1MEZENkFNZHlHS1IzV3cyVnhmM2R4bnNKV3RNd2VUa0FuZ0lPbTB1L3QwWC9PUHRHSzVrMCs5ZWRmY2Y3dE50SjNkLy93L1hKR0d6RWY0eFo1WHRtOCsrMk8yaW05UDRMdWp0Y2Z3SXYzN2h5VTBjVHBTUnU2djQ0ZDMxcTlCVmRLL05vVjByY1QvYXpyb2s2RFI1cko3bCsvRTVYbTFsOHE3dkYxYWh1aTN3aTRsT20xZ3kvMjVWZmRWZnQ4ZUQyMUlmOFNQZCthcHJ2WUFLK0ptdXkybFpBQzVnWmZlQ1poSWhZU1RuR203SFlsVDV5dlEwRHFzOVNseXBPYlVBYmZIMnlPNWdWbEVtSjFZMUlyaGc1bkhqSkFNR1pLeE1jUFJCYk16UU52LzVTVnMwMW5iR3RXOGowRGdXV2JJMzBUQ0JETTVNNWl4TVZ1V1pZMDM1THBkaW9xelFtZTBOcnRNcDRNazVQQUFSS2Z0VVlDQ2JrWEIyNFJRcTNhN2YzTzNETnVkREh3SnlpT0dkWHh6NWFuQzREWk1WWGpzUktZdm1ROXdPcEU2QnAySFRYZlNBR29HOGlUZkJrT2NsK1lXMnUrNmJycTRhL0tTT29OaGFWenNBMnBuc1lrbGV2TDc3UUdEdE5uMFhONHJJTGlVSUxQTEY5ZDJQbGxsQkVrUXE4NCtGb1IwZEwxNzlwMzk3L2MwLy8yRXYyNjFTdDgzODlZZHZpUisrRzNiT2g1aU9kNGRCWHI2Ni91S3p6eTQ2SXg3MjAvZTIrV0dRRHgvU0Z4dkpwZzRqRWRpZ1Y2OE9oL3N1eEdwQWJndFk2L1l0eGE1TG1DM2o4OGdFeFoyQkZXanE2VGIwR25RMUEzVm1zZW84SmNMaittVWg2dk5QR0c0WGx6NnZEUFc4d24rc0l3andyeGp2Rnc1ZFVRMlJzSWdnS0ZJT3NXbWhNME5yWE5oSkV3dVBmM0s0cDZ5VlNGRmZyR1F2b2xvV2lJdHFMbkRveDFMeVdnNjVFTEhETDVSR3k2ckpETHdpVFp6VzBMd2VhV0x1VlhNTjMyRElpeGpTQk1PUzFsckdnckhXMk00dWNKSlJPNm5YZEljUkpWOFJsOEFGcXY3RVJ0SWU5UkxSd0JKVTJZWXhxK1FqYjRpOXhxRysvWFR6NHpGZjNZeWhDOE5SK05VUDhjV0h5NnUzTUp1R0JQSXFTdytzMFhMbzZPSnl6RzRUeGUwMlRqbVhSeFBROVNuNjNJVCtmRC9qNWZiRGp3MW12RVlBWUpHekZkbTNXTjVjWEY4YzRBaWJxeTI2amFaWTZVUHVoTTMyYWpzNHVWZDZTMXZCNEdDdUx6Ly82NHZyNGQzOXdMcC8vL0xtWnN6VDk0Tlk5L2xBUGo0ODNMNi9vdjcxRnhjWHRJOGRheGlQL2ZlSDNkdlUyN3RwNStvdTJWeUZZZnVMM2V1SGZCOUNtVEZJSFZnN2F5UHZVNW1acEpvRkZOeXJFZjEwZnRvS1lsc0NBbXVKRFFCblIrWktxNXJyMTVENWdVZFJ5ejR1bFU4ZDExZzk0Tzd6ZUVwclV5UFduVUxyOXRLdWFXZUE5OVhyWEhmTm5GUFpzREJSVVllVFFVSnhzSXVRNXpsaHFGN0NiYjF4QUJEeGtoekZYbkJLbFV0WkdhN0dwVEFuSkFKUkx2OHVXc2l5d2lnaVZSRVNKV2FWN0VZaUpCalRaR3llQ3pld2ZsK3VhWUpZZFp5eENCV3NrSFZRZ3ljQmtpdnNqd2xrQVhBV2tUYkhkeVk0SWtXNFZ3U3VPUmZFTjRsVEorVE80T0FackVFTlNjamRRMUVXVlRRQWJnMVErQUFBSUFCSlJFRlVjVTZtNGlSMFJKQkEraUF4Z0N4UmR2VmpJWWs3bURyNXFMLzU4WnYwR2FkeDh2MnR5UzdrdlczdW5BakpPeE55aEp3LzlsMkhLUjlmNEk2djVVQ2N0anloWnlDN1V3Mk5hY3JBa29iRHppQm5KK2ZtQU9hWjc4Nkxva2ZBSldXUldzN3pTdm5YNnMxcWVFWXpyWk9CTTEvOGZBK1R6Y1hsWmhKMU0wZmVaZStNK0ZXWEwzNW1keEVrTVdwcFB6c3lkK3lKSk44UGQ1Y1gzZUZEK3NUUTMvVGpFRjRQM3g3SkRpUms5OFBCOXBldnRvVDhrTWhDb0ErM0gvSGdwaDhPSC96ajRkTzRaOU9BVWJTamZiNzYrUkZEcUE5K0xVR1lwUG91ZkMzKzk1cnZ6R0x0d2M5bkhTbnc2VFZFV3MzTXExWXhabElHaFRORC92bnhxQ2ZkMWVkdXI3eU1vV3RmYVFaNlBGSWtQVTJYWGl1eUFJSzArSGN1WUlmS3dKMy82cWhRWWNNcC9ucldIY1BGZVBZR3JmdlJBTG01ME9KekluZ0xTWnVMRzJjV21OU2VpMU1zMHdtWW1ic1R6bFdiZktiQlhwaFFsUzQzSnhqVmhoS3JNQUFyN216Z3BBbm14Y3ppN01VMUtZc1BzcDdvVm1XWERpOG1KQWVURUx1VEI3Z0pCWVc3Q0dtQUVWM25hWFNuQ2dsMHFEa2hEeE1HVHg5ek9INXczWUEwNXR4Znh5RTd6SjNFY3RuMHpJQzRDMk95OFhoMTBUMk1JbEZMVERuYTBMd3F3OVlDdUNhRm5PWHZKMG1PSjM4cldoL3Y5TUlzc3k2aHlzdWF5WWxGcG5IZ1Y4VGE5WDBBZVpwTVlpT3dqZGhjWGUwZW5GVlZpRUlkb0hQeTRJcDAvNmRmVFYvLzl6OU80ZlpTM3YzK2tHODNrc2NVdHNFZzNlYkdiT3o2NldQS20yUFFxTDQvM3NvbWtqMzhzUDE0LzNCNUdEc1hJK1J5UmwxdVJZUFdUa1NZeHhZdE1ydGxERlVGSU9iRXJTY1czdExFT24rd2FDRm9ZR0Uxcmhib21majVTYWY4RStZRFBoOVFMUW9hek1sQlM3QTMrVjhveGFYS2xybXlkYVF4cCtpMFROVFc1V1h3eVJ4MERtZWNGU1RuNFlhZ0VrS3dudlJ3YlRiUDVrTW5CWkVqMUx0S0ZhN0N6Y3k5OVNEOGJLTThXOEFnRW5oaE43dlByb0thbjZMa0RaazdhMmVJUkFwUnNkby9CZDQybXBuR2lhWmJKTmljWmxUSUFtQ0hDbHRpanBLU0I1WWcyUmc5VGNscUJvcWJ1VG9JS2FXWU96OXUzb3paUllQMEtsTXlsZENGWkJRNmQzSUh6QndwUVNSdWZienFmVUNIb095Vitjc3NITTZNK2Q1d2xITlJSSThRNzZjMjByaytCaFBPTzY4cmUyZ1R1eW9PRHlOZHNvb281V2hwU3BrMVZ4ZnVmcnJZdmJyOU1IUWhNQnpsclFSeEp1cURqaC8rcnYvVDMvL3Q5N0Z6MW56NFBxU1g3Mi92YmR2M1d3b1hWenYyTzBHeW5PMnFDeW9JM1p1aiszWm43NzlPSDk3dUpoQ3lrSHNoak85VUpSQ1hOYnR5NVdBOXZ1RjVFenMxd3Z1akhaL292S21EdGFkaE9RRkxZLzJaTnRLNXhGSE9oalhuaWR4WUQzbG5OTTl5czVGbjdZN25DeGhOL1FraWR3S2pKZ290N3ZRS1BxaU5abnBrY0s3WGtGWFhmSEZkbE1LMDd2ZmdYS1pTek9zdUhCYTJmK09rV1dzY0ZyaFN5MmFkZHhXbmN3eGgrd1B1SUdLREZ3eDk3UTRibUR6WCszdDFTNktpaWxwV29qQ0IyRUNza0JNT2FZdXFkTWdTMEVCZU5tanRHQ21wc3prSEphUnBaSUp4bDlPWVkxRkZPNm40bENHWStqeGViMytRWFNlOHN6R0NQc1pkVC9zUjByRk43aTdzSE5MNHNFWGV2TDRuNU1TZE93Y3BTU3dsaFlZZisvZjV0RG5GSi9tdi9HZ0J1ejg5Zkp5ZnE4cUFLY2U0Z0x1T01ub1Nkbk1LWmkzem1abjQvNlhzVFpva09aSXNUVjVFVkczeExUd2lnRVJtVlhVVjljeFEwd3pOWmY3L2FTNXptRU5UbjdxS3VqcHJBNUFBWXZITnpIUVJZWDV6RUZFMU5YUHpRQTVBSUJCRmVMaDdxS3VJc0RDLzl6M09RODgzSHgvR0dJS25YSzRWVHN4R0xFR0h4Mzk4Mkh4OUFQcjFzTys3WGN1Zm43NG1CcVRaWE45ZVJmWWJ4dENqYmQrdllteEk2S2N4eDAyNzJmVG9mOTNlcmkxTENjZ1F1QkRjQW1nNVBqb0dkSWZGaVFWNnpiQ3gxMzJDazRHNG5jZ0txakJlTHVYdDB2S08rb1phNDFJNjJTSzFpcXY5NndKZDhNeHNnYmY4eTNPWGtZaEs2Y1lFdUlqekNZRmowajdMMG9FNjk0d1c2akhnTklXUkszQzNiaE1aUlRPNWRDOWhDbk9kc2F4QW1sNE1HRURNQmo1VHBsVU4rN2t0eXQyZG1FdW9xWllEMk9BWlRKWlpqMWp1MnF3cEhtSDJXaXFLa3hkT1BGTkpScUo2MTJTZzRIZ3FmTStMN01vSXhLS1pDUnppMm5PMllSUkpKYlp1VWhXd3JPTFk5U1lwYTNyWnhrNnYyeGU2MVFNYTdkSlZTSUtzS3NJd0tMT0ltWk9uelZXZlFid2VQcTA1QmlvcHBJdDFpVmZ2eS9TVDV0a2pUVytBSS9paWUrbm9WNisxUjRVZ3E3RnUrN1I3WnpDUUlwa0RLRGg3Y1pIV2Q3TDUrSFhzZlk3aUJKY2dkSGVNTDhOdnEyM2pKcjRmUTVzQzczZDdXOFcyZ2F4YTRhQVJTVUxjYmlOYkpIdis4ait4YmVqdzY3ODlrMzk1ZDc5NkptY1dZVkp4dU1QRE9jRkFpSmZTZ29YUWlma0lUenRkR0ZqY3kwN29oY2NVZ2FvUDVsbGtybWNuZVlIejROVWQrTHlHUGdOMWk1K0VuMkU1NVh0MXdoSyt5WldsbWljSzVKeVpRSER4SUM3TEs5YmtObWhPS2FWSHIyTGRXUHhNWDRMRm5MWUNYdXVKaTdwTXB0bFRpU1dlRmpDVnpHaks1Tlc3ZGlvY3dra0s0dkZuWWZWR1lDaHZscGNRZTNjUXpMVklLSXZncTVaSVRnNWhGQVJYK1FhRmpqT0kyZUFMdUR1TWhNaUwwZ3BPeUU0eVNMWkl4RUdhSmlWekZqSXhjM2R0TTh3Qm9SaGpSazZpWkRudDZjRDNyYm14SHJnRmtoM2NrdFdiVEpHTVlYUFZRZGFicjFqbjN2YlhiY3RPNENuVHk5KzRjMDIxbmxScG1IeERORjY3emZ3SzZEYXpqZWtZaTZ0QWUyODlzV1VuNWdId1FxSXNqSld0RExTKyt0ai9PNGdsRW1lZTRtWnQ0R0h3anU2dWFmRE4zbmwxWldUZGZnZ3R3aHJxSXhwVzY3dXh1Zmx3TStaMGVQcjZyMzk1a1dIL1JmN3k0eUQyOHZYN2EyOHFucDlZSzArTDZDUlBkOElNbitkWCs5VEhQRjlneDNydXBOK3poTWd0RXI0cDFqZWQzM0FQWHpxQkx3NXdKL0pQL1FLNmtKdE1tVVhudnQrMzUzN1RlUzVnQWN4Z1lXNEVuUTRuZktKY2dmZ2NORjB6Q1lnbURPVmlJekZncWZRb1RpOG1LTmk1VWh6cjNOMEpBcG1ybmpLUEdPZXRZMktSbnl6Z1l6TnE3aGl5d0V1cWVJMFJkSE9yaXpZMEFvRGtDR1lBazFzeDZOY2ZwZGZqdDk0eGVUclh5b2xlZXZVR2h4ZDZQU2lCM1JRUTV0d0xLTFk1d2QyY2lEbVY2emNqdWJlYndVd3pRanF3SDJLVDlzM1ZZTDRkZDJHVkFNdk1DaTdtZHhZTlJPdVA4YmR1ZFhqcE45ZFhxMlFpYzBqY1ZFTDcyZnN5VFQybFhOYmYzTGRMRUF6VHhmcHRVZmxOZDJCck1JYk56Vzd2R1U3RTVwNlNFMCthYkpGeFdMWE5UVk9tRmphbG53ZjFQQ2FITlR3WTBCMk1FZHp6TU1pcWplUU5lb0h0OGt1M2x4dmRCaHgyejQ5ZlB1ODNRdnZuWm1oeW44TFRqeDgzbTVUQXpEQVZHRmlEMWkxZGxxd2d2M0FkcU5oZG5KL0FqUGxrV2k1Z1djNk42andIVG1qZTVJMmRTbXVuRWozUXR3aGx4MWFXMHV3cm5BZGF5eTd3dWVxUkw1a1pLbytEOCtMano3NzJXTEhEVHFXTHBZc1NtdVlJM2RmN2pXSFc1UklSV0VFT2cwdUJaOCtyMjhpbW1SN0tFTW9kQkxZYVRUTlpQdjB0bGdEQXpzNHVKZEt6QnBCeFpyaVpGenFkYUdSNDVRWk5jcmhpb2w5QW0wRndRZDBrdlo1bDVWZ3J0MDgzUjNZVVdUQ1Y1cWhEUkMzVDFxVnBjcGNHaUZDMlpHYk9RU1U3NnpvY2hsL2FuTVJTR0hkeG01N2IrL3V2ZWVYUG0vdTlNSWpxTUM0bkNwNzZBVmQvV1ArM2p0SkQvTERkTnRsRmRDb2IrVUovaW1kVE5GZ3crYWRlOVc3bURmbkV0SFJCQ0hLVThZSHoyaE5XbSsxREJWNlRXOHJPbXV1YmFPN2oza3pYN3N5d1ZPZkFGS081azRUUW9ydTZIcDdkaFQxN3pycDlmODNzS1dXaS9PWGhjY2pyajVLL3lPSHg4M051Ly9CdWZVYzl2amIvdU91disxOTB1eFlrSXNDVjRTWWFwcEpXbGd0VHBDNmdZK3RKYU81V0gvWGZ0WDBsZk9LdE95bGhUL3k3dW5nMXpwRWFOUWJjenJ2VE0rRi84dmZXZ1dhTmk1ZmxXMXpqWE0vMlRycU1BWml1QkpnaVU2cUdWOWkxbVRLUjRFRnFQQXdUekNoV1F6L1hGWjdtT0c2YWN1Nkp2UFpxM1lzVUVUWkpvbG5CR21CWnZWaXRzMnJKOXExempESjlLS0JHUmk2ZzB0STBtczkwK0JSL1ZzdWVZOFE5YVRsMDY5TnhtQk1MTWl3RXl0bDVXSFBQSDNVbnpDck1iTlB0MzQwRHdTS1JaUWtCUkF4THp0cEVJWWV3QzVVY1pKQVJOV0FpVlFvNStWVHZFOXdoTkloRTZVVXhRQ1dNWFc1YTlFeE5QcUFaT2FSSGJGZTBHVkpzTGNmbVpYdmJQYS96TzIxRDR5K2g0NUI0bFh1ajlpcnRYSkt1R3dhc2Y1ZC8ydHVLdjhQQll6a25VTjFaZmg2WlU0Uml4VTFXeHdMTVJhK3laS0ROa1hERVZQT09wL2hYbXB1dFhLb3BPRHN6Q0t2c3JXUzUrK1dGSkZGalBxYnNURVlxSnMwcXNqL2Jqci9UWDdvc25ETkdibG9mcVFsT2ZuQWUxdFRlWFF2V1dZQVVHN202ZjlkcXdPaWVQdmVQdnoxaHZaRm4rV3J2SDU5OGMzOXpkVHUrdi9IYmgvRy94NXllRDduN1A5WlgrOTZhYWpYRjZ3UHVrclRtQ0g4K1d0YU9KZDhydHZQRmVOSVRLOWZGcU1EVGNNRVRwdE5ycWN3YlVrTCtLMEpoWGluRlpxRnIrVldEUWFMVlhMMG9aV2pDTEpqUHE3bnJWMXU0RmU4L0tkTW0zL0NFYTU3MXllVk5JQ2JBTUR2SlpSblBTWUN4SHQ5SGgwK0Y2aEwwTWRHMjZnS2VQenNaZkxxK0Z1TTZ3T3gxUUJVZDZrVlZYRkI2dk5TUWc1ZzgxYnF6bHFZcTdFa21jWnNkbjlJMGxyUHlyV0VSckdXWk5GQTJKdzN5ZnR6dkRHSDdjT0RWZGNDNDhXUjJpSHozdE0raVFGem5YYmhTM25Ib0Uyd2tab2FadGNMd1NLbzhmSDBhMCs2ekRyL1I5bTdsQUYwcXlzNWlRekZYa3p6bCtURE9ISEdNVitnMnpHQ1VZNWJTTWFpTmlNaVZpU3piNm5Gb0RBQmJkZ2RJNEV5WjJpeGJ0eTd5RGJMQmNrRXBpRnNRWmdWTHM3cDlkN05XNHRGa2ZNbWIrN3U3Vll3MlBnM2o4K2VIenFJeWV5Si83TEM1dTd1OWF1L3ZROThmbWk2RGtQWVBQOSsvdjh0NUdJWEtxRDY4VWZHOWNwbE9mdWlUT3lrZi9iWnlia1Q2MXNLUjE2VU1pRjQ3TStzZFpiTE5FdFB2QnY3S0c2WFMyd2JDbzlLRWljRHVaczQ2V1hsRW1SenVnV2YzQlUraW5LbS9TRk5BeDFGcldNWXlQZ3NxcG9RUkFoeGxiRnAyK0ZLYTFtaTJrbzBGRVpicFdYanhRR0JTc0pVYjNVSnhkUVRxVk5SRUFYcUh5VlVBa0ROY3pWbkVIZDBnd1NoZ1FyV2ZDR1pBU1lRSk1HTVNFV0VCTXJHdzFrZXY5Y0k4VVVuSnpKbFJ2V3BFSk9KbVJWZklidkN3dHQ0NWZQZXdOeVJkTTIwMncySFE3Y0U5TmdURTUvMjc3WmpHQnFRUldUUmttQm1ZK3FRRVZUK00zUC84WTh0UHQvZlhXbUhIWi9QM1N4QTdGbFFJUHMwaUk3NUFUWjBONCtCejk5cGNMeTRXTUlzSWNZaGRGNXJrV0p1Qm1TaTRCOHA2ODdmM1pyLzllcUNQMUNjM0luYjNvR1RHb3FvaE5EY2ZicmViVFJzNmlVLy92dDlzRzJGbGtYZTcvY3ZubCtZcXRtMVVPQjZUaGlZb3RYcFliWGYvOHQrN0xNSHozbmxQZHcwN01nbVl3ZUV0VHZMcEVjeUxadkQ4OFV3TEthU2MyZkw0VlpkNUhyVHpHekM4aXpGeDA3T1RCZjVqRVJ0NW1qNzRqWk9mM3BoUUxiVTJSM0dzWTRwbHFCSm9MaDdjSTFsK0lrOG9sa3FtcGFpaWhvNVFUZGVzL3dnS2o3a3VTYW50Qlo3emFKMEFZVFp4bVhqUERpYzc1akhYYWRNQ0cxL3hlZVUwTGlkd3JwMWxtbjdWWGNUSDBidU94QkFuRGJuV2I5aExKSzJ6S0lPWU16RnJrQW53UHoyR2VkNCtaNzNaTWUrSWlSalNVQm9KZzJwRGJ1blhWcVhOUTlyZWFNNkg1dDNES00zd1pKdkl3Y0NCclhrWTdxNzJHQ3dQUkJoWWczZzJHbGJpSG5ud0dHbE40My9zdDAxemU2UHFPSE9ubmYzZ2o1bURkZXBSeG5sVG9ONnIyTnk1cUxxQWxqbTZ1aFpkTUVCWm02dmRUZk9IZGo5WWNPSlVSbTBxaURmLzhJNU1uK0dieUE0aGdnaUpKcU9nSXJGdDI1dWJxNFl6aFZYYk5uZ0NCZ3d4a04vdCswTlBxK3RWQ0JyY1pXUE56YlpWU2RyM1QzLyt2LytyUXBuSitsKzY3dDNWcWxVdTNMU1NQb3pUNmVwbGgyUWRGODR2L0preFdrNk0vaWZ6M1pQMTZIU2FZUEVxdnZUMWZCaEhwdVdwVitIdGx1RmZVMElmelJTOHVPdURsY25kR0E1bkZpK3NCYkdLTDF1UTI4NFVVRXhIMDlWY2VCWE1HVXBQZC9iUFQvUm0wYXFNbm5EY1lCZVhzZ2puWXE3bXFoVGxvTmNidXg0UlJ4UDdxUnkyWGhhd1ZXMTJrU25EQlNYaVZsTGlZTVZkTmMxMkp6eUJNQXdWRitSRXdtNWs5UzZONmxNK25uZGxYL2RqTmlHREdOazRNQXhHZ2pLNUNob2pwVWR4M2Vob3R5K1o0MVZ6LzB1NEhueGsxYllacUhFbWV0a0xsZUdRZ1NTdUJjeVdsY0JSOGZKeFBXNjJnVmQwUnAzRXZLZWMyVG9YQ00zSnVzYm52bkVDOC9tUnU0alo1Y3NaMDZUdGRuUFZqaC9TTDQ5REJ4SDJZaVpUaW8wN045ZWJRMmZEbUZFVTdTcktTU1FHWFc4M3E4aEREa0ZsRzdEOTI4MXYyYzNkTmZiNzNjQnRRR1NZQ3hvSnphb0p6R21UL3UyZi90dS9qbXVHT1lIR2grN1Q5dnAyc3k1aVFRb1hYZWtYQnRySDhWcGxDeStDalhCT3VubERLRUZIYTlKcmhkVEZJZEl4ZHBSLzV3VDJNN2JPWDMwQzE2dkJZdWNRRVhHdVNRUEdYa01TVWRjREwxck9WQWRIOHhPWldJeHo4VjlhVUVRQUZab0dacWdIejdiaVNiYUlTdmR6Tnk5aEpTVW9jR29TSGNQQ0N5a0ZSODFXcFYrQ3ZVeU9wcWFmT0lqWVhZbmgyV0FrcktGVXo4SlRGRGlCeFNBTXNhS3pFbWVHRzh5TGFRU0pSYldLL1dmeElxWXdJamltOXlJbklqSGJnSXlrNFVnR2hOWnYwci92dm12U3VONnNidmw1akZpdmR5OERvb2EyZjE1SnZ1bjNuVnkzY2VlV1JnM0tLb3B4djcrM0E0Y1FtNy9aa3podlZzTko5Tkx4QkQ2THRNRXJ4aUpPa2ZjNGxzMG43amVjbnNBbFZYSnh2Z1dBSld6di91YTJvNS9TT0k3YTBpNTdoSkpUNEdFWVNCTjNuK21wUyt3aUxaT0RGRW1nemVwNis4NXlIc00ySE5yUm00YjJGQUpaaXMzWWpYTEZhcjJUY2xEWjZ1WjJvOHEvL2ZtM1AvL1RGN2tlQ1FabTQ3d2Y5dytiOVczWldHc1RpMStsaWI0V2RTOTdQa3dRbW1oT09EMW5jWnJOYzc2QWxlamlyZnVjcDdCRXl0QmNzYzFWN3B0YnpxdnU5dTgxc2VvVmVKcEtsRTVxak5semRhRUlnNkJUMjFMcXRxM1ZySURacDhiZzVXQzhOSU1ac0FMQnFsT0hYSmFlRzFXVkxHRGtyaEV6UG9JSlZpSWpTMS9KM1djcXMwL05MSnVqRHllL1V6bUJjVHlCbVFqUVFuSjFGL0djakJLSlUwTTVzSWlLY0UrMU8rNmxEc2dFcTJFL2NGQXBzVXRpY0dVL0ZyWFc5S0pySlhSWmZhSXJqQmFvWmlVeE0wVFRtTXplYi9LL2d5VjhGV3JsOFBtd2FtUVFFRWEwemVmaDFnT0poa2pqaURRTVVZSms1TnlQeEltQ1NudlZQaE9sMVYwbmRDSkhtQzlDWjhJV0xNNEVMRzNXZktvd09MclRYK2tXY01LRE9rcGpnMUoyL2o2OC9QcXlwemF1bTkyQndRaGtGdFBqZmt2b0xUOTNvd2tCRklJUEppRjRzOTVzYnQvZlhuSGVQYWVlc3EvaWtMOE9XS3VNZTJ0MFo0RVlORGpGS092YjcyVFYyT01lLy94UFg4ZDljelY2WUFjNE5jYWMvS241dGFyOXc0bHQrWTFXejhKM1AzT1ZDMytjR0V2YThzbEk5RTJ4RXk0eEZmbU5IbktKSTd4QVlqOHJ1Vkdpei85L0ZOR1htMWdFTjBpUTN0ekl5Y3RZUmhFWHFxZGp4d3V6SWRtUDZHa0NnWXZldkNRU1REZlJPajRURnplUVM2bVhpM2d6MHJLNWJXRDJzcjY5eEJucVpNaW91OSswZ0drMnpwVWxabFVFYlpQTzBaMll5TWNRZkV6T0kza1dJVnZYTUoxaDJsaVp3QXdQZ0RORXZIUWFvVEN3UmsxRXBSZk94Y00zc2NvQ0VjdENPTEFaa3lNRWVna3hzS1djcmxvYVU4cmQvL1cvWCtmbnNYbC8yRDFoM0hWckJxbEVUYlFlUDltS1BqVmgxWVR1cFVGS2lTRnN6cXFybFdlTnF4aWJibURGZHZPbDVlcEVlbFV5MHl3NXFuRkJNZ1hEZ2lDMURjMUhRRGd4eEpaZHEyT0FGeDlQdFVrU2drV0JoanlNNjJ1blFXNVgyTWFIQjgxTWFqbUg4Zm1YR0RCd0RBZmo2R0JsWlRLRjNHeHVyNjd2djN1WDEvSmduL3NEOTlmWHZOdXBiTFp0UG5UQkR2dGtMQWdRalp2cis1NzY5UGsvZmo3a243YTNnMUF2Sk95QTUweUV6UFFzcWlwTXdWNUxvWEM4UVZEQmpES3hTWDBzNUZPR2xwVEhVRjZnNmNISTBtOHB4OUdRVjFtb2w4VFIrYU5pbGNNYlE4QXNMaVJnWnlVbkwvMGFxUWswVkFMQ2w5YjFXWWJOb1M2ZENpTGdmTFFWWHR5VEtwZDg1bHJQRGF4a1lJbUJkcVBEbkFWVnRDQUVoNm9XMmpKYjllRE1LZ0d1ZlNzUmxzSXNaR1VVRjRINWZGdGxWakpEMVYwN0IyVm1WcDNRVHF0aVFwMEhXMTZnY05DcFExVWEzRndWWVpUTEpnSUR5R3RQbXBsNFFzNk1JRkdDK3ppQU1JNWl0RmFYTGJFR1p1VG94a3dPa0RJam93R0NaY3NCbVVGZTd3OTV6cDhIQXhDaHJFd08xUkdzUXA2NVluWjYzZkE0Y052dWRtMUlJM1pEVktmUWJ2ODVoR0hYYkhLeTBQZDAyNWhyTzZZRVB0QVBIRGZXOTIwZWVOdlRtRGp0dzBxUWZMU1liMlBLbWoveHB2dmZEbDhnVmhzaVRzdm9NWi9kYndLWlFnaDhVdVF4a1d1dHlmUmtnQzZ6bi8wNEJqd3ljOFduR0ZXWjNYcXJ3ZFhISjNtNC92eHY0OS9jWFQxdWFBekN6b1lvZmRNT24yNERlTStKeVozRXRjODVlL05PdDl0MnRkMG9zMTdmN1Y1NnpaU3BHNkhZZjM3YUR6bCszcmM4eHV0ZGpPdTcrL0RGaHVkUG43NGVMRzd4d0w0UGpXVld5Z2JsREdLTHpPNWgzWVJMTUFJczBEUStoYTNYN294VWs5NVJRMUQ3RjVmL3ZhU1huQmpUaTMvck04VDBlNVAvdEg0elBuLzgwU3AxMWt2azQ2emdHMS8vV0NESkd5ZStjd3pNNUpCb3VVWUVpa3dMN0tSNkF5OG5oM1gvdzZKeWNIS3ZhVjZ3K2EvS2NqUWR6VjIwU2NQRlBuc1lqMEhtODVSM3Znb3pKcCs1MWYzTTZ2d0lzK2o2cEVOZHRwVFNtR01pb3BaVm1KMjBiSWxsb1VKTFJBcllVYTJMdVRqaWpJZ2hVK2NaVmlNYnlwM2J5eVNNaFVCTm1hdlpKdmE5cmVKaEswcmtac3dqd25mOVEyUGt2SWFhc0lac0xpeUJLTWlnbk9vZ2dKbUV0ZkV4WlVmcmFIUVlkV1h0OXkvOUdPM04reEJQYVRhMGpIRFNTMUxwMDREM3M1MSsyZlE1ZXNSbXBhS3ljdmIwZGR4Zi9hZnJWZlR4NFMvUFVQV2FDRHQwUXQzellCc2lXQWI5SmlwTkU0ZWJkdFZ5M3RzcVl4eGdlZkJEeTBheTM5T1FkWTBYRHNUaWg1dTJiZHR4dC92YXZid01nME5yNTlNSzBOUlNTZVZ3RndseGZiVUs1MUlsT1o3Qk5TZVlUOGpxVTdXQjQ5V0FMeldBejB0ZU9mRTg0VnpiZ1ZjZ01wNWp1czRlK0RLMTdCdnBvbS8xc2hhTTZvc1RjQlZtbUllV2s3bFhBNkJJVGRxRUgvL3NDWE9LVDdTNFZjQUQ4OXEzbXN2dmN1bnlZNXR6SW5hVW9nRE93Z3lmdS9tQmpuZmVHc1dEc3NKUTdZRW8xcnJpR3FhQ3JPRmFpSmZ6RW13dVpnNUx5REVTS0lSVm1WOFJHWnhnSms1Y2ZQbml6b1lSWUdJZzg4ekduSUQrRUdZT1pUempESU5wRlgyQW9HUU9RZklXQjdTVUdFYk01b2Qzc1pNYmVWVDFSQ3YyZ1VXRHdNZ2hDazk1ellmVVNEWTJJbGhLcmRzQWdjU21iY2RlSHNmMUpqMlB0eGZrUHlkZDhMT0wzeXZUekNXZHc3bmgvTFJ2VXg3NDlIa3lSSnh6OTJuWHYydDUvOUk5L01mUGV4Wmp3Rm5hTmJwVUZLQ2tqWkVUMm0yNzNlWkQyNjVYRFNkNzZZZTBlM2hKSVV2YkVJV1VXSzV1VmlSUG54L0c5WHExVWRqejhQVHljdGlieHNZcXY3QzQwSmpMK0FqRTBteldiVnZwNHN2dlhJNmR6a3Rqc3pyd1dCSTcrQ0lhLzNVMytOVDZoVk1mL3hHZnpYd01KYTY1dW1jbE04OXVuOHNMdUVCdzMyNUc4MFFlWWJ5MlNZSkYyRUVjQ1pRTllicnA4M0lxZmJROTRheUJjQVFYVEg3bGlvT2V1cGdpaGJ4NmpNTEdiQjVra0VseG50Rkp4QXl4WWNyYUxqOGVMOEZCWkJXWkYrcWQyRXI0Tmg4L0tZaklrTjFodzhqak5oSnBqRExaa2MxTFJKS0FtWlFyTUJoVnhFc3VOQ1BScHQ2NkZjTy9NQmQwS294NW92WWt5cGtFK1pBelVaWjRNRWdVd2RPNzIzRFk4MTFXN2wwNUM5V01wOHdNUzcwMDJuT3JmU2NwQzN5UURadEo4S0ZwZGRPTTQ4L3lReHFSY25oenUxN0NFWmZEazdQM0Y4dUZUck5yNlRXV2JlNXlGa2pKVVF2dnJMQVVaYTFmLy9YaDVlVmhEL2JjdWd0cDB3YnZXYmZaV3NSVnNvVHIrOXZyanpjdlA2dEl2RnBoL0xFL0ROMXVvSlZIY2tCWG01dk45anJRZHZ6ODR3UGFKbzh2ei91dUc4SUFWbUVoZHZaQ2pSVW1sVXdsQ3ZocXRWMUpIdnB3NFZ1dk1QRUpVbm5lanArTnNNdUh3TCtMaS90V2tpRXY4Q2N6RldjWlpYazZobHE0Z1BqMVBMblU1Mitld1BQUFp6SFBQaVZ1T0pQd1VOeXJ5dk9tVVZ0Y1ZieTAxQTdPLzhOUi9WNERycm5RTkdZbHdDVHVPMVdmTVIzWEdweTQrRzFwTGdtWlNzd2RVYzE3S09vd2R5ZXJnZDljVC9MTXhzNUVlUklJT3p1eE96SkxUaU9UQ0lHUmxiZ29yU1NEeXBlY2JnSWdaZ1EzSEtNalRtcXNNa2tEUThScVdveERtWnpnM2tsT0hEbVBBd2ZhU1RBckJTajIyeVlOOGZaQlJKamNXODg1azNJaVowL1oxcTRrTWVRU2hRYmtjbkdqc1pWQjF2YThmdi9CeCt0TzNucTNNQ3VOTG9mbzhabmI4SHpzZ3JQMzlNaEM1cE1KcHd1SkNPa3E3aDkyZi9seHYvT1I1a2g0MGREMFNWY2g5OThOSHRERTlmdTcyN3Z2Ymo1M0F5Y1Q2UjUvSEZQcWhyQVMrT2dVdy9yZGgyMWNSZWx2cnE5Ky9HMzNPSFpQKzI0MFVvNkV4Sk5KaUtSc3FneWlFRmZyNWoyUkhYWXZyeGZ3WkZxZDd2cHlaazQ0bHE0NFNlMytuVkwyNUFnKzAwTHpVblk2bjhDOHNJTHdDYnRxQ1JKOEJhbVQwOC9QbDd2ZDAvM2dkV2xWQU1nc09XV1RGbEcwdk9ZVnVUVWpTbzlFR240RnF6NytEbk54c2h0bVhLNkxBdzZkSjd2ek1Wd0tndUl2blkySlZoZTlIYVV3QmRIczdtYTFaQzdWYnBXUEZUekVXSUJSbFdUdXhnRFptSFFWMVlsc0RLeGNTYm5PVENSVzEwQWx4cmE1T09TS0IrMlVNRkl5eGN2M3pWcHJkUUtFM0hPRERDbDl5TlRST2dnWVJuVDNrajZzeUIwWmtRZ3hKTTlPV3EvNE5tcVhNd01JSkJJSUlSaHJHSkp2MXluY2drbHZ2K04wbTk5WXZ6d2IrYWNlaVp6cEUvaU0ySEhtRTc5MEFqTXgyR2dSMFVpRmxxYU5pSTJmLytuVHZ1TUFHbkxpcHZKSm9NbzJwTUZDNzd6ZFhuLzhZd3p0RmJzM25McDkzbjE5U0pZek5SdDFndXZtN3ZidU9oQTBSTzZHbDkrK2pGMDJFS3YySVlybENva2dwc0RtVHFvM29XbmExYnFoN3VWbDN3MDVuQytrNmJTWjJuTFRpK2NuNXFEZmszOWN2Z3VEYUk1VlB0a2haNVR5eVMzNEJQUitTZ3g1Kyt1YzNXM2ZYTUJUbTlkZjdkQkNURTR4T3pTNkNFOUJBM1F5U01JeTY1UmZmeStGeEdOdTg5Qmo5am1ldURjd1laNUw2NDZLdEdJaWpCd1JQbFkzd01uaTZ6QXJDM2dXY1piY2xUbnVzMXE0QURaeUR5bHp0L01Wd1JBQ0oySVdJVmo1UUNFV3FaaWFXZ1VJWndlUkZHUjRGWEpPL2tNbUtUTUNWMWlSNjhORTJKMkRqTW1GYytCdWdHWUl1Wm5LKzgvZG9ZMzlRUk8xT25pY1BjYXdVbnYzMllQQlF0SGFLZzBpeldoeWEvM2Q5eS94UTg4cmRjck5HMklqWGx5QnE4WWJsd0FzRit5QzVjSExDWUxuNUYwUkxMSEY0bG1DOG9EZHI3K3hTQXVJdTRaVUNoWFgxbll2T1kxTjAzeThqdTkrdU81R2tYRlVZb3hQWVVnaEpXTVZpazBLRGtPZEFBQWdBRWxFUVZRcm1lL2ViVllDb3V6aDF4OC8vZnJMWHA0aGdVa2tVQllPMVZuR1RNd3FJYTZhMnhDRktPWGZ1bDJYM0QyYzd6MlRocFJuWE1UWkc0b0wrOWhma2NkNlpGZStrU1RNeHlmT3B5ZjdTWWRNY0dKL1pMeFJsdjllQ1QwcFl5L2NnWmtCYkN5VnF3ZWNpRE0xZkFSYm45QUxjVVp5d096MkFMeTB3V3F3VE5FZU16TjgyY1dhMG5yTGY5V1ZXQ1ZlUEdtZ3krWlhaZG9Pb2d6UFpsWm5IOHcyc1FmbURXTWF1NEhaM1dnY3JOdEpHRWZpcG1FVFVXRnlhQ21QT1JDeFV5V3hvTWdneXd5cmFNZW1mNlNpYktxdzFBUGNNb1c2eThGRFJKL0JjcmlsL1hEZDVsRVp4cXpiZEVEUGxsZEdRUVlYZ0ZpYzRPWWlBSUpua3BKajRTQkNOdVVZS1BEVDd2M05YdTUrU2hRQ1VUdituclZzOXBaZm5pUHl1ZEtvL3JHNVNmVmFVWCt5NnpxTU9EaEx1NHF0MXJHQ3dLcC8xRFRZNDBNdjhnUGQvKzJOdCs4ZWQvMWEwTDc3SE5SN0lYMy9ZQ29xMmRxUHF6U3VWN0Nzd2J2MGwzLy8xWnlaNG1oa2cwb2NFN1ZzdWVYU3JEQVJEWnVidGFoNnYrL0duOTFaaEJBV3VjQXN6RHhXN3JqUE5lK2NzN3VvZ3pHSmp5ckZpUmJ4RkVWNG9VZmJHUkVSTmVTMUZDdVplK2NRdklvdXdZUktXV2lyVDFBK3Z1aXR6U3UrNnZqcklGNFdrU3B2MnM1bW5uUnBMcU5TS1Vtb3lQbkgxc2ZPWGQxakV5eDVOTEF3VVNSeUtzRWlUa3cwbFRCV0ZjNWVwNGtseVZvcW53aGtVampwT3BNdXkwTWRYWVZWU0lqZ0VIWmdVUndVditkRWtDd3BKV1VZYkhETWZ1T2FGTXJrUG9iSVJoTDJCZmlOVklPeTg5ajFuYlV3a2RHYmRWUWlVVEFUaDVJeXF1THVWVUlLa0pNeXVWbXVZdWRSbFZtMHpML1pxYSszOFU2azVCcUtFa0RxVFV4RGpqRjNMbkZBRTVzd0RIMW9tUHQrcS96dXQ5dnVPU0MxVDBRQk9SdXRLQ1VuZm5rSFp6ZjFVVmVrVVNSYlVHbXZQdjU1L2Y3elEvZ1ZIK3h4MnpkcEd0Y0YwRWxaSCtvTGtXdVpZMHZKNXdXbG50WnBteC92YjB3NG9wNWtVVWt4TVlXNmVYdG05UUdyeDgyZnZveERROUx2ZTQ4Mk5GbWpZN09CWHZWZnVxdnZONnY3ZGFQY01lZm5nL2RwSENVMm5QUDk5dm5MQVdUMDNSOThHTG1sTnVZOWNuNTU5NTRPTDgvamoyck16dEx6eXAxazNVbFFKYmlzTiszbUtxTHBuMTkyWFo5TFdBOXBXQVNuOHFVWDNmbU5Xb1Rtb2QxSklNQzVUZ3BIdk44YjZxdlRnUktmODV2NWJhRVlMd3hpTlNKOEFmajl2YkxnaU0wOUl1Z1pRZ3RVSkJ5aFNLbGdjeWNIZkJxNGRJckdLTWFVa3NZd25ZbXpzR2ZLZ3p1UzJHdWlla20zcTFITldEcC84N3haTVNhWGxBTXd1TStycXh5R2NHSnNZWGwwbDU0aHlpb1FBYm41U3o4TUk5UW9xNnBuU2hYVVZ0NWpsZW81cW1ZSmhoSUpoTGtvSzR0eG1jeEZGOE15d0VrbWMxS2gydkg0ZUxXVi9SZ2NsbzA4U1NaWkIzQnFWdjMrdWgwK0h1d3VQeDQwT3duRFVpUEVETGRRTFIvQnN6dk1Hd0NpaEVNZjRVYkJSQms1VTNPOGhyOW1NNVZTbUJmQnMyLzJaSmJOdzIrVjJQT3JXK2NOVVlIa1JOeWJyZzF1QnJnckt4RklSVm5sNXJ1NHVsMXI3b09LL3R0b3hQa3dEbkJwVjIxN3Z4czhjV3p2UDl3Y1JsWFpqQSs5eGF2clB3cmI0Zkd4eTE4ZkV3ZFl3NHpzeUZmdXNCamtack9KeWtPL0d3L2RtTkpNdmduSEtlK3k2TVJDUzR5anU1bk9nT0lYWWtWUHhlWEhHTU1MTVJ4bjY3b1VObkl4S3Z4eUR1M1IxVWFMRkJkZUxqTGlielRWcHFzcEFOVEVkcXEwUlFvaElncGdKTVpPYkZ6dWg1UHlTODQrdDB6SkROV09XQ09Bamp4QVlqQk5tWDVlbE1lRkJGMEVNbEtURDBzcE90RmphVUVOUlFVQ083d3VZRHNpanB3NUdVSThqUDJRekwxaEZnNGlyUXRaVHZZMUpSZ0ROSVpWOEJ3Q0Mwd3hGMWtUU2M2cllsYUpuY0FpTHRuY2E0VkNVL1JPVVkzRE1RczZLcUlIejNhL0dYcUhaU2RLUTB3aEJzMld1RWt2N2VhNXlTcWpOczh0bkJ1M1ZDTGNZQ0U1dTJXZU5jeE96dEg4Y2JnTHlBanRpblBmZVpBalNlVkU0amdMSFMrWUVpNGVUT2RyOTQyRFltcVdUTStKZ3lkenpldCtRTnYzbHQwc1E5U2RTTnpOb2R2djFycHBIVGF5MFNmUlBQU0g1S0l4UTl2a3pKUkhYcTJDeXpyRTNkT0wwNnE1M2NaZ0s5WGRQK2hoVU0yWlJDRlM1cjd0WnRPdW9veGR2OTgvNStUTHVYUTRtOU5pamxnL1VSc2ZGN1NkNlM5ZUlUdVA5cTZqS0VrdWJIWG5ObXdzNlpLdk9tc1h1YjQ4OS9oeFRCOWFoaFpmbUc1ZGFOb2RnOWxxbGcySXVBRkxEc21OT0JPNHhIMkNhNW95VGRBNVhpN2dZdzY2TytvQ2RsbzhEUmF1YURvWG5rYy9CSExPS3NwY1hjVEhGVXhXVFBlbFlXNWV0TTVsRlZ2bEVZT0lLSVVnNXNhZmhpNlRrSFBwNk5PR0dXa2NjNWZCTHNRTWJvSTdYNGxuZC9jVkU3eWtQMVM1Y0IzNWx1WXJpM05SbEpXTGplQVlMTXMwVzQ2QjZBWW1SdFB0ZWFVUlpTOUw2Q1c2TWhqN1RmUDBKUGJZcko3MjcrVmYxVUNzVW1iS0treVdGWjZKc3BOb0tMNE5oUS9TWXJmMzlxcTFma2loblpTUERGNjhuY2V4bml5bUlwZFNMVS9IUnpnTHNRWmZQb241R0k2bkliUFN1SGw2ZU95NmpnWWxJWEtCa0REN0dKbW9aV2NqeXlrUGVhMTJlRG9rNS9YVnBnbEt1M0VZaDBiYWx2ck93N2ovK2NDM3pmakVjUnRiRllsKytOb2J1Q1MzYVFnNU50dk5kaDE2ZTN4NEdkUG9NRlk1L3IzQ0swS0JuSW9Wd2VmZy81TnhHaDBmNEhMdVUzc0ZTN2YrZkVkZDdBdkxsaXlmZHBGZiszWXZ0c1ZxUndySXN4anh4QjMyN1JONHpwZWw0M1M1b3RkVnBGTDgyQmdpVmxsL09PWTNuVGJYYWt2THVaRHpxWGdRYXE1czlTM0tkSEFmVVpLVEVNdW9YQ1lucGRXeDN6MmJOdUYxQVJkOVYwbHFtRno5cGtEcVhWN0drYUlLT1ZreUJ6MElrK2RzYWdWT0xCcUNFcE9xRzloVHkyVUFOZjA4cFo3NzdsN2JtZXJ1emxsMEFncVFUaW9uQnh1WHlQRllmVlJvaHFkeEcxNWdZQ0gxeEQ2U05CSFBjaVdQdEVwdEV5VmUvK0dUSlNjTW83aENnb3F5eEZDbkhZQnhFRGV3VUxPVlQ4TitjNDJVWmNWaGxlZzAwNllLYjBzZHlVZlVFLzNPQ2N5eklYWTVUSDdMaG5PczgyUkZsa0xlN3o5LzN2ZUROMEc5YVRKQlJKUmJTVVltMHBxTldjWUkwRFZlOW51UHNyMjYyUVl3M2ZiNUthKy9mMy9GWFMvMjhEejYxVzNjN2RMS3RkVjF6dTNON2N2ZUlhSE0rK1Z1ZGJXSkdIYjc5UHg0S0JSVEZqbG1jb1hGVUpXUDA5RWpkTzd5VFdIWmhzWXNLRDFhOUdpaHJTcGhCYTgvQlo4QUJYSFNtenFMdU1ERm81U25mbm1OZk9GcGhyQThnWDl2QVZkQmMvbkJMOWdON3BaenpzNXdxdzBOOXhLZXRmUlFMRFRVNWRzM2RvSWZzM2t4MlErUGY5OHA4SzRvcG1xOHE3TkphUUdjUmlvZFBYR0F1eFhDamp2NGVBQTdBZXhqU29mRDZDak9Yekt6bExLaDU2QWlST3pPcEU3U1JJS3lIVnAyRXFFeGFEbURwMGlXVWozQXEzR1JoWWhaYlM4dTAwQVVTbEkySm9HSkEyQ1lHYk1BUXhNR3MzU0lSWC9HcWdLUUJHam01dmw1RmZlbXpXKzdiVEJEZ3RHQUlFR0VXSFRWSkZhRnVCdmpSbUVaekdzZGY4bzNOMWNQeWRkaHlKcnJ6OXo1NVBITUJ0K2xPT0dNZ1hYaFBlQlRQL25iMk9FS3dXY0pLekdsbDE4ZWQ3c2t1bTRERG9lR0hWa0JKVEpubHhDUUQwTVNqWnQxenJzRDMxN3JoOWcyUVZra2ZQZmhVMXBGN0pJRmdIL0Fhc3ZEY1BqTURVV0NVYk9PN01MT01XaTdhbTVEUlBmMGVPalZSdGJpQmlMNC9PYUZJNFp0VWZUajVLVEVpWVA2VE1NOEhTU3pZWmZucEJuTXpuM01JbzBMTHY1enJSWk9raUJPZVVYME9qS2psZzJ6OFg4U2F2OWVFMnRTblRFdm05b1R5NXpyQ1VvMExiU3lUV0RLVXBpRDIrYXJSVEZNK2Z5M1BWRmJGUmJ0L0hZeG01dERSQXhTcnBkdWpDQXl1ZDR3OXhZbmxSWThtNVhCaXpuRXMwMGhYd0JvOEpSU01qZFJ6aU9SdTZXVW5SSzdSbGFCZzFoQ1FBem1EWSs5QnRMSXVXdmJLWjhFWHVJNmE3T01hazlDVklQNW9RQzhNSlBwU1k3b0NoQkdzeUxwR0JHdzl3aG1OeEN6azRZZ0p0ZDVER0hNNHZ0QUw0OGZHM2pLWm15NWxEMUpvbEpPTE1XbjdpSklpYUpRTUZ2LzhiNTd2MmFKN3ZOUVo4WXFGRWMybHN3NmZPTUk1ak9iS3YzT1FURUZyaDl6SHFRSlBuNytWVFUwVit1Zy9laFdwbmNtdWxvVElXZnU5M3NqNVJoVys5VHh1eC91Y0VjYW02aDgyTnd5SHZJK0R0NXM3UDdEalp0bGtyRWZJVkh6OEVCdUh0UzVYYStiSmlyeS92RHl2RStwRVRBaGg3TU0xUmxxaDlPdThMY0RwQmV6V3N4K291bXVjS3J6V0t6ZlZ4dmhhZllJemJZdW5MV3FMczZPZVZwN1hJdFhYcVo1encxRStaMFRlQVl6MW0ycVFDcTRwSGlMNEhqZU1wUHBrYWRldWJMVDU4dlYyRDZaZ1phN1lmMTRXWWo5MkN3WlM0Q1JRZ0JpY21NclFkVmx3NWlFQ1ZPNURZUDVmQUtUdVFGU1VUcWdMZzlHcXZRc3luQ25FWjZkbVRiRUhEU0lNVmhDYkNFeVNrT1pXTUdCWkpEQXpDS2xLVzJrVGo3cHJXc05UYUx1SmF4NjJrNEV6cGhHd3NURWxETVljRjhkckxFaFh1K0ZzcGtJakNWR0grUDFmZ2p0a1BtdTMrbjI2WEh0bGxLMlNUMW1KdUpwR0ZqTnlxTVZJV1BJSUNGKy8zZmg2MzlwZmVUc0p6b2ZMRHRaUjZEMTdHLzcxZ1krTjZXcUdjbmxERnY1K3JRR01WRzNXVWtBalhsN0U1dXJGakFiUnpEV2JJalhkL2ZQVENtbHB5ZHIxbEhZa2h0VzczKzROZWF3YmlOQitmRXZQM2JyelRwUzB3eXJPN0d1SHdIL3Jka3dZaDdKVTRJcWZiZmFyTmh6M3ZYUEwxM21JS0ZVelFDekxtNm5ZY0ljbzJhcTh1SkVYcVRzc2ZOMEdQREpmRmNtc0JyUEJBMkFDOWg0MldjMkVRSkU4bkdqbUxsUHhjYzU1Zm5TMGhoWXFpUVd5aVh5WTVJa2tpMmpUSW9Rb1pieHpJdm1CcVk4Mk1ubUhhb1RRT21zYVhhODVRZ3hzNjhPT3c4K2xDYVBPeEdNQkNya0dpaWxwb0tzcHcybmhKVElCTkdwTm54TW5UU09wRndQc2FJMUhydXNJWU5EaktEc3BvMFFqTFJFRWFGNERubGV3allSYVJtbGZRVjNzSE1XSnUrSE5JU0czRm51YkRSenk5TWRHU0pjRWc0aUE3cTZrWU5oV0szMjYrQ0RhZnUrUDZ6VzRzalJvU2xmRFlBN3NRQmdFRXZqNWc2Ujk1WlR0a3h0a1hscVlsRlI0VUNGenlHU0U1cllwTURPSytrYm8zVnpHRWFPbkEvckdNVUNVN1QrL3JsZFBiWWZmMDR4RGdtcXlaM2NlSnZXYTMrbUZxN1dOK290ajlrcEJ6Vy9INjQvL2l6V3grQkJUT2N0cEFaOEw5M2NUTXRJNkJPaURKMmxaWllzaktKZVpXS0tyMjY5dGU4d3pVaVZDU1FTWC9wYi9vVC9kZlh1UmtXNkY5OC9QTHA2U0trSnh2ZC9HRHR2OHZNdU5FRkdicER6UHZ6TjkyMkttNkFVVnhqdHB6Ly9rbS8vOElHZSsrM21QaWNjSHZhOFFocDNKam0yemZOdnU2czFyMit1aHJEQ2I1K0h3emdZQzJVMUlqSVNFcENUOEpSSEhTWVBMaDk5VmFlTnByTVM0OXk4Z05NSzk3UnBCY1pwWklzdkJHK3ZQWGpmMmkzbnVtazJIWnplb1dmaVVVMlJtNUlaZU9rNExxMmtSVXo3eGE5VnNwczBCckJHcXBFeTFmTmFzbnFKMU9wZFRPZnNxN0k5bG8xdEl0OGMrL1E2WDlkTGVGcmZEMWtDSTQ3U2JKVE53ZEJRQUFOZ0tvSU9FRS9NcWdMRm04UENpNlNTaUtPUGFVaG1Xcm8zU0piTlBWdWtXY1pTeEdIdUtzcSt2OXFrbDU0aW5zSnRmS1NiamlnZkpFU3ZudUg2MVltNHpKaXNWaGxCcHU0NmtkdElHeUluc0RneGhJaWR4VzEwblVNOUJkazFwQlljMVRMU09qWmgyTzIyM1JqYmpQY3ZDYUVkd1hBM2NvTEFpQVZXOFFSbVp1RFFybjMxZ2RyZnZ1U2FVRnJHZExSa3ZXS3B4NlhYS2w4K3dTZlJhVmdlLzlVYzhRSUJ4dG9weS9vSHVZNHlkc05oM0kySnRJemZoTkxMMXh2cDBkeEtuM0ttQUU2NmZmZjlkU1BhYlRlck1IejU5UDgrN0ZjL2ZIL2ZQbytIZEZDUXBoN05lcjM2WmZmbGF0MTI5bW5IMjBaVzYrMlhwOC9kMTROcnR0UENBRE9oallvTDdhZzhLeS84VWttTXM1NFJ2VFlYek1LMDF6bEJKOVY2SFFXZnRQalArdlJ2eFJQU2hEU2xJOG0zOEF1UHRzTEZTVHJGK3A3Nm1NOEZvUHpHQ3BaSnpLaXhjUTVobkN6c1JZbWtLSGtKOHpoME11UlBTaTRyNUtxYUpiYW85K2NaRTl4elN0MHdabkdHWlYrSkNvSzdLMHNjU3R0b2VtZDhHalJoRWxIV1NiQlBBUGR4MzQxUVVTbVRwbHdSV21BaFprZUpEUUtKazRRZ0lDSnRrQS8zM2MvRC9jZVhyNUZqSkV0VVhVQlcwd29xTkkvWnluVVIwVlZFc2xzQjF2dTZ5RCtsaU1lWlRUWG5CQWhBUXU2cWVlUldmZEIxMCsva3FtZVRxR1NqandoOXZqbDBIdHVjaE1pTmlEaFFKbFdEQzRzWXpOeWRkYlgxMWZYVjhKZVhXNTdCMTZmT3VJazFJWXNtNkpsVTh2ZzBKNERDQWwzeHpTYm40azdzWE94R1krS3hiVGZOMWU2eGYzenFhVWVabFJ6T3d0NS82ZjdRNkdoYjFpZHpUNXJDdS9zLzNVcFF2Ulo3M1AvNkx6Lzl5M0QxM2QvYyszNUkrWkE5ckZTa2JadTRvYzVKdTg4L1A5djF0aDF6K3N1WGh6NTFIczFKcHR2TDRtL0RFZVJlSUhzNHB1UFVBM2c2TjNCaDBIMEcrWnBGWERnTCtKMHo2cGZOQUpETG1hbit5RlBnVjV2QWNWOG9EQkJlUEh3NSszb25DN2cyNnk1MEg2dGc2MXNMdUpoOVRFbVZRMGkxQTJ5MURlVkU3c3hoN29BZmc4dExsZ05MTlJ5NFQ4RWRYRUJFOVVIRGMwckppdFlTb3prSldpMlFIczAxN0dKU2E3RWZZMU9xTXNSc1dyeE1vTVBRRFJaaXJQZHY1MmxCY2MyRHFaZENjWVlvMDQzdHczYmI5MTB6L0RUK3A2dUhoRmExNzE0MmdEWTVPeFdlSFFwbkJ6TGQ3Vm1GVmJNTmhjNVF1c0UxRTRtSlFLS01YSlRUUkhBTGJOSkU4OTF3RTV1eDMzS1hjZ3BOM2h5Nk5uVnQzSTNDbnFNU25Ga0NVeWFaek9aRnBVa3NJVjZsL1ozdDZIYXF0eGF1Y2o0R3VDNDErK0FMKy85SmVpUFhPTE52aS9lWmxyQlNJWkNFTmo0YWtYTHU4dU92VDAvUHZuSlNrY3Frc2ZIcjErYy9mWWg3RjVoYlFsRFIxU1p3MDFEODhoOS8rZnpsMDFPeitlSHZQdERMVGtnd21zUlYyd29yeTQyc21zUHpUejgySXEzdHZ4NmV1aVFjS0NRUk9mWG9seFVRNE13QUJ5d1FiWFRzZjlMNStIZXluOHZaSFpqUFZCeXZtMTg0VmlBTEtzV1pJb3JmeUN5YzZ2V1Q1Y2dMcXR6cnVOTmwzdXV4VnBxRktMeTBHZlBsbnh5SU1oc0xUd2tsd0xIWGh5bExCTXh6ak9xaWdlSlQ0L3JZQWFoWTRzS2dNOHM1alJrc0JHSmp0YjF0MWdTSHVZZFl4WlJhdTJFTEVvZTdGYkcvMWIyQmlLZ3phQWhOQUt6TVljdkJ5R05SbUIzbDQzWEFyVzVPRXYybnYvLzQ5YmQ4Ly9HWGxHaU4xQWxwRTV1eHJFVUF3c0EwU1NxUFZGZ2tGUDBJTVNmbWdva3VVYWs4ZlVlb3Znd0RBUWp0N2YvOG9uOWNmWDc2KzlUM2tpbDBkOWhsNEduTmVlUU1DZzRYRVlVYjFBczZtK2RLMGEwNWZQMURLK3dzSWhNUjlQaWp4Vkkvd04vZ04xend6dEJyVjl5RkUvaDRRRGh4czFrWmQ3M2ljTmg5K2p5TUZodEZvM0N3Z0VqWStxK3NtNjN0SHc0Q1E3dTkyN1FNR2cvOXYvejZiNTg2QncxWGQzZjBzZ2M0Mm9qWTNqVXJIZ2JqWGplNisvU1VHdXVlOWw4Zk96Z3JreVVXNVVXM2FEN29LaW1HQTFWcERaWW44UEhxZE9aN3hpdHA4MXRTNTRta1BZdjlmSFk3TVM4QWVueHNCbjc3Qko0d3BTZlhaeEMvemRMQnBXQm5QdWJkWGk3WksyelVzbkZnUy9WdEFoZGRCN016bUdIVHpFb254c0ZSOTF3bzZDaEU1ckYrSGEyYWEzTTN0MnpKcS9KQktZMEpDQ29seGFVeW5ybVdzaFA3cXNScXV4ZUxFeHhVQTM4NVJoSkI4Zk15NE9hRW1zcUVDWXJIUk1Ka1J0bzFLKzhRcjdxdnVJbVA0L2RYTDUxSTJJU1VQQklMYzAwTEpXSzRNWVFuWjJNQjk2enltTTJKaFZsQk5PZTdlalk0M0thd01UY1M2eG9lNzdieE1PREdPYXI0aVAyZ01yVHgwQW9uWm1XRncxWFpBQnNGN3V3QWkyWW5BZExRVXUrcmdKY1AweFR5N0FmcVJ3MEhmOE44ZG9TWUxUaXIzN3dBbjQwdkM5UFI4dFh3OENEb3VrLzdBMGtUV2N2a25NV0FlSE1WRDcrazcvN1VhamVHME1hYjkzZnZ0amtmSG45Ny9NZjlIaEtDamlBNzdOSnFkTmJndVd2N1BRMGR4ZTNxeWg2K3ZQUzczY056bDV4WUtCZXpCY3JuUHh2LzVFSjZrakJqd0hCYVF6Tk9MOEZWWjdOd3RsNWdiWndab3hrOHhUY1N4Q3RIblpiaVFnTHptNk9pVTRiVkRFZWdieVd1RXhhL0Q3NjRnQ3RYL2VMeXJTNHNqaUFGcFR4ZEIxU0V5UW1ORTZzZzE5S3hobndkVTBYVnZhUWZIZmYzNG44WFlqYVl1M3MyOTF4cFd3R2VEVDFXcEs3a25HZHFacW1IZmZKdndUR1g1dTRndU9XVW5ldDhlYUljbDBaWEpka3lTNjc1a2N3Q3k2UWNHN2RNL09HM3c1OXV2UHZsbnNrc05PMGpSdFlNWVRIUnFoUndLNkE2bjlBaUlGSUVVUGFTY0FxcFEzT21VQzdScHZWT0JoUHBoM2IxY3ZlaC83eGZYUTBhU0N3aGZiM2JqRW5RY1RSdUNFWU9WaEpqOWlRTVozZVE2RUFxNG5rTWJSN1kxeno3cXZuQ1BuMWllajNMaGE2L1pYU1VCTmVTNzNlSzZOTjNrb1hnUTVJYjZ6Ky9wSlJmQ0t3TjlzSzVWcWF1Ni9mdnU4Zis1NEh1Nkg1Z1dWMWZYelgwdGV1Ly92cnBzRGRwMkRPMTl2SzhMWEVNb1hYYnBXd3dYMS9kNE9uWG54NmV2enlOKzg0MHlNaEZCVE5Rd1lDZWVBYktnY3NhZ29TempnQWZ1Yzk0UFFmR3NkMTNFaHM2cmNjVGZITmw3eDVOaGllUFpDYWluMkJtK0UzalVQMENqRFAyMUNYUkcyWmlKQzRNOEl1TzE5LzRlbE1rVXN3aVN0bmpGRHNpUmVwUGdMQzRoVG9rOWFNS3ZnREVDMUdTeHhxdVZDWDJuRVdGM0hJTldvQlBDRVliTTFIR2MydXRxY2k2VEtaNXByYlRFUzA1NTQyWGlqcVB3MmdyRnAwMG1Nd0Yya3h6OTZFT3Ntczlid2E5SVpPdHA4TnFPejViaU9OVDc1NmdHaWtqelBMSmtzR0Vtdk5TYkVwd0oyS253Skt6bzR6WHVJQTdtZHVjZWJJMFQ3N09mRWhCdW9FMm0rSHJsUkRNbkdWM3RYMFpJdlVjaVNKeWRuZWVRcVN5MWhCV2xsR0ZtWkM5OWNPUTNqZkc3c0t2bld5TEY1WFAyRmduRmVLeU9jdmZPRERlS3FGSnhHMUl2dVlHKzExMmFZV2F0aDg4R0NxWmdkcmJEK00vZXZwaTk5ZC82aE8yZHh0Sy8vSDE2MkgzbEp1TmtlYXNTcnN2SHhvbWMyTmQrWkNsNjV5YVRmTTE0K25UOFB5WG5rUERiSmxWM01sTmhKbFlOWjJhaFlydHRZa2Fqck40TG0yU2FtaWZ3Z3JrYkNkemVoWFRPRWwzVDI3OUtMQVNhbWF2TGt0Skhxb2hYWHpDa3NLU1NyMlViUGxzYUM4M3psay9XZHVQOHBwcE5YZmJsb2J1NmY5eGNTL0FvcFErMGlaTEU3aUgwQmcyejRONHQ3b09ZMGtQRVhaQ05sWHgrazFxZWQ4cVlZWUExaW1lYUdwK09BS1J3NWdjOVFwSjFKZ0haQThEa1hqT2VMNzV1STdpZVdSUlJTRlVZYUVoS1R1RU1Ea3NrV3BLNDVoSkpaYU1LekRBZ1N4M1pkekVJallpVUZhUWFESC9oc1lHZlhpMzJoL2llcVZmQnpSL0N2L2pKY2pnVzkrMzJOcExESTlYeG9HOXVmcnhlaDNHakJoSllockRLa1dBQTBaU2ptYlpSODlPck9MS3hEQW9tQXdhV01pY2hWTmFYM21YTVhhODJxaXZWcDJGYkp5cEhiTmFMMEdHa2FObVY4NUJNWVFSS3g5elM2TTBrYW1EOEdpY3NNSzIvL1VmNk9PbXk2Sit1dU1XWXZOckFmT3llNE9aNkg3c2dFNUYzUkxVdjFUNHpRVGhjcjBzeDA5bUNVVHA0Ui9pajgyN1hxQXI3MGw2ajl4MkZMeGJzWEZ6cy9rLy94OExEOTYvODlzcndjdkw4Ly9JNCtqY2loRmx0TUtxdytmMVhSald5R1BtRmVGZCs5TGMyWjl6OS9pd04yaW9ZMjRtQndNSU1HSjJKNFk3aXdwN0pvM2k2NVdZYzEzQTAvUVRpOWl5czhRR1hnb2ZnQXZtNFZjdXdFbXB4Q0JpSldFaUwrZi90eFF5UjQ3WWE3WGxzbncrQXk3SXEwcjZWTnY2dGk5MHZpOHNreFY1NVVLZWh2VFFLbXlrcVlUaG1wdzdCWjFOL25LYlpkK1l3azJtTzNHaFdKUkR0UkJtUFkyamV2bFY5ZUxrMWJ6allkMDJJRGlmQUs2bldyODJvaTBia1ZrYXVwRWt5RFRjQXdzTU5ua2p5bU1XS1RtYlhQZG5XQW9qVVNQQTliWHllTGo3L2t1Z25KK1ZFQzJzL1pBZnJscm42THYvOGw5My84dkh4Lzd2SGxhdHVVWnRxYzhHa1ZqT2FIY0RqSXpibWx3OE1JRTFCS3RxRnJiZXN0cHpxK0lkUXg5anpJbFhISUs3QjVVaGplRE1QaGtUVW5hWWtRRGtSbVlsMWluanB4L1dCd1JsaUFxQjFkN1E1QytBRDY4Z1Z3djd5TW42NVRkODd2TU5tY0c4OE5leEtGckhKcHRLYTVSVVF2UFVwd1JpMFpaNGUzVzd1VmtkVXFhdXU1YmNQKzllRG9laXdVTm1ocnVpWTk3dk55c1ZNNEt3ckxXaC9zdnU2ZGM4SmkrdTR1VThteWNwa05YQ1MwcnJIOXVnR2tra3pQbmwxUzh1MDNXWEwxenlheVlRVGhZd3Y3MStKM01BRVdKVkdSdGZiaCtkYURwT2xqalR1V0JqOGZlajExMW9vak5UdzE4eG9WLzJJbmtKcm93YW9uc1NuYlJta3l1L3hvRVNadXJxY2R5RENUTUhvbEFYc0hKcFFva0RiamxGS2ZnTHBXSkxZRU5PeGdMMjhveW00Vzh0YVl1TDJOM05TR0U1amNQSVVaV24zRFZpZDh2MUQ3a3JzVlRoTm9zSU80TWdOcXlIM0VRM05vbVVQbk83WnJGOUx5MkhrZDhQKy9aWjR3R05Xcm9lZnIzNTBEM0NCalROK1BVUE1FejZTV0oyR01Pem8zU1JpWXhGUkdOSVZMS1ZGVG5UZWpqWU9tcE96cllPL2M1VUpZMDVreEtOS2FpRGhWMktZQVRtSUJNQ0ROa0lKSkl5UzRQMHg3L3RsSU1LWE9YMWVQREMrWXNMVStCRjAzVFdSbDRFUE0yRXRycUl5eElXRUxGRWJucS8zeDUydmtPenZ0cDZjOWozTGdMblRBcHQydmViTGcvWTc3NXVtLzdwa00xWmc1TFZvRW9JMEgraDdxWU5aZ1lKaW42L2YzallwVWRpSXNvaVo3QTRMT3ArWVZFaWJaU0ZyK0FRRlFvTEptUUp0SWFEaVF1Sy96WHdtbkVoK08zaUVZeWpieFpGT1ZXNVBSYzVjTFNjdHhFTFhYQTVMRDhPL0ZZVGVRazZBNzlhMkc4M3luQThnNHZjQW02azEwRzhoTWZVZTFybFF0WEhVRURzMC9sNDlQOVJOVFZoc2pFRWxNUXpjd2VyQmhFdTJpNEhiQVQ2MW9tWmhrMGQyV2dkcGZzazFvYTdGOCt0cUp1aHBnS0dhb1VBRVZLdVUyakx6cE1vdmJvOWpJcEJkN1ZQMGpqVExrdWJEcDl2eFozRVRhSTloM3Y0NWtZTlBvYjJMei9jL0hQM3Q4Mi8zdHBCcis4ZmZ2MnN6RW9sWkJVZ0R0WFluTWxVUmRtbFRycUVtZDBoRFkrNkNYbEhiZE4waDJHMXg5aVB6Y2FRUjRvRWNjU1FzZ2lWTlFrdUdRS2xFZWNvZWJ1Wi9yNU44cDkvK0RGdmxUMFZPUEpiZlk5WFFFUTYxL2VmbHRCdldBZjVCQmE5ZExleE1uZTdYaU16aWI1N3Q3M0tOMSs4NTBDamd4SE1uVzVXN015V25oNmpaOFIyWUdIQTZoU0RhV1AyMUQxY2IyNkVRNUJFejQrUC9lNGxOMDNWU2REcFVUS1Bmb1NKSVVHWndxYU4yb1MrcHhDSndqRTBGQ2VEMkhQNEZ4OUJUU2NaQzh2MSsxYXNLTThQR2F4dlRJeFAydlZuUmZhbHozdUpCSGw2QXY4ZVVPZFZDWUdsaTZrOE0ybGdXWUlBTnEvTnVqSnJWeTJYbUVaVXdjWE0xYWJLaVMzTGwxbmdMQzdVZzFnYmlqWUp0SmdMUkdaa21Oc3FhdEdNVDBld1YvanI1T012MGlQTEdVRkVwZnhnaTNYUHpLellBajFiblptQ1dPQXVCVm9zYXUzb2xseUlvNisyenlteE84RGoyTi9zNVVWeldvK3lRdGMzZCs1M2gwL2hmb1NudzdzUHpZOUp0TVNnMUVrZ0JXSlJ6Mnp1b2N5RUFlUXBLRFczL3g5bmI5SWtTWkprNmZFaUlxcTJ1SHQ0YkpsVlhVdHYwejBBWVlpQUF3aVh4aEVYL0Z2OEF4NG5OeThBQUNBQVNVUkJWQndHQktJaDBHQUFETHBSdlZkbFZtVkdaQ3krbUptcWlnanp3MEZVemN5WHlDd2c4dUJKa2VudVpxWXFLaXpNNzMwdlZncGloM0ducTI2cytkUFVpL05xRW1YcXhLeFZUYzdzeTZDOUdqZFo1andDRGdLWGpVa1hQOTVjUjVCVlBHTVhtdTlSZithK2UvQVZaMm9QZm80STg4Z252aWlpenhhd0VOSHQzVVI1a3ZCbmZuRVpZeTV2N29uWmpKVEJHcFhYcWFHMyt6b0tNN20yVk5sbFl4SUlZS1ZXdUZnWmQrUGR4NTFJZ1R1UmtDclZKNVBZT1d1ZVdVaWpyaTFlYldKTXVyL1BHaGhodVIyWFJkYmFSSE1RM3BOMjNwSUx6QTk0eXM4VzBlZFBNWnJGNHppaFFMNG9ZWHZrQ1pGbnFZTDBCT1h6aGNiMVQxYlFjbVlEeHRuYjhWcmRxb3ZuRXVKeERNRXM1Q1N6TFhnSlc0SHdzVmQ4aW0xaG52RVY4em1WQmNwTzdCeFk0cTNQUTlSWlpOTWpsMXdKS1NVQjRYZ2hNWHVOTWVmK0dnQ3J1UmhwRjVSaHplZzRxenljWkc0eXVEY2RPb3ZBUVJLaVNRaFVQUklLSzBrYzhpYU52a28xWTQzOVliVkNUV3VyUTdxU3c3MzhGN2VaUStWdTZPWHo3NFpmdmQwTll5WHRreldHSTR4VlJLc2ZnQW9pRGMyeGZCVFpteEs4U05ybWUvZkFUSFZBeDNWUHZib3pFNFFxTTBxYWhXNkFUUjUwTWM0b3FqbXg2dFIvWFcvdXc1VUNFUDFpL2lTZVdhZ1BpbW8rRGtuUGhFRDhaVmdhUHpxS0ViRXd3V3RoemYxVi9NWEVtbzM3YlFDOFVnU3hxREs2S0Y3RXFLczFCRlFpTjdBb093RXVyRG11dTM1OTBmZGxPaHh1UHU3Q3psYXJMa01iRjBFZU1FRmFnQjRhUkY5RlFnclh0WDkxd1J5SU1vR1pnaTg1b3kxVGgyMW0rY204aWN1RDhlcGN3anlTcEg1aC9ZTFAyTzgyTzRXK2xPMzdoZFRRcHdzZER6SWFublFSSHl1eThCTTc4RktmQzA0OE9aNWpndDBoek93VFFzSThmNVA1ZWJoOEpnRnc1Nk1uYXhZdXoybmVSRUxNTW91N2hOalJtUUVzWkEzUktaVzhOUjFoVmdjdFpiMUp6S0Zwa0UreWJwcHBza3lzWnFVaUVJZW9DOVFERGl0T1RKV1pTVFF3aUpXRlhWVGRTU1NsUWtGcjNxM2lsRVhvb0o3WGJJVXZrdFdPNnA0dXh2MzIrcTRRYXRmdkR4OVhWNlAzZENmUzlZZDNpcTR3M0VOZDlDcVlGWnZScTFlNCt0SU05eG43Vzl6WmpGWld4aEFPQTEvSWFDdjc0U0pvTGg1TWtsZUpPczJGb3d0Z0ZvUjlzWFdWYXNJaDVjMVhuMjZIWDE5bmR3cWtvVDZXSE16dEduMVFUcDl6bm85V2h6TjQ0ek1sNCtPejRubkhhNzc0NHZCN2ViTysxVXZLV2Vxa3ZWNTBZcWdVUm1aUlVXSWhXREVwbFptY05JT1pWY1VJemhMU3Bydm9rMHI5ZE5qdHB1RXdyV01NSktHbUp2T3hKNXkxV2ZZVU5XaElLYVo0OWZWVnpYelFWQXlrNFZHWGVaa1M0d1QwZW5DbUpwM3ZVbm11cmZTYzRYK0JGNUVMTDdvZFBDaHRmdFI0L0ZTVGZSb2dueXUzNU5Gck1QN2p6Q1o4UkhmZ0FSa2tHVk5PM0dlU091V2t6TWJrTWlzVlQ1MDFuVzE5Z2lYOGF5NTljVEtsTHBtb3dreXB3aHd6VHBLUDNoR3VFZ1BqTU9XTVZWQnFqU3hlM0hGZ2I1SGZBaWFxWU8wY1FpY0lDc2dyaExtUmVSUlNXRnlFUkVTNExXQTJaUytIdnF2RVNvZkxKTW1vM29WdUdsZXFidGpmWDcwNldJY0RyVGJEdXpkWFg3KzdNZkVwWHFZcGY0Z0Z3bFltd1ZtaHdzelJabldKdHQ5c3MrdzBUb1hWaVZ5QytMaS9uMTVzQnI4b3QwN2tSWVVDKzBqeGlCWkNoQkpySU9mRlRnR0FKWUppbWZxWDR1WXNRWmM0M0VkNC9GbVRqVVU5ZW5MQk9aNUJWRDdIUkhwdVI4STUwb21GQVAvdStzWGJiVTMzcGZhaG9OcDJGUm9QV0RsMmZVeUZoY0FTUFlqV1RCTG1oUmhnQWJGTFg2ZGViZGhQaC91YmlXUFlVbWQ1Q3FxamlBck9OTThuRzU2SU1QZXFJYVUrSExTN2ZKRVBubU9xbFlJR1huQ21mQ3B4VDNrTVJHR2VoL0JSbWpkZklZZElrLzdOemFLbUJGcE9OUHJnS0FwYWhBODhGL1FQbmpJRUNPRU1wM01rdkJ5alVwYXUxWkdRejM2ZU5mNUFTWFdjQnk5QjJBOWdlVXhQSTFYaFlYN0RkZDdqYzc4cGRTU1RWZGhSU2d5SWlEQlZEYkkwNTBTRXJkWFFJQWdKbFBLc3R1QTVsVWpuL0phc01Wb08zWDAxVXJOSnlJMEZ0ZFJxNWd4cWMySVREa2hkWUswZU82MkZRQ0tFS2l3R0I1SERPWXF2NWxDejJEZ2RrbzFZR0YxQlpXWVZKUkoyQ1pZMWRSNFMrSktxZHpRY1JMaFF2L1ZkTXRHNGVwOGlEYUxkSjduNCtKdS8rTlhmcFJmVE4rdU80Qi9xaStuanEzeHZtOWl0cnU0aWxlemo5RnJ6dmE5Q1lUZmh3TXFnS1N2UXVRZGxRbWd0TEJuQU1KU2l6a3lzU1hPNDNuOGJyL2J4ZWpYUUZqdCtQWHlzNjcyeEd3WFVORTRheFVrSm9weXJkVHpXc09rT2I3Y1hILys2SzNlYlZTM01KVmFqcHZCYjlxYWowR1ZoQWoxNG9Mdk10TkM1dE5lSDB1Qm53UDd6L1FNRGtaQ0NuSmlsaHJyYTQrWGYzZXovK3VyanpXWGhIbG5KcFZKbnBkY3h4VEpadHlLOW42S2xPZ2lSSTNnT0lDSjJSS2U0M3E3akM2djczZDM5TkJEMUJETWhDa1JPb2UwNWZPWnBKUmRWOWhDRFM2QytVd3FwNzVFOForTllVS2dQOWF3TC9meHVaUS9UQUo4NXBqNFVtNExvT1o0Nm5TS0xnSWNQMEVYL2RJNndjSnlFRmd0ejY4bHc2VlJSODlNZEd5ZU93ay8wcXgrQUhFNzFsVm1WZGFKc3prcGtZYmFFTUF1SnpMN2lOaHhnOEZuTGFhSHd3QWtrSkt5dHJ3eURTNy85eEswUnZmQzBmZDZMWjhxbDczTStyRlpUV25Ha1BUbjF6SEFpVllESXpPSFZJSUdiRlpmT3NyZmFtTGg5VEhMRUtRaVlTRVRKcHRpaFpuczNmUDNpWnVTVnJzdDlXbmtwZ1MycmQ1YVZEdS9Dbi94Mi8vS1ZXL3pJMjJ5L3ZQNU42dXU5ci9Yanhtck5pREgzY1RXTVVlRXdZWkJBZ3pQQm1xU2ZGL0ZYc0dxVkthaVpUY3lwVkltYllkd1BVQXA5NXpWa3JFTnRKeEJISXlJNFdOdkVMa3d6WnhkODJNZnI5ZkJ5ZkQrRXEwNHF0U3pUekEvMXlueWN5ejhzNVBUazQzaE9WdkRGcHBjdm5pV2NoaDVpNDdpcEg5NURhMmdva2FYblR3WlBsNnM4YmQ3dFMyQWlEVzRPVWMwc1FRU28vZVhWTnJwOXlJZjlVUDI1d0JQRzBiWUFpbWdieENGdXI5STB1bkpJSVhheEx4RkdNUUpiZUs4VytBRks3bW1UZDhubU9aMHBjRUtubi9QVGp4bnV6L05jUWVmcWFrQ2VMT0JUR3F1ZnliSndQTWJJTFB0OXR0ejVFZmpQSHpNTFBxVWVMWjlzNTZXVzhmN1FrWFpxTGZvQUxXWjBOdGd0K2xCK2VCcm5CNUVCeDlLOHpZbnJwSlhjekh4NWtwM1lzSzFwV090NDZGY3B2T3A3bnl4MXBvVGlvdWJHVEZiVWF1VVl3MkZ4YUxaMTI4eUxNSmVXa1VSSFdwZ3pDNFhJdFlZb0ErVjYzMitpRFp6VzB4aTYrekp3dEZIRGVsOWxNOTcyVjc2bnlNUXZTODI3Njcva2IwaTZVb2ZVa1NxNys5NVdLUjhvR1M5bzZ4QkI1am1LVXd2a1lIRTRBN1Z5Q0JwcXFjSmRjT09FS1FmUEFoOG5vcEcyZGtqZS9JcnpwRXc4RUtFWVNlVWd4UEQ0K1Q5Ky9OblAzM3kvejN5eDNlVDd4T1FPZU9RenAvN2NXUkVJSGk5Z1dUNmxtU2Y5cGJIaTg2YVlSWElwSk1TdXZwdTY4dTMyT2cyU2dPcm1LQVlRSE95ODJpakhmNzR6Y1hjRnNZQ1ZsSVZWVmE2NnpVcUd1LzFkMlE4bVVSL2Z0eWZPUmZ0N0E0bEc1VGZRQ081VXV0VnFGVlNTQkJneFhXeTNBNklpTUQ4c1BaOTdRdzhnYzNTZVNIOSt6bDh3TnN4ZkRCdkZlWUZ3TG9YQ1dhUWd6L24wSjdUNWNxd1JQTis5NW1mYmtlZUlEZjZ5K2VGaDZYMnNMYkxFdUZsek1lNjdjVEFxRG1GUjRubjNiTm9uUERKUUFVZEJ4K3lLc0ZtNDVaSmlQZHl6T0JITXFyc0RBaXB0QmJjZjRrVFJ2TENSN3pjYmhVZ3NYV0p6b2xwZEkyczFNK2NxS0hNejBWQnJuVjM4MWMyVTROV0lnalNzVjZOK2hSaXlLME02ZjBuZnA2L1dOenQ2YzNsYmdrUWJPNGM3MjNpNVBlVHkvbnI3OFlkK3k5YzN0TjM5WS9mZjF0OE9yL1JqN201U1REWVVLNU92MDBSYVdVWFpYUkVUSTllSmdqWW43K3g1TnNDTmdwTnc5YURyY1p5Q3JKVlJ5VElkMXJLWHJkV1ZVNG1pRHJOR1dxek1sbzBqVEZtOUZ0MS8vT1QvdXRxdWRwLzNaVkxpeUFTZTNWYUw4V2JSOVFoKzVBSGZlanRmV3NCUGd0cHg5bGhtcHNCZW1VZFIvdjdpT3QwR0JRbW8xSnVES1ZnUnlXci9lblA0NXgyY3JNWWljMytUTlhhclZYcFZ4NC83Ky91QnlGWFA4ZXFQN3R3bGVrZFlVOTlIZVRHTW95SElwY2FvZ1dIQ3JFTFNkUW9TcWVITWxmN3M3RldwK2R2MGNadWRUNjA4UHIwQThGTy83OVAxKzF3S0MwNjUzb3pIdXBxVHlQSFJRbVQrQW4zdnZFbjJSMlN2SGFsOEMxZFlCZUNnNUxHamFaeUNxS3MyMUkwTG1MMmR4eC9jTWdzZmk3a0JISTl2Rm9TcVRpaUh1cVhBZ2tvMlF6dXlteTlPZndDa0xFcFd5ajZ0VWtqM01heTNTWmxVcElvUXkrRHVxTGxoVlIwd21OVnFXTnJtbFFHUXFMVldBaE9SQ0RNblJ2UkN2Vzk1dit1MjZqZHhyVU84c0tFVVoweGlaVnJGeVllM1haQmhXSDJLZW9HLy9kOHVmdjd4OW43Tm1NYStJeU00NWIxeThwdzVCZ0VzUXFLQTdCQXNxSWcwV3pMUjRLSlNhM1dXUU83bWNITk5hUmdQeWh4U2NpdlpTT0NRUU15NUdDREhteEVDRjNpV3VzTHFELy9UUC96Nnp6ZFhKVHZxM1RvNEJZR2NpNTRYTXVtWk10NGZlOUpiUGdoLzZVSCttT3d5cHlYenpEQ2pZRklpNXg3bDVnKy8zc1JVU0ZUWTg0ZTdMSUdsV2tMcHY2Sy9mMWNTR0RXMnl5Q0sxWGJUcFJnK0gyN3Z4dHBtWVlRbGdPNnBuRUptclYrTVhaZFMxSnVLb01ibzNJWVNHTDBwMDdxTEptc2wxTFlEUC9Wd1BKUTJub3ZEaFI1R29COTNZTkFwbkFqUFNDVnhacy9ISTNnWW53N0d5NjE4YW1qTmRGcCt0b0orNEN0K3RvQjR5Rm4rVVcwMEgrTXBpQVNseEhSTlA2QmcyZzloTXlkZEVieTFpOW9PN0djUXZjVXRoSlBUZkRHS2dJSm5OMG9kTXlzVkZnZURyTlRTOU5FekxzRnBXQXIwWWhxRlNOYVhteURNWFMxT0tEVTN3anNDRThIY0hUQ3ppb2FUQnhVUkVrMWhQNXVZWFZpWjRNWXgxaUxkYXVyZTNuNCt2SXoxMDVhbmNJbkxrVnlRVjl0czBrMHgzbll2WC96REI4aWwzK3Y2ODMvK3Q3L3lkK05GUDNET1pNU2lPZTg2b3NHWVNNbWNtRldKdktPTWxKZ0JZeFdGRzhWUXJKcUlrbm05ZzVNVEpLQkN6Wm1OYlIrVGwxeWp1TlhxRGlVaUZhSEFBTHVEbkN6WkxzVnZmdC8veFYvOFY3KzRwbkhFU29aTVhQcGpNamMvTUJrOUJqajR3cWdBUDN2MUZWL1lnZWYyd2hLQ3hpSlpmVWc5L2ZENTk3OWVSZFJheXVIdXNCdHFBTU5MVXFMNi9YKzRZelZoU0dmVnRWdkZ1TDVJNVhCWFArUXhrNGdZbVJHeitMTjZoRll1aGhqVlY1dElSUElYWTRaSXYxS2ZNMTl0TE5WRnlTc3hsU0h3OGZqL3ZPamg3S2o3VU5ySTRMUHg4TklDZ2p3Q3N6OHlOL0FTR1UyUEJ1VytiSlZuUVVwWTV0RWcwaU1YNjhrT2pCK2JLcy9ybDMvNkhOemVsc3pWL0NGUWQvV1M5Ly96TG90cEVKVzVhVVZ1eTZPK3RlZGJQTm9pcDV5UjIySm5uUlVpUUt3NGNWSWpXSzNteEV5T21nMk9SbGx1bXBBcWhFcWt3dUFDb083ditxaEVuVm5GL0NCYjVIVmV6VUNBVjBmbGhyUHh1VS9STmQ1N2N6VEFiV0FOUkRWdkp0K3M5dE8rVDNWL3BmZEpkWnVuS0pVdkQyYWhXMkgvMlYrdXhUWUZKWWZMejM5WS80bmRlUkNZa2JKYmxIcnd0V1NtNG5IUldpdUR4bUhxV2FIdXpFR3dHb2hWcW5uTEtITTM0OVpOSi9FeWxUQ3BISzVXKzFwZFFwMWJSUTcwQkE1VURaVmNpRG5JWFg4WmI3NS8vMy8vK3pkdmYzWVZmcDVJTmMyaGZNL1owZm54V0xGZHQzb2NaejYybDM2QnlIRzAzY3hzRUk0SEtydHRYRjkrL09GNk00VnBtTW80VENrS09SUkNWRC84NW5lL3lTSWxxZ1lLZmVqV2ZlUkl1ODgzdTlwb1gyNjBnT0dlcERvdE5sME8vWHFUK3FzWFlTb2gvYnY5d2JTL3V0Z0hoYm5xYlJrdDlaRTFocEJDMTRXVFR2UXhDdXlzaVNYbnBRWS9nTlk4RnBZLzFYbWNZSEVuYmRvWks0djU0ZUdWNTRpdjR4aXBmUTFmSW4vZ3A2ZTlmMHdUNjFnOXpFYVVWYkI4UHcyZk5kL0hzSTZzcmZVTW9ZWDZjblEwOHFtSkRuWThqR2V6MlJQZDFyNWJnT1Z4TE5ZK1JUY0h6Z3pGSUJXWVVlUWlyYTJiYUNyTnJPaHdEWkZKUkZURW1lQldIRXNscmUzV1VDV3JBSG8zcDhVWTRyQXNTWktXeWJWOGtvdDhaOG04Nno1UHErM1dKWGErSTR5anMwemQ4SHZ2WDNHNWVYUDEyOE9tL09OWHIzLzU3WHZhVk9jUVBFKzlJdk02a3JtWmlBWnZ1UXRSYXlrZW93aUlSSlZXMWVZWmo1RUlVejlteENEWVR4S0VtY2VpT25CM1N5UWFPTE1hRXhsNW94RlpkV3VlOWZ5TDRlYUhUNnZWK1BuOVAxNWQwZkEvWHZVbFhHOG9rWjhCQ21mVXl6UEo3blA2NUpNS2szNUtFVGpQdVJjN1VBbEJxUjQ2OS9YdC9pQTNlUm9SWXQvdFY0T0JJSjNZK0YxNGYwZk1KRUZEN2k4dTFsSG84M0M0dVJrcFdEdWV1VXNRZHJObk04Q1lLREozNnhjWDYzL3o1bFU4NU5EVFZkcXNZOWRUMzdPNWFQRmN5clEvVE14eHU2WlIvMmJKOUc2K2JEa2lLNXFZY283a0EwNDFidFBpcUtnd3M0WW1nblZtRm0yTmsyVVRQWDBJeDNSb2FWZVBSZHR2VkluYXZvWG1zVUdZMjdQQ3lzSkVRWmhGVmNOc0lWQlZWWlZsUHo0bVpNanB0eHpEdjJjamo4aVMrM2NXaExyOC8rMEpMckpzNzdPQ2lzekpkOTk5ODhQM09hUVV1WUtGaVRXWWhCaG04TVc4ODJJZUo3bDUwMWVadzVrMUNNTmpNY1lFRVdJbkZaS1NTL1djNFdaZVMyVnlKeUludC9ZaHQvNk04NHpkWUJJbU40dEUxcFl4a3pBalYxamJaTWxxTmdwV09haE5aSzU5eE9SRTBLaCtOZFoxVDdyWjVFUGNqdnVrRXNWY2U2bWt1cGE3N25CWElsWGU3ZFlYUDN5TVVwVDNuMmpOY1VWVGtQMnVHdzd4c3NkWVdNVnpNYS9UVkdIbGlxdkZ0Wm81Qzh3VnpPQ1FRb1lvMnpnRWw5UUZHQ3VxaWFBSWhyMTU5YkYycXpxNHI4dXdEbVBNN2pic002WXVWQXVZdWhEZ1ZETUhydFJGZS9GMitKU0JnZnFPaWhQL1g2K21iK3VIZjgyUlloRHBWalVJU1JRekVRWjRUb2NsNkRHUXZHMjhxdktnQ2x1dS81SUNPMmZLbm95MTg3ZldGb1lGdjdpNTZ2L2pQOTM3N1JEVGREdDg5M2xucVE5eXVMdXBBYTRpRVAvK08rSEU3SHFSM2x4Zlh5WS9ISDczL3QydEIyMXpYUkJydTdBY1prUmZjQ2RoVmlJNGhkV202ellYNjI1NzlmVmFDMUl3QUxxNVdua1hOY1l1eGFRUytuWFhoWDU5L2VwcWV4R09ROWJIemJsVDZNeVBOWlRuR2VmNVlIanhXVDRHN3p5ajIrTHpjdVdSQnBWSVFJSnpCTjM1c0pucDJhUDI4aVRET2Jqc3FMZzdnajIrWUhVNis1TzhWcmxZNCtQOXpUMEhUaE5hSVJZWmRRbFpXT3dmOHhsY0dJSzZBTFpuQ2taeFpra1V0UmFqaG9SMmdLVTZDSWFXS05GYUFHMTIzeDZucDNLb01lS29BTzRDUUl3cUU0OHNUTzZ1UkF4eGNvZDdBMG1DZ21pWUQzZTNxZDVjL3NrbXMzN2VSWWsxUm5LTlpRSkpHVm5XZzFFSjdHQ3VkWjhQdUtnVXltR3lUVEJMTC9LN3cxZitYamZYd0RSQWtTZVBvcEZLZmE5TlNuWGlONFRrUHJtcU1FQkMwVkRoazRpN2tvVE1rQ2h1bTFLcEZCSTNjNWlobU1UNUtDM0VRaE1DRVRFVmtpUUcrV3JyWTRXb3VSQ1o4U1puOWVBMzcxWVg2OVZxczE1aHFzUXMyMXc0U2MxQzRCT1lsMDVaR1BUbHMrNlpoaHBuZHNSajg0VEIxSkhiOVA2M0tVTGlxdVA2aWZWS1NQRnhieXdHM0crRFYrZHVsK0lxYlZaNmlYSzN1NzJma0FzSWJ2TG9McXR6d1c4a0l2Tm9ralRxUm1JZ1dCMjd5TlZ5ZGwwalloVXRkcVlpa2hpZWEwRUhqZVE4QjUwekxVcW9KeUx3cC9icGgzQ0RKaEkvbDBEUThlWjlCTDk3L1BYY1dFMUtqM085bTJwcmlVeVJwUWc2QmtyU0dScm5ZVlBpRE1CLzl0OGZ2b0xIMnVzbnBSUkxDQ3p5NWgybXFTaFhJbFVtSjY4c1FxSDVwOXRobUVGa3k3QU5PRm96bVJqT0lneDNxdFVhV002cWdZWFk0V0FoUDJwWDJ3QjNpVXhmVFAwemg3Zk9IVEpwbTNBVFBjTXhyM1Yyd0kwZFRnNlNTTXptUk1SWjhvN0hzTC9ZREllODlqMFlDTDBNRUtxamh1MEhjaXZzbnBUR29qejBwbG9INHNOVnlMcmVkTU9Ba2IzZmNCMUsxRHdKcThLSkR0dVZsWXh3UW9aRXkzVzBWUkJ4WjZYT1JpS01nUjB4Q1ZFMVVyYmNNNXRWQ2JWVVNJQmxwRUFLQzB6QnhIandKTW9FdUNZMWhNdEVGSmhyKzJ3a3ZCaFhIVnp2eUthZzNTcGQ5S3N1YVNtVE1jTTRCVHl5MWMxd0pmNnBzZEdaSFgxMlRCNXBlUzA3aGxkbDJFOERoVDRnVjNBYTlzbks3czRqQ1VnRWRZQ3VkSHZSZFludGtQZDM5N3VwUkljcVY5ZEhib0YycFlYUTVBMmtNY2FnUVZ5RWJkckwzMjVXcUtXVXBCZXZObUZ6d2JHTElRUlJzcHhKa3pPTnBTa2x6L2ZOSjZ3Y2VqSzVYVHliZEtSSU1vN2txNU1GU1BnbkZTOTh5bExpTC9oNWdYbDNQMkt6ZkQ1NnlpTXQ5SU9SQVk1dDlYT3lQTTdYTG4vSnpiSThJU1V4MVZxQzltc3hNNE1USzFHV29GZ0N4OGpuc3oyb0xHV0RMMG1xYzBhaE10eXNORmdSa2JsN0xkV1l4Sm1WYTZ2ajUzMFl4MmdabklLaS9LZ09kamN3WkY3aWdEdEVUNis2cVdGZ1ZZUDZYS2VrWWRUNlRRcmo5V3FTcmRvWWxUbHl4NmkxV0FnZFd6SDJ5cFFuNjhKVVhNbHE2TDYxRlNEZEwyOE8rMFRmcmE5RjJJc2I5MjRHNlZTN2xiSFpzb0tKV0VQSnBDQmhncWdGSmc5S1R1NXNDdmJpQ3ZPZHNWc05adFVsOVZLWFpDdHAvVS9PSXNwc1ZVaVRPSWRwMDEzYVVJbWRYSFM5RFhkcHRkTnc5d2JUdlZFTThlTEYxY1VhdGx1dk1OWFFGOHkwejBlbVBQb0MrT0VSRSs3QkZQSThTc0N0Vzkxa2liWFdrWXQ1UUNrN3lya3J6SENTVmNqUUZDNnUxMnUyYWJmL1E4bTVlZ2hWU0lWRTZVa2M3Unpxb21RZUkybGFCU2JZQVJJRTB6NEl1N0d5K2VwRHNyaVJrR0xRSUlPbzhPYnJ0NFNTRDRmUndqSGthUTVhZlZEaTRpVG54ak03OFBrQXhoL05pZVdaaXZ6SE9reFBwOE44OXRIUEd6MmZDVCtlNXdLUW41emJqN2lEcC9MNXVjZngwMXBjMU5uTDNhRGJydFk2Z3QyRTNLTUVsUWJiOU9PTmd0YmNXMHF1UnM0eHVJTWJNZFVLU1dEVUtpQ3Z1ZnJDUG00TXJpYk1tc05uK0t5ZmlrWE1wNHZyamtXYmRLbWxMOFc1ZlQrYmY1VUFhMTFUZHdhb0E0TWQ0ZTR5QmREcWVzZXFsaW1tYWJKUTJmcFFEMkRpN01pMVRNTWxxbWZ2K3ZYZHplcUN1MHZVZmFWY2ZPMHJ6c1pKNGV5VHE3cEIyQ3VmeUdKQ2pyQ2c3SnNMUFhaT2dGZUNvam9ZbkZYRnlhWkVEY2ZSR1JtbzFkM2t6Z3hqd0dwcVVtQ3AxUFZqZFZFWWNieDQvWWY3WUI5c08wNGdhQ1FxNHc5eThlb3lwa2xpQ29TS2g1V1huUGFtSDEzQTUyaWx4ODF0aUROeHRFLzNrSDdNbGJucjlnUmprVmhiZDFHdHlzcy91NnAwSmRQOTdlNTJkemVYUjdGQkdmU3h4S0haWXB4WnlIV3pDU2tHcWJuWTVXQ1N5RElYQXppRVVvcW5ndWdhbEZsbGtKamkyd3RKVkliYmR4OE9RVTVqRmp3VmRRTlA5NnV6UGZQc2NTV1BVaDM1a1RiejJUbmJRMXZYVTlEbjJhUHpxTXZpTXpvS1A0K1NQeEtyenBZcW1KZnA3QmtGODRHSzdSSDh6bzBveFg2OXV0dU5CYUVXTjNMU2VZVXR1V3Z6MEhjMlpaemlMYjMxbUIxUndOSWtCQ2hUN2dIeVdveUZGNHZ2QWlCcEFxNDJsbHF3Q1dlbERjQ0FaeEVWbVcyTTduQlp5QXNOTEFnbVdKRTJENE5EWDVlUGVidWlRQ1QxMEcxTldPcU80VmFMam01OUlPYW1XdW5IeVNjb2xVSTIvZXkzbjJvbk9lUU43N0VxNzE1TGhCVUpvMU9VUE5Dck1qR0hCcTlxbjRGR2NRaVR0MzU5ZFpEektoT0JEQmE4SGZsVENFVHVaU051Z05YVlZBMms0cWh1N2cwQ3lBUVNIMWQ5a0M2Z1RxT0dGc09vSGNPOTNGZkp6QktKYkkxYTgvZ0R2UzdoeGR0TEh6Y0VOek1QajVSNi9wTUx1TlUrUGxOcGoxRXRhSzFDbUl6VHhaK3ZoL3ZScHNFc3VNTkFMQzJ3aVMxYy9Kdi83dnI5eDAvREQrL3ZTNW1ZbUlTQTBDakQvSmdnNDB1dEZhT3RYcjhNMjVEVXEzbmE1eEM4K3Q2Y3ZiaWtnT0t3QStad1FJR2tKSisrRnViWUJ6dUVZNG42a0V0eWVsbzhodGVjTlFWQTUrZk5FNExybkdIeVphWHlPUmpoRkp2OWlFNTFWSE13VGxIaXpSWEZ6OW9GSDZGKytJeVJ4V2YveG5qSTNudW1xZUZPb3R6YlN2S2hJcUdBbVNVR2RtT1JZeHJjL0NuSkNhbDVuQnJOQUZuajJJYWNYSXROTXR0M1Ewc3JCSUdGQStic1NQalJNdDF5WEpiV3hKS1cxbHFpaTc1WDVpTTN6N0hpTXJQQUFSVnlJcmVEOU5kM282Vk5RWitLYmRlbEVoV0V2Uk9WRWtOUklnNGlCU0hzZHdWM0Y0bkJlZnJxb3ZvK3EyaGNhN0ZheHhCYUdyRXp1VldxUlVBcGlpMVhRVVFqVmV0Z0xBUndxZkFKeVFsT1pBVXViSVZpRUlDQ09iazVoMlRpQmlJVzkycm1ZR0dBV0pYVjh1cXF5MXlHM0x5NFFzakRzQTVwZGJIYjl5c1NFZVRDcWV2WmJ3K0hxcC91cnhOY1ZGbk9vRXo4UEJqaXVZWE1XRFlpUGdrY2ZNNnJxVFYyZjMyeHV0bVArY1B2UHU1V3pLamtTRVRPd2hhWlk4K2ZmL3U3NmZhMnR0dERXSWlORnRIRzR6ZzFZVkdoY0xubTFWY3Z3c3VRQW9PNGxDcnVGTWVwY00wV0xOV2JBNHBaeTlyUzZNclkzOTkySXFFTDlSQk95bVk4b1RVK0Z6Z2hPSTVNanh6TE5vTmIvamxoRkI5Z1gwSFBOTFg0S0FzaFBMUjNIY2U3eDkxMDJkSG5BSkVma1dPY1VuanhSZm92UDlhSVBYRmhzUUlWZ3pwNW1YeGw1aEtTUkdGMzVVWDdnZ1ZiNE1zY2QxNi9zeEJMTkhoMXBlb3dGbGZLczNTR1JKZlloYlpXRnoreCtwRTZnak9MUlpXV2tKN21Tc0puell2UGI3RXRZQkpvTzFDTGtqaTg3ajcvN0JlYmZ6ajgzSWF3V2U5SDNleW5sY0RwRU5SZzB0ODdpRVBnbmNYa0Erbm5MakZySFQ5dE54OXVkSnY2c1h1ei8yYS9Ob0k1cUhaZU0zdElBMXN0YVoxQzI3WFlPU0d4VlNZSHM1dmtDcThVbVVSQlFIWmh3TVVjb0NBd2NnNXIxVkcwMWZvT00yTWxPSU0xYUlTRnk5VmgxQkdwYzJNaDJMUy9qeVM2a25zdjJ2VXBDaWFiT0haeGpWV1kvaW04dlBxbXU3amNkaXM1NFB3c3U4Q0NuL1k2SHRxS2NRVE84cm5JRUtETGNhcmRuN3pWcnlZdjMxcmVGVFJwVDIzVHFOclgyei84SS8rbnZ4L0lYUk1RV2xBV21Rb3Bqc0VreDMxUm1EVm9rSGg5d2F1clM3b1FnWmtUeDU2TDlSdTUyNXRiN0Y5dHgzLzVQay94ZG9ZOFY0Z0U5cm9pZU4zOThJMys5NmU5aVZsRmZCYm9PeEdSaU14ak5jeGp0R09tVjJoSTFRWDgxYkp4bXVWQVNaaDh6a0NQTFRWYks3SElnN0Z3MHhRSm42VVEwMm1lSzhlUjdjS0ZibHROZTBYQ015dnVpWHhzd1dvOEhoS2YvcUw5dkREL2h2YWFSR2JwOEd5eFoxSnV3OER0L1JpQzhsZ1BFMFZ5Tm9ncWVldmFpNnEzaUJReGQxQkxFNXpma1lHQUdnQlZLOVZJR0ZhcjFWSkJhQzVOZHE4U1ZKbklRaEF6WjRDSlJWU1BqSzdsZU5HR1YyQldaa0JnVHJBcThFYUJwbVYwS1N3aW5Kakppb3V5VTM4bHQ1dHFkVEtxZGFCT2F0eDJ1MXRaU3kwOGtCMVMvTUVqVjZ0R0lBMCtaSTFlM1RLRkYzZmpabDI4TThzRnFzcWxjbEFtNnYxMkN2WTVnV0dra1RCbTI5VnRrQlRJdVRmQXdWNjRaQWliT1pGREdNRzlHZHlGUFd6RE1Bb1hZN2JjRGlWVmdoSXJ3WXV5djdtOFM1OWp2SGN1cW9EVStLWmVIKzdlWE4zY3ZBYllpa2ZwdFhpa1FVVGhidVYydUxtZmJuZkNJYkpYSURIQnpEeW9rTlVtUVQycVhoZW1BdUR6TGJMY2RJS21sMkZsQ3JmVzFnQUFJQUJKUkVGVTFGd2tWRWdOSzVnRlhiK2d6M3NSY2F2RkluTWJRR3MzL2V2LzgvMUF4TUx1M0txSjFuUjFaN0Y1bmMxT01ZbTZ1cnpZWHIzNTJlcnk1MTlkeEo1cnJTQWlzMW9oUG4zMlFKVzdWZkgwNGpKQURRNFloZUNTb2loaThuLzVULy93cVFROHFXOGY3STNQbFJqTE0rUW9KUWNKQ1IyVGNjSE1WSm1GZ21wbEJRa1FIRlZZeE9sSGFBZy9qcUU3Z3hyaGxGRDR4MGlzVHVrcy9CQitkMHlCZXY0Rk1mRXRydnBQZTVoTEw1alVBOG1TOTNpY01qek1rQUs1KzJ3dm5wdkw3ZW5tcUtVUUdwNk9HQTR6RXp6VTNpNGpoak81NnNQU1Q0U29lV2g1bVNjeU15dFluSUFWTThEQ3ppMk9ES1pXZWFYRk1hVXVCVkZVcG5vUVFxbkI2Z3YzdUo1S044RkZsS0hsUGxGZ0p6Q3IybmpMY2hmalpjMWVqVmlra3lnd0lpdXhxeFF1aTVNR1VSR3kyYVpsMHFaYzFGQjdNMlZJNEV5c3NOblhqZXBVZHAwS2k3Q1hhYzYra2hhdERBU0doMXcyVStoTkMydmJQK3VvbnpoOFh2OXArdGVYbCtNUUw4WEJXVE43OFNwQ2RpakVlcGZySDNCeGZSRlZkUkFTWWFJSzU3Q0tPdmpqcXV0TTZROTZrbldOeHFKck13d0JCQ0x4N2RmZkdabEw1S09yYU9JeWtrMm01eEpETUphbjdxekVKU0d3Q1BNbXJSTGs0dnExcDR1ZVNIM3VWalk3YUZQdEFlV1FsSm5qQ3I3YjUybzVYN2dWd3Y3dTd0UHYvL1liMmw2SDV4Y1J6aUlwSHN1RmNSYnQxbnJCODE1R0lGQ2MyN01KSksxZk9wY3VWczFPMU5zL3htUC83QWo2RkRUTzlHTVprUThuUm53ZWovcElPYnV3a3ZpNUJqaXZ4ai9jZmpmMG0rOGtVczNxekFXcTdhTE1jMWw2c0ZXU3c5M25OaWk4S3BOWmRTS0hsVklVRHZlMmc1dlpRczVwVmJjUVZXNzFsbjdCMnl5emVxamk1QWRtWm80a2FCb2ZsZ1o5Ylo5UXRaRkdrVEJaUlpFK2NtZWdVTWNvV3FkSTA0VlFsejVNVjI3T29sUTVXOWRIS2VSd2lUYmQ5bndqMjVTbHNiOVlPYkJsaWpaUzhCeTJPeWxkRW03S3RBQWhWRVNscWdTM2xra09Kd2VqMmE1ODVsZUtDOWU3aTlWT1ZLM1dFbHVVRThFZ0FGeGtNRG5jYkVmbTFQZm1MYmt0NzE5LzNvYTd6Uy8xZnJjTFduM2l6RlVSU2lYdGV5a2x3WEtITWt6VGZaRCs2cUtmZDZFZUFOdm9LNmJIVXYxalVEam9qQjk5Qkc0L0pHRktVYWVmL2VuZjNZZ1g3VkRqYVVwWkRCeFAzZTVXdVM1aHZYSU03UkhWSUx4T2lXcDg4WXUzbFdOd0Z6c0drN2s3Z1FJZ0VaUzlIcVFVczFvOWJWU1VTNVU2Zk1Mbjh2R2R2ZnJaTmp6cjd2bENmdTVETmZnQ3JqOEc1YzV0dlBhT2s0Z0dCaVlBRUdHQmVEUGgvZitUTERPZHI3UG0xcFN6Y2NHWEhjajh3Sng5bG94NGFyNmR0OXJubnZ6Q2VTang1Wm8rai92Qk9jd3g1ZFlxRGdnVGZHWkVuMVp3dzBPU3VNK3NYaUdyRmNRTWJ4aWNwcGhjMnM5SFpoUEFRalA2NWZUQ0gzZngyN2VCNmxFSXZBQjdoY2pkSjFVVmtjRHRNZ0R3WVVDM0ltRXpaM1lXYUNpSFVmdERMbXEzRjhwZFBGQ0VvK244S3Ftb3NKZkt5WEpKWENCU09wZFN6VUFjeUNvckQ1WThRNjFRV1VPcE1FZ1NxNUJCQWx4YVFBVjhiZ21ZMTlhMEpXRlV3NHVpWW1OL0piTVR6UmJiVFBVQU9Da1gzY3E0NllaRERxczhOVEpDMmYzSmRUU3VkUDAzLyt1L2JML0MvU0ZOZ3VBZG5DT3ptaVhPM3NkVlpKbnVKcjNZbHRodExxNHV1dmNjcUhKU084SHRjRWJXd1prRTYySDJ6bXc0V3dvbHM2N1UxNzk2Y3h2SXZiTEZZMlhFWkpBV0NEOXZaM1FNcVRwYTA1aGpTRkZBTmxXUzd1WFhtMnJDQXNUNWwwdDc3aEhjUlZBcmUwSE5wUnJpOXZxcVR6d09oL3VkN3orbCtJdjExMTl0d2pOa0FqeUF6cDI4Qm85MjVLYS9rbVVCejJUdUtxU2t6QjJIb0piekJ5dkdHbFZCck5BbldGazhxbmI5eDVid2NRL0dra2pPUDJIVVp6cGZ3VWZxNjNtWmRBbzBmN0FEei9VRzk1dHc4ZW43Yi92ZHlLbFRhZDRlVml4eTc4Y0N0cGJ2eWZCRzNXQm1XREhNV3VvbDEwTGNoVmdKZGJtaDNFSENzQk9XRnN2Ui85VExBNnFRTWlzWGdCdGx2ZDBsSmlLa2dqejNxWVZJQWpNbEo4L0ZUSlFjbmltck1vaDE2UHRhY3BjKzlNRnBOUmF1UmhJNnpxdzJVUitKNmhSNmlCVmRlMEdJMERCTnBiS1NpRWl3TWE4RlpZeGVuU2tKQ3p0cnFZbFJKVEhNRjdSZlV4YlBEeXhtVWJKYUlVTHFOZGNlNXFWNmM3alBVbkFZcEsrNmZkTk5aTXJqL3E1UmYwVnNIRjZQdXo2L2UvSEx6OVBkcDBoV2NxRGdOVmlpZXVBUVhLenN0YWl2MXQyVWgzRWdUcHNYVjZzWEtkVGlYUnI1UEFjYlJHZEVyYk12eTlrSTVDQmhQajVTRVVMTzh2b3Z2eFZDSmU2V3k1NVYzYzM5UEJNSWN4OWpOc1NLaUhEUUxyQm55OUp2cjk2KzNGWm1VMFVqRTFNRHZqUXRQalJRemRHeUIrRzBQdFROaTAwWDNvNzcrNXU3S2kvRmE3ZDUvU1k4WDZvdU9ZUjRCRlUvTjlTMzVRU1o1Nm96bTFWVVZabFozWVl5M08wL3p3czRhT2o2dm51eTRQREVqL0ZqT3pBZjI4emdCNWtvUHpxdU9qTXdneC8weEUrd1VYa1FkTVhzM0ViSDI3c2Z5cVRYcUFSWG9SYnViZVE2VDRIOGlaaDZqaGFET1lFZ0lyQnFNRkdkclNCK2RER1JRSTRQYUlBWnJnOFZySUpISXZVbXdYTUpyWHMybXk4YVRGQllhQ05DZ0hrRWFRakNtZGhoWGxVRk5ZOVQwUzVSaHNNNUVTaU45NUt5cnFxYkNXa2ZQeVZHaGdpOFZtSTE1SFRGTzJ3eUNEQXpJaUlKR3F2NzFLbENGR1JWV2RRY3NERUZxcFJtckhQamw4SkJ6S3h0ZXFFS0lxYlcxUnB2RXR4cXJlVUlUUVFMS2tVcXVrb2J6Y1BGbGZ6ejU5UzFzaHIxdzhVNGRkTXUvZjR2WHYrSDM0UVhjZkxLMWIzendENVJKME1YRWRnclp3NVE0bGZqN3RNN0R1R3ZYdi84Y2pXVSszUzJBL09wWmo3YVY1Y2crbU0vQzNNNDc3d2dsRlZEVFgvNWY5d2VpTXg3TzExMkVzQUNQZUlhODN6SUZGVVY1aVNDbXNkaWFYMzUxWnVWR3hOem9IcFVmREV0V0RNTnJmSGxpTDNiSWNjTzJYWkd1aVlqZzhOcnRpYzdzSno0ZmsvblpYeE02cVZUcUZRN0xQRHNENnJDWkY2OTVIR2FEbmNIZ2hORU9FcGNyWEU2QkQvRDVlQWZ0KzJlTjdFY3A3Ny8vN2NtMW9uZnRlelB4eDk3VW9RZXEyMm1nVmFiREhoY3FUdkJjNEF5b0dMYXZnR1BUQnRNVENMaURDTUEyaHozTUJEWTNlQTJON1hhRUtsbGNyYmtIR2JpZ09PUWpPVVpCQ3FyQ0lPUldsa3VDMEdBUVE1aFRzSXdBOXdiNDJRQ2N6V3UzTWpUWkI2NEh0RHJCTzNCMG4rbTExTU56TWhVaTdHYmdNQVdoSXlyRkdGNDdEaGxMMU4yYWExZGdpTjQ5Y0JXU0tubG9KdXhDR1ZCc1poYXdkeDY2bk5PZEVNM2l3aHBVRFluWjYyZjE1VHJLVXFWQ0NRQ2s2N2ttTEp1UGlOZXlGZmpWSVFjSEl6Mjd6dmRoZkI1dC83NjM5WHZKakVpTmhlQmcyRkVHaG1rSGFrZElDSEtYYzdPSXZ6dlgvL3ByOStzZTB4bkVsczhPUGt1Ti8yWmZCaHpIaDJmUS84ejl4UGUvdFhmZnRUT2NWeS9uUU1xL2lnYWhSa2k4MXdoQm0zZTdXckZIVmJMTUJ6NnBIQ1I1ZFFLQmdqc2dsbXZLNVdWblNObnFVSEI0WlpRS2FwOTF2N3E0a29QNFVzbng5TnErWkZ6NnF4MXdteENaR0hhRTNrZHgvS2haRmNxV1ZtRjRCN01JU21GTHkyNUk0dm5SMWZ3TTNPN256NUFQMC9VQVQ5cVl1SEJnMlI1L3hJRGVZR1B1cEpwY3JjV05tZWhhVTluQU44NVlMNDFLdW9NWEcrNkRXL0NFNjlHTFNHbDJSRGRFVTdaaUkwbzgwQ1Qrd3hCUW9nQVF4QWlGK1l3bzRRRkFFSFlaZzBSazVreGpNRGlZRm9HaEFvSmVVUUtZOWwwVHRoK0YxL1hvZStpY0NsVEZUSlc4VnhYa1JsbTAwcGxva0NWVUV1bElPNGVZRXpVMlRnRlFrMUJVSmtzVllTUVVvbHN0U2hxZTdJdHB4eTJwYW5EQWdrc0xmd29qMU9BczhKc09ZaXlDbHpVZWQyWnJnOU9kUEZuOHQyN3ZzVk9rSHo2ZXZWK2MvSDVxMi9lL25uL3Yvek9Pb0JRcThOY0dibGMxRHBPaVRxakVDT1ZvVUNpczlDdmg3Ly8zWnRmZmJVUmZ1SU1QamF4anZpRnh5anlzL3ZNWVpxbTJ2K1g3NzZWRmVmalZFV3NRQVI0b0tOb0xsa0NSSUxHS080K1dDNlFHTTMzSDRwMzYwNElUUFBPRFdhWkJ4aGg3a1lINFZwY2xSVktKcUV5bUtWZ3k2dnJWeGRSOUcrV2VleDgrbVdjK1dzWGZWL3JmaEtMc0lPRW1MbVFDSkZJRkxqR3BJV1lVZk40ZS9mRGQ5Ky8vL0JwWHd4V25UY3hoTmozcXk3RUpMcTYySWdYam0wc1JxeHFUWDgwNDVBV2R0SHBqNS8wMkF1Z3BuRitXWmJSeS9HMUh1MGtiUUd5dEQvTXpLeXFzd2lSWjhFRm40K05ad0s0NkNrUXR2MHk5UXJKdHhQZjMrVFpXY0ROMnUrc3FtSWtMQXdFSVlSb2cxcXBGVVNjeDByS0ZGQnljYmM2bDJVU290U2NLOEdQQjBTZlIwczRUU2g5dWEzWWZkNmxXN3hLSUFLeDZqeDBjaWVKVVFtdUtUQklwR1lEdWFramRzR0sxdXBtUkJQREtLcFQ0R0lod1VMMGJBRG5pWGdjSkpkR0NSRXJsS0tQa2d0c3FHRVlKNi9qV1BaRDFRaUFIZXdaMnBteGdEV3VraFVSWGp1Sk8xbmVyR0FjT0ZjakphOGtNQ2d5MnJLY1BIblZPa20zOXdnT1ZpVUd6OW1kV0lTSU1xWEkxV3J1TDJKM21jcm5ONy80dC9TYi9PWmI3dFVrMGxBbnJEQm9scnFMci9HSHZrS1JLZHEwR3d5d2FlSllEOE11a1dETTBGNklsV3BKd3pEODhLKy92M210Q2NPSTZDd01nS0laUkdDeXhMTE9WMEJuUzFvaGlVRVcvajRneEtpa0huNS9XdzdkZXFlekR0azRDRG1yenIyUldkU2dLeUhTMVBmcDVYcTZyK1FackNwZUk1RVB1Mm5vQ3Zkc2V1VWFnN0tUTGdiMnVWOGRsRFJHbFJDQ2FoUUlpRFgyNis3RnE1Y3ZObjNTditFenl1U2laWGlZejNzbTJDQnVrYlRORVUraTBVbENpaXJNNVhELzRZZVA3Mi91aGx3TlFVUkM3SktLaGhCQzNBcUhmdnZ5NnJvUHd1VFdtR3l0NUppaEg4elBheVA1M0hXMDRLSDVJYU9MSHpNekgxVzJweG5yL0NQbHFmdHA4VXpReVl4QnBDQldDUjBIcXNVMUdzdDhEZ0F6NE13aXpFUXVzcEJuaVVVa2VYVUFuZ2hld1VJaWJkakNjRFBNaHZJNXU3RFpBYzhMa0RsNW1FblEwSFJMdVJkbzRTdUlzSWh5NnlXU3RQd3luVFJoSERrUnlCMmhLOWFTUjV6ZGlGVmJYZUJXcUUxdXFWRGk2bUFtSzVXam83b0lTU21sbHBKektZNHlGaU56Z2huY1FGYUp5VG1JZ3hBaWl3bzhsMnExbExpT1RqSFF4RXBXS2xydVc4c3JGL0hLblpDVVFsRTZta2pySk5MeVZaY25jK2lDVllvYTF1c1lLYTllWHYzaTY1WGVYT3h1cHhSRktta0tJdG9OZC9iaXBkcDNLNzNKVi8wOUFlenV6QUNucU5MR05uQjFFbVlnVDlJSGVQbjlEVzB1ZWlwN2I1VnhxYlU2eDc2ZUdkaTVCUkV1R0R3UlhyVDBtQisxN3ZyK2d3azd5Y2xsanVXQmpIbjFzZGRNMG0wMnF5QXk3VWFtNGRhTHgrM0ZxcytsT25rZTlvZTQyYWlWNkZPQnhqanZucUx6N2tQQ3d0S0FyRUlud01WNnRkNXVWbjBLWjNQVkI5Z3ZQRGxDbnNaSXZDU0hjTkRvWUV6RnhqcnVkL3VoQUJTQ0JqQ0JKUVlGbUVXWmF5NFNwTnRjODNTL0wzbGVyVTd5S0l5S3YzaUVQWk5LMHBQZTJqTm1DMzdHYm9Jbkpva0hQK2pvWWo0Sk5wMElpTmZYV1l3bXo1L1dySEFXTnFpUml5d0wzWUpTTlFyT0V1WXNXSWR3VTExQTFWdkFvRFVQb3N4YVhhYUdZaURJNGtNNmFUa1lER1lCQ1JGa3RqWWNZVzJxTUxDU0daRXdITTVCbUIwVStrb1dJN201NjJ3eDVsaFpxTllrVmtYWnpWU2FFeUpKellRUmdieldHSlRNbWFNY3lJbklJVVRWUFRRM1lERVNVT3RXY1lwZUMxQldNVEFBR0dzd0NFR0Rtcmt5ck5qeVNUWTlpeXp4NkNaMTFlMEdVWEp6T1dQVGt3UmxxNEZEOVQ3V0dzYjl4LzJ2LyticnE3Ky9QM1NwV09jKzVVN0k3MFR5Wi8zNjh2NVR1VmdmUHRPMWFJc1hxVTRhR1Fad1lGUWxWVlRBQXE5b0xMdlBONS9ldnI3czVCSTJHR3VnRm1oaTUyWHpPVDlDMFJKeFcxUTY0QTNGajlYUHZ4M1lTbHhZRWFEemVObFp4Q3VDVFVnQkpadU1OWWpWRU1QbXpkdDFIZjlsdDYrNTF2Mjc2NTE5M2FzNDl4cVFTNXdiUy9Lb0IxWGMyKzNnS2tTZ0J1WlJEYWZzbCtmYndHZXpJeEFSMWVaa0k0TUtNUkNuS1UvN3dYYVdjelZEWWc1Ulp2MktNakhjd1lUUnFrN2h0VWkzU21rWUJLMTE0NDhZUnFDZkJMZWZTYXI1Q1l5UVRxM3FSNzFoUG9PUTRobE85QVAyeDl5VkJxRUFnS2J3OWUxNHh5RlBxYjB2cVdncTlvVUYzYUpXSENCVmgvazRqa1ZFcGJha3RHWkdnTU9aNStDWlZtZkozRmxyYy9KSENjc3RhcFdFNXV4MkNKYUNLR3NBaklpRkpRaWpWQ2NKaEZVZDF5OWx0L09RRWxuTnk2bWt5NjZ3aWk0WEVpV1BJV1R6b0RtS2U1U2NUWnpGeHVxd0lxNFR6Q1dTSVlpWkNVL0ZsWXB4UDcvZzBvZ2Y3clVHZ2NDWndTMXRsTVc5c0FPc2JrMzRDWURjd0cwYkY3QllpR1loU21UMzZzZGhMSmpaU21GZTMweXlraEFQdzRmdlZ2R3YzbDZzLy83QTd0VjltcnBBcUt0SWQvSmkrOS84Nys5S1BkaGxWYmlMa01QSUF5RWFsTVc4aUFwRUVheU9nWlUyOWZmZmJWKy92ZnlGTU9kcVdVaUNlSzd4ZEUveGVmSFczR2NzMnN5TzdjVHFJUHJWZDk5T0ltZms0TGFBZFRsOUFSUzZMZ2I0VklvNW1Xck8yNWVyN1ZlL2VCUEh3OFhuZHg4UFhrQWZ5KzNidDErOWpCcTRWdk9XSWl3SXM5YmVqc3h3STRLN3pUSjdNeWNSeG5FSC90SU9lQ3hSNS9ONUFNMnBQTXlvbGUvdjk5TjRQMkVFc1dndlRCeVVnTkNTazl5ODF1THVKR3hzRjVjYldtL2lPQnp1ekpaRUpaS3pydlR6WGJQVHVvWVEreUpqUFZ0d2p5bVV6elRtem51SlQ1cGZZRHpZZ1JmOGh3dkJ2ZUtyRjNwM1U5UGJIYW43a1dldjBZamhESXFvQ0ZvTGhKaUwyYTVNSml5U1ExQ3hhbVcyWER1emcrZEVsbU5VT0pFc3liam5EYlpXNjR0UTAvdTNsRWRoRldGU2RYRVlOTVFvY0Jiam9HVFJ5dFIxUGQwWDcvdXVaQmNJaVVpc0lGVG9hcjRoZ25qSnJwWVZKcEhJQ3JQNFdLaXlJSnN3bDRGNk5UZVl1OVpqcTBESW5XQUVxKzRrNmxtVU5JeUVnc1NzeklwYUxaV3FNVkJ0OVlPM1hZN2R5ZDBFR3MzTlNKVVN6TnZJYVE1YXRJcHFvSXY3eWtsVCt0Tjk5YnZ5NnRYLzhMUDRuKzlWTW5rZFF3QTIwOVNsK21GODlWLy84eitONllVTVRncHhaOUZTSk1aQ1RLUm1MZXlMZGFxNUpuWW5UalMrdSs4L2I2KzNxenJWYWtpZGtQdlo2dVVITGMxbTQ1VFpjQ1pvMUtMNitsZi81MzNrK2xneHQ3UWtPNVlZVXRJN21CdUlzN051WHJ6OTJldkxWOWNkU3RYN2w5OTh2N095S2ovYy9QN1ZMMy8ybDlHc29GdVhGZ0VxeTVGMkVmUUVhek1TbTNjdklZQll3K01kbUo4dG9jOXUrSzVCVVNtbzExeU0zdTlHc3NHVEVMTkdGVENKRU1PSnhIS3BZalhYREdPVlVvYWU0MlNybExxKzVHenR3UGlNVVBrUnpSSVBRMlNXeWNsRFYvRWp1Nk04YWlXZTdjRFBuSm5QdTlJbkVUZ1RVV3k5SS9mWFZ6TDhEaTlHWWJqeElud2lweG1KNDA3YWRCaHdxOFhBN0pXc0tzT3JzNThkbGVZNFlwcVRJQVhFRUp5eFArZndUdmwvQ1h1VEpsdVNKRHRQajZxWnU5OHA0ZzJaTDZlcXJPNHVkRGVhbUlUVGhnTUlvUkFDaUhERkJYOEJmeVoycEpEWVlZbVdiblFYdXFZYzN4RFR2ZGZkekZRUEYrWTM0cjJzekVKSUxqTXpia1M0dWVsd3puY0FCTFNYdkt1Z2V2VTRZVVBDNE5HcGppRmpEaEhRWWt6bCsvSHdiRFBQQlNuRUdDb0JPTkFpUEhZUjB1RGhaS21zU3dFRkN5SmFtTFg1Tk1EZ3JlSEtSaFlLQjNhd29RVU5CQnhzcm1CaVV4S0dkbVpDZ3FyVWxteEllWkFJTVlSRHNlYXZ4RnBDUjArQkFRV2xKSW5hUW4xVlcxNkNXYjFJUUhVY2gyU3FlQmJMYmp5K3VaLytMTy8vdzdlTlNkak9LaWpEUm81bnlPN2xpeS8rL3J1MzJIaWxDcDNaTkpDR0lvaG0wckZoTUR0cFVoVjYzZXd5bzUzK2JqcGNYMTBkcGxvS1BaNU1kTHFXYzVmOUVJSWd3L1ZpNEl6Vk9KcGYvZXl1cVQ3NjN0Y3ZoMEJOc2NuREFHL0xQU0RlV2lCdzljVm5MM2N2Y3VhRHErMjN1KzNoKzV2ajNLSjZLMjhmbnIrNjNnWWl1bmYwL1hQNGVERDZ1eVBXY2IxNjh3Yjdsd0k4OVgwLy9YVng4a1JiU2hQbzRQUE4yM2MzdDNmM2kwSnNISExPcHQwNkplR3gxTEtjVHFkekxVdXBMYUxVVWgwbW0xSWRCckZlbS9BeC9lTVBZTFVYN2U4UFRtalBuN3lFRFYrYzB1OTkwQlVKOFlpWS83QjVKajRFOFh4d2t0Zi9ISGlpK1pzSW9PQTVEM0YvczJoT0NraDQxb3Rub2E5SFhDVEk1Z3FoMTFJcHE2UEs0SE1KMkdQVU9obnNCeGg5Q25WeHNGMStBMXhkWFZpSGtXYUdOVjFaa1ZQcUEwazZVbEpNS1NVelJjNTlDajJPbzBZQTIvNkNvUkVLcWdiRVE2V01CQ0tDTmJ5UHQ0T3FFY3B3TDh0U2toa2lLRFptRHpQWmNKMXJSbzhucDhHcENGQ1ZJY29XNGpXWWM4elZERGFNS0VzWW5Rb3ZGVm05UlVTU0lFd2NnOEphbFhrWWw0ZlE1aTRBV3pXdXZGNEdxZE9reStHampKeTk0Y1ZXVW4wM2ZmNzVkamsyRVZWcG9ROXB3K001SHp5ZS9lSlR1WjhuQ013QUpaR0hiRTBrdkZ1QUlwQ0dscm9KSldrUWxxeVZ1N2UzNXdpeGFVQmZKU2dVU0d1Y2xWOXdsUkhCY08rNUY5SDFobEFGVTd5NVliNUVENnlqVllocUhxZnRac3J3Y2o2ZmEzaWpwdUhWWjMvNjUvLzRIMzE2bUN4NmtNYXcyYjM4K05rMUpKQ2tIcisrS1RwWVBmYzE0MU5JUUljVzk4L0FjQ2M5M0NOYWF3RkVTeitjOXY2QjRmazl3SWFJeUVOcmpteUo3ZmoyOXV5OFRtbW5jd3plczJ2aDBjdWxTbzhhTFh4ZGlHaEZHbmE1dlYyV3hhL1ZuNmNRRDZBOTFpMlVIMFAzNG4xUzBhUHc3UU5YTVg0TXUvZEhmQTRpUHhJTXp2ZEUzUmRFRUVRRTRhSVc4dnp1NjV1NmtXd2laSU5NbEdnTWptUW9oWFUwMXRacnFNNnRNNGlvTm1HdFRTVkhlS3poV3J4d0FFVkUreHZwQ2F2WHBYNjh2STRpVkZTVXVWdVlNRW5mTWxpam1LcnNnekNEd05RWFVnN0J6ZFg1K08yMTZrQWd6ZHIvTGpGbzFlekZBUTBTTlpKcFNPUVNTVndTd1RvMzE3N01nYjZPMFYzRUk1b3B0WTJOa0dpcUtUUzZsVm5RSVpzV2RJSjFYb1RRQ0dsVkxKQ2tldUVUeHRlaEtocGlDbWtzRHEweDZBSkxGaEt5eWk0UlZFV3lteGdTSk9XNjgvSmdWKzNWbTVzdlB2MzAzLzNIazBDY3dKVi9QMjYzWTF1R3Q3ZWYvdHRmL04vbjFtdWVnemRUaTlrVWRIYVhsRkxUV012aVF6THpLb3BXZHNJNG5iL1d6MTU5dXRXZ05RRzZucUdINS9yN3lqZTZyeW0wMURYenl1NFBYNzc0bFc3OWZkTXJBRmdheG1td1dNN25Fb0I2cytucWF2dnhsNTlOT3JBRUpVLzBsazJldjhMOTIyLy80VC9mUlYwaXZmMzZkMy82czRQMTJqS2VjcTlqTmF4RWh5Q1E3ajFXQzNWSk5QdWYxbFdvb2IveVY3eVJYbVQzRjJqV0ZMb3NMM2Jmak8vZWNVeHB1UC9tbTZvaGcxaE9hZEkyU0pPY3dSckx3eHpsdkN6THVaWmdqV0F3QWxFWFBYejA4cU02THg3anRkc2dyZXJRMUFRQ2pWWHFkYm1KNDlFNVNESVkxbisxTkZ4WTZvL3VuRDVzV1BmWTF2YzZINnlJSDFIWEs5MUV0Zk9EdFkvblNRWVRMazJ3bWdyWitkVlFxQ1VWeGR2NzE5L2ZoU0o5aERyeFFaY0dNV2xGUTlZUU1RR2tEK3g4T1MvTUtTUlpoTlFXVUVWNC85TzQ5NGxuaEtTVWRHVVFXME0zVVllc1B3QkZzd2xITXhXcy90U1VVaDZtd1V4MW1qSnNNOXBvS2FubHRNL3J5dHZNaHUwNDNEUkoyWlJaV2tQTzZOSFp0aFB4RmlRcmJWQjNDVUdyQWRaYVMyc1JWQ1ZNbWgvUGxrSTNoS2xBUXFVWDZ3NkFUWEtZUnZQd1FWcTFiUzZwbk9jUXV1Z2c4NUZqVWVrTDFxaUZCb3F4Nm9pNUhiSkRXMDNYYWZaa211UWNrNSt3Qm9lanhUVEZNRlZlSFViY3hTZmpTZllicVVNZDI1dDQ5V0x6OVZLNm9YTlJQWTh2cnB5YjdWeXZ2cnlPVzkrTThGUnRsNHRzOWlHRE1lL1I5MTlMZUtoNktkYm5TN2xTMUZUaXplMDloNjFXU1JtcXl0REUyb2hlSHdZalBKeHFBb1ZBMDZVUGE1YVN2M3ZJTFdXVEVKZ2FhazM3dkwrKzJxVjYrbjV1RVVHNXMrbncyVi84azcvODV4OU55VWgwTXhZTUlVbDhmSG45OGJXZHowMDQxN2ovN2o1R1JVam1vc0ZvbGJaRVJJUzdlOUFqVU4zZG0vdDVJN01sSlB1WFR6WHlVd0l2OEZpVjZub2ZsNW8zZWI1ZGZuOUdUcGJTYjk4dGtKQ2NoeUVob0JZZVVaZXpTbHRhVzg2dDF1WVJVU0o2Z0EvU2RuZjliS2NlUHM4dEJrMDVhMTA2QytSaXdnZWVkREFmaktld1JxdzhvdGhsWmJIckR3VGMrbC9RWStralVnY2ZETUQxVVNoeTRTU3V2ZlQ2TVo3dkQ0Y3BqdmVEZXl1TERGUUZSUzMzVlZHdmIwbEpoaWlsTkppRWdMRkV1SXRxRjJCNVlCMEJLZ1c2TGh1RmpMakVFajlSNlMwcFlHYkorbGJRVEUyVG1xbWFKU0V0R3piSkxLZWNlaHpsTUFKc2hNaTBuWkoyZHlQcHJWbGZZa1hXVHRBWGdVUkk2bThMUmZGV1BTaWFFU0ZDaDVtRXB2VnQyQmZQNGk3YXh5ZFFsUWdLaHpFQnNNb0kwWjd3Mnh4V1JJS2djOGkrVkxFUWp6eEpsV2ZEUXJqYmJteE53ZElLaGphdmFUckFHQkNPRXl5cmpTbVBhY0VtdVppUHlVc01MODd2VHJwdkxUZmZYOHREbGUyeFpTWDFzLzJMRi9WMWUrWkQ4c2dEcWd1ZGlJaStua09yVHN0NVVETUFrbFVCVmQzaC9PNjJUTmQ3UC9rd1NWMWQvUkdYV1czSHYvWi9WSEY1VUZURjR1M3J1VHVWVkVFZE4vdnI2K2NiYStmNzI5dUJVV3ZBWHZ6OEwvL3lsMTkrOGh5UHU3S1ZuZEZWVWRqa2FidEx5MmtNV2Q2OUsvR2crNUdPRkU1UmFjdDZ3L1NTT3RiOUxVVjBJcWVzUFc3K2ozcjdMbUNzc2ZtMm5DRU0zWS8zdjdsZDFvd0ExVlpEN1ZSTENGdmJSRG03ZU9HYVY5YlcvNWxSMCs1dzJFb1N2eitXWlVyak5xT1dKS1Jlc29VRVQxallQOXdiWFZnYkJDRXE3eEVVT3JTTThrZks1Zzk0S3UrUmR2QTArOFpQWUpJNlgwTjMwMzQ3dlgyNFQzcGNwZ2h2b2pCTGExajhwZnMyZWxsS2N3MUFnbEcxUjlIMXAxc1laRHlXeUt1RUpTUldMYmsvVmRJUVV4TXhtSFU1M2txbnRHeHJjS2hxUnRvR1kxVU1LU0F5c3dZMTZZN2gza1JNVTZsdG5iS0lzNnFvQnBDckUySFcxcFR4Y1BjUWhiZzRUVTNGVk5JcUpmR2dkMzV0MS9WcWVGcDcrckk5K0xuSXdQQVdaaHF0S0hSNThHUkJDZXBnOCtLYnFZVm9zaVk2bXZ1WVhhT0poWHNUVDRSaFhvTnBGWnBsMExxMU0vTzJ2ZjdJVFkxUlFzMUtHYi80MStPL3Z6OHp6bU91OTJIdGVNSVVDN1Z1ZDF2ODV1WTgxd1BPdUpaV3NnVUdxWnVWdkpJY0lXcWFIbFU5cElwQ0ZINWJqL3RQeHBjeDN5RzVPeWl0UFlvUys4c0t1b0x4ZExWL01wWDBzMS8rdzdjYlVxQkEyUDdaRkM2K3pMVzFVaE1qaHYyTHd4ZWZmYkVUR0dvWENUMitucE1RRElvT0h6Ly8rVGYvOE8zYmMzVS9MMit2di8vNTgya2FCOUJWamM0UFJkcTgzREZlVzRSTHRuOTFVWno4OEFiK1FCZ040YjRzMi9qdDcvNjJqWnRKSDI0Z1pneEpyUzduODd3c053K25lVmxLWGM3bjJzZUtUMndvTXBnanh1ZWZmSFNvQXJaU203a21GYVoxZllNbmkrSjdicERIQ2ZYVFdFblgwN0xPSFBCRHJvTDl4QUYrRWw3S296RVNUNnVEeDV2NUEvYllSYmtKU0pSQ0hjYnQzUTJIVTgxTlJTQm1OdUNwVXU5WGFGbm00bUptS3FRMGlSQW9ZSmFBRlNNTndOaHpQMFY3Y0hiL21SbVBtUjlRVlRWTnlYSk9PWFVwcUttbElhYzhEREJMT2VjODJob2RrN3JDTXlVSlNZclZRSzhwWnhQUjFIdU5WVmVxcXRwQ0lLSzFWL1hlMWtSNUtqM2pNSWhaQUFBZ0FFbEVRVlJVTlZKU1FOWFViTVZ4ZGZHcUtTUTZ6aUFJOWUwR3pjbVI4NmtOdTYza3BLekhoMDVaWXFSUjV6UEgwZWlTdEp6d1hHNDhLeTE3cWVFVndqUkZ0V1V0WW9yc3R3b3ByM1lTMDFZanRYellnQnhLemFQVzVkVkh3L2R2YllvWXlrUGF4ZTAzK1FwdEd1YWJVM3Ayd01QckpCS1VXZ3BZTU9WdWoxUG9RQThSWVpjK3JraFFnWlMwMmFaNjg5MU5IVGNJak9HdHVwY2lIaEU5NUZuN1g2S1hMcGNBUHFaRm52bDM1OHNPdEcwL2VyVnQ5dzgzTjNlenUrUlpocXZQL3RFLys2ZC85dk9QSmdVRDFsOVBsOFpPZXo2dE50cTB2Mzc1QlRBM3M1aVhOOS9kK0pCRklSNldVanp0cFMvd1Y1SWlnWVlSOGhodTl0TmYvVXBFdEdTbnYvdWIrT1cvK0t2MjY2OVArd1Y5YW5DdVM2T1FjNUNLdnE3WFIvY3FxWlRWeHo3dFAvMzhXYm92b2VSeExpOC90Mm04M24zRGlMVmUvVkVDQlI4dDYrRDdHaXo5d2ZpSy93VWlBSDVpc2Z4b2k4UUhkelA0UkNVaEtEaWNUd1doZVlNbFcyWlJBWEk4OVJvWFRYeUVPelYzNEg2STVqVit6R0M4c01hZXJHb1h6cGRxNTFGQ0RJOXlQQ0ZGVFMybHJzS01vRENsbEZWVmhRWVJzeFRtc1RxYUdSVFZsRnVFajZ2V3VrbC83Q29ob3FKRGZ4WnhqdTVCbnBQU25STFI1WTVZZVhuWkZBVEUrcVhSVmEvYVRWTUMwQWtLVk1PTFFMMGdta09BRVd5Q09HbUtDQ1dOTlN4WmhBZWt1VWhsRllvTnJDV0NLb0JFYlhaaEcvc3dhSkhkOXJDZnorTTBKdUY4RzZacFEycm13cHRQLzRmei8zdVhobk9XelhoYnIzLzU4TzJMYmNualBHcmQvWG44SnptMmZhcHRtQVlKdFNSOS82UDA2QTkvazU3ZkZXdDF2T0dESmN2MnpUZS8vcE12cmlqTld4TUdQU0RVUHZ4WDFjNmJ1UmhOS09MTm83MzRzK1hyZGFyYUtHVjVmZE5rZHFQYnNIMzJ5YXVQWDMzeWJNazFaSXdXSGQwcHNUNHByVUZGeFFBdzhrY3ZONytkZm45ZlljdkQ3ZjI4ZkxMZjdnYXZ6aFZES2hReSttQktHYUJNY0cwbGIrMWZ2VzlmL0pFYitKSlJQcDBhZi8vM0gvM3IvK3ZmL0hkL2x1Zmp1VWU2Ump1ZlRvdEhMYXZFVnVBQnFTMVdvbXBJOUsrMitmd3YvdUxUbmM2MWlNSDl4dE00WkV1TDFFWjVjbkU4YWEvZnU0RXZDeU9zbW1ub0greHhMNS8vcDFvQys0T0E4S2ZJOENkY3dwTVo0dEw3WEZ4aDRVdzVXVDZYT1pDa0pxaHFNalYrbUZzTXVoT1dJTkNlR2VockNocWp0c2VvNlI0dHJHQzNxMFRYVVVNa29VZkVtUm9VU1UzTnpKS1pYa1pxeWRZSU40TWdaNGlJcWRiMURlWXE0ZlM2WGJ1UjR1NFJFYTByS1ZhR0g3QzBVSVI3RFcrdEQwaDRnV1dLbWVpUW9VbVIrbjFoM2wzSG9lOUo1Z2cxV0lScW5aY1FIUWIxSkJIQ1VqUW5CaU95ZUFtRm40c0RkRW5qTXB0UkJ3a1BnYmtFYkRuMzBrUElaS25jNjh1WE9pTHlNRjFKSzZXNUNNWGlQS2ZkYVhqK3dyKzV4elppSjk5Yy81di83WnR2cnJiSHV1Y094N3A5OXV5dXRLUTFVaFlYUmF1aUtoNGlYcG9EZWhFcWd0M2ZncTB2MVlYQjVUeWZIamdzTGJ5dldqdU1VWHBtWDIvdWVCbHI5Y1R5R1AzbTdhVjBVbi80L3MwQ0NjdXE0L1V2Ly95Zi9aTmZ2SmdrUUpwRnVhREVMNlJnaGlnSUl6ckRaSGoyNm5tcTFSczA3dC9jSHozdmhtUnM2NmpuOFZHTjFWR09xRzErT3cvMnYvekVBZVlQTkV5MnRKdnZQdjAvL3M4dk04Zm40L2w0amhiQytYUnN6ZDJEYTFZWHBJV3l0b3RyWFlJQ1ViV3JMLy9xSDMrNno0WW9vYUpXNnR4c01CbkZBd3I1WXdkWW5xWnN1dnFkOFNNM2F4ODEvRlFKRGZuQXNQaDBnQzlyckVlVEJDOC8vOFhtQkJHY21xWnhtTFpwdXh3TlZVWFYxRlNDNkhQRmxaWEQ4T2JSMlFaUkpZVzNXTjhIcmJnZ0xoU1hOZjV4dmJ5aDRUUUQxTlJFeFRTcDB0UXVUdkNNMVJhZStrYlpCRWtjQ1JFa2lkQ3VRUWpyYy9HQkYxY1dlMThCaVJDZ2hhOTdQaGVFcy9iUkdnaFZWWUdhQmd4aVk2S1k5V204bWxWTFkwWjRXdmZYc1ZJN1RVbW9GMWV6UENZeGVDTnJRelp4U2tCWnE3YzZ1NEROdWJmRk01c2lDSEdpZ1dxbGdJQUtHVGxRNi82VDUyZXRsU0dqdTA2YnlkRE1hdFVoVDVUbnovUjB0cUUyMUZmL1l2ck5jU3RMeXFvc2tjWkRHdXJzWnVUQ0lVZU5sRXg2UGthcGZzbmdoRWpJYWxLUVpGcVhlUnAzZVBQVlhmTkc4VlhaSVgxaFo2cy9yYnNZUE1JOUFtV1FlZWQvLzNxTlR6VmZqcWNGUTJVZXpGNTg5c3ZQZi9aODhOb2M0clVzeFJpWEtOaExvTHVDMHNXM1NWRjNINzE2ZFdVVXNKM3U3Mi9PdFZVT0ZoZnBUOS9GUEVrMmExdnE2VGF1MDA5WHp1OVBjWWkzMi96OStELytyOWZxZ3F2bkx6NitEUXRwNWI0QzBtajVERWdBYUMxVUdPb21LaGFvYTh2NjgxLzg4dk9SMkpTVExWVXRIZTYvbXROMHJjOVFtZ3ZWM3dmYzRBOVFPeDlLcGxlS05YOXdnUDhvMFlPWFJUTS96RUxpZTkrQ0luK0FQRnYvalFNWkpSaS9lSFovSSs2REV3QkRxeWw1aVJBRU9sL0NLVVBBSTBRaUl0YmdoZFVzYzRFQ2N2WExSTy9BZTBSZG43aFRhU3BPMGNjSUtJVWowUEduNURveEMwaHpENHA0WHQ4Z1VNMUN5VVZDWU95QjI2SU5FbzhSdXF0ZitKTGUzdU5hMWx4VXFHZ0FmVXRzb3RxOXBLSnB5S2pSMWhLaXh4RkxTQklKRXBhemh0aVlRaVRpb2phblNFMEdMOTI3MVZwZ0N0ZFVtODdhbFNaUXFxcGFyS2VrdWRxMG05S0FvSjkxNTdwL2ZtVzE1Q1JwTThaOGRYKy8vZlByL2YvejI1L0wzZWJGN2I4N2MxT1d3NjRkR2c1b1ovN1Q3LzdtTi9Vd3pLM1pkcXJOVXQvQ2FYYTJpR3hUSDVkRzY5ZXFMSG5RaGpSRzJGYmZmZlg2cjRaUkkxenlPcjNpZXYzRkNoZU56anhqYnFZbjVITkVRSlJBYWRDc29hTHFHUGVaRHkyWWg5Tm90VmxPTG43QjhvTkNzUkNRRXR0U2tTenE5bndjdm56NThoOSsvZnBHRE9mNTl1YjE4OCsrMktrLzhidFdHVk4veW9NQVpOZzkzc0RXY1llZG5zZkxDMGZFUTZDbXBydTcxeC8vdDc4WWxVbmJ0MTg5bk5MTmFldDNtMk9qc2tSQ2RVaWpOaWliQTFMRmZMSERacGt0WTdyKzlCZGZiaUtFN2VzM2VhcmM2QlZlM3grdU01a0dtWnV1NDNoalY2THBaWU9iMXZnU3d4TTJXa1NvNnl4RzhZUVpWRmhQZ3hjby8wQVN5cFVlRlVIQm95dmdzbmU5QUlJdnBPRExhZGFMMW10QTZCQVArNnY4NXR1MFhZWnNhS0dtS2hRa0MxRkZ0RnBhY3c4UjVFRXA0SzJrckJTUUxXQ3JPWWxjV3lHb1hyWVUzcEF0V2plQldES2htTkV0RGNuTXpBVVJUdVMxYVc0cFI2VlpKU2xJeWFHSUNLalhnQktqaEVNaE5TUU5xY3ZmYWNPd1phTnllYWdoM3FJVE1GSXlhRElWVVlOUVU3S3NjTmVVdFlrTmsza1prMHBJSDRHckpiVVdLWXZtQklVRU1peHROb05CTmVZbENCTkNRVW1sK0h4Zk5IUklERkVVMHFreVVLUldTZWFpcmE1VXVBaEhDcjk2TGplZFE1RzJvVGtCZVRzSURZMzUvSHk2cmMrdU4xKzNscDA0RmtTMXpXQW4xSnQ1ME5QOStCZXZiays3elR5a2NIRE9LV3Q0TUxtSGFNcEV6aVowdjRSQ2cyQzAyU0hPblBGbXlidk5RSmEwemFDbXZBWmhYM2krQ1FSaHB1YzBXWHIzbjcreHJCR1dISEFYcytyTjA4YU84Zld2L3VIYk45Lzg3dlhyMS9mSDQ4M043ZDNkM2QzRDhYUTZuWllsUk9mbHZJU0IzcEE0bHo2WWtzMG42Y0NIV1lkVUg4N2w5bTM2NUR4WVd5QjBVSUloaUlBd2JjNTMzRVo1L3ZQMElSSWEwTkRvcUJqeVBXUUJjb3Y5UjN1RVpLbmYzVzAvKytJMi9iWTF4TzVVbllib1FiZDBpVUFFY0MySVdVYlRiUnFzR1FhV0d1ZlQvUEI2U1JyYXd2WlMvdGEvUEtTZGxNbWxpa0EveUlQN2tRQTAvdVR0ZWhGeDhZOUE3ckNtOXZZZWFFV1lYS2p4M3ZmUlhaZ3NZTHU0ZnRZTE1HYkRVdkpIM3g5L1g4Ym1qTkFtNGkyUmNEajZPMXJFeUhBUk1CRGUvVEhkbGhmQnJoQzNWa1BURUkydEFwT1pHdDJSTlVSeUxxdTAyanBCZzV1VWJmVy9kR0RzMnFNUEpsQ3lYYlQzMnJmSjBJNjFZQVpWS05HQ0RvVGtZQWhMeXkxWXBMV0JUNmhDOUNSWFVxR3RoMzRnWjNITjJpWGNhcm1ubVVLMUo2R0laaGhzcFJDdHJ6d0l3N1ZGdjV2N056aHFzbUZva1ZNSEtwVFZTbDREM2RyUWVoeVNNVWpDZEV4TW11eCtsMUtPYUdFaVpMaDJDWTU0eWZ2bC9QeGZQdnlIWHgrdTVyaTZkNFNkTlFzWVZUZWI3VksvMUwrK3NVRTFUa3daWGkzWjJxK3J5aW8wNjhCMUFaWE80T1B5QW1POE8yMm4zZFdwM05sdUVOZTFyM1FCQktZMVdvaFM4bldlY1gzUFNhTlZlblp2b1paTlhyN0FzZTJ1WG12eSt2cmg5SWs3ekZSQWdlYXhReEZTTmlIU09KaUdwREVGa25xb3NaUUQ2M2owMHpIWTVuRjcrKzNWMVpWbGphWk5ZQkpCSkdFaDkvUHBnYnV0Zk1qZ1FqL0I1T09FOUxKQURaM2IxYXR0bERTMGIzNXpmLzNxMVZlMzN4dzlOWk1TS3F3SjRYUVJvMWlpRFIrUHZGZU9neWF4ZGhadkQyL21kdnZkVGRXcEFScGo1T2Z2dmdsKy9uSWJTOVN5TW1vL3dFNSthQ244RUtHakgwNnBWd0RnQlNqeVFicmtENkQxS3VzQmZxUVA4c0lkd1JOaEp6MktyUWxSWlIzUWhoM2t0MTk5eittaERmM0FleE1WRnlHeXhJVk9CUkZvc0VYekNBdFhoYmpSUmNYZHNyRzRVS0RpbFpEQnNvalE4OWdXVC9ueXhrenJGQm5vUEVsY2pONTBob3JTWFdCcytSSzZpc2Y4WUFxZ284SXBJV3d1SWNIY2tJVGVHcnE3S3Zma0txbzhqVDRFWmdGUk1kV2NFWnJocENna0tRUVNqa2dRcXFvb0w3TC9FSUYyNzRVRUN0aFY0ZGFqUndvYW1tWlQ2d0lrNzR4ejZYMjM0R0lIUmkrY1lKc3BsTVE4aldPZWw2TnFFS29TdmNYZzFEQ1YyOTNILzd1ZFoxYy9oU05xYXlneURhZTdPcllYdVAvazhLdmZUS0dwelQ0NVl4aFNlQkFwQU5HMW9DT0VMc0xzWGRzY29JUUFWbWNabnlGTi9XRlVyRUc1dWo0Z1E2T3FNcGJCVG5uZ3c0MGFiTFBmL0xKVXlXUFM1eSt2bHRmSDhmQVZWTXV0bDcrWks2Wk54aW1OZzBZTEljUlN0cVZ6TGl6SnNKc3NEUkpNU1ZyajlPcXczSDE5SEpmRkpkMTgrL0xqVDU5dkV6MUVUQk9Fa3F6TkRZUGRNWTlYU0I4bWFvcGVzbURlaXdEdVQvcml1MjNNd1BMMk45K1BML2ZQN3JkV2FJdUxScUNyWXFGRFNwUXh5ekFldHVLdUcxTUNKNi8rTnVheDNMdzdwdWRiZWtKczc4dm1xdDM5YlV1Yk5Jb3MvVEdLSDRWaEVvL2JuQis5aER2VGRzMHJXbDg1K21NODViNk1CeUJVZG9LWXJxSGN0a0l1WWozQmFTVU5Kb0lTSVhXVTJPNisrN3V2dnIwZkliQVdBdEFWai9rY0VSVENoUkdPaTNlUllFaFNpZjdKR1JZTU5jUzhIcG9pWm9RT00zb2FpMTVjSjZMdUZCVFIzdXoycDA3Ulo1Q3NsSlEwWE1LcElhTFJHZFE5TGttdEJVa29kblZ4SWNOclF4S0pPV1Y0djZndk1iQVgzd2RGMEJmR3R1cEtBU1NTN0lNY0JoeXdQbTNxaTJ3KytqQlZMVm52djRBSXRwN0pRS3R6QzgxREZYcGJFNzhrZ2hJd05mUXBiNGYrcVVBbDV4eG1kTXREaHBmek1KRElTWnBDUWlNMjV6YnRvbnovOGYvTS8rLyttYnpkU3ZPR2xqYVJKdDY4UzgvejZjMFhuOGp3M1NKNUk2M1VORUFKMUJEME9VQ0lZSzFreUo3R2F0RFZxYWVGd2VEODV1WG1XbXBQZEJPSU1EUG9RaG9BMVJEZERFemkyMStPbSszdSt0bitvMlhHT0NyM2JZNFh6OFgrZTIrdGxYTzV1M3Q3UDgvMzUxMHR2SVF6bUVGT09TTWthNUpoUDZVOEpvRWxSQUIydU5wRlJKcEYvT1J2WHQ5ODhtdy9KVThXeEhhNjB0MEd4VFhLM1BMQWx2UzlHN2hiQ2pybzBQRGh2VVZKRStaejV2RjMzL0p3TmJIbzFseVdJb00wVVhNR2g4UFY1ano0bEQxdFZDV1B3MFpkTGFyTi91WjRvOHZaRFJRUDBYb0t6cmEvZnpQdU51T1l1QVJESGlmTStHRlNNSDRrNy9jSExNMUxXdURsTHBhZnpweTRCR0t1MVNid1FlbmRwMmgxTldVdnZjZEdxbm5YL3ROZi93b05jOUFDRE9oYTJ0bXFXQXpwVmVZbHhsUXYrSFpiSTNORnU4NHdoWmVjekp3SUw4eDVTQlFQYU16VDQ0cW1JK0JNSkVCaFVvQlVCVlJFazBhSVpYaEVoSVRHR3NuWmUvc1E0TlREaVhWQzE2SXZwWUZTYTBYcXM0WUxGZW1pQU84Nk1VK1FucWZSZzRqREdDR0NqbVlBSWpTWnNycW8rYU5SV1NIV0JXTmlwSWc3U1ZlTm9EbGRWTHNCUy9GNDRxdC9xQmRxblZRVVlPaTR0VExtSkJHd2NVeDBJdFNraVVxYlJYeDRXZWF2WC83WDMvMUhEbFBBYXhGUEg1bllwcDQ4dlQxYi9mWDgrVExmdFFOODFrMktXWE11akk3WWdSSUFVMWVqckN6WnA1TFRMY09Yczh6WEwzWkR5SHNoSUozcDNZS0FRamVEN3VVKy9udy9qRGtObS9GbVdiaGt4cmVuSTZmSkdPRTZYSCtjcmg5dTd1L2ZmWGRqTjkvZHRqUmxKU3hKYzFPSlJyZUhTQStEcG1HRTlqeU5ORXliZk4zZWVYT1IybEJQYjY2ZnZ6aHNkYUJyMms5NWY1V0NWaktiWmorL2Y0QXZTQmU5VUxrZWcraUZncVFXeXluVjExOHRWL3NCODUzdnBoTlprdERWb0tweStPU2p6ZmMzZGJLemVEdUpHeDFka29ycXk0UFZtRFpvY3lTdCtINDN6RlVZcjdmRFI3dE1ad3QyM0hOdlZ2bEQxRTJ2YkgvaUJuNHZnTFFmOUQ4c29UK0U1VndHM1l4MVAzVkJmTnY2bmRnVGtOQk1FeVE0bmFmRHIvNzlyM0prSzhXc0dnSFJhTHA2UUgzZG1URnA2cVErcUhxNHFDaUoxQVJSMVFhcFZUVkp3SEo0QzFGeGVsZ2VhNldoMWQ1cjlaS1JCUGFxRWlSVSs1UmYwQlZaR3FKR2w0aFExVFh3SEdwRkZZeHVLQTJvTGFYVWlOcWlOVGEyVUltVjlJcjNKR2hkcWRaYkNqV29nS2JRSktSRU9OUXVhOGdHeTBxMHJpTzU0Q2VFU1Zma1FQUW52YyswZzZFWmFqRW5OYWVoVmxPREtjNVZhQ0VVaGtkelVtQXFSSVJvSHBNV2xhRGt6V0dUdlZSNGtxZ3daZDNwdkd5eTNvMnYvcHY2OTZmcDNUU00wMkZqazdTdzYzMzUxY2Q3dldmYy95eko2VFNvQkVIU3BLMW1pY2Y0MWtzSjBwZVBaSmV6YWxJVkVIaHpkL1B4eDl1b3EzeE5HbFMwNXhjVHFucDNzN2pQODBkTU10ZUFSV3MwTUtoSnBUSjlDN1ZoeWVrdDdmRGlpOVA1NGY3dHU3dUhoeVdDYVRDR05FZW9oRGVQbVpyWlRUWmlsb2JOVUJxMDc5RTNTMzM0ZnYveStTK1JOS0xWVTRhbDBGUUZvWG1hMGc5S3pTY2VpQ2lFZ1l2VElKUmU2N0VjM3h5blE2SjgvOXMzQVV6N0FaVTJwSUFLRHRlSDZWaVdIVml6bHlaZXk5aWdiSm9LRmtrR0NUbktzMUdoWG1KZUpQandlNG5QZCtQMXd1YVBza2tRUHdoQnd3OHAwUEZENEFENGFNcW4vS2ljV2lBUVcrZlJmbkVMZG0yRFhFTEkwanJFc2k2M284QkNXbWxMVzc3OW02LzljQnRJRWoyZ3d5RFJ4OGlYMVhUUTBXVlRFRjBIbGhBUGlGTzg2cFNiS3B0QVF4TzlPY1RBS2ttTnBNRGcwQlZpMS9XWG8waXN2bUVxSVdVZHZvdXRIVWRQMDcwc3NDVVVvUGQ4OFNhUmJtc05ocmRPYzdDc2o3YnJSK2lEQUJCWFVXTzNhT0dTK2k2QWlqbkUxalhQT2lRd1RaUXFWSzdNbkdCbXVDamdUWk9Lck1NN2RpZWFocThrWm9lRW1DaEloZ21qMzJzaTFtOW9pVHhJbThjdzYrK2haS3hvQTVwNTFWSE54Tm5PR2RmRi91TDg3cXVXZHMvMnUyM2luTU9ISzExZWIvYmwvR0o4OStKbjQrK1BZUU9TcUtyRkJmQWMxdWxFdnBZZzdNRmxQY1pZbFVJWEl0bnBQTS96aTUxQjFFeFZUTUZXM1lFb3M2djkyazhOUlE1VWFaVXByV3RscTJsQVJPT2tFRDhHSEVpcUxhNnV2dkR6bTYvZTF2bFUrZ2lVWWdheG9Ic296NWVIS0N2U0tBM29yemNKNS94dzl6YjJoNjNxNjN4dDI5MGdOa0JGTi9zazZ3SG00MU4vZVMvRkpZTUl2WDFyM3FxM2s5ODljRFBTaDY5LysyMXhtZEpZN2swMzFrb0NOOFlsMlRBWjgxaVdscmlFZDR3WlZNTlRFajhQVGE5elJrckxmUWhyYTIvMThIeXlNVGNnOUNmZ1dGMnJ6Ui9jdjQvcHYrL0ZLRjZXNUh4S0RYcU1Vb0lvUlZkclRUeE96YnFSM2dRTWoxaUowQ0FiVzZtaGFsTFBwNkxiNDk5OXA0ZFpGcHZ5M0RSSUlBUytScDVlVnFxbGh6S3NjWlVNaUVZanRDbWpxVml6WEZ2a1ZBbE4yZUFHajdiSUVQU0FwcllLd0JxQXZsT1VZQSt0Rm9ySUFrdm9UQ3lsOXp3TU00bFYzVWczRVRyUnhHdUpsTzVhRTVYV1RBRkpscVVMZk1XZmxDc0FCRTVEQ24xVXBQWDFOV2w5eHEyK2NoY1E0VEJEQU0wUjlLNGtDMG9qVmRHYVdWZkVyYnpxdXN3WjBPb1JybEUzRkFSY3pVTUJrZFQ5RVYycG9FbnJNTlN6VDhqSlBGb1VkNjlKRWg0c1hHRFVVMnkyMGlJZGZmc25YNVhqeDg5ZmJKTXM4L0dRM1VQS243MTcrL2w4Kyt6bDNiTlB6K2Rxc1ZkaVNJejNjSFZRQnIxN3MwR29TVVNJOU5zMU9yTlJKcTgzOXpkZmZOeVhlbEFscXJlNUhLMCszQndsbllmaUkvMmNoQzNVaG0vVFlDb0txeVZQQXoyQmpCQ0t0eUJVN3lWUHU5MG5DOTkrL2YzZHViYnJXZ0dJNTdXeHl5cWtxQzRxMFVJalZqM1JRZ1BQZGJuYlhWOXZaR25OTnZ2QmhuSG5zajJNMHRKbE1yc215bmZKNFJxR0dDVEZ0TkhnTmk4eUgrZlQ0RmNiM3c2Ly9hcTgwT1ZzVnpoejFHbk05OHNKV285Mnp5eWlzcVJ0SzhYSHplRjBkdlJDejA4cU9DZCtiNThPOWF4VGxFVnNPSDQzVFBac2ZIWEx1U09Ic0I2b3h4Zkt4V0pJb1R4bUsrVStNM3FNZ2NFNmhHb1hNVlovbzJwYng2dGlaRVhLQzZyYk5rb3ptRWdJdkZwbVdkeWl1a2FUVFhaSnJEUGRQYUxMbHhBY3Zuazc1eEs1amxJb2d4V1hhSktzWmwzbXZOLzJNaVU4bDVvMHpaUVVQbzZJS0RSZElqMEFUS2ozR2RDSThNUkZzRm5tSVJ5RHhybHNVcG1SYlRnLzJIWVVweGhWVlpmdUtJQUZCZkRZS0lRdXpPR3FqdUdZcEIzVE1DN2lMU0FjcEVUejRqWEZlWTZvVE1sNmxEQTBxZm91V2dTQWZnT3RVaks0VzBaSVloM1hjVlFMaXFWVktVUldGUUhDYTdaQkFVZ0t5N0hRTkdiTlpvZ3hpWUNPVWFyVDZLUXFKTVJ0TDFYU0VJdm80aXpEaUJZVXIyRjVvSndPK1h3V1dkSVk1N1Rka3Vwbkg1UHNwN3ljMDNhWW5NTWtTK0pKcHlrMVp4SS9pOGp5N08zYlQvLzUzYzJmN1BSNFU2RDc1U0dsV2ZIOGRMdmR6OTg5WDJUelNsNmZlZDZPMlplUUpPcE9HNW9tMUZCckszbTlacW1hVFp4RTBNT0lOQnBkaXo3WCtsM1p2THlPR1VONnVKbGphYWMzVmFLR1JJd2xXaVNjckxRMDJWMnhhSUFVMzV1cUIyUXlQMHZ5TW5rRWhTeGN6bWJDNGVOUDVPSDN2L3JtTEphOTJIQldvNHNoclFrNW96ZFlDZGZ1Zk1vdUNOdUt2NzQ5Ui9XS1c0YUxEYmtpYjVMQzBxTmo0U2tXdUN0dE84VDdNZW4wYm1tVEgxRkRNNEI2U29kV3BtczdEdGdpNWFSSFRXUU5jZmRnbFl4aDR0STJCMHNvYmlrNUdDTFFpSHA2T0k4YnNqa2w1TWp5emJSTmViY3RzcEEveFpYbDZsUjZqNUMvcGw5Y1JGUnJnaGJZS0FEcW1oVGhFU2tiVy9KZ3RHTzlOZFkwYUgxUisvVzdlRk9SNGt1T0ZoYmVqRlVtZTZSdXFRbE02ZWZ6WElOc0FRa1hnV2lRRVdJT0VYck5FV1NmVHFzZ2hTQmFPR25KSldwVmxaNGJHaEZPaGJiVmVPUVg5SWUzMXFSS1l1TGNVbC9Bd3F4Wk1vUEVnQkFJNkFFMWdCR21DcGpScTdPMTdoZ0JndEZLS2EySXU0NmhSVTNERWdpZ2crMjF1NXk3MUZlNWlpaTl0OTUwQmRJd3BCb2QrWHV4WkRsRDFEVExtc2lrbWphcFZFOSswYUZxMTVNR0wyTGlBT1RSdkJIZXU4eWhMNnFFNk84T1E3K29vbEhIU1JkZmREc2NjcHVTRU1OMkgrT1VjQzRwRDhsWW42VHVTYVk4ZnY1Zi9lNkErVlJUQWtYb1ZYemNIRThxT0ZaZmJDKzM1emd0dzVoNlo0TzE2bExSMVh6bVBaQ00waElmRlg4TVFFUU5VVHpLM2JYTzRmVm1TVGkyT0c4WUhpSnlnb1FsU0F1SlVtbzlzRkZWc0VCVlUwb3FuVmwyWTJZb1M5MnVTUjJ6NXVIWjV0UFRYNWNtc1RRK2E2MFpZMW5qc1NTN0t6VmlYS3ZMS2s0WDkwTjVlenNNdTkzQnkzd3VqWVFtWmZUTjBudkY1NlBQbG85T0JnRHFNUzk1eE5HeUhBN0ROSjdQL3NwL2R5NXl2eCttREZhV1JtRXRaQTBKakhZOWp2Rnd0R0dyTG9XWk0xb0loSXpDMjhOaEw4VXBScEd4dkVzdnR0dnRzSXZXYjlRTFovZTlEQ1ZjVWpnZjU4VytEdHU0bHNleG5uT0xXTWZaS2lya3JsUmhPYytERXl6SFU2Und6eXFRa0JDS2hmdWFkdUlVaVZGZGtGUWU4RGdQaDVCeWQzZXMzcE1Id3k4ZDc2VW1ZNnNXSGwwSWMvRkZSbTJSakZBaHZRMjRHRm02ZHpDOEt5VGlnZ1dMQ0VRdFUwNWVsbUZJM1U1b2tYS3lQdU1tRkpKQ1lHaU5ibTRoYWZibTNscUFmVHdhcExmU1BLSmh1NU55SHJMVTBMUzYwQkdyYmMraUVRb2xSYnZXZVkycnNHU2FoaUU1cXpmb3l2YUN0a1lrMDhLZ00wS0JaRW9mV3VzNk9iTUlFUW1KV0xGS2dBSnRiYVliVlVSVUJ3WVViQUVncUpvMG1xdUlDMnpLMHBMTGZqODRzN1RLTkU1dE04ckpoMjNLV2R5VFhXWWZYSlQxeFovZXp6ek5raXdBVmRid2NWY2ZlR1ZWUzUwMjQrWjRPaThjRWhrZGdlclJWRWt5d3lDTVRsbU9KM0NjQnFPSml1WTBSUFA1ampYVjg4Tk0zYU5HMnM3cmZyNm12anVzNFVRZUpwSlZ6YlFaZ29wVTIxSkY2M21ic3JvSlVsRFlHQlplY243NTZzVnhEbDlPWGt1VnBPRUxoTzRlYU43aldMdVZVVWdvTkhGeEFiMHVEdDNhNmY0OGFGUlI4ZlIrak81VEhnREVWdzVBRDNxdnBiYU1za3k3M2N0dFN6SS80SlB5NjVzSExScktOcy8xZkFrTmFGWHpOQTZiM1lGWXlubHdCaVZiODNDNmtaUjZ2QzhZUWkxVXBSbDQ5OVh1bzAwYVZ4YmFJMmYzUGZNQkg0SE9qOFpENklWMWkwdUMxcXBpc0NDWiswZ3AyR3J6Y2xwNndzWmNKbFY2U1hycTZ4SFprTjRJazlSRi8xVjFnTlJtQ0hGU0VxRk5XcnUvUDRxR3MwZldyQUNDSUJTUkVzVHIyb3QwdzVoSVFKUnVhUllWRytpdVR5WU1NandZVUZHeklGVEpCRWthTEtRSXZWRENUYzExQktOZkM4NnVOdzFLekV0ekdodHRicUhTV3MvWE5oWHZXMjVrTms2ajVqd05NUmRhV3JsTmxVSUlZTTI2SGFyWFhPdXN2QTlzeEQzRTZEV3NIMTVBdG1WdW5VQWlaUzVFRVZYMFg1bDNDWWl5WTR0Vy90dXFFTzhrci81VFE4MjBVVTFxb1NnaWhBbmVYRVRDb0ZHQmplWUJjNld6MXBBb1VrOXR0dTIrY3hQNEdCNkdOdmh4czczL2RqQlJMblhxVlFYbmNmdDk3TGZRVW80K1Rwc2I2LzZNSkF5R2lKTW1FTWxxNk1UWDl3dTd2bHgwTWZWUWgwRTMyb1F3azNyQ0ltekZYZGhvRkpXSUtCS3Q2WDUzOVRzaFJWTWFOWUhDdUt0VnB5enhqQXdkQjNybk9rT2pWdGNoZjNvZHlaeTZoTURFL1piUmFxdGtxKzRlUkxnSG9MZGR4OExmV3dhOW5vYnhzTHM2ajZjSDhZYkJ1cERqRXZYM25sUDFhZmpUQzdkU3F6N1V0TjEvOURJS2x6ZXZOM3E4amV4Y1NQUHpxVFFZb1FtSXNNTWhlZG1hSnRid2NsNmFhRTdTYnk5UmxmSndmOWdKekNwcGM4bnRkMW8zVitPMm92cEt4RnI5di9pQjN4ZVBrTmxRWHQ0NXhKcm5abjEvYStITkI2SFhWdU11SlZZUFBLVFVJckFwRFJHTWZ2T3BZcWFIdzZTeWw5QkNtRVp0VzRZNFF3SUE2MXp2emxXME15dFVMc1ZZaUNpb01NU1NNeGdTb0FnNm1peDVOQ3JnbGtObU15aTBFeUxwWGI4SlRSYkIxY05nU2FKcUxCUnB0VUpVRmJKUmFNcEpSM2RScXN5MWliVHpqQnFJUWtQRGlCcmFpSlFVTW5UN0d3WnRKV0NhcGduVFhQdDJIMnNBTFZhaVFIZjNNaVNwS2hVWkZETUdQUVJJRVpZdU00ZXRVVWpuTUtWVERXUVhCd0twS3poVkh2T3BPc1l3THVhNW9FQ0ZzQlVpMUZ5ZzBaYjM3WmRoUXFqeEhGTWUxVnFya3J4UEdFNVRDY293cGdZcmdOb0FBQ0FBU1VSQlZHaFZjNkkvUnQ1NGpnTGUzdTgyYk5WYnQxeUxuSjl2OVhnL2FDU3RwMlU3TloxRUdwbTlOUklJN3pTbUVJTE5YVjI4TDF4Nlk5Yld0YkJIcTBvdys4bVU0N2ljajFHem5hMjQrc0xFcEdLcEZRRnJZTFN6UWFpTUVWQ0tGOWY5ZmhzUHZBc1Bhdi8xS2tpWGxJcFgvM1hlYk1XMlcwc0RXbWsrZVcwZWdRaHZMZ0o0YXlHUXhXdno4UGo1K2QxdEVTdlFFN05zeDYzTWQ4MFo2VEVkOVQyMnpBcGI3K3cxRVJGZlpvY1UzYi84NU12dHUyVW9yOTlzYjM3OTIyRjh0K1RnWUVQb1RDRjF5T015eTNhSHFsRjRPdDV4Q0crT0xBbTllUUFoZnJwL3VOcmtmSW9hdzFtbWR2ekdudWZOVlBWWUxweGRQcjQrK0RnZDU2TnRmczFlaGp6bWhYYktEc1ZVRVZRL2hYc3RMWTdUeUJxV2d4RTFMQzhoV1V4ekF5RVN1dENGS1R3aUloQ3huNWRRMGFrRkNFbENVWGc5bmVlNWF2V2VQWFZKVlFDRlRjTElTb2daU2RUR3ppaDFBWllpTzJXTDk1SWVRMkFTb0s3NWE5bWRFRXBURVNBUGNCZG9hMGJDd0xnakxFOUR5aEV3Vlo2OFJiU2xUcFhLSnBJMURReWJQSkNuUWZqc0VXY2I1Nklxa1N5bG9UWmZ6U21EckJRdVRTRUNKa2ozdlJvaEJpOEtXMUZZYWFDcXJTNUp0Y3hnK0dZWXNiamtCWWhnU25YOUE2MElWTEZIZllSQUh1V2dmV1BUc2RCd2hEc2thRkRoeFljTURhOWoxb1FpYWNnaWFpbVp1d3hKalV0eVQrbTk1WVJIYzVWYU5wbGxnY3FSTU0rS2lEVGV2OUdEamtQTWpWRXhRbFZTOTJrVGlnN255MEoyOTB1SUdGQkphSmR6aWdoa2FGRVZjR2xVMVdFY0NoY1M2dFdUdHdzRlNuSEt5bVU1dlU3SkpCVEtHaW1weEROTVc3NTlmZXZhUTdNeVlka2dnMWdlVzIyRkZzMDMrN3c1REF5MXFSdkNVVVdDWm9rTUp5RmpxeDRNOHZicnIxN2YzZHpiY3FkcHQ5LytRczd2VG1oeldzOEMzNXNXZFF6b1dsTDA3SUEyMTRTNnUvNzhzMC9renRMZDE5K2MrZDM5NFh5a0I4YU5qck1Fa2FiRGRvcnpVYW9wNTFyZjNqNmdhWStGVUxFa1FyZG80SHc4bmFmdElJMHROaG5DK1pzckROT0lPblBGNnZBcHJXRVZKY1VITmdkSXJCYmdFRW9ndWthUERtWFVGdmYwQ0tmc0RBVG9pWTFrcmRxWWtraFVBYVJSMkJ3SnJCQW96RkNXeFN5aW03TUFOak9nTGFlbHNiWnFJdzNvQzMxbEZ3NnhabzAyZVlzSU5VaTRWNGNXenlDbHBDaSt1c0laREtvYUtERHJodE0rZWdMN3VraUhIcXNEelU0MTBDdkZ3NWRPMEZOaEZUS1liRXBVT2pKbDNIQWVyc0lsVFNuOHhib3VtVFZrYTlKY0dEcW9Ob1pIajVaY1ZTOUdCbVdFUkNBbG1xeFRCVk9GNnRBcnQxaHAxbHdDbWU3dUJUSkZsUmhTbE5Ea29xanhtQW5aYVYyZDlxUmc4MVdhRHFoUW9ycEczMDlISTd0NnV1T3BFME5UVnJVa3ZuaytSYU9tS1VzMGpHTUVpOExncTd1eDM1VkxTMUxOT3ZVeUdpVUV5YXpZZGxQT2UvV1dyeVJpRWxFRjJad0t4S1h2MFJRZUFZT2hTYmhFSVFGeDBoTGdnQ2hEME5XajRVaVI5LzdHdDhaR1VaVXNKb3p3b0h1dEZOazVnNVlUV3huU21KSHJ3M0Y1ZDFkNlk5RzhVbUJLN2dVcEFiSlg5YklzNXpTZER0c3htU01MWW1XaUlTZlhMczFoTW9pSitOWHpuOTE4OVRmSDJTU2txcDIyKzh6VWp1bUhXOWZMQWI3d2JoVVUwdHRwUS9mTmJtdGxYalkzWDMvMWJsY25QYzVYTTBMK2Y4TGVyVm1TNUxyU1cvdmlFWkdaNTFKZDFSYzBTQWdRYkNnakpUMk16TVI1MWNPTWZyak05Q1FiMFdRVVp6Z3pKQUVJWURmUTNYVTd0OHdNZDk5NzZjRWp6Nmx1amt4NGdNSGFyQXRWcHpJeTNQZGU2L3RLUVpSSThlWG11dWd4SDA2TGZ3VGlzYXFIR2pORFJHeUEwSVBDM3R1akxYT3I0SWRKVHQzaTNUZkxqUlpNMW4vOCt4a0dleEJiZXZtVFl2QVk2bGhxSWhFSUMwM3dqcGtaaVRiNmwyQWQ0ZHdwVXllc2RlNlJERVNCREcxVGRMWE1CcGNBSlVGZmZGMmJQc1AwSEVEdkxUTnFLOU1veVNIS1J1b0FNNlAxT21kSG9vaVRHZWVHNmRpWFdTSEhnc3BpSG1wa0F1bGlNbEx5RkJISnVKd2pkR2pQUENPSmtSd1N5S3NSVmNxQ3pURmtJcWx1M2xJenhGUDJCKzcyYjNxa1R4YnRRdGMwWWxxV1BMZld1d2xRTWlEYkJJRVlGOEdVekVrUUljWDdsdGxVY3dzeU5jVmNldlp0ZjdlT3hIQzJiRzVUMUlDSGRveHc5dmk5YmQydXkxMWZSREpEUDdtYU1aRVRzNHVLa1FrMVNtemhWMG5ZTkRrbUQrNCttNCtQSkxRZ1ZvSTkzV2pLeUZJdWwrRFpRbWVYL1FPVDg1UnQyME9JTnU2dTdxWHdxZTgvMi9kMTZUMWxhR0RNcEVjSU5VeXo5ZFpvYm9sMjZzb3dVb1kxVTQxZ0hrbWhSd2ZNb2xHbmErTWZqMzVvWTNRK05XYWo5SFdYcmNaeWM2aUlUbEdYNkNMTHpuNTRlSXFVcTZ2M0FsQ0xXMFJtanppbTdhNlhJdWZVb2p2MUQzcDNmWHRkOEdmRk5XdXRCeGtVVXhNM1ZXRHFMY2VQN3Zibi9kM3J6Lzl1OFg2dUg5ZjF6ZXRYVjlkNTlNdDRTRjlzNzUraTNaQTB6NmZqR2g1TmRsZXY2azRFRDJ1THUrVEhOdDhmc3ErckxXVitqTU9FQjk3aTZXSGR0OGZhYWdzalk1b2hkY000eUxEcXJvL3Y5L044bGVXQTQ1UmNhazk5Zi92YXIrZmRVMWRrY3ZSNWgzdDA4Q2FSS1dhUTdEUko5YVpGczlmUTZEMmhzdXNkS2hIdk15bkYxZUhqNWFiQklEVUhEam5PUHFrb0dZT0JuWWxTMERHdGJYVEdLQjQ5UlRuT3VtbHU2N3QzajFFQnVFa1hiVTFtN1p2c3g0aXNOY1J6N2RQa3lBUjZoL09VcURSRTF6ejN5UkhaaFNBWFFhT1lpcG9pNFVKR0Vyb1JtSXBWN25MTmNpNWcwcWJxa3pFVGNrRzdrR0ttbk02OWFOcWtodVQrTVA4czE3Tk9lY0tCajNJVjk5ZnJxZ1o0aWtVa2xTREZWU09HM0pTdXZZWlBNd2FMUzVNcHpxSUxqdHpQZVRMUEpycWNQUnV0bnhhUE5iMHdjK1UwN1lSRjFKeHRISUpVMmFyWU1EbEZJSm5LWUtLRUErTEoxcitvai9QS1ZaRm1iT0pCU0xTNU45RkVrZGtWSVR5OVhoNGpIdjk0ZnFVZlR6L2Judy85OFZBVVlTUU03TFpkcVhxWTI2cGYvckNHeHhIMklGb3NlODY1eTg3OGZsMlcrb083N2JPMUhpa3lHOXNhZ0xsbURldjExR0NtcUEzRmtWMGxBK1pXTkRzNGhrTWRGdTd1RS9DRTYxOTk5WnMvZlB1bHQ1TVhIclBEV0drckE2NVo1VzE4NWtmczc1K3UvdXpMNDNmckZHcEl3eGZSb3ZmYXV5K3lIcnNzNTFqbHFQNHFvMVU2cDhNYzMvWjU5L0gyelp0bDZmMWVwdEs2TDMyYW5abVFhVVE5bW1UVXovLzZYLytidi9rUGRlckgrdmJ0MTcrNFZpLytTWEh2SWdzWVk2RlAvbUgwaUVGb2lqcVRFODdudnBHQmNFcHZLYVpjSVVyRW1VK1A1MnB0SFJ6a2tBYTBnQnBVVlZQSUFORE9hK2NNQm5vTEs5cDd2TjB2Kzhhcm5wSFFUNVFvNC9mQ0ZDWFRYQnVNRGJpS3ZwNWJUeDNnWDFsVk5kcGFCNjZnQXhoRlQzbVd1UVdIV201NGVIVFRXZlVVUlY1V1ZJTWNNYTVIekNaV2lzWDVlS3Fabys4MkROOEVtb3p1VHcyS2lMa1BoWGhxQnNSRjBCdVlTRFZybVNGbFErNk10YW5xQmFKNmlmakhaZDhLQWlaMlFFWWowOHZrak9DMGNTRVhRazFJdUxxTSt1RXlUeTdPcEU1SmU2MXlmMTVlZFNzTU12S3lXOWZpU1dRU1NsR0pKbnBRMlhxS291VVVrOFBuRXpERGlPSDZpMDZLYVFucmhJaE4wem1pVTBTVm1jZ2VNSU9vS3RBalF5WEdER3VRQ2w4UzZabGE4b1dIUW5RS09oTWk1bENnaUFMWjAxYTMweDgwLzhLT3JYMnN2RFlKRXE2aUwwUVJCU3g3aHMzWGl1d2d3NmsyelNhY0gvanE5S2ZQNTZqU24yeDNnT25JelpMVVVkOW5kclRlVXdMdzFrWElnREJwYmtFbGJWdG5xcWhJcm1MRjUvV3hMai9QYjc3ZDc2eFZXQ1FVQW0wQXNxODh6cnlmWHUyUHgvbFZlYnc3WmcyYnBVc2NreFNkREtENGxDMUVlSkpKM3BiSmxzZ3Vhd2NjOWIvTTE3ZTNyMjUzZi9sd2QyNml2cmpiOWdNa1NSVFF6VXI4NjVzdmZ2ZnRJN3c4bkk1cFYvQ3RpM2Zway9GbGpIVzViS1JFYTAwelZlUHA3ck5hdmI2L1d5TjZNb2tWekJUWGhyNUNvNTNpOGVHOGFyVGhTSWIwRkFpSDh5bVQ0K0ZxOS92REc1azR5NHFFeDVyTHd4OWZ2OVpwdDU1Yml2eUVxQ09RRkVGUWVhYXBtdHJIZGpxdFFmR05FYTFhV3B4N3VBRHNvQ1NabWVrSmM4a2V1WlVWWkJQaFJTVFVySVZDNG1Kc0dUMEdpcUJrZ0dyT3VqNDhuQm8yUGFpTnlwR2k2OGhDTXhrMll2OE1CQ1dDVUZmS2NOeUkyaFNaV3RoSDMySDBXalUyQzBSdUNKVFFMVklQaFRwTU9RcFBpOC9HQ0M1TVVGVG5wQm9paWxQU2ZHcHB5KzBjVGROY1RlZnJLODdMdE5jUGpoN3RzaUVVaENnbEJqTUhJaUk5L0ZENnltRW9sYVhMYkFFNmRFYnExQ0dpMG5zT09aT2VMUVBpaHRxQzZpaWdtTldWWG16ckEwUVRzeG81NWkrajRETW1GNUtJYVJuNTFRMXoybFRSdWc1L29Lb3VBMTBhNS9QKzBKK3V2am8wMjYrdDdnRjJ3czNVTHVoREdWeC9nQ0ZUcVRVd0tMZmlrNUxMSTc0K3ZndUpibmwyWDR1NUFpS01wS20yREpoRTNCRXFpQ2lSR3BxaHlOUmlHUjNpc20wN1JNY1ZsaUZxOVFIWFArZVJQWGlKQUNnVlVBbTJYQmVuTDlQWlg3OXU3eDVaSUFwaGI1VlVVOU1rYVZNN244UzFCK3c0eldOdGNRd3RVK1VoUHI2ei9jM3VldjdzaTZ0MmJ0b1pXcWF5RGhZV0ZhRDZrcWRmM3Z6aW4zNzc3U01kSC83RDI1Ky9jWHlpUHRwUXFqOTVlcGk5OVdETjBvOGZpNituL2RQYiszTkc1NGF1aWQ0Y3A2Y25ueTFnMGdKYnozYmJIYmloOWI1bGJEVklzWGo2Y0hqY0ZWR2ZvNWxvbDdMZS9mSDJ5eDJYcURFV05DOU1kd0hnZ0xnZ2IrdnAvblJjQmRrNnhjYURBTktrdFRWMXJpQ3lEMGtnQ1VaQ0VyME5LS3BtQWNFRStyWUhidDFvWGZJQ2tiQVlrVXhONm1UQ3B6Zy8xaFJKR2YyT2JSMHBTaEZGVWpWQUVUbERpaHNJQk1GaEFBSkVlNXBiRHJ2WTJOL29aZDJJUzk4MlNLcUtDVW0xVGZjcThFbE1aek1aWTY1TXFLbGxFRkJNSmxIRFZNV0x1V1NOUGppQ0Q2ZGpPY2dweExKM01SbldVdVNZRFZDM0Nmb2tXVXd5YkZ5ZjVHaEsyVEdNUGtYM2ZiYXd5YUk4QmhSRW1tb2lRM2FlUVVaYVVoMFZNUjZtVURIUFlLN2ovWnNYM2RWbEo1bStWQTZRMkhpbm1HZkxNdFdrQ2xFOFVreVFKL1dadHJ0K3FOajdpUk9aUFlTbVd3amxtUitxQlpFdDl2VzQxZEVSQk5pN1JyeDZFK3RrSGJ1aWQ3dVpTV2htcHFoWlJLcmFxSUdRUFhwQ3hzK0JVS2xaTXRVd0Vnc2l3clhNeGw0VCs1bFBmZjV2cnQ2K3JidGRycm9oK0dtR29IRGY1V1lSWHMyZitjZjNzUURzcVREc21HSktkbFBJcFBZSW1BaWk1Skd3WXRtYU1CRXBqSHhxL2xzNWZQN0Y1MisrQ0VFS0EwWUtaWHhHUkJVZi9jM2g1Ny8rdi83anUybUs5dzhmM3ZnbkR5by9JY0EvWDRLTkljemVHZWx4dkpzT3A3by8zcThaR2FSQ2pGeWZ0UG5qOFVsbWo1eUx6Z2FWcVVkUXhKdFlLV1QwY1FTQ0phREk5Zmp3OE1wRWJlbzFBWkduYUgrWVo4bTVyU0V2M3UrWENValNpa1o4ZXpxdTUxUDROY1RGVEZiTklRQVZ0a2FYRGgzY3NhMGxwRUpFdGk3UGZLdE5OeTNtSUZ0bktBUEdTekYwTy9kbG91eDFQYSt0Tm5xTUxvU0k5ZHlZcEtTUTBTZkNRUElFV0hGbG1xb3l4ejVZQmIyQ0txcVpVSTQxc09TbFRDVWlqaUdQMGpHRndLZ3lrYlBJME5XRENTdmVjMWoxbGxhN3FJZ1dyUUdrMld4UmRXcXRRNXZLTzdSV05JOXBZejhFWXV3OHMyZEN4N1JKUk9ERFFpQ2pxTXlIRzNtYXZseE9uWTU2Um5paytNNVlJOWhiMHRRY0VUZ1lwRWwwU1lxWVcwckcxZ2h4OUlpUVVTVFVjVXNZTTJhQUtFVmpHTEJJWnBoN1ZLb2hxYVNYN0tHbFNHRHhJNWYydzI0MXoyb3lxVEhaNmlJcW1xTU9PR1prU3FZZnJvNnN0STNiRzJCL0tueDc5YlBmNW40NnluVTVyMll5SElOQmZkYjg5VHBISkVsVVFGTnlIQU9rOTBsSHczRVlHRktUaWF3OWhidmw5Sml2LzlzRmQ2bzBTVEI3Qm1YOGhYcHRhYnZEVHVWMHRyMzFabVZqK3lkTWdOTitpcERsc0QvVnJxNXFyWWNJWVl0VFV1MmticEpySyt2M2YvTFh2L3pGcitlNVpGMWJJWWJPaGVQTzkxVTd4ZXU5M2Y3SGg0Yys2OGQzbmk4K2EvTEZTUHBKVno1QlJqZXFjVDNYNHhseU9vdjBuaHhUK2NSam5uMU5aSmlJcUJ0NmNNcmFZYW9wa3JuWitMaTlreW1JOWVIK09KbkpuaDJST3AwY1R6OThNUmN0MHhqRC9pUU1uVEJscSsxdk8wdVo1bDJGcUNBWXNRbDh6Vng3bnBPQ2pNQ1l6UWloeUdpUlN1clk5NDNGbzVnYUlsSnl1RUV2MHBwNDdnZGJjY1pxalJBZG1DdkIxcW9uekhzSE9LVHR5RzZrSkdBTVViT3hZQkFSWWRZMEtCQ0FpcXFrR2pTM2taUW9ESnJidEo4UUZUZDJLb2U2Wk10a0RycjRxQUp2OE5jeEZqREVQQzNTczB3UklabGF6dnVyOWZ4bzFxR3dBUmNZUUlCSUJWUWJtS0ttWWFhRStjYXA0SDZmcDNwMm1STUp5OGRkSkNtdSs5cVFMUkQweVNVbGRVNkxaRTlBVWd4a2pPQzgrbVMxeVFXOEtjOWVTUktFbVdRSTRrSWNNYk1VRWJFZ1NYaU5YbXlXYmxkNDRLUlBWaVhXWHE2Y0V0SFdweXVsUWdmZmUrU1plMVRmZi9udFBSdUxRbFNsTjByQmJPdWlsZ1NZdlU0Q3FHUU1BbmNFZ0RobjY3dGtKbkxBQldXTHZFdGt3TUFCWjFSUmtaS1ZBV2haNDJaaGY0ckRMMjd1anl3aHhKaS9xeWdUWjFrZjdjOWZyOGRPdTVsckxjc3NqTk5aTThWYzVFbXo5U0w0NHVPSEZtYTYwb3Fia0xCSXFoNUVJanF4bEdzNWZqeis0ZHRYUC92aTluQ0YrODF2b3NNeGh1WnpydE9mSGZaMzMvMXdmeEw0VnVrUmVWNEd2eHlsTDNwRlpxK0xxR1p0dVlibTB4bFJJN2ZlTUtPYWdqNW5jUnZJemdxTEhoMjBwRVFOUmFrZ0lLWU53bENWODkySE40ZWlNa3R5eldLaDRPTzMwMWZpVTgvOFZPdTdZVFNMMTd1N1V4cWtHR3NPcjFtTzFwS0tPaEtRN0lrdDZMaTFoTU9FdFlsa0VPa21nWEYwOW90UmRIeWlob2xhSUgwUTA1RmFiSzNuamp5dmJTekFTQ0UxSVpxREJhMFFpVXdWUmhlS2JEMTZFam95d0dSSTY5T1kzRzM2RlJYbE1LM29PRk5EVlNXVFNJV3FHZ0JIZjY0b1E0WENrSzNqZUlvRU1sSlNPdzJORE0wQk85WHNya1d4VGNnSTB3dk9Gc1R3blNJamFWSjhFMWhLaW9DSk5PNTI1M3EvT0ZKZjJmcllnRHcxMHlsU01taTVWcDFFY0M0UXBSbUhBY3lsRFp4ZFM4eUxaNDc1RDVRTWZOSk5vUXA3R0M2SVhaaHM5em9HSWljb2VIbUtTay9xTVQxQ3A0bUFPU1JDTDlqdVMxaFFoUERkbHcvZm5VQWlUVmx6OGtuWDNWYzR2bms0NWl3bk5XRlhjYWFvcUtJSEtkbDdaQ1JrbzZrUW9zcEVtcEtydTBUU242d1VoNENqaVMyaS9iNG9uaDdueGFlUHB4QkFEYWx3bDA1U1FsOS9mU3ZSUWwxYUk5aGI2OGVua2lubUtpMTF4VTZxY3JhSUxsMnNGSTJJY2NISVUzSGZHb25RVXZ6ZjcxNTk4ZlhYUDd0WmhoMFlPUjVobnFaaTVUamQvS3R5L3YzZi8vNDhPVitjdXZ3a2V2d0NvaVVTRVprVVJHdFpxZTNVb25XR0dKbUQ3U0Fxbm1tbDZCTWpXamVOSE5kL1QvYTBVazRFSWNheklnSEZxdmZIYXVEQ3VsWlYxQzUrL25hK3ZyTGlMWC9NYlJjSTZPWDQ5dHNuR09iWlVxUkRZRmFrYkZzbVdjOTlCQWkydGRobDJpbmFhL2ZTTTdaOHlndkVDc1NnbVhFY1lyZiswVmd6TFhPZWpoMXRQUjF6R0Z1WjhveTF2R2lNdFBYeFlBMTBMRVV6WkhUbEJXQ0V0VkFuK3dhZFQrU1E1SmlaNHVVSnpqTTRrandpS21WY2xhbHVSek1abWZSTlFnWXhaT3NpQ0RXaVFZeU1PZ2N6ZW1wNXFwaEtQYy9neUQ1aEpKTmpBOGYxVEtoNkdRbXdwRzdheC9mSFAvL3orczl0Q2ViODV2ckRtaVpaZS9BWEExbm5GaldTaVU2TnhHWTZnMWlDVkJGcExXUXFKVTFIcXp0dzRRMDhMeVF2cW1oY0JMRkpKS05uanlsOCs3TFJWR2tmMTJVdWk3RzJoeVhWSnpObjhsa09CQkNCSXNGYVg3L2RQMUlGRmNabU9jZjA4T1hQM3QzZEhCOTVveC9selZQU1pSQUZUWU94VVUwOEtPTlZTeWJFclBXUTRzb1ZKa3poeVVjbzVXbmV6eEtSNjZLUGViM2tHakhmVHUvdnpXQnBhZFNCSkZqZTdmN3FsL1V1Q3lYV0R2OVFVTk9oWkpLcHNCN25NdkZZZmRtM3A5NDhzME9aUXFwTDlncGx4b29aM1pDbmZuWDh6VDllLytvdnZ2NUxabmFKeThnRVB6K2RVWXJycTMzNTRyTlgvL2pXL3BjUitCak53YUdKSDBYcnpST3NndG5ldmlzeXc2OFB1M2xLVzk3Lzd2Mzc0N1JraUlvU091OW1XOEdnb2tYMjFrVkY1OE9zVkZlR3pzNDZTQXpSWW1zYngzNFBMRHRmdGNUcHpLS2lpQ2psVlk3OWFHenFnaVVqSUd5M2Z2cisrNk5NbUJhRE1BdHBiakZlZEZCNzVBWU90S0taWWowU1FHOVo2b2Z6ekxzUFlVYW9SdzQ1TDJHbVpOSVVZc1hTTUNwLzRtWW1vaEtuWTZXK1A2MDlJYVlZUFo0RzlzNnNLMTBpeFU4WnZUR1RnNzlNcXBkeDY0b0JseFpSMTM0V0dUWmdDTVRLVkE2bUVIY2Y0dGtjM1F3d25GWUtjak5ZWmgvQkRCMS9LUUx0bVJrVVEzUUtxUnVmSTVNQXg5bEUyVGxVS0Jkek1ZRWk3TDFIRklGT3U5MWVKcWxoa3JPSnVLTmR5ZkYwL2ZQcDNUVGZvbi8xK2tHWk11OTNjMDFFSjN0WGw0VFpGRUZGSkhvYTF5Z2NBdmxMZVVaRGpJemVURlV2SUVJd3NzKzMvdjYwVHllM0RBdVRvOEtrUGsyVVpPL1kzWGp2SXJKY3M1UU0yMC91anRScEdyL09SVndQaUVhb3lKenYvL1BkR3o5NkU2aVZZbWJYOHUwSEYrbVZJaXJMTHNMVyt3aVFNaG1INUcxVUxKakVwT0tUWlhXZkhGQjNjOWM0UHBpV1NWckhsYmRUbU1YVmVaMTJzWVl6WlpxWC9kbE4xSXZ2ZEJnanYvbjEvL1RtZE14a3JEWFY1TE5sMmwvZFhMMWFYdDFPUGFlRCtPNW1MeXloVnVhSmRZcGVld0JsbUZ1ZHU1bW52dHpNY1Y1bHN0RDU2cm9jdi9tSEg3Nkx3KzNjaituT0NDM2F3aGJyL2NSNVdYKzRFeGY1OGR4S2ZxTGFaS1RVSHFvY2Q2OTBDU3c3ZDgxdG1NQm9LNHhnWkZxUUZIZlh5WURHQ0NXeTJraUpEQ1B1dHVPTmRXMGQxb2l5aXlBSlM1NCtmRHhNeGJ3Rk5BVUNuR3hDRXQ0Ky9PbjlxcWhsNjAyT3hpbllWWmhiR1dsa2pSTkFiRzdYSHEzV2gzYkNhaEU2c3NzWHhIMUF0aDB5QWZqMnJqQlZZU1FEYkdzbHprR3pnVEo4bGtHb3FvZ2FrYVJBYzB1TURSQStWRXhBVll2Qm1nZll0U2lHRENrSDBXcE1lRGJ4bjByS1JoR1NvRnljTG5MUiszNnFscjE0NnNicVRENVZUSEFyUWxFK2RTMXZCNndjclJieFNKUlN6SE5NdFZIUDVlZXYzLzdtTUxYSGYzcHorQ0kreUMvNzcvZi93Ly91azRuNGNnSkZRcm5CY2NUSVpDU1o2TkZidjh6RWxsWVJGUmxBVUd6UW5Qbk1KeVN6eG14VGJuK1NEU0dzZXZuOXFRVVFLeHE4bERTWnJVZE1aUnFGcjZpakVmaFRUREJ3OC9sbjMzK1lpVVZjVFNGZFZFbmcraHc5RmJtS202YnZueWhrUkd4cHNkd3lucExRckFrTEc5TU1Ta0o5dGhRbVEvTGVEUm05SFd1eTk5UUdpWmgwOTFtckFTU3ZQdlNkUHAzdHIxL3ZNMFV3K1FRVjBOUWhTQndVWHJMTVRRUTB3eVM1SnZWd1FqRVRwa0lTN0x5SnlubWU3WmdPb1RuTmtjbjRtK25taXovLzJlZTNkVDNLNU92OWRVWTd0ZkN5dnVXVDdlbmJXV2lMTE1vbk90N3R5M3NVdTRhUFZzQ1lwZkZ3dTJ0ajFTTUUyU1NzaUNCN2hFV2F1MjB1SXFhSU1WaU1vNWZpZXZuUjE4ZmxxVktUTWwvajJDQXc5Tk1QTjEvdlVIcXN0djNWcHdxQ2F0KysrLzVvTmpBUDNHb1d3UkV2akJ5amsyU1NBWVZFTDJQbjNQVzhqdDJlQ1ltYWZmdERkc3VoOWNTNEI5bjJtU2l5N1VHaTlkNWJQMU5NTWtLZnU0MWpBS1dxa0o2aHZBRGxtQkdPSWUyVXdWY1NzTG15Sm53NzNXeWx2bkZmVWRYTjNNbFVEakJzRXFDcmN2dDIxT1RGVmNWeEI3aElucmJIWkxzYmppOHd2cFJSdG4zM1phQ1VoSnFJZWxKOE1zbEEwWUpjWno1OTcrWDF1ajhzdmI4Ly9yeDgrL2lycjQ3ZlhQZldwNkxqdmpGaTB6R205NWt0a2dSN2J3MFd3M3BySWRrSE9EVlNYR0xUdFYxQ2ZiVWR1eGIyTW1ReWc0S3A1dWN4SzhqSTBjaHZ4UXBEVXdOcFV4bC9Fa1l5TTM5cXppRUEvZUlYZnpqNU5CaG1KQmxkQllMZGZHeTFTSmZ3T1NPbmt5STdCa1FCYWxreHNxcGh3cGFxdVNuS1pwTmdxOTJqQXFHbDc0cXBRTTlVUkNkNllqM3RkOU9yOVZ5SmpHVzJYY3Zyci81Vm5wK2FaSGR4RlVTR21DQ0hNSExISVF3SkFqTjZJMVgzNTlOWmw3bXNZcGFaMUJibE1PZjY0QzRKdFJCUlpNU2hmdmZOMzMvMnhlMi9LWWQyV21IZnVaZG9tWWU3azg1ZjI4bituVnh3YUQ5K0JldXpselJRUHp5YVRLVmNMY3RlZDlvL1BzYkRpdDVId25Hc0JpWlZ3RTA5VTB5ejUyYU1Mc1dSTk1kR2pPamJDNEtaT2g5MlN4TlJ5M3JXaEtrd2MzOXRpYWkrRmNGTHRsREorbDhldTRFNmo0UG9hUHhzcWxzUk1ZL3hpdUNJR3JVcW8rZ2VVKzJtWWJ2ZFpNS011QVRPMmdpS0RabzRBTnNjZzdhaDJORFh6cXkxZ1FKR3ZCRGpkZmdDUjI4aHQ2RW9mQVNzRUJkNzRqam5XUjJwQmtMY2JiQ3VWTFk2b2c2VXFvcHcrLytuNk5BbFhLQisyOXRVQnlkQVJoVk9SVlJVeHkrb3c3MmxueXdSTnZuWnh0bmtTMWJXM04zTjNaUnJTaWthUGZkem5rNmNEa3ZoOFpHSFAvNWkrdjFka2ZpNjM1MjA5T1BGVTM4Um9nWVF0YVdvQ0h1UDJPeHVRT3NVTSt0Z1pNcEZmallVTnN6c043dFdCVkdBVEtvYU0ySEZUOXVSSTFwQzNiRHNka1ZFcFpFeUh5YVpmVmcweW9pK2ZnS2lIWC9lcDZXL1BlN20wUUljOUtIeEpiYTJoSUNUeUtTUDU2TEdscUk2VkhIUVZEeURpQVVNSFdZb01UQmFiUTBSdmE0OVdZb1FZTHFqcDA0cGlOb3laM1UzdGFMVFR0djBxLyt4dCtPYUl6WGZlMTNYaUlnMjZ1aUR6bkw1UVZLbnFVaGVJVlBNcmNyd1RxNllkaVZPUjVpNW02SUNJLzBMWlR2ZXYvL202ZXF6YTExUFp5QVR6TWY3eDhxVTRwOFVrT1JIVC9EbHYxVzNYSVlvQmtjeHM5eDg5blRzQVc1dVhSSmFScVBTTE1CZ1NCclZoV3FTeUFoU2hoRnUremhvMU9QOXg1dWRRb3hGNmRsaEx2Snc5M0J0VXpXeHNVdXlIdE1TN3orY2EvcWNXdUNxU1FGMU5PUzNncTYyWnlNeEpUT3paZ0JJbm81dEFyU1lqWDM0cGRnM2lDK1FacUlKMGlVdkpKQUJqWWxJWm5aTjlndGE2RmxGb3FxanMzeUJXNDRYYTNiVmpXa3I0M1Nnb3IyckYrMGg2b3FJOGZqcjFpZ2NYeWV5NmNXekt6MDVWazRYV05sbGhmUmlwQmlYWVVKTkJ6THdKMFk2WG9hUUYvOHdSMStmOHF6bW81RENoRXh5bWorUEUvWnIzOS9vSC9MMmVzMHYvWS9UbnkzWHAwZWVzaGVCdlB3ZWxTc1FtVUsxcEZvT21aTnd4RmRTTWZLYWFjOHJoSzFldHZ2c0trcm1QRnJJZzJJbndPRC9NWWQ5T0FQN2VTTFU3Q2doYmtXbnJiVkNNbjlFQmg5TEU4YnkrVmR2WVF4UWxTSVR4NmR5bFYyTnJzcGE3VEFmanpmTXBCV1BvWUdoVTBKRVlFRXJlVG9mR0VFVmZWUlRsZUkxRVJuR1VnWGlEblBVQ2xOUlpheFpPVTlXbTNqZDQzUjk4M1g1MkhOS3dvL1JLV0JTRmRCU3h2Y3VrenBXK2l0a251WE1EN3E3bG5ZK0x1WUFEWFU1eVBtVWNxRDRKSzFsVDVCcWoyV2VRbFMvK2VidmZ2M2ZmZjNtVk9PNDZxSjRzamhHeW1ML2J1TmcvU2cwOGFMMGhBalIzejg1RnZmOTVOTzhzL2o0Z1A3UTFyNlJnQ0ZxT3J0R1JJYkdlSnRQZGpuc0lpT3djVFpHZmVkU2lGZmJMUk1naUI2YTBETFBVeGViRjRsblE2RkFGM3Y2N3J2bDhkNE9PNU5pUG9BNXFvS2h1WlJ0dndsZWxKcVJHelRzWGdBQUlBQkpSRUZVekxHbzU2bWxxbmdaYndyZGdrQ1pPdFo4MHNjcGZCT3R5OFVTS3FmV2V2VGFoZkU4MmQ3Y2dhS2l5TWhnUEVlTlJXR0RlU25qekpyamE4MFlBWjlVMDF5RnBIdVpKamZqdUF2TGRqY1JxT2oyMVNBQTZOdE5PN0VKM01hTFYxODhxenBlSmRzMTBsNmVYMTZlM0F1dUhNK25GYkh0MjR1dVpPdGxmMm82MWZXTHYzcTZPMy8yWlhsNjkrWHhmUDBLeDBmWTlkTE9uUG5KakdTY0RBWVR5aFNSZ3V3WUhGM2I1a3NLWmd6ZTRDVUZLeUJUUHJmN3l0QU5ueW0ySVlKV2lxbUlGUlZWRTF4TkRwUzVSRUhYdzY1TTQrbzFaTDZYUHl3dWpFTmdjdDcvVUxVUkFsRzNraEVFczA0ZUxFVWlWdGxwYlh2SlRpODJzbUE1c2grQStKQVR4VHd3M0NwYnJDQUpZVktMSXVFS2xUeXRVRGF4d1VpQ3FZZ1hNZnBubjYrLy8zQTZSejJ1TGFPVEFxeGs5QnhzZnlIUnVEbHp4NHZlejV0enE3Z2h4Y3B5S1BXeGxvTkVpbkE5VFNvQ05kODVXeEM2Ty8zdzdaOCtuRU44Zi8zcWtNZVo2OVBUR3JSL2Uvbmc0b1VTZklHTlh1QTI3ZjJUNit4bGNaOTJzK1A5ZStkOVBYR1Ewc2IyUkZWNjUxQ2FrTUNHREJyeEVWR01wT0M0cW00eUhhUHU5L3Z4MFBnS05aK0tzZkxxU3RMYWRrU0s0cWNmdnYxWTVTbjNCNFVWTXdGVXg4OUdMaERaMFZEWXV1bTV3Y1ZKWmhkM0w4VmViTG5NaU1qTjMwYm85aTIwamVtM3FCWWVXKy9SV3NSWTdsNStQQnNrRjlLalJ6SUg0RTR3SGpQWjZKZ1FwQ0J6Vk5NQXNRSWJsMkF6SDRwdWRUZmJsTHdqMUtFaml6VisvWEhYVllTcXE1STZrTTJhMjZ2WklHWjZTWmNOQzhSR1ZuazVPR004U0pldkhuRXpQQnRNSjg5dVMzUFBjOTYrZm4zODQxc2VGbmwzL1RYZnhyNVhtRVNLQnBHWkdRUEhtOVNNM0JRS0xZYmx6eFNaQmlLWVZESWlaUURVT1hZRVFtYTdXZDlUZzFSQkpOVEc5emdUVmt6VWlvaVp6OFdLRTZaWWw5bW1uWFhQaENKak1qTlZlMkZpYmQvdlM1LzA0NUY5VTFHTHROcVRHVlo0enNsNlduRG41MU1CVWt5Zm1Ud0dKQWtwQWxWUjI1STEzR24yVnRlcUtjb1lqcXd5MjNBZ0QrZWRDcGpNUUNrT2grNlc5ZHMvbkQrOCsvanh3OE94clQzQmlDYkt5R1FmSURXc0dkRXpRWlZZSzN5UDliaWk3SnFROE1QVnpucE5LMTRUekZwakhvaDVSSzFkelAySDNaZlh4MjkrODV0ekwvTmhoeHphOG5ieUgra0xYaVM4ejRQQzNMUjN1dm1QUUtxRUxyUHBobzZEa0tHckZvb0pvZEo3cUZVMWs3R2VHcmd6bGUwbnZOMDdWTmlPeDFWSXFDLzJRUVdtZ3VuKy9ndzEzYUswQXVXSDM3NmZybitRejE3cFdRNFk5RVBaMk01aWtMeTR2OGFUSkdSdXgyeG1oaXRna29OZGx1bmJyQ3RsdFBOY3Rnc2VoVkFxSmNIRStFU0U2RHErRWo2MUl3N29XTVRvcU92bGRJSFJqQjBOaGhjc2tYa2ROc0lJTVI4SklRcE54OU03WEdGQ0tqaW1vK054NnpKOEM1dHRuTTlmclpzLytSSUovb25uK0ZKZStlUnNQZGdtTVJMZU9veG1JZy83M1dTOTE1czFEMS9sM2YvMnk2dGZ2LzErUFh6MitzT2Y1djBOSHZkUGo4VVBwNU9BWUpLK29ieUtFR0xvSVl3Y2I2MXQxQ2xiNW5wVEF3OWJJUy9CRFVSZER6dXljcVRJTnVST0d0UWxZQWtSbjVmU1IrYys2dlUxeGRmekpLYkNESGx4N1B5NE1aNVh2L2pGL2FNZ04zMXNiM0FxQzlvS1pKMG5aRk8wODJ3ZUdMQmJFYkd4NVNBTWttRmxlalF0dlVXdWcwZ2xuVVFtNU5US1ZCaHRocGdyMndKUXRVZXBYWmFKVFRITnArL2VaL3R3VDVOcGRpM3pwQmxpRUVaRXNaRUc4Y3hRTTFsM3kzcHVuWWRTbUhFNmg1bllmSFU0bmhyMmFDY3Zob1E3UlNXejUyUWltazl0aVh1bW9QMzloL2MzbjM5OWMvTll2M3c2M24zMzN2N3RKeWZtVHlVR01reTJVQVhXZDQ4K0Y5SGRzanZBcjlZUFpHMVBkMVVFS0NQdWcza2M2SW9VNjVVK01TcDNCK3ZRNVdBdGxHQjJxaW1UYXFhRUlxYjlNdTNuaGpudUgxZTZkRmthZytXd1FLdzNYYVR1OU4wLzNkMHNkOXpQdmZzaXhxQ1lnc29JbUdPZXJUZDFTa2JyS1JZdHpSZ0xVU1pHanNmS3BsbzhhbysydHJFaFRZZ1o2MmxxdWpqRFpDUXJvRzFGOGFpUmRLbHIwMjFMU3d5MGY1b2JJanFKN0xHcE5aTWJOY1NraVptSW1hL2RzZWFrR2ZDQzVrT0xKMjRLUW4zeDhRMTQrVkNhcXBxYWIvSG4zUFR3dWlXN2pOdnNXc1pERHgvYVd0dlVaTUtCcitGMlU5RkxzdnY1OE94bU9nVFJOaFhoOWZudDQzS1Q3ejkzbmx1NXV2MU51YllXNm4xeWRlQ3FSMDlrYTFSVFVHd2FCbHU2S252UXdrOG55M1BtaFZBYm5iM0JDdnY0YTk0bWZEbEtWdXFUczJucDZocXRZeXRqaTFaekZYTVRuNmE1dVBIVTVvT205Qzl1d1FubjYzbmF1aEJXYy9hVzIrSENObi8wMUdFUC8vRDkxUnlOQ3FMS1BDc3pyK3RoL3hoTExqcGZsWFovZjVXOTFVNjlmTkFiZk5sTmlnNDFpVjdaMXhvUXFkRjdFQWpUM3FpQXFmanNZRjBER1pTTVh0UG1KN1FURHQ1YzZvY2ZIbFB1NEFhd25jL240L0c4OXVhbFBaeW5tM1BVWm90VWloWFhYaVdEeGVOY1dZcjAza21LeHVuK2o5VWNDUituK0hHaUVSR3QwWHVsbHVDWU05dytmZk83YngrblYrYkw3bkQ5K2M4ZC96Ly9DUTVDc2Fpb01QcXdxNWxmSFpZR2tHMGtlZGhFbFpIWW1aYVdhaUNuZWVkNFlMU01pcElTWTMwdWtvUHhTWjZQRC9mVFFZSysvL0x4REpFNGtmWERZWGM3UFI3NXF0M2JtL3pUUC9jRDd1NXY1NzNSbGFhcGdvellqcnV0S2VpR1ZXQnprbzFVTWJHdVMrbHh6akJYa1d3WjJSb1pVemFLbVlWa3FNQ2YyTVc2OUN3R1FxM1lZcnFlenRZNmV4ZXZBN1U3UU9pRWdEbkMzWURZNWNpNlBZbklMZ21xSUlaMlZsUVNseE80amkyYXFLa1YrMVRYSkM5elE5R3RxVVlaTVRmOWRPVDZzdGpGVDZMcm43YTZ5VStsTkM5S2dvMVJ4SUNyWFkzbzVlM1RibTZyUi8zWjAvSHExYkhQQ29yNjdJZmpVd3VJZDQ2M2EyeEJyaTVaRytZNTJScXoyVGJsekNLYUE4VTFYTWFYOWxsZ1RBTThXNm9Qc2J4ZFdpTnF2bUs3Q1cxUlhvdldxV3lIZVdheTNJNFBqUTd1MzRpcnlLZTJ5UkN6Nit1M3FEREpCcDlNS0NiYU1pTnk3V3RtUXZlZlJmRXBhZGEzSTlSbXpWQmxKaWtlRjBmQUpVVThmb3JpWlRKajBqam0vTG1GdVRYVm52NXd2WmZUOGRoVndwTVpDSFJSOWVhUzY2T2lhTXlhN1V5SE1tRm1PREhCd1JxV0lrRUEwWU9KTVN2VnFYZUNRUFRJaEVBWlNaamtpTnNhaFBuaC8vN3Q0WmV2UDU5YW53NytVNGZRTnVoNy9rQnN4OVBSNVFFN0NEV3hjblhZSFdPc3VSU1MyUzNOcy9XWlZyeUpLVkRjTUQ5a2hhcDAyOEs5STNnMEluRzUzay9UZnFlZDVYb3ZyY0dpdTNsOU9ONU8xNzJhTmZDSDMzMC8rK094SEE0SGd5QUtCNUM3cXduRWJPcXBwWUJIQ01tK2phNUloUnR0UWZoa2pHUUlTV1owUU5YTmtsa1RabDJvRG5EbmxqM1Z6NUVpL1Z3UFpwRnhmazZZWGg0TE1oSGpNelgwWS9HTTd4SkdDSk9xTXA3a1MwTUJBUHVHbXNsdC8zdjVuSXgvUE03SWhNS3BUSklqRFAzOGFaSlA0YnA0SmhGZVN0eDR4dXVPRmJuUXFmd0VyTUxuQ0lnU3BCVmU0K1BIMjkzOGVEUHh1SzcxZFRhZlBWc3FNenVYcVhpT3lSa3phZWlxSWtaWnBiZnVaY2tRWm9zcDFBeEp1WVJ1cmVjV1Z4ekowY3ZXUWRZNHo5cXJ3c1NZR0dkZU16ZVZFVElmUTRtZEVEQ1BmYnVUTXBsSDZLZ3diMm5NWjRuc3hhaGo0cmMzZ3pjWVhZb2dGZXFlS3BDK0dnVE0rZFhoVzdQQ2dhd2p4bDJkZzk3T29LaHFLSm5CRnhnNVI3N0VKMU5lSU12Y3BMUUpwTm42S0s5eXZUdTdJa3BrbDBoMmlEUlR6YlBOdXhJbm55ZTBEcEV0T01NY3FRdjJkSnNqQXh1L1NKS0VZcFZOYXRsclN6V3p6Q0JDUE1HazVNTnVtZHJUKy9pN0wvL2lMNzYrcmVkLytRWW1QcFg3YmQvMXpDRE1WR1JJM0tEVGJ2R2VtWk9vV1BSa3dreUNEZUlUeldjayt0clBHVEJmc0k3dTY4Z2FSMUtHcnZYMDhlWUVsU2k3VTVISW9qaFBFK3ZUT2wzSkR4LzNyejcrNTk4LzVuUTY3eisvbmFTMnpENUZRZ1I0VkhjenBvSEJMdHd4NlNYaU5LS2FhTmxxYlQ3VEhkRjZLcGlKREJHVlBFY3FrQ21lQzhaN3RJYlVjL2owc0o3VEorRmRnM3JwTVJvSmtCd3ZDaXEySDhZb2dIQXptVzFzcHdEUVRaaVg2Q001NHZLb3FvSk1Dc0dVb0czakpjV3ptZzBDd1BrSjJPajVKUTMrQzRIRzh5V2JQNExnSzVPanUveXlNNVhMQkZTRVlzb1VTTDh1NTQrU3FqbC9jZmV4NlE4M2g0ZmpkVGxQMEZqUDY2eVJxZ202akhWR2dLUk1nbHJYeElwZFh4S2tweGREU005a1psSVZBMzJpbzhLYzB3Z3hNMDlyZUxhejdpWTJpdG0yRi9VeFdONktJS1JQRWVjaUV6N2t6WnRkUDhzWVFvdU1tbG5xUlVTNUNRaFVtZk5PWW02VktjaG1Qam9qNWpsSFRLS09EQytaRjI3bWlQRHBJTTg3S1VvSVZJS1oyUzhqSUVrSUtBYkNkS011a0tTck1CSUpCYWJsZW5wWWE2ZTJjVURMd0pDWEs2YWttblNWL2FLVE1qUlRncko5amtSajFFdW8yMUhaaHRCTFZwK0tSQnY3OVRFelVXNS9sd3BUbWsxbHpqemQvZnQvK05WZi92clBuRC9SY1A3MERXd01BTmw3aUhvWnlYb3dhRmUzRHdPM05WYjF3cUJKSXJ0UFVDMDc5THF1N1d4TWltY2ZyNklrUmEwUDhvUWEydmwwN3BNUWl2azZWczYrcXVYanUrdEZiYW4xL1AvODQvMHk5N2k2ZmVWeC9IaE1wdlJ6cUx2RWRta1ZFVWFxOUVncHhRUmlhbXA2ajR4V1RiWFZxQzJSMHRlT2FBc3pJeklYSytibW9zaWdDTzhVYlEwdHNaNXpPdXo4WThmc2V0QWpJeEs1eGIrMlJzSW1FWkZNS3BMa2VHd0dFSG9Nb1czVW5UcEVFU1BsT0lZbU5pTE9lbG5hUFUrYUZKQWNZZjNONjBKUktsL01pcC9HS2VYVFYvT0w3UTNiZUg3Yi8rS1RBcys0SzZjWklsdk94K3UvL1A2M1QyL2tnM3h4ODFDWFIzTkxsZEJpbGkzV0JyaUx1aU5EYUdyTTF1RSt0OTZZamI4b3UwZ3lSNXdiMHFCQ2d3NTVCUmlhbzcrUkNWVkFXMlAyNExvWXM3bFpDc1pzYXF3Q2hzUVRHUzZ0VFVzNVl2S3NIUHdEMlZTRitUTEYyNEQwQWo5anV0clpjdjgweGhPcVJWV29UbG5XMEY2QUZnaFhkdVptVWJ0ODFFWFJ4WVNKTENsa1JzcHc1bEZHamRlaWVYbVJzQTY1QlVpNHN0KzhuazhQcmJEVmlPMnFtVXFRU0poS1A2NVRrZXErMjBrU0N2Yk8wZVZSeURZUkxzek1Iam1OOG1tNk1RUnVhU05LTUdxb0lsMEVxdTZUU0llYXpycmUvYzBmNy8vNy84b2QrTWNlYlJzZUVTYkczb01SVUJqazlzdGpaV2dJeEFSd1ZETTE3NWtqREFiTkZyMGROSkNiT2tPQXBCcDFEQ2hGR1BYeDhVbEV3S2tZMzJmWVBnTHIzYU5FSEtZLy9kTS90MldSM0YzYmg0OTVlb3BwUXErMWl4ZVJUS2dnYzVvMEEzalhLc3FrTXR2a1hvb3J6SkQ5RE1sV0E5TFIxcFNvRVVtYjV6SU41Vkc5RzNqMFdKVklrYzdRVXFUbm5EVkZiZkpra01ydHFrYVJ6V1UzMm5DTWl6SmlTMUJoVzJycE1HYUhpbzE5aFpvQ1E0VDlpUW4xa3JoNHNSZVBweTE5aEMxZnZLL1A5ZHJ0MVRQK1dtUjdTc2ZDUnVRWmdIL1IwT2pMdnpUMllCa3E2QjAvZlAzWFg1L3Z2djcyb1pWcEN2L1orYmd2N0VzRFVKQ2NlbDk3c1JsQzY2bHFyRm03K2UyMElMTDN4MXVQTkYxTGJOTTVVU0RoRVVrVlJxUlF6YVFsMVN4VDFZbWd0eHhiMXRHWER6Q0ZIRjlzSStrd29UWkMxcS9lOEhqZTdjSnNvM2VhYmVXSXl3ZFVJQ0poak9YcWV1RUpGRE5SSzhVQWlZeDBxYUZXaExtZTNZUjU0UmVObHAyb0RFNXRhbTRRNnhkUkp4SUdpckd2VTFGQXR6dHdqTE0rWEVOMmgvcnVCSkdvS1pzUGRpUjZBWnpja2RxWDNmckEvYXVGaFNKZ2htK0U1TEYyRXdtSVRrNEd4SlFkUzdZbVB2dEpCQkZCM3dKN0pvQjZzUWtNRXJFZVhsMDluZi9QLytUL3RlZjN4NDEranU2YnFmblkwcnU1Rk42MHU0K25jYW9yeHRUV2F5bGkwVnNXYVYwc2F5TzFDN050eWs0RDJNY05VSVJNQzlUN0Q2L0tVbFRjY0RwVnhLN0pYSS8zNjBIcXUyKytyNlVJcmZTN2ozOVN3V1NHN21taWh1Z0pVeERKeVdKZGQ0YVV6djZoRkZlZmZOL2c2Q0ZRaW9tSVUwRU5pMkxUdkV3ZXRUV04wK2xrdldIUkxGUjFaWFlUZFVVdWNHU3Z2V3huejlqdUZYMlFZTFZ2cVlxTkJBNzNjYnNZVjIyU05oNHZxdWpsZlFFbTR0bWVTSG01YlYyZ1J2cVNDNkVBWWxzSWJEc0Q1L09DWGpaVkY1VXY3VStCTU1hR1JtTDdvT3Z6VzN0OE96Z1M2aFk5M3Y3dTUzLzFJSzl3L3RObmV6M2Rhc3NtUHQyeGE0cWtxQ1p5dE5vUkFLWDAxb09Qc3ZkemxmSjBneFAzZHFTR0taSTl4aWs5WWtCbXkzZ2VKQWh4RmRKS1pLT1hQQU9PT3NqbzJ4YnFrZ3NWc25weDBkNWt0M3RxTGxIS0dJNWw1S1ZDdkttR1IwU3R1OUpjUFh6dUttSnVZS3BxWjJPeFNCTXJtb2htM0JZclc5Qm1HK3Q3SkJNcTQ3RVUzUnhiM0l3Mk90VWVNbm9RU1dZMjgwR1FTOS9QcDhmVFdka2lBZHN3OXNKVUV1aElvZlZxUUs0bldDWEV4RWJ6Wlp6VEdPcldSZ29BYTZhYWxsQkZpaWxLQmxQMEV1akJCQ0Y4c2pZbW8vblo4UWZPUzM3NC96eEN2ekR0Q0hVek14dFN2S0M2SzlydXNOTU1HdFRuU2NoVFpuY1JkbmJ0YTBaQjdhbzRHVktLT2lqbUVMUXhVaHhFYzNRYzd4OXU5eTRNVTV1WS9lbTRYUFB1L2J1OWZQKzMzMC9MRVRwUDhmN3VoR0xxMWx0TGltUlA2VlJ6WlFLNjlMV2VlaGVSaUoyNU1CcS9PYlZwbmtxUnNiT1NmZFlLemJWTnl5TDkvUFMwbm0zUzg5bTB3UGFlTFZLQTNpYUNJYXFQbUhkeVBnMDZtNHJGdG1iTWNjbGp4NGhTNVdacWNCRW1xRUptS2pQY2lhMExnQTJmTWM3ZUt0dTkrZm1ya3ZqUnJHbWpYMU5FZFN0WmJkVEJNY0Y1dHBtUDN4R0ZrcEl5L25lUy9CZG04NjI0RHdCVHByZ3h5KzY3LytNdi8rZFhmL3ZsL0tlSCtXZnk0ZU9mNisvZXZmcmNwbVJDZ1pPcUM2THRWWVJNZHJjbGtmckRZWlplcFRSQjVjR3dXcGdLVUZNMFFqUkdVWS83cUQxQ2xZU3FqV2hwVkpIQ1ZkVjc5VzFBWnpJcW5EcFNWdm5JR2NoNitpTHVqdHpiMHh1LzJHSnpTKzE4c2dzSElHNHQyOW5FZGpWU1ZSRlFLeENrRkllME9wbHJzU2N4QnpPRkY0WDBHQjQ2ZXFUWWxwRFJGeGpiNWpyem5oUk45dWhKWnA0TGJjelRwcHZwNFVtelo2UlNMWVVoSWpvaUNnQlNWTEp5MlVFUVpOSktNYW1iZjdpclpnNHdZZ1NKa2lPV1gzM25aR3NtYWZBUmdaSkwrQURDTlFnUnpTZGZsSkZpLzZ2cUo4UEtzVnRUc1V0aEd5VzY1b2Q3bVErVFh1Mm5xWlJweXFlanRETktQdFJGckV4bEtvNElVU1BFY0RxbjZCckpxQzJhbWs2VGlmNi9qTDFia3l4WGNxVzMzSDN2aU15Nm5Fc0RZSE5JRGFrWmphUVpreDVrK2dreS9mOUhtY1prbXFGUkpKdmRhQURubkxwa1JteDNYM3J3SFZrRmNHUWpQSFFiWU4wSFZaa1IrN0o4clc5bDBNUkhxTklKallyczVGbmJ3NmNIN3VKamJOZGNkaUp5V2ZQeW4vL3VTd2JhbmVINjg1OWZ1S3JhL1YyOE9HWW5pU3BpMnpZL242N1BsOWZuU0NWRHpCTTBnYitnK2ZYNTh2THQ2NWNYQi9QUFR5Lzd2anQ5dkh6NStud2RsNHJPbUtvdERXVitKaUN6aXl0SDdpT1I0ZHJFOTMwb3E3VWdNSGVZMXVEREk4MGtBaFlSQVlFMGlkQVYxMjVhZUFGbG9Fa0tNa2tSV1JiczNzNzFLNVNYUXdIYUFldXEyNUhYRUppRjloSzF1Vk5KMUh4WXhFeVpwSm82RmQ0aXhUS0dNSmtaY1UwaUtRWXpJZFZhYXBlQmhXM1JzZFBhK2NUclJUNUllL3lrMzhialQ4djN2N3Y4VWY2SzF3dVZxVTJGRkd1Um1TRHhoQVlvOCtINUc5YTQ3dHY1Yy92amo1LytwMzhta2U0VStNV2x0NEtMYTN2OS9PSHkycGVBbW1WU1VybUhjcHNPYnV2MGdQV09DRjFYK0dvTnBIVTNqSUcrdmp6OGN2NWYyei85dnJDUVVHc0ZocElaL3JKeWtoSWpsOHYvL2FlMkFrZ3NkeFJ0WmdwMWFkZHJYRDczODczdGN2OFArbUc5NWlvcXVXOHVyU3ZCSFBzbE9kSWF5bUNpWFczR1JWc1RpTDg4blJaWkczdEtqZHE5cWZSVHAzejQxQzZYYlo4cFVsUWxXYjFtS2xGMEtWVmxocGdpditDOFN0ektaT0hNYXIvVjNvUWxYUURiTTMyL1hnZlVVN1daYXFvMUU2RWtJZHd2VVdZbzBSelhqVzFwdno0dXYxK3o2OWg3VFJXL3VtSm9iNnZadEJZd2lYNzNPTlRSVC9jblNYVFAzcFhQTEhycXpMaXhOODMwbWdGRHJGRUFpL0FwMk1pMXYzNzdPVFc2Mm5yMmdWVkpiZjdsRDdIWlVvSk1ScmdzZ3R3eE9NMkJSVzhtRUw1dEx2c29rN1dLS2hHekt5a1YyQ2xRQ3A1UlNDdWJkeFNSMjN3TUljeEJGWGdHVkZRTjFvT0lZcy9LY2lDT1ZiQk0rOFlHV0RQd3NXbUlBejQ1bzBNTnNhdEpsYU5wbndMd2NUc1I1TVJ0VExPeXZHdDNyWjFYVTBtZExveHA4cXd0WTlJK1FVenZLTXU3blhWcVR4YmdtSVQwS2c4TXJjNUVPVFVLNVFoSnFVVG9Pbjc4eGYveTlObC92dHJkTXI3MTMwbjg0NytLb25PK3lWOVZNU05qUzRxYWZYelpCdVRpVHcrUGYvWHo1Ui8rdzkvL3NUM1l2alVtR0hzVWo1QmNsbVhCcU91K0FxS1FSU1J0TWluTGxWY1phV1hwWGdMUmxucGF0Mi9iK2ZQU3Z6OS80N2NQK2l1ZGJqYkx5ZTB6NjVJSTkzRjMwcVpiWFpqTkJEdmJvdHZtVkd3ZzhwT0VvL2RSNEo0eStRbUxKQk1LS2hOYTk5TzZ2RXplOG5yWFZTUGdKWUd3UjNhOVJpd0pXeFA5RmNWMHNZcFNTaHg5MWRPWmw1R00wZFJNQkNZV2RaeWdFbFE5RnUwRWxTbXE1anBISGJqMVN4MytkaWd6T2lxTUNaTHBVeXY1ZGF2Mjhiek5pdUFPYU8vZGhMcmNhU24zSXJKZzZMcmdlUUhhL1psNzlKR3FEY0tBU1ZaZmlDYTdBVEVrUmFscVdoQ001aTRRVUFYMDdmbGx2V3VRZGtyNWRvWDZzQlpmZHRQbUlaQU1EeDlZRzdqSFNDU29FNjVJa0FzeVEyaFJyMEFlYm5ROWFJR1FKc0ZhVmc0cVpTWWJTdzdVMHYwbHJFbTRKNkhhUkdEd1NJNUFwQzFMNWhWU0pPR01nSm9xN1hTL01Fd3hISkc3aUJvZzNqVmp0TVp5Y3VSU3VZMDY4NHBBMGdzVExFaFJVUG5XU1NXRjdvRWVtYWhaZ1RaTEdESFhrT09ZeDZwZ1FSQ01TdnBsUnRIamRES0RCRytUSjg0R1RnakF6ZTBoM1BtSFR6K3NEOXYrdkZ6K2NIZjNGei8vK0RkTEcrVlVLd2VLMW9tSE9pcU5kMW42aGpWZjlwL2E1Ky9rNWZYM0g3YnRndVh4QWxVaTA0S1ZGWFVGSTYwTUVpSTJjRElmNWl6amVrMGpHV3hONmJpUmpucUdjclAxQjZwOWVWa2tCY0pmcSswc01hdUFKMFF3RXVxNjVEVjlLQ2pXTWh3UzFKWnAyTkN4bnk3UExSWnpoUmlBMEFLRlFVMVRoS21lTUF2WHJDK3FGQWJCK1g2aHpsWU5nbHhmMldMUDlzUFNZdHM5RktsWm4xTnhKb2o2RWxrbWl0VE04Q2FuSENLcTllb0JzR0NWYkVXUWtTbGdDclVQS2tIa0JHQUFqRHhFdDZtd1pYSFNJY2dSamIveTBiNGJXVXk1ejRTNm5CcmFzcHpXcGJjQlNqTnQ0clk4Zkg3YUduVlpUOEdueUl3UTBacG5VUVdpTEE1eHVzNlRDV1QzRktzc2NTb2g5T3NXWXBLcU9QbXIrNklSeUhHSy9YSk5hNjJNQWRqUk5ZWW5tTWdHaThwbkE1RzdDMjlsMzhraTVvaUlTSkJkUkNVejdYaHlhMlZNQTJ2SkV3U1lZcTB6Q051VlRLZkNQWUZNVFZIVjlLbGxBZG9YYmFhTGFETWtkcUh2bzZMaWhDaGlHclVEY3lJdHQ4QWhBVFdXOVdFU29BNUo1bGZGNWlYU1orcGJuK3FCNkVlQlNtc0REMENaQ0Vrd1JCeGdaY0ZDUWxNSk5pSEw3SGlsa0dJejY1VGt2dDdyMFBXUDM3Ykhmc1pZL2ZYS0QvZXZUMXZPcm9oYkJBSUEwRndhZk0rdjU3YTBidmpwOVovSFhmKzQvS2dQMjM0eWgyZ0hnM3ZoSU9QNlM3OUFJTVZuRlNEUU91cE56ZmxMQ1ZJSUV3KzFlaVV6MVo5ZVF1NU95eGY5OXVRUG55N3Z6eWZWZmxNcDB2bjNROXdvcmFlSzVHNTlLVE43YUhveWdDRVdGTzZ4RnowNDZya3NQSmNRaEJac2dhRWlXZE1zdmZVdFF0cVNrcEFsUjBZQUlyRGMyLzBQc2IrOGJwU0s1aEJIMzRZbFdKc3lXQzMwR1NCMUo3MVpwNVVsaXBYNExyZXlST1NwTGtSYVpSMHM1KzdraEhFMjZvaHFhaDBnRWFxS0JCdHY3K3R2ZHVDcDJXY09rNDdYeDNaYXJaM3Zucll0MVVTQ2V2NkIrcmdsTGNlNGZoc09MVXN4NTZGUGpJS1FlWit2NkJuSU1MU2VlN21hMVBsNmNVbEpFOUd1YVUwM3Z5SXYxNWNOVm41ajdlU1FwaGdqbFFsUU9aQk1VRGJuSGlLMVV3Z1Jrak1vRElnbVF5VVp5VFl2bUVWbW5EZTc2alVSRUZSNERoZHR0WERxU0Q4eWhreDR6RUVQVDNYM2dqYmRueTdGWFhpSHdhVkdXbmtsSVBXL0pHdjM1QVRpbFRndHM5b1l0L2YzRGNwOWdCTHljRFFmSHJBNlJpV0Z5aEF5TFdsVUt0VVhJQnFMZmFzQkdJWE5XZ2hTaWRCNmNySU90Y0Uxb1pMa0Q4L1hiMnM3UDd5dS9mcHErdkdwRkoxOHk4N1hWbUlnT1J6eTNPOWwwKy9rYWZ2NXBkK2ZjNzFjN2Z2eDk1OUlVVEpHMlRhQ1QwSXorUEVlWk5LN0thZXA3VzM2VmN2SlRFU0lyLzMxVy8vZC9mWnQvOWhlY1ZxM09wbStqendmaGFhWXJ5QUpvTTBndndNeGtra1ZnZVgxTHFWUllvenN5eERwR3lCQXNOVjZxaUVHRmZnNHZqKzFJNUpXT0l0SXFwcjE0ZUVwZXMwbWlmTm5IOXUyZXpHa0lWcVZPSmkydXp3QTJHQ24xSUdRekZ6c1dIN3FxaE9aWkpxUXFaWkNFbDIwQ0dsMUlDa2d5enlTbTFVMEh5SVNVQk90NmozS3UwMVliam5zdVFNanRaMzZaWGRweTkzSFIvMDVzalVONnlueTRYTThYN2R2bCtiak5jVkVWZHVTanB6NFhoVm10WjJMdXpPaTFSY2xIVk10cFdubWNHbFhFVWcvMzV1RytxczRQR0RZL0J4b2JaMEdpZlJaZGltZVBFYUpqQ2dPVWtwOUJqbVA2Z2NXaWhHVThyQ0JZODRTZkNiL2NrcE5HZWtCU3lOWmhZY3BrbFVkNVlqZ1lhd1NNQ0xpOWJUNDYyYUxUOGc0Uk1nVWFMMzNpcVNLNmVSaDg1ajJpcUFLaWRwaHpaQ2pTUDB0NDVxWVp6RXlwMjZqUkNJUkVzeGtUVUVZQXBQSkpNejU2eWlwaSs3UnFyMmdnV1FpODY1WkJETFdpZkRad1ZUa2lQWEI5aXQ2MnBMN0wwMjY5aUplSGgrZUVFd21ZMlBzZXZyKzY3NWR4Mm45Zkg1K2ZyWVl2L3ZoY1hzMit4QkpCUmhlZVRDZXR0RzZ4TTNtSE9JWFc5dXI2ZTB1TTN1b2t6ejRCU0txSGJrKzhHdCsvTzV4RFhreHhWSGFpL2VrbVBuUjBjUlU2S01uU01UZVZCMU5oVzB4QUZ1T1VLU0xlMWVyeWhjcGp5ZElhU2JkTkJYbXhnbDZNYXNPbmZKME04Wk1aSk5KY0lONW5oNGZSNkkxMzcyYTUzRHJWelVCQlZsZ0I5WnpwcGxxa0FhQVVhcXlCQlFPQUJIUlZEUlZwUmlMU3NsRCtEaVdoSW5XRUNDTzZMZUlLQ250SFV6bk55am1FckhRRkxDK0RIZjc4QmVmSGxlL05qMjFhSWlVdHA1ZThuS0ZLYzV6anRvRTIwaTFhYVFGQWMzQVZEUEZqTXdBbWpFVGhHanYrN2V2NXhORUllc2p0K2ZYNEFpY3BJdEhacVpLV3hRU2pCeE9MYWJvRWJTVG5FRkFKMG1oV0NRVkFzbnE3RkJGUWt4YlRWcm1QaVlTVTQwYldsOU1oSmR4anF6YlpOSERKVlVMa1Rmbmc1c1FqTWpyV0lUTHNyd1dvQmhhZVZocHNJWm8zUS96WFdyOTV3MW5hMW9DSktZV1YrdmxMYzhyUUV3L2x5Q1BqdldjeW1FV2lFOXYzckQ1anNHSmNKR1U0TEl1dXRYL09hU0hnK25SelFDSjBWSk4xTERyeHI2YzF0ZEtQK3E2RFpydjJvVE04amZlK25hcVFOSG9tOGg2MzY0NzVldmp2VzZiWGwveDRmUGYvT08yL3NXZkVYVUdCcWpWUTJ3U2FUZnNpSTFydjE5b1J4Qnl2a3JWQmFoS1FGWDdZckthNVI2Wmd1dllBQUFnQUVsRVFWUnhaMXM3eWJnanN5WVc3Mi9BOCswdG9jbE1oU0ZpaSszWE94T09YRHNhWGJRMTJhOG5lTFRsZGFSSmh1YmNXUlZNSlV4TER6UzFaRW9MRmNoMG9rTWdTMDF1d3owZ3pCUk5YejU4UHNVQXRXdStNZzdpcTlRVXFUQXBNMFpaaFc2aUhHeUE1TzBuOTZicHFVMnJWd2NiYmJxdDN6SVZBbWJORWtrdHdFQ09LUUNabHNqeDZ6endmMEhFdXR3THgrNmdoMzM0L3ZOZCs0YlZUazBHeGRyRExqOExQWmVsZlNLUWRLNlNNUWpMQXlGVnZWZmw0Vys5T1lNSlZTdGJNSGFONjAvci9abHFZdllnZjNqK3Fzc2Ura3pmZGl4M0VLZ1k4Zmk2UjBhaWRwcWtzUHp5ZStuN2twWHBrNFU1RWNKNW1Kd3lPSjJ1Qkd4NjhQWTZTOUlyNVFFa3RSbnJYV1VsOXllbGlreW96NU5ibHEvS1BvSVVlQmdKTXJMWDhGOUVlaHVqOWN6YVAyVzY0RzkraXVKWFRHeUN2RThMRVNTTmg1bEhhNWg0c3pvWHV6WkpVbm1Mem5BT2dDTTF3eVFsRFUwenZVNFMrVUFoTS94bFdzbGNDK0pCWHA3V3o0L25mL04zZi9kNi83dnY3ci84NlhXOWs5UmRZc0MwK1h3RURqUlA2Rm54YmZOOE9PM28vTnJ2RkxMbzVaLzM3NWZ2WDE3R01tWVpBd3ZUT1FLU0xpMFBzNWxoZCtzM2F0T1JPWmZ5NkFrVEttM3A2ckx5bW5kMzYvUEwvZmU5VlV1cHZxWGo1ZzZzODJZeExDSFdXcE9lc1dNZVoyRXRyN3RZdjFmZk93Yjd4eXRiWnc2ZHlGNFhTVmFucnJ1aTZQeVk2YkhVU1ZjVFdSc1NTRzVNS0ROWEJ0ZFBqMjJNMTAzdjc1Yi9ZN0pKbDNuaVBiNVRlZWRTRnhGMVJMbHQ1OWFjMEV4djBKSk44VEs3alRoQjdpd2RraVpxVXQrNk1EUGNTc1RRTW82SS9lOUZYS29EcjRpOFpkenFDK2tBcmk4dnIrZHUzLytQLyswWjYrTzNwN3VYbjA2eFlIT0w2OC9mdm1uVHU4ODI5bkY5M1hPSllIbVBHR3hOTHRvQXRTeERqUFdVR0dneUNtVnNZaXJhdS9vUENHdlhmL2hQZnhobUFJZGVydUEyU0d2VWMvUFQvYjM1N3RFNEsvYktHNU5adFpGWjd5M2dwZkNPREZZcFFYaENCU09DRUpVNGFrVzdEUFpHUlZhQVNkU09zdXJTU012akRXT2dxVThQYmMxaEMxeEpvRUkweFk5UkZSTzlseGcwR1ZwVXpMRkFCRDY4UG1OcmUwS2FJa1VMSDIzbDRlZkI4amxxL2Vhc3UrcDhBSVEyWlZJa29VdFgwUjNxMmpaSnJPSkRMNGFncWNscFVXbHFiTUlnMUFpQTJuWktiMGhZakZSTkY5YUtaNS8vbGY3REgwLy8rcjlieG1obkhic0lsTDQzazlUR25Vb1BRYVJrOUhzOGZmbjhLYS9JbDIrbjl2eU1wWS9yTlhQWXc3MWZzN3hvaC9pamhMWFpja1V5UnpZWnZwV3ZkSnJFeENnQ3NkTkpXMU5UUVdaYkpkZlA1OVAxY2pvM1V3R3N2TU5xeFQrYk9NK0o0MWZoMDUrK1pUL3A2M08wcFRWVmJhYlgwMW1TNDdyZTNTOSsyZll2VjNUZHh4SXpHTlJNMHgyU0FWdE1kWVFuMWF5SU9UQVpUbUs1dXgvUmw2YXhienVFTVBhMmZ2OEQvL1RUbDI5WHFzbVBnMHRMOUFVUWc0OEtkVUMwQ3VzTzZHanM2K05KUEdHTWZZUzBRZGpTSlN5Q3ZyT1hiUWRpSGh3YjFub2JiWUtZU0FneTdmeEJOVk5hWHg2eERVaU05bHREUEc4bHJnZFFXS1d0cHlXaWYveTBJbTE5bEdWZG0ycFBvdG5kWXE3WVgzUkUrakN4Y3ZNSndWUm91MWNUb2FkUmtobWpOWlZRU3BUdkRNbTQ2dW5EK2N2amVYejU4WTlmNXMvQWw0c3JOK0ZaS0Vwb2I3YkFoOC9tMERyUzBpZnJVc1g0NW5wNkE3Rm1IbnVJb2FhbGh5U2lnSXJTSi9hbnBqV1NlZXpjYzFMeG50NUNtU09lS1dqanZlZzBrL05DYTZnZTNpbXlFS0lXdGxzVFFSUXdSQVN1MmZoZklFd2NzdFpFNWRTNU9rWEE0TkVucDBydUFTMlgvN1JKcDBDUllXUklaR3AxdU54SVlkV1NpOE1OSWFMYXdLZUx5c2QvOStFLy91UHI1Ny80WC9LUGY5cmJCNDdCWlRsZHFQMmtyNFdCUldhU0ZGdk8ra1E1WCtMMHRKL3ZYLzNWUGo2NXlnWG5rK2RsN0RBNTZIKzh4UTVxcjlVV2duWWFwYUZMbTNhY3lNcGJlLzNHOUZObnY5UGM1YzU2aks2WnlSbmFlamZ4NU8yL21LQVlGbVBybHZ5U25rbnk5TkRUZW5LUHc0aUtraTVuYndlcFJqWXJqamlsSmJKbTYyWFZqcXdDbkE1cDlPRkJaTHAwdkxZUHk1ZVhWeCtlTVY2MHpVajRWcnlEbVNrcDJ0UVJJQUdJSGsvN2FWSHpaS1FBOTJLS1VFc1dwZlErSWsyck5CNnd0czliNyswUktmUjVKQUZHY295Ukp0RDIyMEpSdmcrc1RURzYzNTBXT080Zk5WV1dEOVIrSWdGRGlqMStBY2t0aE9BK0ZsUEpRdjZDbVZUemNGWFVFSXlTMFp2R2RsdVd5V3djVDNxMlpXbGYvLzZmWDdNQjFDRDJrY0pFREtFeXBlbXlySEFYcjJLRldSMUdDcGd5aWVaelJKSk1PMkpqYzF4UXQ4Yk13MzhMS3FuTklncWRQcE1Bd0xRaTFrVDJPQkROaVlQTWROYXYzSXE4aVNzMUpqTkZacXBGVm14OE54Z0k3RjBVekxKY0tpUzlzWGlPYjBYcTc3c2hhejNncEhPSWFDSTlFeTZ0NW5QRnpJdGtGSlVzcGRTakpEQmZWdU5rMXdqUU5YM2FQak1FRXFMRzhici8yUCtiZi84Ly9QNmZudit2di8vOCsrLysrOHZyQzY4K3hzZ2xROUNhWVRhNWw4SHFGTzNiNi9mbmphdjhlUDM5K3ArL2Z0SkJreTBlb1BmOWFhQk53K003djNjdG9hWXRRTHQvNWMwYW1oQTdhTmxsVWhaUkYyVC9tTjhHem91VnV5eWdrL2FaZHVnemNremRsSkZqN0w1WmJyc2EwME5QRnI1V2N0SXY5OHlJa0Vqc1RIR1pLQVlYYVFMVDQrclZVcHc1QndZZ3E0S0FITmE0dTdzS01sTlZ0L1YzZHovK29nSVYrTTYxSlFoazFKNWdwY2xNRUFONWRETXl4KzVpN21lRnBKZ1JYcVJsaWdyVDcrcTlwdUlvaEpVSm5EdmNOd0RTTTR2Nm1UdEVLYXB0N3JtL3dXVWZ6NnRBbE5UZUZlbGxZWkh6SlhWNXBkT1I2SStudGpQall0cm9ib2lpRkVvRElrSWtSdmF6MWRPdGxIUURQVXk3WkNhWW1mUnN6L2ZibDE5Ky9LZVg1VzZRa2xsS1V4SkVpQXhveWJxbngvV0o3bE5RejRxWmliQVVHM216Q3BkbEFzdzhYcEY4Ti9DbWdCTG92Y1dNQU13TGFFRXo2OFVxS29DQ3YwWXdhUVdyZit0ZkV6bHFhNUg3anQ0SGlSVFZ6YkpKUkFqVERTcEgvZTloUkxoNXpxY2d4VG41VlloS2pTQ0tZbEZIZmFUTklYR0ZmbTBFVmNuc2tsQ1RQdVJ3RTVXeE4rYlJ2NHl6MVhjWnhhMDIxUXowUC8zODEzLzd1OWNIZm52K2g4Zkh1MVAvTk55dlZ4dVhDODl5M3BpZWttNmlTZGlhVDYrdkQyMms1YmYxOGE5K3V2anJlV3ZtcjEvYlhUdjdDTnc2eUlwbUp5WENRYUNhdnE1dDV2MHBTRFpCV1M5emlLaVpOZE9JVXhlMGZZUXRFVkVoL21yUFNLWGVSbkczRFRnenR1ZnRaNDNnMnZJRGJEMzFvbk0xN2pJUzZlRkkwRUVOdTBtSmRuQ0hoS3BRMEk2blJFVEVOT2dac2E4cWtkUWVBN3BBN01QdlBtYnFza01obFBSa2NINm1ncWJiRVNtcnRYTCtPNERSYkdud09LR3czdnM4b1NtTG9rb2hYRVRiNUM2MitYUDQzRUxLWFJCbHdVdVAwYnFxV0owQTVGL2FLWEVEeGVpYzBvbTFMa1Rhb2xzN1BTdmRTYXludS9NMUVUNFJ4WEpwWmkxVUdqRFNoWjNSbHFXM0t5a1FKZzNoWEpvbzZXUTJicTYybnNlZm4zNTVhYTF3Q1JsQnBqT29tUkV4ekl5N1g3eDMyYS9KMW96RENldHR6M1J5cXNhazBONWhnOTg1dk1jMG1rOVBnR2FJdHZxOFNKQ0RrT01RTmQvK3FscTZVZUxlczIzS3AzSGdYT1hkL1dOWHRaNGNVWVljc2diNWJFSlBFYnNOTTdYY2c0WmYvN21IN2pHZFBUS2pkNmdpTzRGQnlFS25rb1hRVldQS0VnbGc2Yzh5UGRjVUZRMzQ3V2RMSXFsVmYxdGZhMXZQc2ZSdmYrYjV3K05majh0MWZIbHBjbmZ1NjJsZG56dTNvYTFkVVN4d1UwUXlJZWZMQzFxN1B2OEYvL25sMzl6L3h5ZUpMNmQxd2JQdVowaEVsL2VlS2FUTmJZZ0o1TDcyZGRTbkVNcWdJUzBUaXVEU3JMWGUydkpMZmxqMnZJdnhkSGRDSXVhQnFDNUVCMzZmTjRuY21TS0k3UWVOUVpNODlXNTBrU1drTGRFNnVnSUtsNlpXSTZKS1pwc3BOT2kzY2JSbytRWU9JSkVvUmEyZlRrc2w2YmpyYXBueHU5LzVNODkyamFBSWNhM0pVTHJKdktyZXFqUG12NnErVmUyTHhtaHRFeE1pTlVGQVJSUFZNN3lkVHVKcEdzSk1ZVFFjSU9ZM0k1MXd1aGN5L0tpK2FtK0VramNWV3ZEVzFaQW1nMVJKMVZLL1lmVGwvcWNXSWtCWC8vanBlazB4RXhHajVPVmtyV1ZDUk5VenBOZUNrWnlWb1pZaUptWXdFNEZJODVDSHo1OGZ2MTIrdnRxU3o1MFV1cnRxYWhvc21VaTB4WmpYYllpdUdCQmJXd2dUMXBkUjBmcDZqZXBnclJTazVOdjRYeUJJblRQMmVWZE9VVVdpMVVHYlV1Nmd6TWJwdGMxRWJRL3o4YitCT3V2aDRYdUFpVXlEa1NTOG44NFkxMnVsa3lCTHNXeTFXSXRKbDZwQ210WU5lYmNEMzFhZWdqL1BVZkRNdjFXclJJMFdFbm5jMEd0YWxxU0tJck90Vm0xS3RRbkU3Q001WHFxTWFVWk8zWW5nMGxyenUzK2pML3JoT1hIcU92YVgxeVo5MWR5WFZaMmVDWGMzeVZDemlCZzg0L0p5cjFndS9SUCtjZm0zL3duNUZBOUwvbkQxWGFYTnEvdTdwdmczU1VKeWJOWnprcUtCS0thSmFEUGVPTjBtN2R4ZVpZMFlEUXBKMWtGeWhuZ3Ezc2c4RWxsdzB2cDZpcjlwK2JydFBxSkp1a043RWpsMlgweFNXd3kwWnFyV25LU2dqbFlFVTk4MTNXQitaeUtDa1lDMDg4Tml6TEVIbDFGTUVqbkpsNi9VWFRNRFFteENSOVAwc2o2LzFlSE9zZVBOV3hHdld6dmRuUXRSQU1uM0MzOW1ScU9hcUY2RmFXMk96eE5pTWgrM21iTHhLYXpZdkFvMi9PWU1MYjlpdUFEWkxCeXRoKzEvL3ZObkVVR08vZTVNVW51NjJQM243NTVIYUd2Rnp4L1J4Sm9UWWJkNnJkeURvWE1oam13OU02ODk2bXJuY3ZmcCs5L1oxK2Q5RDhrU2Y1RGhrb0NZbk1wRHBQMnFvaFpSVmhTZG8xY2dsYUtCUEVnWkZGT2JIWlFsT1JGSUNURnRWZ0g4SThxZ2xwNG1jMEpqVSttWWNZSFNlaUN3dVMzT0QvendGLzlhOUR2MlRnRnRDSlpXSDN0Uzhqd2pxRFZOSEJCdEJpMU95MjFjK0s1ZTd1MlF3QnVIU1VRMGZPUlU5NWtxR3ZNR3hia2toVFJjOXBUcElEZ0lYSkd6QWxsc0VxTjFUb2hWdVcyaXAyejkrbFVlMnFmZjd6Ky9MQSttTVJJZERnUTFSekk4UkxGYlU2UzdhTDl1Y3JwNy9HUC8xL0gvdEg5N2QrV2lsNnMyUlJKTnhwc1JhTHBBQ2dJR1FDUjJhOEtVV1ZvSU5leFFhMzNXVVFud1ZjNFdrRmozRUlrU2c2cmFxYnkzVmt3MUhvMFBHczdRZm5wYTVmcnQ1YkovNTdHMlh1UEwzRWZtdURJRjdrczlpemphbytlc2hWSlVQc3JVVnQ2R0FZVDJrelBEUFRMWk5hbkxRN3UrYk1pdFIwbVZxVGtBZFJOQnhpeXBrbmN5MjJTVjVSak5GTkhVREJUc0VEQWdWclhaRGY3YXU4RXBETkd5Y3FSTVlBTW40MU1pZ3hRVmhaSFNPckx4TjJpV2d3bFJOa09VNFVHMEwzejVwei84OVoxUmZOL1BTazh4Z0hsNmVEeC9nVFROQkpDdUZHdnE4S0srUTR3UWhVYVNLc0FlcG0yTXZhSlZxdGZ6cDcvNXZYMzVaY21NMVBVOFFFa0dyNWNNOGNaRnRZUEwrYVdmRnBJY0JYZE5keEVpcWgzM3NPM21wTkZNYUtPSUlLV01Qb3RxSFhKbVRxcDUwM1MwRkdabTVGcGdsd21KNUs5cWttZUhEaW95VXRGNmVROUE0TnZVNzdRL2IrZWxyVFUzemhTbUowVmNWWkJPVldnU29rV09sZmM3K1RzZTJmVHhNQ2NsVmlNOGJacWt0WUxHeHhhY0JPaXRJNjh1OTJETzU3R2UvQm85UW1obFlxbGxOWmZlYzkrY1QzZDQ4YlUvcmQrV0gvNVcvL1RIcGd3Tm9lemJhT2NLSnlhSnNUUVJaclNVSHRmKytQTEpmenovOWZQL2VlZjZhRCsvdG5CWk5hbS9haTg2SWhobFJoREpHRzE2VzBRcFZFMFhrZGFxb0J3QWZ2bXc1QkJzOTlGTW9rSzZ0eXRlZlJTSG83M3l6VnZHUHBKb1BhK2IyVFlDZHkzaWhVMVYybnE5TmtqTHNVSExEVjZTa2s3VWx1Yng1eFBNUEpDSUNaTmtLb1JlVU1paEozZ3NweC95UXZQdGNpMmlUSWlBcWVtTEdWalRSeDZyMTVzaEUyaXA5eC92a1h1dkg3OU5VRDZGU3BNdVkxL3VseGlyT0Voa20xazFGd2dseGNORk5LTmNBSW9sYU11Q3NQK3RQbDg3TUMwSGI5ZTBQSDdLb0hMc2xQWEQ3NzU3QkxILzlIcU9uNzFiSnNpcjVkZG5TdURvN3VpR2tXakZqTUFraVZxTENGSE5ZVEVDVEx3MjgxemkyL25mL2Z1SHkydmFpMmRyNm52VHB2UW8yVjdYczZUMDArbHVIVDJlOCs0c3IrVWZIY0tVM2d3K0NaZFJ3MEZCT2R1MDZxc0xLU2ZTak5hVnNMWVpJcFhPWnI1RnphUkVBTGVsU1lweDlxK1EydGRPWDJxYW1mUDR6VU13bmE5NnVTMTRkRmNMaEJ6WERUM2RkVEcvTGhrWlZPMG85V2JYYnBtemRBckFJWFRQZm1ER0Fjdkp3cnkwd3E4cTltenFNTkxVaExuS2lLVWxZOW0zYnJMdVRVbmt0cXBoUkZ0Y2xXUG9ZcFBidldnRnphdVJCbWc1UEtIVzA2V3BXRXBlUjd2L2NGbzFQZGY3KzNqZG9XTDV2QzNMY01uRll0dHBUaVpVL1F6M2tmM2p6MXU3dHkyWDF6cnNRZUNEVFRJSVVsb3JSYzZVanFWUjJxcDdyTGxMTzNsK1BIdlFtZ25FUmtQMnUzeStuczRjc3E1YnUrK09sbTBTWmFYWVczQTFwa3JhcEJjTkpNZFBQKzNuaDNWL3ZxSkJ0WFVWd2NuY1Rud2RwK2FEeVZ6UGQrZXUwa0JSRlhicVlva216Ymh0VWZhWlRDNWFxeHlaZG40OFk2Y1owdjN6Ni83dytYeDZ2TnN1UXhDNXB4Q1phRW5WV3B5aUxsS1JGS0xWK2FEcFhOOWI2SG1sdEM0MVZranJoc3pjeXArSVMxdnlaVnMrcEZodmxXb3dNek1DbVI1VElTZTZxRFZUYWEwck02WDl4b0IxQy9mZm9FcDFsbDIyVU5pVWVETm9TRXgyNHZycGx6RjRtOEh1cXhuQUxsbDBsNnpMVGs2VTZJQ2FhWk9UUXA2ZWwrLy93eWQ1dXFqNGNWUzRxaUxjc3lYcjhNSWVMNXBTSWI0WWlZYndZQ1NuR3k5dkJUelZTRHVqdXdlNFJDc0g3Qk82dXFqSHRCbFhyZzJBdGdWN0t4a3U1Y2hndm1NdXY5UEQrR3RMSDMrcjNWZXdnWEVZblM5VkFDRXppTTA2S0VLUEhvZGZNV052ZlJodnhNbWNsc3JrSlB2V1ZRdURiYktWeE15OGp0cE40QlhnaXFwUE9xSjNRS0I0TVVoRmZTZEhGWTFrWnZBRTd0L1NmQkdCN3prZTJCUDd6azk4M1NOVTFtL0xkM2QvL0luTGlPV2VyMStXeU1TZVl3M3Vlc3BzRmJBdXNzU2hzRSsvK2xHenhrbklCaUJxWmtJZ015S3gyQ25EWXFSOFhETk0zRThWaU9SQnBKaGdYNzdOMzBtK1NSR1FFYnNzNGhCQktESTlVekQyZGVtU1NtbUtQTElUa3NoRlJLRVV5VXpwWnA0ZTFHNEJOUkhDUW9Cd0dwZ0owNi9ySFovWHgwK3YyN2JsdUZ3RkFVbGl2SE1yQStTeERwY3hYdWpIbGFKcW9VdnpURUNZZE04NUJsVlJSSUsrTndaeFZHUUp4R0licWExdExJUkRNNlduTkoxTXJYWThRbThlckhlUFpJa2hLZEpQejBrN3JSSUcxUnhjcER3U3Fqai84TzNicFFaWEVMajJ0alR1ZGNNaGh3aUNWWW9KaU1aVVQyTTNOZjMwdDcvbjYxT2VWRElESXNSUWxkTEFKSk8rcHlFY2RwSUVWTUtwYWw0QklBV0RTa1ZXYXBiSXBNM0RjNkZOcFBpZktoQ0dpSW9zQXIvSkN5UVhwSWlabVRBbWEwcHVXRmNlN1o2cDhWdkg2YS85TDhpWjNocFZCbHBOSTB4ZSt0cnJWYWt1QXNaSVZNalc3WURpdkhzVzliWjZ5cTEyN1pESFJWVmt6c044emdjMVJac3drVU9nSW50Ymx0aUdHQ0NHck5wYkFsSHlYbkllN3VKTm9XY005MFVSRnplY21naGlZMHZyUGp3ZVZ2cU92SjdpZW4zOGRQa2lBZFdFREk5a090YmNyN2J3c3BCTUNLcGFsdThId1RPNWpIcXpWUXZKWU4yUkVjeDBObTN0ZFZoZWllL01kRjA1ektyQTBJVmF4dkZFS3Q4VnlCekx3eFQ1ZGc3dHMxaFNRQXhQNUhYN1VFMm11VFJsUXNRbW9QQW1Gb2VuTnVaSVFsWEZNY0ZtcUluNWtoa3BKcjdxcG5jUDl1VnlHWXdSTnVWTlZ6V2RWcEVDMTRvZ1ozSk01SVpHU0trOXVRQmZ6SjRBeGNTUm9FRTdrNkp4ZmFqenV4NHZ2a1I0S2ppa1diZk10clM0aEtnU3lRQWFibktvL0hZYVBBVldrbUtyaVo3dVRoQkFqYnN1R3NWajdONC9mdXIxcVloQTZIdW9Tbm9UMC9DTXBveElXbG5ncUNTeXpEMTYvdnlYZi9sTXAwa01qMHF1bFBSYXNGWm1waW0wU2JNVEhYQVBMYVNGS0NGa2NNRkJnY09oNS9BSThKVjZYQWVEWlg0bE1PMVpoa2h4SVJaRU1LUVlnTVcybXIrN3lGSEdjSFFudkorWHo2MU5mbU9BSWNTcWdhaFVMSVNGemhjRnpFakxJR3FZVXlWamVMT3d2M0VxM3oybjAycko2ZjJ1V2FVQzdyS3FGU281SEFpdmR1MXg2cjZGZzAybW1iN3lUWVhncTd3NjMrQ1dXVHFGZUxNR2FQY0FsdzY1c042TlB6MVlhL1J0M09lZjl4OHNyNnZHTDdsOEdsNFMrYkppdnp6MHZXVVVaUGNvZ2VDYmlNQ0VVQW9LdytvMGg2aEo1RWlSWW91MXBtZTV5TnJOdExYUzNZNDZ1bG4wUTVCcDcrZm1oMFpCZ0trOTNMQUpZOURBSE5RWXdmQU1KbHZoYVUyTmN2T3FDdG1Sb2hMallyMUplamptYkprQURKb3pSdjV4dXk2ZlAreGZmOW4zVkxHbFVtSEZsYm5WYTlXa1ZnRk5UWkdEVEVNQjBoQ2ozZ0dCaG14cUFwZ3lTNTVxa2FLYSs0V0VNUDNZTUZ6UXlBaFI2MTJFREFsSStqSWZtaWEza2ZodlNxUGUyTUtFdEc2UXZsb3RuYkwzM3Naa1NvV2Q3azdkZkg3U3hqRkN3S1ExRFBjQzJtUldZYnpJTERyVGxYdCsrTXNQNFdaTGJHTlhZWXBXbEE5TXpCNFc5SUN1dXNyZG5yNkoweGdSTkVFbTRlRjF4TUdrTTlRYmtVck9PZTV0eVc1bDd3Y1diUVM4bVdhUmFrUWp3SWlNUENDdDg2akhaSWxnNzJORDd3RDQ3OWhxYjNwMDBhcDVUSTZhQkNIYVRBU1JJMDd6bU0vTU1qTzh2Y0MvYlo5UHZSa0g1MFZkajJoRVF1TWl0aWhIQkhmZlQrSUJRUVIyWDNvYkhIcE14SS92a2hNeWUzdnlwNXNDRUYzbFFqWFI1WFFkUTVhVzRSbEpYZkFqVHFscWZINXMxNWV6ZmY1WnVZKzA3aWtta2h4TEgvdHVOZzBIR0pxekpKRnZmRnVHd0dwM3pHYUZDbEpGTU5pQnRuUkZMTXU2YitUMXp2SWFYWEo2a1c2aGtySURlLysxQmU3b21CRzBOYmxwdTVJaDB6RG5DRVVNQkdFSkFVd3RENWJQWE9wVG1obzlWUVdNOEtPb2syU205RXdwU0c1L3h1OCtqRjh1dXdjb09vUE9SU2xLWnZiYndpSVF0ZU1La2JnQkdtS0RTTnlycWRCeVhwakxucGM1b2Y5QjF3TGdycE1FSEZOcGFkb1dJNFZqaVBTNDZURHQyRzhPdlREbE54ME5PcW5qaE5RTXhSYlpyYTliK2ZqRjBzNGZYd2V6cGdhYXNROFZxOHE5OE02a0pxdG5Wd3ZRYmFiWVRQdW43K3dyU1REMXhHRVZkQzdUSGlMTHNaaVoya1ZTcE5aU1pveElPZndNNldYOXVDbm9XdFdEdUJWaFRNWkZacVl3MDdSQklOSVV5VlI1YVpXUThUcFJjSnBBYjNVcVdTdlFoTm9JZm1zYi8yMktTMVcxQ0U4aUphS0ZVNDBubVRxbnFBQ2hvNkhyelNKUzR2aDdkSHROQVE5cGk1eWJXOXhVV1NiM0xqSXllTjFpcmN0QzdPMjZyTlpUZk02R2E2Q1ExT0pQaWVWYldHMU8wS0RhYkJlWU1MbWtreGt1T1ZKVTJmMDFZVXYzeStuejlRLzZjTnAybnJuL3RCQ2lvdlNtTFFjNXg1UXNwcEZJekM1bEh2cThTdEtxMjV0UXFDV0N0Qk5VbXpKeVBUV3VVUFNUWHpZc2I0Vjc4eEF1VmFuekczVE03VGloWlJZMkVlVEl5alZHWkc4TUJOWGN5dXRlNXdRZ1dXT2dWN0ZHQnM4Wk8wVzYxRnRIU1krZHpacVlKTjEvaVUrUC91TlRWN1h5Q1U2VlpaNE1iZ25SZVNGVkhOUzJBNWZFUFpzcSs3eEtQcWdoQ1BFYSthYVhKRU52dFdMWVhMalc5TkJsNlNKcUVxUUd0V25MVzVQSHY5aDRmMVZYU1prT0o2cTFyZ2tsdEd1RUxqYTl3Mks0Lys3NW0ydVFvZElZWTIrNmxqSnJ2WktFR2NzQm5RT2x5cEllUDM3aUJ1NnNLaFRMcEFxVVdaYnpHYXdLVzdwazVqVW9ZNmVXWnpaaExHdmhQaDl3TFpFSGxoVVdPSXI2ak1tNkRkWWNyVE1TQmxQSmpFUzdycTFIbEt4Z1NJYldxRDJtMnlDQjFHT0ZlM2ZMT080WDhoc05zRnBVeS9BNHJZeUpoS1NDRk9XQWF0MUE2NlIxVTVscVI1ZVlrbHhPYmFNYU84bkpiWm5URDJicTZ1TWxsZ0hHOWxLU1I0T1QrK1hoMUJOamlyL1ZTWloxS0ZHbzZoRnVPUTZwUW9iUU1xbE0xNjZaVGxYUGJIQS9EVzh5aGoxZTAyd0xxVDFqUmxFVUZOY0Y4QWpVR3FHcW5tRHgya1YxUXR6ZXpnSFZjSXJXVWhPMm5Ea0RuK2xvbjJJajFCcE1aejk4cldRaWhhaEc1bS9oaThjRk1GNWU1Ym9sdXpDbmhBUWYyUTJlbnExWkZRTlI1Mmd1eVJTbTdBWU9USzY3cXJhcWZCYU5ZRkxib3JNQzR2TjM3ZWtTZXNRcnBYeXV0ODh5cXJ0QkxKTjFSVHc2dGVZVkx4MTJYaHowVENaV05OV0V6RCt4K2toRkJNMU10WWF2YWlvV2t0cDZnV0o4K0tKQVNyT2R5UVRRWnN6MWlIcncySUh0N1I5TEl0bGFhMW93TFpQTVppcnprQzg0M1orZXF2TW5oYVI3bW0weGFMTDJsNlFvTWs2VlZyY1dra2pJZDh2M1ArRExwUm1wNnR0MlpxU2tTSjhKZlNrY2NiS2RsblJaWGdYTWtTMktTRU9KOE9KQ3lTRTJIWVprekcyVGdNREtTcXlrcURGcGtsN3lRa2Fta05LcXFCUWlpcVNxS3FpSU9nVk95TWUvUlAvOVZzUzZ2Y0ZsbXFITks2RGZGdGdDdFc4YUFGekM2cVNHSTBtSU45S2lUQVVOQndLVTd5dFlxdjFxNytmdE1xQVVvWSt1S3FwTjNPQzdpOW1NUWNta2xremxSQ0EySjUzeVJyaElCRjB6b0FEMlpZbXJhOE1Bd0gzcmdTNnZyL0w3dG4vTGgvMGl2YjgrYmYzRHRTcFR1RVNlbWc4UEVXZ0tyZEg4dUJMY2N1MUgvYXJjUGlnekU0aTJucDZSTk9UbWovZjcvcnFZUUlWbVVrRUh5ZU5VS0ZPQXg2OEtZK2JmN3BkZGVhVXZ5SXlxNEVJNEdqSmpqODVITXhOVjZWNm11NXc1clh1VGpMUjJnWFJrUmdNejVzWXBWZ3FrcU5ySHovZFhYL0thMVpZb1hyVnRjemhRNUJVUm9EdVpqRVRXbmh3M0QzM1NUdXNlR1I1QlBpMm5iZ1dJTFRpRnRRcE9hbE9WUnFxYW1jbVRyaXJDdXBuNEdLMXBCRnNQU21nQ0xmQjJkT083QitqbUN2T0VVQmU3KzNEZkZSQko3eGgyYm9XOWdtOVl2Mys2N05kWTJpNkxCc1V2ZlkzRzNidktzTllrbVdOZHgrdUFNVEt1OHVuN3Y5M3BFYm1OS2grVGx5eEkyMjY2SURQREhLcmorakZnQ3IrU2FJL0w4NlV6cXNPbVpyd3hadFpvaXM4NGFJcWgxVW5rVUJWUlRSWHhvWGVlSWhJQkNjZVMrOHRaSGNrTW9qemxaZ2h0T1dvc0QyU1J4eTJuODhtbWNLenZBK1p5OUJZS1o3TXJrQTRDYXRWU3BkRXhYRVZXUVlpSXVtV0FxcEVRUTZSWHhIVWF2aEpXRUVtRW1qaWg2bW1MdW14cnkxQ3dVZnA0ZmRYb01uVGgwNlBHWmgrN1A3ZjgyajcwTDlvUUd6VVhsVWcyZThrSXFPc3FZcUxBWldJa0xtcGRBTHkyeGNTRUo5OVVITGh6M2FNQnk4dXVwM1ZadDdqdXVxaXZJL0xjdG04TEpmR0JmMkRENittY3p3K1hxNjZyc0RPbDV0VXBJa3h6S3FCTmtFb1hqUy9lMDBVc012TmgzVGFTSG4xNTJQTlJML3FKdkhTeitzNlluSkF6bWVCOHNjMmFDU0pQY3dmU2wrd3hySjhSdS9UTVBUTWh1WDhjc3FnSFl1eHBxMFlxQjdWM1NkZk95K1ZUeElzSTJDT0NDaG96eU1JTElKam5xN09mR3IxWjJsbjlmLzdqVC92MXkwWE5ReFFabWs2RXU5YTFVM2F4WmlxeVFZeFVoZ1pqZ2djSWdhZDJQbC9SbUZBQlpWa0tEdEl0dHFIV21YMjE5TERXaFNrTGlnelNhNHhHRVpYQjlZTXJSQXNKWjBxUGYrSEVlck1XL2FyOVhlVDYrUGs3UzJVRjJxVjFoWmhJRXlUTzk0OFh2NFlRV3VWQllvdUVnTzZhVHF2akNvRndOZkZ0ZWZoTHFtaXF6VW9uWm9JWnQxUk9GRk5UV0YrbDVHNnNraGZQRUROVW1oL3poYm9WMmh6cTgyMExFNFhVQVdjQUFDQUFTVVJCVkNSc1VZWmxpcWlxVFRQV0JtME1hRTBqeFVKdWxJc2p2UFViV0FueC8vc3ZBaTRIdzdaMERpTWpLZVdtRXRBWUllTHo2aHZCcVdUZU9veW1BSGVFSUFObUhQdGdlckp3U2tuNnJscnU3eXY4RXRydkJ1alhibzhYUzJTa3ovNFpuTU05WnpoVklOSktWWmRQNGU2QWZIYVZqTFphUUp1K1BHVXNQWGZhK01EOW9ucGRWNzErMC9OZENOTForeDZtdWJmenk2SkpiSG1SczEvbGRCNlJXTnJ3OTZDK2Q3QnhUR2tEMjFMZ3B5R0lrTFoydGE0VUxhZWQ2REZCOCttN09qN1hLQkcrNVR5L3RLNWlxaExVWnFVbkVXWVN0cllJTjZ5MjJmMmRYbmNZcEsrdUp4V2lXMm1RR1JXVmgwczVhdzdkYzdCcDYwb1hhZXZqV2ZMeTh6WEQyaHp3NCtob1VSNnV4VG93SEVETGQ0L01UWXNQRnpScEZkODJSS2tQS3JUeTZlL0M2alNEYWdwdkRsMm9JQWhibWkwWEtZaHdBcW9VdEtQRmpyK3FSaEllbGtxWnRUNm5MM0grS0w2a29ac1F2VnRJQ3loTlpIMzQrSHlwelNpZ2NHT1RIR0RHM2ozcmlCRkVOM0p4bDRlUFAzejhLaTA5UkRzelBKSU1SaGFQUmNDa2wzVmZCZW1DaUpVQXhQbzFvalVkeDhPb043dndQUExuWEhsMGRoY0xVMXNiaml3Y2paQ1pJbnJ0UzB1VmJtWk1VZVlSVWVDL2tJU25lZnJYWTZUL3loc3N3OVJxRENBQUF3dVlJWnBXOTJRS1hGVUdPaElzZ1B5TmV5ZHZPUUJoWkExdnpUVER3NHBLbVJSa1pydytXRTlvQkh2TEovbDA5c3Nlakk5M1VPZklkR0ZYUytaSkJWNUxRbGtiVGVpaHV2c2VhRXU3YnMxMDhMVGtvRGJObi9YdUhBUEw5bjMvOGxVN3IwdTdqKzBWSjJZNFc3dUcydGpzN01iWWUzOTRSVGk3c01lNFZZYmkxclQ0bGdLSnFmOWUxN3JTRHBVUnkzTFhlbDgxUlE4Y1dJaXdPcGpmZnhGbGcxTVZoa0NSeVpITWZZeHRhVXRUUnV4a1pXcFZFYUZyVzhlUXU4LzZoMTA3eGc1WEJkazZKUUZHTFJBUm1kcXFMblpPNFFldDlhYUNmbDd2N3BiODV6LytPQnFZaXJlQXZWTGZsTTVEWjN2cldPY0JMVU9Kc1RFR2xOcWJDUkd6RjArUjZGWnFxME8xQ2FOZzFRY05vRFE2WnFKQnBDRVRERXJ4WnllVjh0Zlk3QnZuN3ExeGhmbjQ4Lzd0OWVTZXdMb0lLYjBGcGZMUWFQY2ZmMnp6K3hHbEs3VU5PZ1d5eWk1aVlOS3NJN1B0K2ZqRDU5UHJhMmRldHprQ3pzeVJzMzk5emkyOUhEMkl2TWdxR1ptQXdxd2xiZEhVdEFQclhiTHE0U1RPSTQ1SlpxcTI0cnpSbUE0R2gyWWt4UFJxREliMkpoemhNMHM4TXlEeXZoOTVEakNFYisyOC85WFhsNkN6bVlCMS9qdEs2STh3QVVpNGlqV21RUkxJRE5TSTgwaVBUVFEvYytibW1sbVZWbXI5T0NtazZOak8waE94WFU1M0ovOTZPWjhlOWoxR3RMVXFOQW9sclJPb01ZZElRVkcwcGttcXNpL3Q5UEN3L3VNNC9RNWY0bDR5QS8zand4OG9IWVFKMjUxejZWOHZJOC85NlZsTmtBRnBvd1l0ZDNCbjludDllc3FIZTlzKytEWmNZZmsrcGlxM3pwb3FYeE9LZXdOOE1BUk9XUmEweFZCdVhDRXpKSU9pN1Mxb1hUa09IbFhybkFRUEVqSGN2UUZCenppTThDMTNjZTFuYlNQYjBrS2haNDZJK3doQ0ZWRnRpck5VTkdpVFZtMXp3Zlk1dWxyT2o2dnRYMS8rOURYTUlueVpoZ0N0L0plTktzU0ExSVdZY1V2L3lic2pTQW5WUHNSU3hacVFWcmFXR0tDcU1FV1VLYjFXRVpFYUgwR3dUR2VuZWFhUzBXWkF4Q0NabWFqWFRuNlZyamtJOE1KYlppTzFuMS8vNDk4OG5pNEc5TFh0b1czZFFoRktFSHIrMUpxeFJlSDh3ajBha0drbVJaQ0NraUhLaUNmOStQMFBwOWN2QWNibXlCd2pDa2M2Uit1WWo2d0NrWUFUZmpxSjVnUitxZEtFUHF6MFpkUlpnMjl6NjBQQXJxbXdxY1crUzE5eUxrU1poRnJybXpnVFhSdWQ3dE9LTEFwSWFZanZqMzZ6NnY1WFIrdi96Ny9tbXZ4MitUaitzY3FjTHdLcG1ZbGtHa2hOcVhZSjNyakhCN0FPczRPa29sWVpOTjB6WEtzZFBHRStydmVteExqbWFiM2ZZdXlQcDVleDk4dVRhYVpvdWI4RXpFRkttOEU4TUtVM3BUVEtzTGJlbmRmKzE1dWVOOGtodWc1WGJSK3ZjWkdVdEtkdFdWODN2Zi8yZW9YYXg3QXV5Y0F5bUZENFpyTFNJejRoTGlySWJ6UkVWTEdCNEhEVXlPUWI4dTEra2dGTTlyYjBKdDZRRU1sbUFnYnlWT0xmSkpOTVZzTnhIOG0zRmRhV0RMRStvcHAzWlNrU21MWTlyUy9pZDdITCtTeDdWNlMwMDhQSGwrZXd6aHcxbzJTTDhDQkVNeEk2MndOTE9YZUZOWk80K3ZYcnQwdit2NXk5UzQ4bFNaS2xKMGRFMWV4ZWYwUmtaTDE3cGw5RGtBM01rRUJ6d3kxbjBTditCUDVPY3NzTkFZSmJraUF3Skh0bW1sWGRWVFZWV1JrWjRlNzNtcW1LeU9GQzFhNTdaRmFUUGN3RUVnbGtSSWI3ZFZOVGVaenpuYk9tQUltRFBqY2c3NE84TWtJQWsya3hPRGd5bWttNUZXOERkejlLNzVUTUNqVkVwRkNNWUk2VEd5cW1rbFBPQkJDYVFnbnFhQlVGbWlqR2NTTWxCZVZORXZTYmVNSWpDbURxVmtYVDYvN3YvODJmL2FJS1lhZWxPZXJwc2cwMFdhS2M1ZkY1Y1dONEpZWFJkcVZhRXNWRlI3U0NpRXRHdHAvOTRwRlAxNjZTUFpIUmV1TzRJdVJtM0o0RHpDQUZpZHhweTF3SVpqZ2hrZDVINmdTbktoSHltbUF3MTNLVEt3VmtObEV4bzhKRFFrU3RGRnN6SEFZRXc3MkwxS243R2RaYnlTODFwUmhoVFBnaXhPSWZPNy9EYlRJQXlESTR3VE1aYXp3QUkvUmFrajUyVGlQMGNjalNKd0dlTitTNU1NVUFDV1lDU0tlSG1hUU9WVmxjSG1vSEdVOEdxWkw3K1M3UnBUOHRKaUVHUy9HRVJDWmd4VXl2bkllZkdNRGM3SDc5VHZIVjNxSjVjVHN2S250clgrM1huaUpkTDVkN3VmYUw4czZlWDhvNW9RdWxSNjNwV2Mydnk5Mjk3TTh2ZDQvMzM3MWNLbjUzT3EvanBYeTR5bmxJWThicmVkWjJGcGtBRXhBcjUwb3lxSWhjUnh6V2thY00zRVlhODgwOHNXVXp2d0FFdlNkMGgxQzBhQnhNRGRXbFJIZnBlZi9WeWl5bHY1Zyt2Sk1NUjJUUEpJK3FnQUtORE1MTTRtWUl5eUROakJmM2FMMnBEZ0hMQUZWTGpEb29qdTQ4Wm9lUUdIR2hkdWhab0lKQmVSbXFpUXhQeVJ6cG5Jemh3Sm5SaWVuN1loVk1TcG5SQ2dNeG5KTStiV1dRaDVJaHlVakZENWhZeDRiektJSEFNZXFPWXAvKzcxOSt0VmlZcmxXNjFydm5UU2JtUXF2OCtPWHo1UCtrU3ZZcnlyS1NLWWtTa1daZElDbFc3ei9jODlLcGtQQUV1M2Rua1JqYSt2RURwa0JrTE41RnBReDVxa0NBOU80eSttbFZNRzVoZGJmWDV0Z0FEeEw0V01wbUR5TDZJbXJUSG1zSzRkSUR0bFJzSExhYzRleE9FRUVtbzd5OWdXOFNSL3hUWjFpeXpQeTFzUzFTeEJqZklKVTUxZUhSeURMZXpYRURiWkV6bDJNYzVUVG1DQU9KZ0NLRDZUbGVXdUVFZUwzMjNhUmczejZWbEdqZi91akg4VjE2ZUZFeEZNSzdDOGlPWWxvR1huT016MWxyNmYyT0ViMkpwTFNMM044dGZVeXJMM1hCSjY4V3ROaWc4ckl0OXcrYWZkUG9nQ0t2aXoyRkxUQ0dsREQ5dzQvdVRpMTdlRk9ZamVIY3JDRjR3N2pQUUdDSWlQcVJNUU03M1MrcFlJakd0c3lSUXo5OGp3Sm8zbnpaN05VTlZFMlJURUtDSThCOVBybTZqNjJQcVFFc3A0YzlsL2NQdVhXM2pEemw5ZHE2UklZYlk2d1hSUXR1NmNvcCtWcDNTdmFtYkd4amtPanVRK0VqaDN5RXI3VUFjdjcrMnhjeWlLV2poY3FqRVZBVFpoREpjS2NnQ1NzU1ZCc3NiWStDMERmTVJHbFR6K0twZEpwRnBFQTh2QmlVWkNHSVZPTDI5eHNOTVE2VWdvaFlYZnZIMy83em40TXBwU0paMXFMRFpSU2lzSysrWGRxZ1NpVkVvamRiVHU1Qk5UaFR5OVVVcXJYKzg4Vjdtamd6bkpwOWNCR21kT04xWmlUTmpKa3F1a3dzL2lBeFJKb1ZRQmN6alJGSGNKeXV3NnN5ck5BNXh4OFJMa1hSUzZhQ21SVWpzbG9CcTR2cUxvdzV1aGhheGNtUy9qNGs3SkRZOEo5NGdzdTBGK25JbTlTUThOUVplek9pWkdhUTBiSHU1L2RRUUcvMGdvQm9xaFhadTNIWXo3cEVDTWplL0xvc3BTaDNCNkovL3ZyK2xONkZOQmlnRmVFQzVhNERNVnZtUmJhR3JDZmI5MC9wS1RDOW5DUUZlWG5BM21GTCtmWkhob1JGbkdQVGgvSnB2VjdQeTBQUExWMUI4bnBhWHdLbHJPM0ZUN0RUNzJXWHN6eC9ldlROVnhzRjB3OHp0K1Mxelkra21kRlRyWjVxTTZXSVJFdVFxbXBiRlRFa0p2SlladDR0SXdKRHpUVnF0a29xeWtMbzRBeXJpSmFsV2lDM2pnOC8vM2RhSDVibnAwZzdaZVpMVHlzcUNaTXBqZ2xSYUFSVm1jekdaZGFqVkZXUGJsSUJ5YlpYU0dIMmRrZ21kV0pQWGxWUDR5MWx3Ni9NQTdpbFVCMUhlWmgwSjJVUjlEMU1GZk1YS2pOVlJidU5pQzA5WGlNTnBnb2dnQXczSWtKQTkzMWRpekJwLzNveUQzSmUxVG9oOHpiQXUybWpwdE8rOUl2bnUxOFVrTkRZcEdwdmh6eGRrbGQvL3RpVzRrV1JRZVJpM0hmM1dCakJzdFFsSE5RZi9mbkQ1U25OVy9xNFQ2UDVtRXRDa2xRem43d0UwOHdCeHhLdHF6SFVWRHdnWWxYMkRsZzE4ZDZuaVhBQ1dVUlNxMlpPZERBQWoweWtzSW1CR1lsU0NwQkNyUmJiOVZwOWQxMld5bExaTzFXb3hTaXFFMG1yb3drMXp4UlY1a0hnVjczeFB1V1FReDdLK3ZuZk9LekVrVHBFelRxdEZjTkNsb1F0Ulh2YjA0eXhpbFpqQWlQSmV0QWx5VVNLMVNKMEdQc2U2Rll3R1dkU3FtOUxZbEVLMVBWdWpaREhqLzFuRHgrdlgvWE1pTFJhZGU3cFJqcFZ2MUpOTW1MWkw1c0w5SzZxbWJRcjBqdXRsT3ZldlRjNW8xOXAyYng0bE9MWEhoSE5iVDAvYlMrTjdHMXBzc0pEdC9WYytyNTNwRWQwV1ZHWHdxRG0vRHdna2xSVFI3RXBNaENTZEFWdGtWaUloNi92ekpheUxKbzBHL29qTk5VVVkwdm9rQ2pOSGtUVmxvSlgvSUZld3k2L2VWcVkzaVBKUlFZYXBuNjhmL2hzOTkvNHJ4Ly9kTjlQL2QxaTZWSVdXODFiSHBlaW1oUmw3NGtENHRKaFpUSkF0RWcwZEE5dlBYUUlZZ3BHb0JGYkRtTlBUZ3p0Z2NOck1jamppRXlaUHJmUnRTY2g0Umo4YVIxK3U5NnlsdXhTelE4a1VsV0tJV3l3N3NTcTBRTWFWaVFGdklSWmRMMS9kOHA0Lzg4L1dIbDk1UTkwQTI0a2hURUttc251NlJLOC9PYVgvK3d2b1Z3Znp2Q0VGUmM5aEZPbjg5M3BKWVFqa0phNTFhVllZQkRkQWt4bHUvL0pUKysrMjlLOHRaU2xlSTdRRG9KQ1pDVDlRSWJlcm1OWjY0S2lna1UxMjk0ODUxUW5yVVRFTUgwTWdPdDRYSFFFYUkxcTV1aHlqdk5FaWsyWEVXUk10bzgwOVdFbE5FMU5Rdk4ycy85Z0EzeDRoT1Y3c1k1dmxrL2ZBMW5pS0tvc0I4QTU1NEk0bmFIamdUMkNXT1FIZDN5QmFVYVFZMnBobXBGTU9ZK1N3SWJJMEd4bnczbUZSczFQL3ZEMCs3TU9wUjR5T1ZTWURLYXFNSU5KQkZSYVpKN0V4TzIwU3BHSTJJYW0yRnRYcTR4T0RRckRFd3ZnTHFFZityWTNZa0hiNm5xUFQ0QmtKZ3BrOFBQc0NOajgvOWllbTFJWTdOQnE0VXNkTGgwQkpEMUVOVFBHVCtzTGx4eGVYNVN6clI2NE5VRk56Q3dpalM2MlJERUduNTgvdWw2ZlEvM3pXb3pOU3ZIY3VsVU1uamlRUWs1bC9majRzenRobXFiaVREeWJLVElsbERQaTgzQU5EcTFuR2NFM25DQmdHVHluUkx6T0pLRUN0WjZTNmZSMVZXQlozYTA1VFROU1RKR0hpdWR1cExCb0JxSEtMTW1rT0gyZ2QvVHJFTkhsL1BCUXRtL2J5LzJQeTV2Ujg2dWpINjhMN2RubXMrYnAvdVdiZi9qOXowNlc5djc1NDZkZVM4Rk1EaEh5L3QySDczcVhTVlZKdjV5V1VuTTROekJpRXJ4K2RibyswMHBHNnhrcjU0cjVobjFsY3FUR0hRc1FBWWVQaDBsRjM3WWtoUTZZUUpHOXkzelRUNFFNaHlGVjV6NTR1dnZIM0gzd3UwZFdFZ1dGa3U2QXB3aHo0RmFVcXBQTkxmRXF0cVc4a2ZEeHJkLytCNmVOcjYweTMxYVJGSms1eFVOZkxwS2lUQTlVTldSWTdiZjlDSEZZcVFaYnBTSjdaSjFvbTVUb09kZ3BHY0ZLbFJRck5lUHlGTzlYN2l0Zjd2N2swMitDcEtSakU0cFN4Q2lSaVJId2xaQXVOYk5uK2xLTm9xVlZDWHJLSWxiQXk5UDl1aG8xSlFRWmZzUkxFbmVyNGJuWnNxYno4VjMvWGJVU1BWSlAwVDBCWGJ0VHdkUzNhWUx5VnE0N0R6Q0k3SklzcHhxdERwb3FGQ1A5Q1ZqRG9zb1hMbGVJNkJCY3o3RitIb0JQVlIwSGFQeUFlNGhkOHZyMDBmeWx2S3NmdnowdDYvTlN0WGZWZTIxTkJPWWN1THdrQ0JWdGcvQ0F3aVROMUpiaW5wUWVabUNTdkJHR2g3YlZ6SVRCTW1nTncvMHJNMjJPaEIrclJ5RmdTdTlEVnBRVmtoNjVtSExNTWgxV2tRSEpwS29iQTRTY0l0VTBJelBFVExGWVZWWFZOUW5LK2U3aiszdmRyWXlXNkpVQ0xmTDZ3YytrdkJuTVZueTUzeStmcnArcUVmclZqejlIS2N0bCtKb3B3bnIzL3YyenMvUlJmMlM0V0kyaFFJNGdUMzI1LzNxNWZxYXQxby9vS0ZFZFpHZGhRS0V4Q3ZuWHNiS2cxOUZaTjJYZlFzb0lQUUlYYnR2QkFUbHdCSWY2NUZnWHZqVVVrcGxUQmN0UlpHVkd5a2dyVFVKSEJIajZxNzMrNWtkbGZtOG8vZVpVOG91RUJ0eE84TzJOT05WUG5ObHluUEx0bUY4YkRPaUpNdXJFdWFwOUN3b2cyVHVoT2NLQW0yVVNob1lNaitFbUl3V0x4WGU5bUtaVDd1NkxYeWYxWXNNbzZNdU1WbExHaUtTMXdsRFY1dzZJU2d6S3VXaEdvQ3E0ajBjdFVwbnVST3VlRk9BUGE3WHEyWXJHaHZjUVZkTSt6eXVwWXpxTzVBOVZNT0RiRG4rNDBHRGxkQWR2NjVGc0R6SXlVbEE2bC9Vc08xNnRtektCbzNrN3dSVFdTQ21tT2d0WFZoVlZzSWZzTHk4S2YramYrS2Y3TUpPVXFrWE9hakhJVlhQS05Cek1OL21PemwxOVhiRHZUZFZ3WkhIZGZLWkRKS1kyZVFrNmU1MHhLcmViK0ZzSGkyKzZ5dDBEYW9acWtzVG1qNkkxbVZLa294NGJlcExYQmRBaXNES29MWWpRWllHb1dSbmRjS25zcU8wNTZsM3BsL0lGRXZGTDRlREJPK0RZT0FlbHYzeStoRmpvK1NkL0wxRXE0aVk2Y1ZudkZ5UW05bkRrNU5ad3lvaTBMWDcvc3gvSnN5eUdvSnFWYWttbzRkVTdKekF3WG4vQW5PbUxFQmd5czBXcWxQbXAxUDI1c1l5UUp4a08rYWtYeUJHemVleFJaeDB4U21xQ01aWTQ4eG5LQVVCWENRSUNOd2UvTjBnYXR0SHYzOEEvQ0lXN0VWL21JM3RjMGNOMFBKSVlCdzZZS3FJSENHamtXT1Qwb3N6a2FoeUZQMFNSVEppbHgwMFhBSWcwcGxDc2tCa01oNTN5NWZLODNsbnIramwxclI0NXFHc21xcEF5dGI2VHlBcW9FYWgxWTFPaiswT1NpcnJ1MFdIbEhGdlBxS1RyRklPNFIwSVNXemVrTXA2TGRuOTYvLzRwV0FCb294Z21oUy9mdWc3ZXRHVnZQOWdrVldqbGZGcllmZnJYb2VJejVJcWRwN3Y3dHMyN0pKVUFWS21TY2FNdnB4QWxSNzZWd0FSSlVIU1JlTEVWZkx6dTl1Mmx2THVUeTkwYUY5RWkvYVVLaHFsbHlsdzVnTmxIL1JscVFxR0Rmcm5BMUNFS1VXSXVRZzRldDVuWkZBTHFnYzc5b2VGRmpwLzlBVmpCbVZKT0M5a1ZDOVNEYkV3cmFkTzAxS1JDS09ITG9rUXA5eDVhQzlNd1hpWUxyWkRKUDVYd1BmUjhMQitIT1ArTi9wSzNpZUhoRjlhNjF2YnR5L1Vzb0Q0dWUxOFc0eEh6eTkzdGRQN2sxQ0ZsSTdJdFZyMzdDSGZtU3o2OE8xMjRDcktURW5mR25tUEFrb0xCbkg4cnlqNDZuU1NEQWx1amlSbGdHZzZGeE41enNlNWwzc0EzMHVpeFJZWktDdDRvWVE3RGRXYW9LRk9nSVpJWWFkd0RxQ01aZUhzMmowdjhoemN3SVQvSXN4aHJTYjY2REc4Y2dHbmFIL0hCUWgxRUZMNGltdytFNGNHMnZXM215MkFFNkhNa1Jqd0dMTE9MOUN4bUl6VXhzbWRCT2UvN2ZycS9KcCtmbC9POWRvcjBQc0tLY0FQcXpEV0pGQldSREZRUFVjbkJUeENyRWIyWHVqeGtzcWVpSW9Pd1laTW1JZmQ5VDVpcFl6azc3dGJ2V2orbGFObWdxa3cyNmkxYi9vc1NtdmhpeGo0R2w3cWNLcWdRTDdNSjduTGpNc2d0eUk4amZXUDRtek5mNFVQejRzcndBc3R3ajhoVVF3WjF1ZE5mWCsvS3crT2ZmZWg5dWJZdVZSblA1Mm9MSlRXWUl6bzVLR1RvSEhyMFlzb0lLZDYyV0JmOXJGYk1NQjFSbklwUUhYV05GazBaNENaODRTWTdGRDF6OWpKR3J4bE5ESUw2Y0JhL0NHd3RyWGRraHNzWVg0cHl5d1piTmU1S3JhYkZvQlRwRWFlSlNEbzNSeWFXOWU1dS85VHF1UndYVGs3NDZGRTc4K1lYSFNPZmhTSjMyL1VmZmtwNUx5SzF2a1NwMVNZTGlvVFd1L3RsQ05BRUFIeVhkYzN1Y3hIb2o0L3hhUS9Wc2Y3b0ROK2kxb01pejFIYUhhN29ZK2dFWWJwbnNCUjNxVFkydkN6cUwyNjFIcEcvZzZFN0IxbURzVDlVdEpNdFJMNXlaaWNxUFFUakdBM2JtaWlGSTQ3aHFPVU80L3YzMU5HM0p2aDd1Y3B2aDFoNHpaaWFXQXFDTjI0SW9HWEE1MEVVY1ZXTHZraG01TkhDdktrQVVsUWxlaDlVR01ZWTlLUzJ2cTRRaHNLWUViM0RiUHRPMXBJdEpKcUkxY0xXbHdHK1JFSXhqWElINkFQSS9TcW1JbEpMQnBTOWx4ck45eFNvWmQvMWRCZHRiQjhQVU5FcFFBbklPZVNVNXZMMTA3WXpqMVpHcFpreTBtNnR3QTFVQVBuQzNLQUJGUmxiMEdMRzFFSGFIMDBMVkJUOVJRU0pWRkpRRHpIYlRLRVVBTlNVdVhCUUExSTh1b3RrV2xrdmJuZVBwZnpvNTBWTzUwZTNMRDRJYWFvMGtaUVV4dWdvUkRIZkdBQkNWUlBLVWh5bDZpd3hSNExDQkxlTHFBM1VnTUpHV3ZSWU8wNjhuTTVrMERFVGswRVhiQ2dlWGlxaDhGMmplTmhTU0RWeEtUcUgyR3J2aW5COXZGTUxMS3Q1Mjh3a3hxUk9GUkZQelZVQ0plOGY5THBqSzkrYkZSN0w5emVjOXlseFZBUGsrZGMvelhXNW8wQ2pweFU3VXZoWTVYUytQN3RPa3diRVcwRXBOclk1S3FkZnZOK2VZS0hEZytvUjdSb0pLN1N4V1ptVjA4MVZlN3hFQXMwTGEvUmRsNFhoU3FvVy9hWXNpL1haZ01qQkF4bXZQeFhZbElManpma2RBQlFSRVppbVRyVEZLSEhIWFgxd2N3NFIrWkhDd0MrUVE3ejlxUDVZSE0wYnIrMFh4dlBEOUR2Zk1ha0RQMGluR2lRdEdVS0tmVzh3NW9SWXRrWlJLN1M0MG9iRm96VVVFQ0VtWTRXcElsdVBaWWttNTVxZjZ0MzVKT1B0bEttU09xWEk4ek1Jd3BEUml4VUpXZW9UVlRNUzcxU2pVNWhWOXd1V3BlbllmOFd3QWZFcXhTS0Q2N1V0dW45c2Y2S1JHWWdSb2FMU1ZTbmYvd2dPY3VLYjcrekFFeWdkWlRGeEcxV0p6cEtIcXY2Y0MvSU5iK2lJK251anNLWkF0TlJhQVlEUkdnenBXTzVqNjdLY1RuL3hFLzM3LzZ0K2ZhcUpHaDdKZGV6ZnM4NVExOHhVZ2ZJNHdOVk1WRVJPbHBVVyt3TFZRU1FnTXdRMmlNQ1RBYWVpZzFOL1E0Z25sRHJZQXh6QUN3Qm1hQ29pS0F2TS9JbUNyMk5YV1lUcmFwRWlVUlFpTVBzcFV1NS84dlhwMzE0MktkaWZWTTFDS1MrWmFwTGUwZ3pwL3ZqNWQ3cXVwWThRaDB3R29HKzFSajRORjdpVmpEWGJ3L1diWHo1SC9yUUNuejIycGVyTEtjS1RLcWpHeit0M3pVZnBXakphRlVVdUxjNjFkZjRuZVhITGtLYWl6ZVhydXJYdW1WVlltQjQ1eUdmelZHU3laa0lrczBUcXF1eVJoZ2d0THk5WlRybkhmYVlUYXZ1UlpCR3BGZUhWTzZGelZrbEtGY2tSazU3VVVzdUxBWXd3a3RGZHRNQkRLL3ZoM0kyU25YWEUrK0hZamRBQmp1MHlwMHo4SnBhYXlwMEQ1amE0enJNdlorU29GcUhDeUVGbGg0akFRc3hHdmpna083UVhSYUJvVDlHQ0NGVXlJcW1xNkwzN1d0R3ZFRjFBRVRkMU5UTjBYenhNVXBZVTMrV2MxNzk3ZUxmazNxMzRaOTYvZjk1SXE1azgyZFFQellvS0o0b1lSREtvaXR5WHJoVjdlRi93K1hQZVA1N3oyNzE4dXB5MjdlcW9aZXpqNkdIMG9LanVKYS9aMzcrN2YvZkx5OC9hc3VXcHVnUDVtQkZtd25nbGxJd2R3YXhveXB3UDByUXVKbkUxTlZKTEdjckN0bzdBcDFoZHJLaVdQcUtYTFExSVVZVVJES0FPYXIzNjQxUHNWK3NQa2g2eTFFdERMVUJkTEg3L0lvL2JyNTQvdFh5SytuSXBQMzRYVFVEdnFiNXZrVmpvdlNnNE1LVTVrRU5Lb0JUejliNWZRUzB0VDBYcTZWS2xvV1QwWWd5cTdjRjZLdG1ibWxvVjlCeG15YUZHTUdzNFdKcHF5dDFyVWtKNGtwRDB1SHUvTDNmczEyVGxpRzFhZDU0ZTdoL3Y1V2svdll2Lzh6K2NNL3gzSk9ybnpjNG44V2hSTlVOb2xoU1RYdTR5TjRQOTE0ZTIvSFZYT3RuMEEzTTBVUFBqR1cwOUNOYWFsNmVYVDllbXhtM1hZOVVsd3UzU2tCQkNpNDE3enYxSkt2ZDgvNHV2VE9qaG51SGVlKytsOXk1cXdGdDY4SnUrY3ZRa1NaM0xtRXhSUys4UVVRTkhYWlUrZkZWNmNKZGhlcGd2UzhucmJxZkRZalIyajBCSWlwaXBDVE1UVXN2d05ZK0FqVEdHSEJEaDE4eWl5WlI4VFpyNllTN2hGMk92c1JCVTNCU1k4cnBTR3RNUUhWRE53VzFLRHNQNm15L2l0a2RqQWNnSVZzV0FlazBmYjRSVW8yZ2I0eFQza0hKYVZXb3RFSmhxUmxxMXN1VWdGYVJZcldZMldKaENVa3RKOTJLalNQSVdrSkN5MHdvWSs0LzQyOS9kLzFTK1lYT0tzRU44N0FnT3hIUFI3TEt1SDdkLytkMHYzL2ZURG9ZVW02RndwSHlKR1g5Vml1ZThHS2htS2xKVXJkUnFwSkFlbWVGQnFKcVd1cHJLR0hQcTRNc00zYkNXb2hnRkJRanMrZkczMUJQSURPOGxDUlAycmFmUWZaZnJkV3V0WFUraEM3YzkxMXJVakhucFFZbTJMNGN6Y01aSDZGRWtGUTJ0OUc5aldhVmR0NVJNRkFQcmFwSVpCV2JGWUdJcUdaNktVY2RUQVFIVUI5M1pKdUpGZ2tCR2R2U0l3T2tzVm90QnJWR0xxYVRaM2Z2N2FySzM3ZE52ZnZOZEU1OVJvZ1Q3OWJLcko3aTN2a0FZS1hBUEFwTGxObStlU05mYkdtbU16bTk3ekZTUldsUmU3TnRIcVFEaUtvdldramx1YmlHV2QxKy9mRlFtMDlReVhiYTFudHQydmZ2d2NGNGdBMGRubVV6dlhucUlNR09nd1dBeC9RTGZ3enhLQXRRRUlBWktSTkdVZEdiTmlHU2tIb2dXa0VreklEQ29qVkllaWJtZlMrUUl0QXAxd29yT0JOYUVGZzUvM1hUaGp1TTFOUEgvYU83NW03LzAremp0NzRNQWpsMmdNQUNnampJampVSFJST3BJRko2amhobmtCOHhWaVlMTUdEcFN5cTJ1U0VsUnBNQzZTU3VuY29tUTVhVG4zZUcwQWhIazlhTjk5ZTZKZEFiU2lxbVpoV2RDbGRuR0tSRFhnU2lTM2JPUzhiS2U3U3lYL1duNWtlY2w5Vm1veHM2YUVna2c1dTUvZUx3akxoOC9mUGlIam90SjBrd3lKbkRQZnFBT0g2Vkx6RlM5SThpWVZGTVZhVE9ienBJVW1BcHNNUk5XekVDVkdURXgzczVEQS8rcXl6Uk43d0ZUVWFVV2lZczRHYkh2NG9MWXNsclR6ODhkaTBaaFp1c1FmNjNPQVVsVmpHSDIrSXEvMWsweTl3M3IvVGtwTmlRSENLc245ZVpNUnJ0QVJGUlZVQzF3eU14bS9PRk0yQ2kzSVEwRlNIZUdvcElvcGJCR3BwVlNBTEgxOFVHMmwrc25iOWN1NnpuR0NvaStMTEYzcXhFTTZVNVhNQVhha3FXYVJOR3hHSlVqcXVWMXpwK2ozSnIrdzhFSkFHSi9manFkVUNTYjNLL3IraklFd2dTcGR3L0xaTW1GdURDQ2EvRkYzMzA0UzMrSjNsb2tNNFBNakgxVWwxSmVDV3NUeER3MVRuTURsQ05DRlVVU2dqS3VvYUc4U3ViZ1RZdUlMS0E3WjhJeUtkanc5VS9zMjkrdkI3MThCR1pUSklyVlVWYlBCRUFPTE1IY2ZXUFlwNzl3Rjgzeis4ZGlXUEdQT0J3T1d6NXVET2t4b3FzWWtEYmhxSS9uN0VKVmtZalVBUkYrczRNZ2t5TVArWmFwT1NvV2gwSnlMZHZMY2w1RHhMdXQ1L09UOTc0QUVLMzkrbDJ4MVgzTUtlQWFFRm02aTVaTVpxZW1sSjVqazFKeTR4b083bEd0bk94cGZmZjQrUnQ4L1R2TUlUeWhOenBZSnBja3pkaTQvYy8vOHEvKzk2LzlRVVZNZXd2ODRCTjVIVjdodHRNYm1PeHl5MkNUM2NDVWF2ZmVPOVdzRkJORlFSbnZNK2pSZHc3QzZORnRJYWxhSUxidmphV2M3SW1sRm1RNll0dTYySk9oaXFoZGFGdkdVbCsySVcyOHkvYXljVGtmd3Axam56NUhzRGkxL2JwTHJSUGoxd0FBSUFCSlJFRlU4SHlxc2U4NWdKYkt4clZYaWVDWjJqdGhsN0pVT3dRR2pJRGtBTGZQRzBGSENqYVJEcW5ycVF0VHFnVEtVcXVxbklVaHhYUmRGMjZmTjN6dVVlNFdoRkRTM2FPdkMxalcwM01rUllwdHBzTm02MW5XRlN5YWd6RzRqQU9jYjBOR0Q0ekNpUGdBeFJTK3Yzdyt4VUtTclMzTDZYa1czU1lKTEJZK05GSXV3bWk5b3Y3a0s5bGVscnR2by9jaENJek1KRHh6UkFHUHRKQ2paRTdoRFVQQXVSUktqSnp4bElKeUlaRUNaRExqTmpEaVpGMldTcFdCMlExRTJsaWN5RnRQcXFoV2k1UVJrcHVrakp5S2czRTFEcTIvemw5ZVgvWi9iSEtGL3hlOTRPRnRmUHU3REFnSWtJT0lPMWUrTWxuRjBHSHZKc3ZjbWpvcEU5TTBxdTlaWFdzMk1aT28wT0V4UkdHWHBkZzBOMnRkUzd0OGpGTnBPMGR2MXlHcVpidzJqT0VVTGJhb0dUS3psQkU3dTZZTG9MWThYKzd1eS9WWmsrRnFkZzBZMHNObU80dHdXWXRzbi9uTVAvdDNuNzZHQXFZaERsV0k4UXVPeHRGR3lNaUxaQUQxd09lTE1NYndWbFRYV2lTVFdxMHFobXNETjN2NDRHWG9BSjRkeFpvWExWWENJRTdVcGY1aFdUUUE5VnJpR29iTFVqSVpVYTJnU3lrWm9sQmRkRDNYNzNaVjUrVFJEdU84ZGdWRXlkLzcxVlVoMzZwbTZ4S09kS2kzTThOVUFHZTRKMmFVUUdiVkRLWU1YQ0tFcjJwNXBnZzBZQ0M3S0NRRU8wUExlbisvbEdVVUY0amRlZmtjSlFqcG5nNWhobnYySGJES3VQWlV4Ykk4bDRMd3lPeUI3bFZMWmtUa3NOKzhEWnM1SGhhQ3loU0NDZGdTRWZ2MVdxQ2RpRzNCU1lVNXUyVHE2WHk2RGlhcXJPS3hYV3o1YVkzbUp2c01CbUpJdWxOdHZNd1RvYXFTWTVHR1Y1MnJIQnFNd3gvVmswb3g1TFNZOVNDUEJCNFJpcXZBckdvbkFSVjYwZXMvZ090c3BWOHpoOHlXT3N5WWh3N1Rxc1dlT2gyTDQ2YStTUUZ2Wm1uK1kwNGsvdEVEUEMxMHVDbFZiNS9uU0IzT0VUUkFpQ1l5RUVNUU5sOWowNW5KSENqdXNUMUoxWkhjUFFNYnNvZnFqdnFRclY5aldaUzVBWUlNcDFxeEt2dFQvTFNzbWJNeFNBckdCRUZVNko2MkZNV1lZSlJhaTZXSkFjWElicWYyamY3ODd0OUR3Z08xN0NKbXdTR1FJVVNTWlNteFIzdi9kLy9GMy93UHU0b1JXczV0alBPUjMwT1VZRTQ0ZFA3QWxFZTl4UVFGS3hSYXF1M2hDVFdic0JvSlZTWEJHWmM4bC9WR3ZwcW5EUmw1a3VnTUV5MURLS0IzcDFPNVVHQktrWXkxVmdiWjBWTVZGWmY3dTBkOWNUL3kxRFZIZUk5UGdPa3pVQmp1VXU2cW1jb2RTS3ZSbnVZdzAzeFg2ZTU3aVZvVlVwREsxTkRaTkRVcmFvcVJmd0tGVjhoK0RkdHFvYTY3Z3JaYzNaZW51cDdvbVMwWSs0WUZhMjJmL1hUZVpESjQyNTVtTDBKUFZUMnhaMGg0c0djaS9GUkxINnB4eVM5aXExL1Q4dzVoc3BHMFVtT1RkdDJLY0V2dGwzSXVBL3lzRWdLc0QxOC92d3hsaGxpeVE5YTd4OCtmOHNPNy9pUVpFWkhzS3RGa1hYelNrbUp3a3ZsYWRMNnExbkhUUVk1TnN5UnZiL0RKVmtJZTZvQ2dHWHViVVNwaUVOOVJhd3lhNnB2STRMS1kzSEozNllGYVN4dlJiMU9UT1VZOVgzNGh4NDROZi9TV2xYL3NiTThPYUVDU2grTmJKWWtCWjd2aHpqTDZTTmNVcFVkSU1kekFCS09rVG96N0diTUVqM0xPbnFlMTA5YnR1VVVKWDRwNDZQQTNpSFpiUzgvKzlMaUdlekRPeFRTRklhQ25BYldHWjNvcnRTb3o2UUxvU0FBVVZPejNYL0UzOXZYalowajI3Q1ZFeld4MExoUWd0UlJqZW5YL3c0Ly9xNy8rUDB5enk3cXNWWDZRTXNHNVVPY3hzVHcwbzB3ZGFhbFdxMUswR09kSUwrR3FJdlJrMGFsbmpVeklBTTlsSmpGdVlCTXlQVUZkNkEwNEZYb1c4YlZBRjRtWUdIbDBxeWhBd05NaVc5LzdmbHJ0dW9tTThseDBSUFdXNFZuVHhIQ3MvNHZ6d3JJYXZ3RmxSY2FQdlhrQ2VPdzlKYjEvbDU3Tml2azQxZ05Td1BIN21VSzZoNHc0S0c5WnozazZxYTJJczRmR1N6ZkhDRk03OXhEdllyRXUyU2pZT2RzRk10T1RBOXgyT1FVWW5zQmVqRDFqS1gxbXh2NUFuRCtHY2p3VzhIWFEvcGFYeE9WRnM3c285N2JZNHNJUUlCU3c4N3NQdjQwK2liaWsxbmZ2dmtrVDczcjZGTzQrNGtRa1JaZkFkTVlxTVlCSk9WVWszMk5oekJzTXFzV1FxU0lSaE1hUnVERFB6eHFlU1BkRmhoRzRlcFN6ZVZjWjY0RTVKRUpxcWVvSElJZlNGRGdwM1hKS3VxWVJrVjhNbzhidDhVZlBLZVdQMHJMd0F6ZXhBa0p4cFNRbmlVTUlOWVZDeEZFRXFsQjZDeTEySUxSc0tEbUhTSEVvTFFFSXN0UzI5V1ZSWmJaTDF0WDN2S3NXWGN2SXR2Qm1Zc1RMK1Z5VmtSZFpoeFJySkpjV3E0djB6Yk9saUVxbTc5MVNVSjJac3A3d0hPVW56OCsxd2hqajhoTWxpbzdoZ1dndXEyWHZ1YjMvUS8zYis3Kytmb3ZlUExYV29VZkJEMTl6ZUozcTZ5MUVmVHhpdGl3WkFUSnlWWVF3eEl1SnBJdnE0U0xJeU9tVDVTMjBpbEtTNlVIZEtNaE9yT3hSVnFac3o4OWR4Y2x3S2lRSUt5TGlpa0pQeWVlbmh3OG40VDdrM0lnUlRac25DVWxtN3BISjhuRC9WLzc1RDV0cUNDaDlqZTJUdDA2QnJMVDdkMmZrWDF5KyszUVppSElVVVNsZ1NFSXJSblNBdGs1UmlIcmZXdjM2eDM5NWY5S3k1TGIydmFkRVJMdHNhVXU5dGtTMkxrNWR6L2I1OXc4VGV6blVoWlNnd1hmWjF1ek5VY3AyS3RvN1dUaEpBbVdrTDdMTTRlZjAyR0ZlQXRiTndrNjRua0krSzVETUxQNjhmdlh5MGt2cEtiQjBzWFhWbG9XZWRjblQzYnU3L3Z1OTNsbVYzaU9wUzNpY3VzUGNBekF3b3RlR3VocWlDanh1VE5HUkV3TkFmZnA4RDltRkNtM1FEa2FVMVBFb1JFSUJ0VVFVSUVtVmJLV3N1MkhIVXRrN0t6ckxuUlhMREFMMFRLd2JqYy9Dc245MTV4Y1hKcGE3ZVBZeUFjM0hHa21VY3B2aFlOejhyeUxOU2JHbDNIamFHSkI3RVZjRFI4Q1BEanJoQ0trZWdrTkRpVmpCOVpSd21LajJGbVlDa1pCc1RkZjVjcVZyRVpOb2o5RlRsRm5FOTZpTHFyV3QvTW4xWXovTDVmZW4rMlVQeDJJZzBmUDhFRmY1L2VkRndNUkwrQjJBdW5kRjlxemVvRVhpK3VIVSt2bVVUeWppak5oTmRXL0ErL2JDRDU4LzVycjFIRjdtQ0syMmJCTnF0UmZObDVmUWNubk01Ly9sOHAvL2o5OTlFTFhmL1VqRHFacXhIQmxPVXhjVWM5VTRSb2N6ZTRTb254L1B5c3dnRm9XWTlReUt1TnliQ21Ed09iOW9JNUhFWmpjeTRqeEVKQXRpS2IxczJiT29aOERXYk9XY2tYWnA1M2N1MFZ1bUtGU2xLSVc5a2I2ZFY5UG5mWGxZMm83VDZnMFZaSTFlSlhKclJPbEVpeC8vMmVYWGw0ZkhwM2puSG9xK1hWMkNGR0FydHYvQmxuS1B4OU4xNzhKclA1Y01QWVZUSUxsNkk2VDd0UlJrcVBYVSs2L2UvL2svcyszanRjUDBoYUlxekwvY3pybFVoWEhiT3Zlcjd0Mmt5YWtSR1JrRUk2eG1LeW5LTUQ1M0xxZVJXVTlrN0VXUE9jdFVseXFQVEpyYmZHWm1nR0VrRTJhaVhiUWFKVW42eVZNa2grZ3p4TTRQNFdDVVJVNFA3MDV5M2M3RnhOTmJ1b2NJaWljSk0vV1podjRhVC8rYUFjZ2pIbEIra1BsMTJ6S0NQekFjRE5MQnpHUVlkbnlJSnF5Y1NqWUJNL1Q0ZHFXSlZrYlFkS2dyRitrOVJNVktnV0JFNmY1SC9YVnNKTDUvUytNMnJIN05YdVF3cnc0TnA2cElMMGF4YWhsYkFJWENucFFJeG1sZWFHcVNPYVpEc3hCUWlGOWtoY0NXYXM4cGRxcDVXUWNlQVZTbXUxZ3l3dFE0b0R3VUJsVEM1VFN5V3NxUFAxMS9kbjUrUG1rUjhVWkxxRWhrYWpFdVo5OGlQTWYyU2xXRlB0VXJZdUxSUm1hbVd2c05mdkg1Tjcrdzd4NnVKc000ZTFPbDN2aEFiNkJFSTYxTUZKR254VXpIeFg0QU80T2ttS3JCZ0tYb2RJOU5CL0FRaHNiOGY2VlFKQW5XRmk0RHZ6QWZLRnZaYWtIUWFtUldzR2REVmloRm9SdTBya1hrcnE0bzJkdDd6VGJ3TVpFaW50dlA4UGZ0TDM3U3Z2M3NpbDd5MUQwOXRqYWRneUowSjh4K1YweGhpM1hsV3J4bkU5U1M1TlZEREpUSE12SStxaFlOdlB6dTgzN1p1aEJVU0VibmQzV3BZUEJ4VWVmNnJrUmlaWGQ4TExYUXZUOUoyM3U2WHdORm11czVwSU82dEhRSldpbGxQdEJITXZ4SXJ0R2JxQUpIaXM0WWdCUVZwbDlSVjFFaHZkOUZlcW9sQUFsZDMvMGlHOFBMNmU3ODd0NTJzbFR6bnQ3RDNhRkFaR1l5M1dOTW9Ybk1PUERsR1owWjJEODRJZVNYd2M2dmRqN01tMjg4YnNrVVpLcGtvSzd3aERDb1pZUkhrczFxa1o1aFU3WmFzL1ZVcEJaamQvN0hZTnkvNXdlR3ZDVkl6N1o2REp0dnlPOXBncEhVNFZEMnRoS1U2RUZSUXpvMXg2ZHY0YUZUSUIzUWxiZmhIa3o3dGI4cjJiTXU1MGhQUmZoaU5UM1ZxQm5kaWluRDFRVFpzemROSXMwVWtsMlZBZFUxK3pVK2NVa3lXNWVoTlBPOXQvc2FlU0tTbWRBWUVxTUJoUjB6QnZIV295Z0Q5ZVRmUHYyWC8rcC8rdTNQK3VLcGxoa2ljVHc5RTdYOUNuZ2VBelVuaWhYaC9WcDBXWWNNWUhBUGdrRklzVkpNRmVzb1dtYmNqc3pralJIMmRJaXRHNDIxOVc3bGNDMHlSYXhvc1NKTTArZ0p4aERDekZoY2NhYldIckJpU0xGNzJUM1Z4aGJYcmswdWUvdkZmMlovMTdpRVdCV3FldHZiMEVhbndxWXR0WmxCdFZyNG5CR3FLWmpwSHFoRjBtek1KR0ZWdGt0NzBlNG9FcFJTdGUrWi8zQjNWNktGWEI1V3o3c1BEejNGMkZHTENuVXA2NTlaYmpzeXYwMWFlMzd4U2pXUjVlNjlJajJ0SGdmNGlHS0FDVG5jUFhpelQ2SWtOQlZxUzZiU214UUJrTzM2WWUyWkZERVZVRS82SjVlbmpiSThmRlZMMzczY1V4Zzlvc2VnbXlLWmtaSXRScndxU0RCeDZFY3dyVDhEVVBYRmd1WklLcEN4N0RwOFIzenpXQXk0enR6OEo1a0JNbE1BZGtJWU1Bdy8wdHpoTThlMEdVb2tBOFlreEZ2L0p4UGMvNGdiNllmVGFCem9LeG14cDVPcEtNUkljMmFpUTR0M0pOWVFSZzg3amZXdzlSRnlNSXNTMVQ1dnNWRFVWYnp2Uk1hTDQ5eUNUcFdYMHdwU2ROSGNjeENCVXN5U1pIUkprVEJaYXRXdW9DZFUzc2Z6SnZmWnR3WlIxWUFJWTl1M3RLMjh1OFBWSUtJQ1BmSjk4M0FBTVZKSWV0Z3FML3V2L3B1UC85dTM1K2Mxb0JvcE9xQURyNll1ZVp2OFpLcE5kSzBuaTlVRVpRRXJEaDM1RUErUGpDOFJ5d2lCV2xBQWZlV25qdGFPSWlIc1VWSXppVW1Pb0NSb0NoTEZTVlZqRENHelpoc3pPQ3V0TVh2d3NxeHJXVTY2U1FSVENlaFNxeG8veXAvK2krWGJmU2tNbG53cFlOOWJqcmdYY3FTRUtWQW03MEJvYlRYTzFTZXNlbXF0WUR2Mk83M2x0cHRraWk0SWYxa1dVMVJzdGw5Nml0S2x0YTE5S250emwvUGR5VDNVMXRJVzJSc2dmd0xEOW5uSEltYWlEKzlTSmJwVGlzMEMraWpOZEhvYlgxZWo0d0ZNelJRQVN4Tko5MHFJWnU0dmoxb1F6aXlBQWt2OTZ2RVVxRjk5T0tkN1dyWE40ZVBXVlVIMmNDR3RMRGJQM0xneHg0UjJiSzU0KzFyNFpRbE5wczRUbmtJN25NakhmbFVHK3Frb21CQlRaYVF3aG1ZMmZGZzl5OGo5QzFLUnBFZFNWVlJVVWduVlNGTngvMEdCL2s4dG9ZbnZqN3B3QTZweTRINEhwZ2hIYkhXSXBpUXk1M1JlU0dlbzVmVGZYWEwwL0pKTWcwNHdGTmlsVk5qdVhXdU4yRkc0V1BQUXJDS1NvWXVsaElHajVyWVNtZkJJVk84Wnk3b1dNREk4UzEzdTdycC9NdCsxbXJCSVNrWTRtdTdSU2g4elh6RmxCS0hJK1M0SkdDenBKY05za2ZxclgvMzFyNzU3cUhsVVNCTU0rcWJtbUVvWkNIVFV4N1V1bGlvSnFtYVZJZklCTTJsTE5Sc0Q1NGdrekRSeUNMaU81aTZQRFgyQ1d5eVpBVE5rbi91M1NFanNPelJKcUVaQWtxWTZGT2lpR0R1YXpCNlppNXlXNzVRcWh1d1UxWHFDbkQ3ODNINjcvK2lGdlJ2NjVjRlVvR3JYUXduS3NhZnBRMWNpUkd4NUtyb1BXQjRRWWJWSWhuaFNoTXU0aGN0THFxb3dJcWlGQmFlMnBSYmh1MFdXTk8zbmFOQmt2bmpydEdvZkYyNjdpSHkzcm5iZDlHN0h5TFQ4UXpGMWI3ejF3QWZDNGxVNU5FTWRjTlJCNDJRdnluQnFEYWhKTmw2dG9EdVZTUk5BNnNPSGtzdjdoMjFBUHpQSTRNaEhnV1I0TjlGeXQrQUZOMWtPYjBiQVlSemlZYWI4OGpiakJEUHpFR3gvZVg0VWszU2k2V0ptb2NGZ1ZpMHlJQzBKVzJ5RVhDU3BJakZUTHlFQVhKUVE2Rm9saHNwQTVNc0E3My9hRFN6ZnM4MGRNZzJNMnVFMUxXZHFxRlBjRUFRbEJTajF4YVdZMXRwR2xSME9VM0tZMEtIcFEyaW9zb2xvUmNwTHNvQWRsM3BlbCtjOUZsT0FQYnVnVm1RWGdZUnJzWlhTZHlrUUY0bk1oYkFWVytoL1dQLzhxei84NnZsUGw4NU1jSWxPdWtCU0M2NStxUUZrQnl6VENSdlRmdzVYaGlwVGpQMWE5ZlQ4My8rM2YvUGZ0ZmZmR21NMjk0ZFpkNVJUQjZocEFCTk5UMWFxcGhVVFJvUVZFV1o2cGtnR3paWmpmdHBJVloxTFlNV1J3VEhCVkJRRzJOTENxWXFNRWZiRlJBNytLcUZGUkd3UlpLWmdGQmhVcFppWmljS3loZmVpUlN1cWVJT29tWjErcGxXMnlzN2VhU1JGVGFtVWdLaWFhU2RIR1ljaElDaks2QVpoK3RqQ0JJM09zQndKd0p1dWk0bkVPMG90U2Y5cVhaZXNLYUlxcHVHeEM5YVR1TE9lNkxFVlBaOHpZaityckl0WmZpNlZsNjNjZVlRRTF6dXBhMFgwc0w5NURXcUU2bHorM2lJdXgvUjNwSEdORVZadFRZUmFKZFVrVXBaaSswdUhNUUlxREZXVSsvZG5lcVlXUzJkMlY0czJsTXRKVjZFdEphK0g4Z3BqZWp4eWJIa1RJQTRPMFNGc2t6ZVEyMk1EOUdVSlBVcCt0VnBNQktVTzl4QTBSVVV3b0FITENWNDQwaG1Ja1ZKaTg5dFhSYVNhRlhoTEcvblVjZ1AwM21wOCthT3d0bGRMeGtDcVFHWkV5UEh4NFdpOVh6VnVJNzhaSmtCRVlJbVFzbWhlRXRWVVZLQXFJYXBMUmFUV0tzRnFmZ0VKSzhVY0lwS3RKNFoweTUybENKUm1ZR1JrUUd2cG13Qk1Xb215YU4vVE5MUVdla2VQc2xRa1gxNnlHUE5PbEsxak5kOTNqK0Zmam0zclFiUHNBZmNZRitzOFBlTlBGVWdwak5SU251VXYvS1h1WmVpSjh3aXpPT3lsd0EzdXAyYW1XcXVKbEtXYVVHcXhQRmoySW1RNXJXVkM0NFJpUlRNZ29uYVVoVkNVSTRpb1cvN2JiKzdTYzVyemgyNkhFQ20xMXRtU2lvNVBrNUdrZDQ5MHF1a0kwUmFKZGkzSUlDVERWSWk2dnVQenM1M2FOOFhUbEZnSU5UT282MDBOQjRCUlNsR21oeXBTVkh4ZWdVbWlWQk9DSVZiTmRwcEpKSllRVWQrMlJUSWlNMWNyUmRVcWl1cDZXbXR2V1ZmTFZDMXJMYkJyNzY2TDhxUUNNUHcwcUx0MnZ5eExMVlltUTI0TTkyWTg1d0ZJeDVleURvcENkVjB0SllQTnJFS1k3V3pLVklRbmpPbm5ENjZ0N0Mvbk5xV3U2UnpMY1lvQVpwcnBQWDJ5NkNhMjlrdTYxQnhFZk84S1ByaGRYL0tUZVpOQUFxSkQ4NTVVODBGTzBLMFdEbDRCb1NWajZnb1EwQUloVFVpbXNtcG1XdFdNMXNVWTl2OTdpUFdsNFBKb0EyZjMrTWEzTkI1cVRja0k5SENlenNVM2loYjE1QUpUTVdveHRLQ1ZvUzNwMS90eEJLUjZwSGp2ajFLcVJoQ1h4dnRxK0Qyc1VwUFBKekdEdUVBWnJBbXJYUUxTWkRtWDFrSllhaldKL3BOdi92YTdmL1VYbi82Z1MxemFjdkpzSFVxVlBjQ3c1VnBYeVMxekh5YlhJenRJRk13VTFYYXViVS9SKy9oZjMvL1Z4MDhySTJoVFpNSGJGdU1MeFNrQTFWNlVMTGFvU0dRUUEwZElPcEl3SzdQTGxaR2JuWDBaRXhOSktQVlZ0VDk5blJpMG9CU0xxWDB6ajlPSkxTcWpSNHJ5Mkk2T3FvcGhDcnBDb0diaS90bm9XSXdLOGRSVnY5bFoydk5XM0FYZDllNGxvYWFJRXozU2lYcFFyekJVQmsxTnRTaDNRQ1JqOEVNSFJoWUNaV0c0eUxKQXhiU1VnblNwUmlrWnJjbTZWdkYyaVNyYjg3NmU0YkV3WGUwc0laRkY2WDNQdGE3aTZWRUt6TTR6UWNMK3RSeFR3aG1KUG0rRzEzL2N0aUNxZ3JvbGMrOW1SYWkyS1AzeHNXOUVHRk8wcXFEMy9iTHgvQm5ycWFRN2dveVcxbVpkTE5taTJQN1pSeGJCV0JNeVhKbGtadHJ0MlI5Y1p3N3BINEJwMjNsTmRSU0ljQ1RSakE1TFRhVklEdm5jZUxsU0pZV1p5SlJsMVRST2hpOEdzc1B1aTJTcDNFL3Q2bGp2N2ovM0VEcHYzMzdlQ3NFcG9KaDJTNFhhN05FUEkrYk5qM0ZqdGdtVW1MZVE1SXhSblg4eUFGVlRvVHZMVW1UbmFWWGljbDU2MHdKUmVHZXBSYUk1VmZqTTk4dExmMVNtTGhXOHNHamI5ZEVMMHM0MVdTMVoxT042RGQ5eVdZeUVaUllGeXJKV0NTbisxTXRaaXpGbzIzcm0zcVhHazc4N1BWL1hYN2Q5RDlYNFhNdDJSU0dob2tvdnVXMnVLbFhDS1NKMURJZXNSSGVLWlBHdGFTMjI5ZlZ2LzlNUHYreDNmL2c1UDk2SEZ6VWJrVERIT2hBWkNVQ3QxcUpJUmRGaTZHcFcxenJyYTZneDlIUzNqSnNSZFVsVnVvczFxRVNJS29OaXhjcjRGWEk1M2YvNjM3d2dyakhqOE9oZFYvVmFWMTZ2ckxHY0t6MEZFZU54NWpDZm8xanVqZWlwRlM3THFlMFVkNkgycDFaeHVmWjZsMDk3YldxcTYxb2lnaW5yKzZlWjcwc0t4NGFQNlNGUWdWbDZ6dGhXclVVVkE0YXFrRXkxRXRkTjE1U0IzbHhVU0RIYnRqMnNLay9WL05LWHg3N0ZVanhLdUZPVSthNWs5d2pmSGlYWGJmdGFzVDR1SWVzRDdWemJwWlhYUytNVkZQT2w2dmZMTHJDOEs3LzFJaTkxOXE2NU5WdTc2eTUzYTMrcDcxKysrOVZ6T2NYekFMOFFxa01PSmhLaVFtbUFxdGJUOWpiSWhRY2MvUXZLNDIwYkxHOXN1TWFjaUkzdjVYL09mOWtIcEFGVlZEZ0NEbE9QZTVDWWR0d2NPMGY4UDVTOXphOWtXWmJsdGRiZTU5eHJadSs1UjBabVZtWFJNQ2wxaTY5dVZCTm9Kb2dTcldiQ2lBbERoa2o4YllCZzBFSU1Xd2hhNHFORzNaUmEzVVdwaXZyS2o4aklpSEQzWjJiM25yUDNZbkR1TmJQbkhoRVo1WU53VitpNXYyZG05NXl6ejk1ci9aYkRhZTVUV2tzYSs2VnZTL1VIM0huNS9WL0gyL2hvK0FjM0FjUUQ2MjV3MnpQa29OY0Vscml1ejhVSlZ6TVZHTjFIYjFuQnd1ZzVybUNTbTBWSXlCYmNGaFRXeTFVenA4b0NNOCt1Tm5yY3lFajFFaVNucklDa2lPd3ZTemw0WDdvazVtKytDR01xbzgwOXA3ajJROG5zQ1IrOFVvUEY4RjN2cVlENyt6OHVPVkR5K0p2blAvNkh2Ly9Ibi8vb0w2ZWZyS3A3T1BKRGNzL1lhRzAzQUJZZ084dVdXWGVqSjhKWmEvRkhzT0hnZnU5RjF6MTRHWUNLUVFtRHhZWStORktpeHhxQzlUNXZRd1liYmt3Tm5ZUFlleW9VOEswU2FqSWlOOVJkV0RRdkpRYXZkcHdGcFJZdDY5b3podDFvZDZJSk9SVHFpdHlSTE52bEwyeUlZQWthRlFBVmtTalZxek42WCtEOFNSdTN2RVJQcWwrQmFPakFlamhVZGZObHRIaEJBUm45TXJQT2trcEdUMTJ1V1haL21uUTNFTHlXVkg1MDQzdnlMK2xZQTJVa2U3NGM2OU8xbXdvV3pIYjl4UmRmcjArNUxzVk1FZkNSYkp3ZG1Vb0RnckFCUG42VVlDUVRXOXZxVVppNEthUnZLSng3M3VjT25MejVsVzNiQ0dLN0tZOTR6WUZDQ1JBRlJQcE9jdWVnR28wSDBzd01aOUVSbDhzR3JIaWRUdjB0MjlrbUUxRis5L29sOW9kZHl0aEVTUHN1dFR0SE0zTUlLcjJ2R1d1Y0dIQWZjT1RCd01nMHF0bUJmUTEwRGhCdm5aZGdpVFV5WUVxU3BXanBwTTBsb2tCUUU5MjNIbVVNTy9KQjA2QTFKR3V1OEtsbFYrZzR0YTlPWnBLNlByL2dtT2VZUVdPbWxaNFpnckVQbEJ2U1lROXdXTVE0WVRxOTRzLy80Qi84NmEvK3pTLzc4VncyOTlDdFQ3R0hseHRwTkROTVpTS0FOQ2p3a0tNTE01L3JqdERPM0hFTWhwc3l4SXhFYnY0MVE3K3VrV2tobUxWTWN5bmNscmFxSEh5a2lEdUdMRGozZkdMQ01nUlQrQVk4YWlxSUhBMWlOVVhXZ3Q0YUljRkNVRDJXNjdwUUdYdUs3YmpTaVlLWmJaQmc1TGFBY3hPYVVBbTZtM3FRRmd1enQzVTJjNFI2SkU2eGhnQWRDQlRFVlVCSHdxNVRyUzI4TG9na3dXTXgrS3dTT1phQVowcCtVTGtsZ2QreHZjSkhDZldQcmRqc09KMFQ4MXBMQkExY0xzZlR1eXVtY2xuZS9PVHJQLzBMSEdyL1JqUktFYlNlbVZJZkNRRUFQTkljN2Z6SW1FcVFnZHRrWlpzZzNZNWczTFhhR1A1WTdLek8rMWx0ZDRtU0NMRFRSbGpvWUVTUXBDSDIvcldoakhWc3l3QWRycU1ZRW56a3JETis2MjEzZUl6eWU1TUt1YnVLYkJPR2JlMGMzY3Z1SWNieWFBR1dZMldFRlVPUmsxTFBIbW5HM3VjRDN5M0RLWU5NbHFOV21ESUFJWnVwZVgyZWUxdnRZRDByVnhzR2RHdUVlYWt1WTJLQ3QySGlzTktEQU8zRVdESE5kVmd6STIxV1dGV0VtYklUSzZJbmkrMmVCTzA5eGUxMEhVSFVLYy9QdmlqL3p6LysrLy9IK3RQckJ5dXJqdzdXVnFSc3lueWErVWp2WTVrbUd5RTAreWU2TitldEZCdGlBQ2hqMDRMRG9SdTMweWdsMHpRVTB1ZVhGa0dsR1pBc3pCN0FhbE9XNmVBY0RXUkNRNFdTMjBOZCttN0hoaFNJTUdjSW5wbklwaXlGNjh1NWE4b01veENsSEVLTDZ1YnQyblYzU1FwbVplU2VtWVh1K2Q1NUM2VTFUNFVCc1o3RTFsYkRXMWtGRkYvM0ZvRFE2anhQRVZmQ1JuZFZlOXh1YitiT1dWYnNkSmd1TEVnZ204em9Rc2xIRDlBakl2cStnRi9WcTNiVjArWHI1VzFEemFETSs1SzFNdXVxTjA4dmYvUFg3dzh6bHJWVTM5ckVMWWErT1Vjc0pLWkwrb0hYWHU3Zkx5MzNDZkJ0QUt0UGNyNXVySzVkaEtpYjBpUnh5MS9ZeG1EQ2FodUVWbU9OT2N4R0NQT0krVFNOeE9FQWk3S3RIRUZJRy8xMWJ6YnBPMC9nMjVEdCsrWks5eFU4d05DUEh1UDlyVGFaTzNFTm42ZFNwbmMybnlhdG5NakkyQU1xSVhNbzNZZGFnYW5xd3h2cmdDTE5HYkFEbHZQU0dEQWFyYVFoczROdVNGaXgxb2ZPemxob2FkQVZpSHJNcGREblpjdTBlem54MnFlNHFMZzBxRU8zMU9PRWlVa09kaVJ1TmJJa3hxa2YvRS8rN2Yvd1QvN21kL25WS2VvZTBtemJFelN1L1U0YjhJSXRROEQ4b2N1aThWcEhFc0pPN2JhNzBuZXJxQVpaZElBMkFhSmYxL0VaandhMmp3TlN4N2xIcmFWQjhKcGJkc2t3N2d4bmVPYXRHby9iR1QrT2pPeXFqTFprcVRXYXBNaXNDZmM5dmZRMlliM3g5VUlwT0szZGU3TGpjYWJSYmJzMXAvSWdvRWxLcitaS3JURkEzV3Vwczg1clk2T1pJaVpjMGd1N1IzWVdzclZpcXRXbkJFVDNkejVFaFVXdmFMWUQwY1pQMk5UM1EzaGFOQjJpSFpJOWdwUzFkWjBPMHhMTDZmZmUvOHUvdHFmNEVKamRpMklFUjR6M0NhTWlURkUyelNyVEl5azlEUkx0RmhTbWU4enVBNTd5OGVIWG5nZDhOKzN0UzJaWW5KREszQmkxTG9KMWF6MkU0Z2J4VlNhempqalBiVXFGMkFIRzRQZnFLVTNRcDdxcmgwcmxucENlMnFYQis5UHo4QmNOYmc3MTFROG5yaGR2VDUrOTFZZkVISmtSMGtRYWt5UHJUU2h5S2FQNVJsd0JobFBGWnEyYURrZVBEbGJuMUd5OFdNc0VranJOMWhjck43azUzS00zdHk5bzgrejFlY21SRXZrTnluVTFkTFlnTEpKamIvQng3RzIza0swaXZiMy9TWVIvK2J0ZnhELy9kLyt6LytIWHo4V1dINTJsdkRmaHQvbVowWHlZZlJVUjJ5UnRRS1AyM3N2R05ocjQ0SUVPR2kxQXMwMUlPZkoyU2R1MldnbGVZazB5dDVPYWh2VGowM0psOWhFYkxMVHRLak1LZUdKSlJTWkwyWG9saGxDUDZCUUtJVVcwem1NOXBFb2FyZmQyTFNxVmVKeUI4QjVLMzBadkpoL3g2bW1BV0x5VVRjSVRhV2VPRklQM3BVNFlzcmJCNGlwVFhmdTZKQzFONmlkMmQ4YnFFV0VwY2JFSmRlNXAwZFpFb3czQVhIbVVJbzZIZ3E4aytaK2NSQVdOODNLbGo3TXNzVjdLNGRqNmNmNzFYLzdGK1kxNkR6ZTMycHJjbExzRU9EY3JxMWhyTHUyMTJ5NjU1YXJkRkZDNjk3SDBxcWFmbERGUUhEZWpQUjdUdEd5SVZRR2g3OE5Ia3F6WSt0ekszTDVveUN5UklTdFl5YzNveDN0VytHdHo0K3NUZUFRWWZZOHdLMGRtS1Y5dHlSc3JpcmY0MXNFbzdTS1J1V1FlbjQvMjhpRVBVbzl4UmhrRFpyYjJvT1FzVlVNa0FBQWdBRWxFUVZTbW5zcStWbk1GakV2S05LeiswYnlVUTFzUDFWU0FrZXB0U0NreWVmUjJMa2V6b2FmaGlVS3BKWmZHcHlKTjQxNlN1bkNHdDZ5OXRaRW5hQ3dTVUJDalFZT1F6RVpaczlWQ1pzVDBqYnE5K2VKZi9MMS8vMTkvT01IYmhremdEU29yNDRadzNqZXhzVFlIaEFTMnFXQTI0NW0xRFdheHNjR1lSdHVZSlJ0NE5qZkRmM2Fac1E5b0hKQ1I3bWhRSkl1SGo1RVgydDV0c1UwSVJHTVFQc0VkbEpoZHJYT2RaTlVpMFducFZpeVVnNWlSVjdNUlA3c25UNUNFbklaVWFCc1UwbmRJWkFZWkJwblh3a2pCRUYxWUhCaFV0bHh2RS9MTkNMNDAxT1pVUUJTTXlMVVowdHlnakhvSXg2VXgyOUtnSDVmc0s3QmRCVytpZTMzaVdlZE5yRFQrdkU1YzlPU1hzcVViUjBaRG5UdytQLy94bi9ucGZKbG50ZFdxcjVsT2hhVWxjaWhZSUNoc3N1WDlXZCtDVGVJblpwNXRIUHk0anFhTUVaU3kvYUJKUFd6eGhPL09xdEVrUjhGbXp0a0FYOGpjcG9LcFZNb2pJNmN5TFdhR0hqbnBveWJBZDk5djlUMEg4SzBEKzRqeitDVDVsN3lKeXdyV1RNMm5Od2Q3K2ZMZDA3SDMzbUZPdWl0RVUydUpUSHBvZEl0ZGdoZGNZcVNDTGZQc2ZRMU1TeHdzNVpOeW5HY2lqY0RTdmEyYVdGS0szbkRLRUl2cFo3LytjRUdtalk1OVNpLzVoS3VldmxtdW1BOFMwcVZFZVBxK29lYWo5WVRiY2pqOStjKysrSEZ2Ly9mdi9NZGYvdklwRCsvcmFEWHdvUTB0MnhtZUJNb1doQXVER2JISE9XL1RlNnJkdlNzUFVJK3Q1TkE5TkNjWWtWQUd1VzNka2JVb1ltVzN1YXphSDk3dDY3dVpKNFJOeGxNTHpFVUNFZEU3V3dXZENZWUhpSWdScGUyWWVsdExLbTFEYytaV1haU2hvNWVQbTd6S3R1dG5Cb2Vld2lkVDVFWStOeVVEOUhxSzFtWG1veWdMOU5aenpWb3VWTW9NVWIxWTd6MGRWZ3k1TEdrdGxxL25RdEI2UXRsNmNmUC9kTitOUmpPeFB5U053cmpYWEdUWmZuY1RaMTlmbm14TVpnOHZZZldKNy83T24vK0xyMHVzbXJKbFBVM3VHWUJhTjBRSTY1bWtJakt0V0w5Mm9icHR3cS9NMGJFYlJkUWVZWEVQa2R4RjBxT0oyZG9hdVdmWmFCOEhqVFNHSGRlMDk0cU1RSU5GcU14dXB0WnlETHdIaFBvYVptbTlXN1V4d0xPSjQ0SzhHZjllTDJUcFFkMk1udUkrZ3VhRFdzdzJkaFhjWkZQWkNhdTZQN3NiYTN0a0ROdVVNa2JpOUhTczAvSE44L056KytXN043OTcvTEIwTWhOaVhGY1dyRk5wdlZnL3FVZElFVStINjdYWXV2YXMxWkZkVnJ5L3ZFK2hOUmo4MnR6VzdqNEdscDJJUUdFaXl5RXZlVmhscGc0L1gxY3lJejU3UHJoVUR1djg5dTJrZFRuMlJzc1lyTmJZWm11WmFXTUtueW16dThTS2FNZWM1SWZwTC83eEZ6OHZwNjhQb0NFSkg4TlhzcmliemM5dkVHRnVMTEFSckVvcjFaVm9JYStUMjJTYmJ5SjdTNSttWVFJMzBrdDFrMm90SnRFR1NTZHkvbEIvK1ZkdnAzTXZyaVg4MEZMWmxxYmo4ckptVDh1TWRlMXRYY01taXkxL203U0VVT1o1UXZiclpjM29ZSFlaM2R3eXBmT3hYRjZTTFdJYkdFeGxmZitTTmJhWUdtdTlWdGhzNDFLUEdPazAyNVZQMndXYmRCNmY3ZVhLS1Z0WVpZZEVtb0xJdFpmaUdTR1M4blp1cFdveHlZelJFT3YxMnVEUmJOWTVqK3ViYVUzeGhGSWNxSk9mUDhRMHUrL0pETndBR2Z3MG5JbWZKQTFZS1hWMWVpL0dkKzVuTzViNlo3OTR5VEUxU1pCcDJUSkJXT2J1RDRHTmRzeFlCOEY3TDIvdjZRcmZCNmZaZjQ2UEhiZmYvaGQ0U3hqTWZTZFBDT01TT1dhYlZRVnFtWkZ1cU5VaTRtOWpZZUIzRHBEc3JzRzh2WW1tVnpKTVVaTEJLRm94aDMrdVJEMGNwL1BsM1ZlSHQvNUN5QXlTTTNvV000QlR5QStSRzJReWFlZ3FIcVBKRTNTcFI0eTZtZTQraHFRd1NCa3BtOUhoZFdsckt0Vk5Ra1lzNTBhQ3hSM0lMdVZQWHQ3Wlp6KzFkL1NhQ0JwRStnYnZ2WlY3MmpYcjJsMXM4TUh2aXVWLytVZS8vdFV2M2p5L0kraHcweWlNVTdCU2FtV2l6QWVhZTBReko1M21nTm05ZUpadFk1b1JCNGJkajVtZGVZK0ozRGY0SmlsN1Q5SlJBcDBjZTh3MU9tQ1RnVUprNUxUMjN2cHQrRE5BRU80V3lONkNKTkJUMGxvS2NuaWdSNCtITUxVZXgzRjV6bjBuSDlpajdNNmQvcnRsaHBPMzlnbEI2akRIdFV1dHF4aHBxL2JUTVhONFhrZlBMV0RSUmtDRVRFS0NtUmxXMEhvSzErTlRiYjB3aHhTSjNwTEd5RjV1U3VqeG9CdnhMY0VnZkJVTlJKWnB2cXBrWmtaV2hqMmovcXQzeThRdGF6RURiSklTdEI0cFJESUh0Sk5oaVV5aG0vUFYrdDBaWmE5VE8yOXg0emZDemljdWh1OWFUTU1Wc2t0eHRhWGVEYXdhMFRVdzNDV0d5Q3VxcVcrOG1POFJTVksvQlVjNUt0YkFJK1NMRHczckhhQS9Cb3diVUJ4ZVBWbU9rMmQ3L3hYZWZoWXZCWUpieUJRaG1LdjVGQmZOUW9sSWhUcUxuMUZxeGdiaDdGS0lNWFFhMXR4N09NUE5zMGRJYVk1ZXJTNHJqNGVPd2E2RWZ2YjFiejVrT1oyK2NhWlZjOWVGYmdETDNIdG51V1dLYmZHbjNHWjhId2tGQmlBd1FmK2p2L09mL0pOREJPNSs0QjBHTVIwSytsV0hXb3orZkhucFpwQ1pGN3MzOVdVQ1RSRStCb2d4R3ZXQ3FlZGVpdDljNFFCNzhZU0NwWHBSQytWR2wyaCtBSkhOQmN0WUEydEh4TTNYQ1FPTXhhMHJXc2c4bFJISTdCeTNiTXZJd0VnZFJyUStDVEdJVUdQckN0WWlLRWVla3lFMi9MSHRqT1J0MGxBTzgzTHQ2aEpaelV2ZnFMclhna1IyRmtKQnFWUHJIdEk2OEp2S0RLT3BMWDZhZVhwbVZ5bWRpVWlRS01Vc2V5djdFSW5haThkdjY5dTg1bFJabVE1WFpVTEFzYlhxSDc3NWYzL2RiZk5KdTdsSnpZWktJaUtwU0c1MWFTckhWakhtaDl5YlJuenNXNzFXWkcxSE0zVWZuWDVrNlAvT1ZUZXlZUXpGWFJvdXdtQ01wMHB3UUp3aXRML2xQZTI3YjdVZmhabnhPOUtSeG5aTXZVNGw0SU9XK3lGVXo4REFnSkcrci9OczdhV1ZpLzNPei94bHhKRnFleUJKMk5tZVQrdDZmV01Sa2FGRkxCWkI5MHdaVWhtZ2xUM0MzdFpUeVNBelFHVWtMSzdyMHExTVdIM3liTjJ5VHROVW50WjMyUkxyNmxTdzhtTEgva3V4cU1naUNlVlFLZHhuWXE4K0tlNHZLamZ4d3VuTC8rbS8vUWQvMUY1b080eFl1eERYSFdzTDM1Z240d2JLNGw0Y0FqTjVZOEZrandTRmdPMU5JWk02YjNxQW9VWXhJTE9hekREeUFpSkdSQjRrSEk3bzZuMkN1UUU4ZHhWanRPbE9XWUR0S2RFKzFUYUVJMkdiMXJ3d3Q5QjNnVmE0RU5FVHFIdmtwTHMwY0NxNXIxbzh4S2h5Yk9VOEhyeW5hUjJSWjRZNWxTSVlibFIyTVROQWlrYXRjS09VMm5oRGtuQm01T0ZIaDFUdkx6eWhKYklGb0htYllSUjdGVVIxMXhoL2QzY21SWjltSUdOMVo3UjUvdnIvKy9sZm1GbEdEMHZXcWFqM0hKaW9qQzVYRElIYnNBSHBNWUlKdkVsSWJybHFldjBENkxhQ2NjdVlmVjBSZk5zQnZLc21mTnRwUTRnSUtyY0VDTWNZejhneWtFbTV0ZENuYzEyOTFtVThkT2Z4VzdBZE44YUVSa2pzdlZXNFI5aU1rMkQ0SUhzdHVsNWIxdmpzMzNyKzllVzRKSXdwZENUZGthWHI3V245OEdHT0JBMTUxbFFNc1lJUVhObUZkQmdYU0JHRHI0aGsxWWcxeHh6bjNxT3RrK0phNjdJWUltMHU5VGRuSFkvczF5UDZzbVFwbUEvTE9hZTZ5ckZsSVlpV2lZZnMweHROYzQvL0pUQllIY0tIcWYyelAvelQzMXlmeUVRaTl5aEVKN1BwdWo3N2NaNFNmdTJZRHJPakdta0Q0M3Q3YXhDOWcvU0V6SGZuRnZid1NteGhtbU1vM09kK0FaTzlaMTl6QStnUGNuVHJWaFR5YXBYV0xpMjNaTVo5bEdiR1ZGTWt6QXNURWFsdTVoeExGbVkwbjZJbjRHUDhzNXVxS0JSVGg5bElxVWx3ejVET2dURGIzQm5PbzdWMGIxSHBWR1NXaldidTVncEVXZzVhcEFHUlNpdmFldTBiSTZwVlRzZXB0djV5T2M5cnZuL3FHWm5weWtUMGx1V1ZiNGIyeVFPY24yWVBqSHhNWnFNaFczMXJQLy96RnlmUWVpamtWc29HUVFFaW84TVZXK1NNTWsyakJXVjdMY0pkZ1RFSWhmcFd5ZE5kb2FHSGNNOUhqczJuYTJuNE5FZGU4VGdnTW9FSkkzL0lFdzdBVSs0anQ2YTMvTDZ1TWorNStMNmFqei91Y0RzQWhpTlNmQk9iZ0IrRkZaS0FLcTJrM09jWnkzV2x2NnR2NnVXYzNtVE1FQktEQ0dVSVRFL0wrZzZSb25HWmV1YVVJMVdqWkZmMkRCSUJKQ3hVNEZVWE84YXdpWVVwWkNIWk5DR2NSbldSNGNmdXErYkRQTnFCbWJwZU8yWXVBVmp0OG9IZTF5MFZDZmM2OXI1UmFlZ2hLV0E5bG4vKzcvMlgvOTJ2MG5hOXFXMFJ4ZGxUOE1sTUxhak1XdWJKVVBlTDlMWklMU1ZGajRCWnVZTkpkd1hzRHNiYkRRVnNjWG5mMGROenhNa1JRVU9tdGVzWmJ3NmVMVVhXNmRuZXJZSlY4WkZ6Rk9yRDZaSU84eEtaR1QyVlltSFM2S1VpY3NQRDBBQUd0Z0VaUWw0WmVNeEx2SXY3QVlMdWhkWWJYTEJLTXBGeWpFUmg4NUUwMGFHRWx6ckVLNm1kQzVYSWpWNWd6dk0xM3piT1U3VHN5b2hFVDJYUFRKVmJUNGk4MGNnLzdoNjlsbFlPWk1pc2pPWnUxZnVITDVaNS9rQWxIV0dtcm93MHBWRnRSUnFVV1dJb0luZDBEc3JJU2JoUFlsNnQzMWNCU2JkazZGdUQrdFVKekcrOUE0K014NjNSa3QwM0NaWnMvK2c3YVVGM2x0SUd5UzEwenpUN0xTMnliNW1QNy85L3dBSmVqZUR1U3Y2TkVEQW0xU1Fsb3h2azFiUDMxdEh4NDZjdkw3U1hScmZzY21SMGgzR1YxdTV6OXUzMGR1czlaN3RjSkhxTmRZSVVHM3hCQXRuYWlXdDUrM1M1aUl3OFQ0Y1Nxd3h6ZHNqbkpxQmZMdnAzU2x6ZW84enZ6UTlvNE1yZUxLMmI2R1ZLWSthNGhPb1Q0RFVmWUVaYkNyTGtlY1UvL1cvKzRJOHU1dU4wdHVJbUtReWhVb29qVjZUVHFoVW5yUXlONFpZY2w2bU1sR0pMK0FEanR0UTJlOGdZTk5oRzI2VjBQYWNsYUxDaWlORm1pbjVBcGxlSHIzM0ZZcVczSUpXdGJzK0xKMGhHRE5SMWRFdFoyY0s2QlNjSFE4YXZ2U2NFMVcwUDYwaU5yMHJXT2RZTmp5bkxjUWUrMVZpZ2VTbTJCaXpYUGsvYlJMUWFIc0tFZG5Qek5HWElTL2JlQjZSdExGOHpWbmp0Vi9sbm1KN1krTnd5RStOK25wR3A4dENWdVZ0WFAxWUVmdFNKRmsxemhFRGlUZi9WWC8zYy9adUR3V2pxUXNpUVNZVmNmYTI2ZDZFMVFvZEdVdURINi9EeE4zNmFMUGF3bUg5UVExaXdNUkpQaVVuVlRaK1JKbEFoZElIaGxrNGhUV1Y0S1c0U1QzejhWdHlqMTMvTDZoNkl2aTNaOFg0MzJacTRzZjJqT1d3NWlwRllhb3RFNHJyODdLZjI4L1BQeWxjc1JnV0tLYnJMN0VQRTlRS3ZwZ3dwc3BhODJwTzNyY3VEUXc3YXVaa2djMis5SFBJNjRTa1htcWozejhlQ1NGc0M2bkNLZEl2V2Z2SDJwK1hYNTk2cmUrL0xLcDlydjdSajdXbnV0VlBRcUo4ZldJSjZ0VFdORnpSUVRLbTgvUFR5OC8vK3YzNzVQMzFZZVpOZWlNZ09KdTAwaDh4RXJ6UXpCV0ZEcmprY293T2xrZHJLOGNRQXBHOEtKM3ZWMlJ6NWFEU0xzSko4R1kzcVZqS0I3TDNNMWN1SjEyTTI1ZUwyMWFxNXJNdFNiMDBzbVFHYUJ4WitpejQzK2JENTJ4NGM4RjVES2VXamhsUGNMVlpXYTNZejBxU2tqUzQwOWwxbWM4Q3VVVTJMWm9jU010WkIxV0pMU0FickJqT3YweHFpbDZGQkg1MW9JODFwbmRZdU9yN1BxVWJqY1JtU3JyQmlKUnJrLzJnVUwyTXFkeU85N05lUjFLWWdWVFUzVW9rUWxQRHJFbldpbGVOZi9Pbkx6SmdMUkVxSnhybkd5T2p0YTdJVlY4Q3lVRDFFN2dOdzNpU1RRNkFhSEpnaUk4eVlkL0lEYjVsQ1k4NjZkU0MzdW14YktNYlJRK0c0MHROb0xVdGxadHZHbGlXaUIydDFaV1pHUDZjcGNyMXdsOVMwenJrQTQ4NWxZeDY5eGVEZFNMdGJ1cWZ1dm5UYjN5Ky9LWXlNZzlvb1V2UTIyc3k1Rnc4NVdnTWFtR096aXJhbUYyVW96cGZwcHovS1gxL2VsbmRMWnBrUWRqekZ1UjNmbE9XZE9WZ1paZEwxb3VKaGJOZGVubjlaYW5ITDNPd0dBalBLVTFtenpKNFpseFhXT1hNaHk0UlZKVlVuaGgvUEpTK2FmWjJ0WC9oVWUxK3pzSzE1cXZIU1hDOWI4bHNPdTEvRUlNS0xEdEdkTkFXODJOYmZIK2JZRlBtc2J3Nm52L3JGZi9Xdkw0dFpLdVppMVpHTlBzK0h5UTN1WnJWc0FhZTFsTUhyVDVXSmZVM3JFUm05OVN1aDZYa2VRek9TWHViSmQ0VTZmWVJSa3FhMi90bkw3N3g4OGNTTUR2cWFpaDVXajRlM0p6Ujd1Z0t0RTYyWGFrbXZscktwSW1qbW00a05zR2txVExIVTZXQktXWjJDc3NNcDN2a0FkN2lQWHFBNHdnRk41aDVMK09BZ1JtY0xZNkR1RWZJeW53OGV5L2w0akxVK0hUelhFWDdTV3crWVlaaUp6Wi9uMEhFS3JHdDZyWFV5d0kyYW90dnA3ZE1CMFdMdFBzM3puQzNqZXBuOCtxRk54OGxqN2NWUjlzWUV5ZDhtUDlyamJjQVVqLzNTV1duZlhJWkx1MmVDeXF4d1J5YUNVR1NtVlkrMWp6amZJUjM5WkRMMTBCajUxZ0RBYis5U2ZlZnBxOXZjaG1Pa1FGRmFlNHNSS3lvaFUyYktFVjg2WnV0T2N1aFdOcnZEOTg1NnZ5c2ppYTlUemJTdmQzMDZYUi80RUNLNlR3ZlBsUTc2ZExSdW41M081K0N6LzZaODdpOWFaWWFJR2tJc0tMSTVYUlFrOTNiUlQ4N3IwWmZnT0VHRWNNLzE0cE1XZTFOZUZzdVVRbXRYaXFYMDZ5bXlGRE9GSTlkYXBtdmwrNWRTNjNLT3VacG5ISTdYbmlyZGxMYkR1VGVGQU85cGQ5dDVxVTlrZStkeU5LKy8vS2YveGYvNHk5TmxmUkxCU01tZjNJeEdiRnUwYTlOVjduV2tsQkxOY3d2UktlNVczQkM3aFdzTGFCN3ZhUTd3c2FEMFNNcG45Q1hOK25vanRzU3F6TDdBQ2lNemQ4R0p2RkFkWldOUWF6VmpLVk10elZwS1dqblNwa1hITlBIbURSeEZQR3g0OTJtYnF4RXBLQWxMc3drdDVUc2ttYzdVdWpyTlhGVEVxSlRhYUxMbEJ0L2tra29hVldxd1RJeldrekJvelRJZkprYVRpWk16TS9ONmFUclM2b25WKzJpUmIyaWhXOHJmOTl2ak5ob2dDZUs0WEZ1YTlJdDN2ZXpaU29EVXJWcnJzdHpmZUsrWmpaN2krSEJ1Y2RnRGNuNHZubldqQ3J5ZUFuLzdDcjVIQm43TFFFZTNiTjI0L2RQUjZSVkpLVWFaUCs0aWtTWmg4Q3BoNWlITFY5RmMxQTlheUhyOVNwQ1dlZk5NRUI4ejdzem83bWFJbnROOHlHYm92WmZUMDNWWm4vSjhuU2N1QzBRc0RXNlpNVjFaOHV6SGxVVVdHU1ZRNDhPYVAvMzVTbDNqMkxlR1hYcU50dkswdnFmTjgwS1Ixak9vREV5SFM3TWVObWRmSTVXeDBwYlpMbC9iMjZmcGZFMnZ0UzNIZVQ1M3M4Z1lOY1hXV2JuWlhjYkViVGNGZlpRRERMYVRoUTdmL0xQZis0Lyt0eTgvNTd0L1l6RkV5cWNUU1ppN3pBa2FDbWpGdHhVOEN1WWMvZldRRTJtQTJkZ2h1T1hOVWNTd25ZNmpZTVJLV2V2b05sTmRWS3pUL2ltMHBCaGhnQ2t5YmlJZ3IranB2ajMySTIvSjNhb2FBYkQ3Z0Z3bFIydnBaVnZBT1d4cTNQQUExRDBXSzJrMEN3T043c01HYUtDNzJyS2NNZ0IxckFrcWtERkdhOE5FV3N5V25sbU5NQzhveFFwVGFTWFVXT2VpRmp3Z1dEMnRUdG5NdWRMU0hDMllhZUFJNU1FbUF2c3RCSXBYa2ZSZUxLMWYrNjhhbENFck9WcXRNZGhkTHBKd01YUHRJbkk0Qm5mWHlTNjdIckFGM2ZXdHUzTDIxWXJrOXgzQi9PUTJlZ3VjUTBaeU85VTVUVFJMa1ptU1ZHNm1weTdaU0QxaEZxYk1wT1M2SVZIdHU3cGsrTFlFcjNzdGtlQW91Q1Q3cEFNMFJneE9TazFscXBhbzZ4TGxlUEFsMm9mSStWak9lcXJ2eXR4QlU2TUlyN0g0dklzWTJGRkw5bUtIME5MM3k3bGt0T0xtY3krNlRzL1JVdWFXTmkyNTl1TXBWMll2WUY4OUl4bExNcXZIMWUyMHBobU5sNWtvcVVRaWFNWUNLcmdWVDl3SkhCeXIrbFVFMURDeVZVVkU4ZlAvL0ovL0IvLzcrNTlZTTJOMFRyUE1EVzRjWmlBekk5M2RqVnNYZTRqVW1SRUJRNFlFVjllKzJ3MSt5ZkR2OG5ISFZMbXN1UVRwTlNCc3RHRWlNN3dnTzVBUlBlUjdpRlYybzlzSVY0QlV6RWkxenJYMUpERUlpeEhkd2Nqa3NyM00yR2VjMmcxWU1nQnlDQW16aWd6S3kwWUdNdlBDVkVSZlRhR2VuYkRFTnV6ZW03VUpxWTk0K2NoRUJKRFJaVFFyUGxsZm8zdmxXcDU4V1NiekExRys2Q2F6M2pieVA4cmp3T2hiZ2tFZTdYRzNWaEpBaGsrQitOQXZLZ2tSMDJZSm1nNjF4Y2dqSHhmSE5RSTFncnN5WFJ2amNWdTR1cFBKYmlxTjExVG1qNWc2bjV6QXIzOW9QalJKODZIRVcrZVRSZDhiSVh3VWdVaUF0UjRwMGdiZkZIY3VLbjhnWWtjUFJxcmR6ejBtTVB0TTdmNmRTWlhObjlxbWVVSkxmTWljM3p6NWgvVzVYT0pndW5BK0t1QTFrMnJPWkozV3pPdU02RTFrQkdRZStHYXl5MklUZk10QW0weFcyQzU2anBkeXlpLzdXa1FqZTIvWGVUclp1a1lOU1BPNlpzWDFldXlINDdHOWRITE9ycEN1d3VRUmxpbWtvZDRuODd4Ti9pQU1NKzRyNFFzQnNGd3dxVmYvNm4vOWczLzRmMTEvLzAvZUVLVFhhcVVhaEtqbUJwZ1o3Mnd3VWpUMWlCSEVOOWpUQTkxTjM5aG1PM0tNTzZwbzk1S1U4NEpyZEhKcWE2TDJuVDZjNlc0OUxhSkgwbTRweFMzcVpJcTZ3L2xHMnhxeElYOU5HenlJeUZpajJlUGNQMjh3OHJ2K2I3d0lrNVdLUG9MRVNNSkdwZUVSVFVrMTBrYW0reWhxTU9STmdES0lORjU3aURBc2E2ZGd0WTZFQzNaak9LUVBtU1ZrZGlnbUk3cG9OSWNLdElrcjlQMEc5VTJZc1RYRGFmS2EyVi9laFdVM2N5OENFRkdlSjZ3UnlMUWNTWlN4eUcwY1E2UHVrWW1EcFA3Z0VQanVFM2lyb2ZRRHI4QzJCNCtBQSs4OUZLazhPeXhnSldEQ21PME5ydUsrejJRcXUrd0lKRkpEL1p2U1pxZWhmc0FKL0pwRXNBTUc5SEY5UDB3aFE1Y21LOVVWRVY4ZG5qNzdVWG4vVlQ1UERYRzU4R2ZIYzc2ZEZzS0lualhOVWhicnJJeWdXNmU2SnZMcnorWUlkOWlJSEdZbFNsblBlRDdHdWo1Vk5vM0xBUkZyUDlSNDN4Q05uSzFGS25zclorZlRlcjVHUVFxcG1tdVoxZGEyc2VoamRBc1FHNVFxZCtPcCtaWkQ5Rkd6b3MySGF5djg4Yy85Ny8vZHYvekxOd1RkNmxRUDdoYVJtcllyMk1Za3lkdVVVcG1wakdBWmsxR1ZxUnJNNkVabzJKVzJ0Rlh3L2o3VFhwWXBvcWNoVzVyZk50TFJtZVV1dVFyZGNjWFlmZmtrUTloc05RV0pGQlF3QXRXVjJYczdTQ09XUUV3cDg3NXVCeThyYkF5MlZwOVBQRi9hdEZPL09KeklWSWRaR3QzR1pYZnJJMndtVzFpQ0NMTklvU2ZVUXN4d0t5WjExTklZNWtDSlJTVnB6VWEydVp5V3hXWGxCZ0FkVFZ6b094WkdZdGNWalkvUTZ4UWR5N3NKWUpsOW4rNG5zcDJ2U2RtUTZGRDBTTkszYjhDK25iSGo0cFA3YVRVMlZIMHFFN2hyQlg0YlZ2MjJnRzlSV3BrM083QmNhNmFRNGxBR2JzRmJpY0Z0VmtoSXlkWmhJZGxrcVRuUUx2eUJkK0NkZmZ5NEYwbzNyOXg5Qk1JZE0ydVRRNloxcWFjM2h6eS9mMys4T1BMOHdyZWxYUkRTdGFHd0oxbXdka2U3VGdxUXRDbWFUUmJ0YkUvVE5jYjJUck5nWllaR2kyenBWUm5GbFRuVStkSGhibXQ2ZGFvak1ldXN3ekh5NVZ3dHJBQ2VZU09aWnFRSjlpMDNOOUllTW5pQTZwWWJzdXBSRWtlM2dzNXlqZmx2VHI5Ly9ldS85d0gwVXFzNU0wTDB1OFYvYzladW84RTk3STd1YU9sR1dTbWpVVDlvcWNNSmszdzgvU1FaempHNXBKNGRST3duZ3NFY0dabmIwTmozR0YwM1Y5L3hXaVJUaER0Ymp1Uyt3WE9PTkV0RTlvMGpucnBsdHQrajJ3ZVIyd2RzV2htQnlDRmNHU3FkakJDeUMwNGlSdXZOWWtlRkRaVlBKb3pack5CTW1SbGhqZ3l6UXE0cDg5TVZwUUoxUXU5dUdTRlhLaktOQ1dZcjIxaDV4enZndThhZ3U4MXYyQlhKZ21sTnRSVUtUWFFNTW52azJkZVh4WHdNaEFCMkI1cThCRzVodzNzNXhGdmY2a0VGclkrYVdKOW9zWGY1bHI1TDczZ3ZlVkxwbThxSFR4WmJwRFRKbFByUTAwbHBCTkp5eXk5NXNWcThnRmRRVE5QNmczdlFlbjBGLzY0TjVzWXpUZ0hPT1NPTHhmVjMzaHo2Tjh1NS9iaTNncFdmLzk3WDcyRy9PVDVmc3hpUldUM1hOTVJMZUFxUUZheGVTcmRMZlh0WTJxVE1oTG0vV0tuUjY1TkZQWEJaaTRKV05YZ1JHVzJkYUZ6WGFrN2ttdk5oV2NOUGIzcWtaWnFMRUxJcGtKREpaRWt6RXl4Y3ZLMWdBTlVzZWliS1I0RDdNdG15UHAyVzg3TmZ2dnE3UC8wVkJhdVRzU3NEUGxYdHJCUHRUOXlvY2ZxT0IvU3FZR0VUYWJrWmZBVEl5R1JxRFBoeWR3dElhREVoWUwybk0zSVRkb0YwS2lNNkFXWnExb1ppTHhXOWo1eGhnaXdNQXNSRkdLbGtadFBzRFF1UmllaDlDNjBlVFZuYmQxLzBMUS9leGtRdFN6K3Y3Q2pieENsSktTSVZDRlNUV3ZwRzFSNkRNU01wSnNQb1NKaTdGSkdacFNBeTNTM1pJM1hvcStmaXMrVnFJTHZBVE1EUEJXbVozZjl3SEFTMjE1UytMZVhZSjhJWU85Q095K3l3cmJaL0xuLzZGMkVkMFZEemZDNnpYcTcrL1BMaDZnZlQ2T2x5Wk0rRGlPRW56dXpRYVB0bGJIMk5UZkk0ZHR1dFVEZUxRWXUwWXVCQXg0L0phNW9oSW05OVlqNjZwRUJFYk9qb1VwR3BtTXpkQ0lRWDlvNENLUHRvOStjQTlvUEZCNWJmbEwwUVJQWlZHbFhwdHFWejgzZmU4NEgxK3RmTjUzTHpMdSt4Y0JzV2Y3c2NpZTVtZGVyUmVzSUxwaG5YTTQrZnJRdGpzYytla0pGVDdTcjhjRDArOGYxMGNCUUhVMTZRcXExYlJRalpnMnlMTCtlVmhsNHdCa1dMNS9tTXVlYnB5STVhaDZLbWx1c1Z2Z1RCNG4wSklMTmRlckhHODQ5KzlGSVB2NjZTVzdaVTBlV0s2akl2YUx1ZVRWbVFrYm5mYmR3OVd3OWhKRVhmbVZWU2dTcGJxVk5jN1BOajl1bDRtZ3NSdmJOVWsyR2NoR3ZDM04ybnFWb083MXlDVWoxT3JabmpNaDJuNGtTNWhWaU02NjhOVTlsSS9SWjQ4bi8xODdtL0M4SFZ1OWZld2d0aEZhWG11WHNNVVJTVFRzbmNPUUx3Tm1hVnBUbUxMZTg5Vk9aSmtkTnBZckk2RThwK3E3VjdSbyt4OEVZNm94VUR5RmwrcUNtc2RJTEd5YnlVUWpQRjJwUG1UbFByV1F0SlpyKzc0OGE2eWlScGVTMHBsdUkyZDV4bXFSN081N1gzK3NSZ2NjVGFCdmlFWGdDZko2ZGFra0xaNHc2RTExZGdlOUJSN3VtaVczUUlrNEFPN1JmZmhFYktlRU04NjVweXRCeEhLUWRiYk5qS2VET0FhYWN5REhJUk51VGdvOEJIdHlwenYxdmVXeGhiWi9nSEpZOXQ4WSt4aFR5NU8xSVlsTVA3dHhHRmpJUUcxWkp1OS9PMGIvRTcrRzBkK2svbndiZkw3djVnazNmK0Y3SDc4V2pHRExDYS8ySjZzcmx3YXIrNi91U25lVzdYMmxBS1JYTWZIVi9hYU4yTUI2OXJQUFpPdFF1QzY5Q2VrNjNUUEMveGZPeVhkamd0YTY4V1lWUDNJa2xyRnBIa25sWndNczhwKy9PRnpwUjhaVVlhWHFWQzNSTm1STnZ1d1B2WUxCL0lDMXN6VWdDMVBoL1A3Lzc2N2VtS3VKTEdXa1l2eW9Ca2dqT0ozb0ZMbVp4V1BJWTRLcGs5Q1dpdUk3bDVmLzkydnZmK1NHb1BIbDQ3REtVbFJxS0QrOVloQloxbGpkdkdPL0NVdGUrdTFGM0xYaWZyYS9jRWZXTFgySzlFWk9zcGxqMCsrK1pmZklncWlhRUFBZ1J2RzJXbkpnSUdsT3l1RFdtOGMwbjI4dk1WWXc1U3BGQUJrbzVyT292cytPNmF0U0l1eDJqUnhvb3FwUnJTRUlJVlQ1ZVpzdkFtTm42dDVIaWdaOThjY0NUZ216bWdudjdtcjE5eWhEOHJER3E5SHJXZXR3QytJVllkOXFOOTZwdTZZY2dHYndXaDI5dXp0OEQ1VVF0clN6N1pYRVEvUERSd01JQzVnd3JnZzJnVWRpdlVkd1RoUm16YUtVZEFBaG0zNnhUeHJaNEZmcGVhOG40WDRIN1I1dTdGZ0xEcGxiV1RFWWF1eUF4VERaaG50cWkrTEVNNTdORzNlSHNIM0UzV2wyR0Q4SzdvemtoMzlBdk0xMUc4aExYdVIrdlhPY2xjTStwWnRWeDZuZVMycG5MWlFzSjZ3a0doOHdXbnkrVjVHWkNLTGNNMUh0Ym8xbmZlRmMrYjVPZVd6cjRQRXJhTXB0alc4dXgxZXZuYVAvczhXaVNMZWEySXhJRm9tdklBQUNBQVNVUkJWQzQ4R0NrK0VsclJWR3pNMUlBZ0k1Sk16Ylc2aldia1hTdC9lOXR2b2s3NTJyeXc5bzdCc04zQVZWekl0TnA3MEVnM1NDR1llOGY5SlExdjdPbndzdHFwTEMxN0dmcXNFZDNjVjVudDlEVGxSK2VHaGlGeUttcDlvL1lJWmxZakZOcytSaHRDb2gyeHBtM1dvMWVzdGRGMFh6azRieXZOclpUamgram1sdXV6NTFZZTA3d1lyNXRNMnBVaWg1bUJkd2dxSG1pSjFPT2RKMitmb2dTbVRzc1g3Nlo0S1FtNmdiN1V3Nm1zbDdQbjFzN1pUczc5ZFNmMjVFa2tNa1Q2aGwyL2MwTWYvUnozWWQvdDZPWkk3UDdCS3poVE51WUhZeStpV1c0L3g5MkpRRzRaS1VtQmJzTVdsckxjVnJRZXhOZy8rUHpkUXZSdWNpNnBZTVBSYi9wUmpaaE5oeFVpb3I4OTRJeERyTXZocytQbGd3NHVWWXUyWk8rTVRsWjZjWkVyc0dIa3huT1lwUTVaajRhMmRwUTFmVG1jdi9KeXZINzFlNjZaL1FwM1Y0NGJHRzNRTnh5U2ZUMWQ4ZGw1L1d4ZDF4ZzlQcFFzcnMzU09tQ29EM0lXM3FMYzlzQ1lmVjBOUGV1d3JCamZ0cXU5WVp3L2o5YURicGlxQUN1SDdVRmViZHh0ekV0eElyajVFOUNIMkdjcTdqNTZ0TnZUbVpaMmgwenYvN0ZyYzRNbFV3bmtFQnJSeW9mQ1dyR1R3Sk1TRExialoyOUxXSXp3NnZYTjIyKytXbkptTlk3YXpjZTRkc2c0VXJwaG5CNnZiRjVucGdSbUZocGdYcllwZVc2NUt6c3BhaHRGalBpRVIwbC9JMnhEUUJoSFFIZ3FQZDcwMW8xZVlMVmF6NEVVakk1THNXUkdHajBwUmVGZHFmOEl1cjF4c1c2R3YyRWVHcW9OWk9vWGY3VitkbzQ2d0k3d01oMXN2U3g5T0RYQllYV2d4Y09jU0FBM2FaUVZNd2I0YUViQ1BhMEtOOTJlRXJrNWZQUzNTZTNkWElyRUhsamVhVU1CZjg4VkZzQUJYT2VHZmpEZTVvVzI0YUgvdGlmd0hTK3ZYYkQwT0ZqYWhXK1NvYmpCYTBIdmF6eXRHZFg2K2NObmh6VVB4U0phWTBTZm94VkRwcGtYVDhtOUQ0c3Z6Y3hrT2Rkc3lTd2p2OWQ3TFlZSXZIZzlXSTN1dGN5aDZBcGtrdWxHazFJeDd2amVaK0hVM3Z2YjkwczNVNFBCNkliK1lOMGN6a2ZpRWRLWDJqSUFONFhIVFQ4LzFKTG1heDVxb3EzYjZMTTZCYStUWTE4TFZtcHhPam5TUS9kcFJLWlJLTzRETjV1M3VGdWthU01sNEo0azB0OWYyTE10QjZTRVlFK0M1cE9Wb2g3UmJZeXFtS1NUR1h0bzM2WW9vN2NYNjRsd2QyYTZtMkxZbk9BMU0zS3ZEL1dSM2s5cDlGcnJOd3B6YTczUUNDOGx4TUdXaTBTeFpPNUYyRmJkMk81cXYxMVBiQmhmTllMU2pyQ1F3QXFyVmJKMzhNa29URXJtbW5tZUNpMnpWOUNRR1dWL1B3eDRiU1hVTFErU3czKzA3ZmdSTUlCZi91VVhub25la2tVcC81SDZ5M25OTVc1STJ6cnBOenJqVVBMb1pnWElPampRcGh1UTY0NWV2WTBKdDl5MXRQdmw2b2N2WUNiM2M4Skk1WmhzN3Bmb2U5SURFTnVNYTV0dURjOEVOaHpQcDBESkgzZ0M3eHN0Y1F0UUIwZGF0MlFnclJqU3JVUmZteFIrOExoY1AvZExQRCt2djVuNjJsbThUQzFRc3FzWkJkS21TQ1ZzeEY0WHNkT1pWRXdad3kzRFlwS1ZQTHpGeXlWNTlWSUNSSTlJT2ZzMnR0U2dwUkJPUkZmL3pXZnVSbVVNTDNudUovRCtBZDdVYUZ0Z0YrNGw1YVoxdENGMElHbFd6QzUrOEloU0xtYm1CQ29sMHJoMWRYR3dVb3NQQ1J6MkFEaGxtbWlRbGVMREhMSnUwOHR0UEtFZEU1OWJVWHI1K3BKcmovQTlRVjBPZ1BaMG1MSzFucjVyR0VBNkl1dWVaYmoxVkx3djBzcDNiSDZrRVJsOVVKQVRSb3krM2UzVGUyZ1NVV0ZtYWwrN0ZmY1l1NTY1TmNLUUVUNEU5b1BnZWF2Z3RGV1g5NUxPdHlWUkIxK29NSHVJdWJhb2g4T3lScWNETk5iTWtlT29sSGRFMlNpdlpVZHUycWQ2UkJKVTM4ZGV0K3h0R2QzYUw3NlUzdUZ3eVhDU1ZuTjkrWEJWTGJkUWlPR2hqd2VMci9pSVdTVWwwZk11WjlaZENuWkhZOXdyNkRHQS9xRy90bVNrN2E3cGx1cVAvYnJiWmxCU1JPeWJ3OWp3c2RuK2dOd3pYdmhEa1hhdm1samEwZTZESG9FdDR6YkVwTG1iSlZpekw2dE5KNWkxU3ovOTVLdDM1VG12NTlKN2c2YWpMUzNkRkd0SmtsQnRYYWxrMytyb3pJaUVJcE5VZGpTcVZ2Uk9LdGRyaW5OVnQycVJTbmQwMzA0VlN5QTdnZGJPMzhUeXZ1amdheHZkZlNYU3RDZDM0bUhqNUkzVW5mZUI2MmJNR20yT1FYOHV4S0YwbFRvc0kyYmJqcGhMa21aT0hzeUsyN2Fuam12Z2Rpc3dTM0VxWnJ6RHYrOHNLcjJpa1FuTEpaMHEwMmFhUzI2Ymk5ZHlYUUpsVzNaam1NMHRMdklPVEtHcVFvNyszczBpelpmV2h5c25oKzJlMHVDdlU2OFVnWjdkTFpkclVrd2dSUnJHSnBiYkZaK0o3TUFPdWVNOWdFQjRyVnVRWUM0em4wcFpldnBzOGprbnFOTUJCYnlHQUxyMGJORmtGT21FQnZSZ3BJcDhqS3JocHhFcld4TUs3dUZmcjNONy8zdzgwNndVci9XYjVieW1LMjV0MGhIcGRlTTg3a0VGZkdDemFyOTM3eGNEOGFNZW5iUkxXQWR5bmovNE1ycko4T0VTckxpM0hJNjQ4a0NXSUlBcFU4Q0lGaDlSUDJQY3Q2VnE3V0o5L1MxOVNUZUV5SzdXMUJhSTVFUU9NNkdaTVJFUjZ4TDFXQU54WFo5LzU5MjdEMjkxemJjbE8xSTJ0NjR1UkM2VlpZelVMSlRNdnNWR0tYcExWL1lSaFphaGRIZms1YXMybHpmTHk0ZkNUQ3NtWkxxcGMrelZlME1mRnJGZXExOWZwdGxqa2NGTkVzTHV1cks3MHdVM1ZMTjI0Y3BvU0kyT2huSVVoR2EwTjJpOW5yQUFZVVZ1SmhteWRUT25sM3ZFQ2tPa2RuNzdtUGxrc2hUdVNTcWZpTjF1MlpDUW1NRmE1RzI0Yk1kVlVCbTVUTllhdkxRdFk3MUU1bERzNndHUUJMU0R0M0NET2R1Q2VXcXRKYWxFSm96R1RBVnVZSlg3QXJaTVpyUitHSTdwWHJtMXkwZllzVXZKem1qMW82dVZQdUtPOTRFY1Zzc0tvNWVwazJYeStQemRGVzJOYXRFWGcyTVZ6R0U0NHJJcXkzQmJpK1ovdUZIdWtUSkRiem0wU1ZzUE9kTzNlK01XMEczRVFldVB5Ny84UmJ1Mm9nVTVGdlQ1ZkYxYlJHU0wzbVhNT2p4ZGtSSzJRZ2tDWkNrM1dMV3h1Y2NEQW4yWFJmTzJYWUIwd3J4NDhlMW5lc3UrOWdldHgzNUMzMHhMbzB0ckIwUUV6TkRERG9kcWpqSE12Z215elF6MEVqRUt3bjJETW81QnMyak9yWGUrelhEd2tQU3lGMzdKMjNEZ0xvam1qUmQ5ci82MFc0WWpRbEJtclpaaHJuNjlaamxVNS9xK3YzbUtYeTVDUGRteTlBQWRiYkVDbWNuUjE4NDZMWDJvL2E4eXc5cFJxRklOWEZCcVFmUlNEVFIwcmVkK2VQSkEwK21RYThKci8vRm5YNnc2NWRrcjYzbjF1a1paNTk3UDdVZnpyNUdDbWJwRkQwRVdVSXFLSWlXZ1VLbHNhOEkzMy9ndVNBcEJvayt6ZXBKUW1Rb3dIV2RyM2FwNmVQYXdVdXZXd3ZHM2N5M3U3c1BEVGN1aFdlZldZRE1XUzNuQlU4L0tkUTNmcEFoQk4wVHZkZis4TTNva3VQeloreW5TamhlWU93MHhXRTF4blgxcFpOdWpJQnFaMDA5Kzl0TXZKWnJ0TjhQTVNTRmthNVppS2VnNURtYmZPc2xLUllRMGJzYVpzWGZ6M0tzcnJlb3pXMmhSbkZERzJwUmpKMXRaMkpvTVpBNERzQWIvZlB1MTY4Q0hFaENrSTFHMFR1a1RXdGFjNXV3MG5RVWNucWVlODB6NVZFc1hlN05UUWh0amE2RDdiK0xkajhuUXIvRDRHQU1XajNkZnBUYTNqekxXSUphTUJNMEtqSUx4SXBGVzdmcFJzMGY3VERpM2x3QitDd2ZrVzZkQ0FzQkltSDBQVG01emMxbmVla2xXM0JTdlVjMzNiK2JJMTVTOVI4OFZFSWxQMDk3NFE5eEpmR2lsUFRnaTk1YnRWRWFnckZFWjhOblhheXZ4MGxaNFFjVG8wMFNIUVJsZWJIRXdYczRxS08zYXl6eVVSY1h6MXVsUGlFN2x1R3pXaU9ocFZWU3IxZGNLbTRwNUxWT0tKWHBaQTZKaWpQWHEwMm9GS1pZK09zbTZ3VXJ2ditkSXN4OGJPMi92SHdVdmxqblVSVk5oc0xoRmlpSk5adVlrcGxHTkRmVHF4K2FPaHdNMlIrS0YxbVFpa2psWUpoZ1ZMZTNlUlJacFp0ZkdvclYzS2lJSlg0Y1hOQ3R2WUxheFdqeVo2OWxzWlB0NkdTUVEyL3JxMnYzQkc1V0JlVU8wN3hsWHIxUitlK1BPZnZ4OGhsdFNpRnRLbHpaekhXMHdqTDhkZ01ndGNtUUl6VkxqS0wreWhNTExmcFU3QU5uRGJaNjhwRnMybUJPUTVlaEtsU0gySHQ5K0wvTDVFZXRHRHcrL0pDL3R5eStidG94cFpIWXErOEFjQXh3T2tsVUQzWCt2RzdZRk9GcXdDb09CTk4wYzNkOU9hdDBidWJ2YW82WG9tZDk1RngzbmIvbi9PWHUzSmp1U0pFbFAxY3dqVG1haXVycG51VUloK1Zzb0ZQNy8zMEFSOG1Gbmx6dlRsNnJDSmMrSmNEUGxnN2xIeEVrQU04TkZQN1NnRzBpY1MvakZ6RlEvTGFBOG9JUzdLYm9kemlRZGMzV0ExcERLSDZCNkpxSjcrNERvL0ErdTMvRnBHazdFOTlHY2hzRzRPaU95MEVJeVh4aTdITzlmd2xmUERhd1IrcDRMNVpGK2U1Z2hIdnYrNjh1cjNyZHN0K3dodXZWQituU0VBT01PcjZOTyszYS91Um56N3JmbER6ZHpwdml5YnJMYnRpM1lwUklGTVByclgvN1pHakxROXBQUVZqSVd6WkZFcHN6ZFZLRnJKMXEzYW84OVlXYU9tMHZtWm50bWplMlh4V0UwUjZCOHRGWmhYbE8xOWtFa3E2d2szODE4N21Pak9FNlN6Yytua1VhQVh6ZGJJdmNnb290V1B4M0doVDFINE9XNEVabnlQZENOMmROOUNkWGRjTmdPQ0EyTE9ta2k3SERJSFhENXkvTTIwa0pBdUxYbVk2VWZXbitoY21WSTY0Y1NCZDloaVdlanVNckxldUsyWmJFdFlaa1N6TkZ5ejhqbVhOeGtBRnRydWJsdm9tam16Yy9HMFRFUXVQYXpwczdEanFMYjF2WHJYMy8zOFc5blZudHM3SlBZdlNicXk1RFA2NUpxYys2ejFWN2lvRzBSL3diemFsTGd4amU1UVZZdWlKL1huNlRacG5sMktydXkwbW5PVkxtams5YlVmemljR3QrYmpia0ZmeXJOL25semkrUUZHY2paaWdGcHpvWXNsVkFtYnpmcjZGd1daR1pyMm14cFgrc0ZoNkVwZDNCdlJWcCtYOW92eWI3ZlRwa2FRS2RseGlUNlpFUlhwQjczMW9IK2VIbFoyWW1NZlU4b1pZdjg5bm1ydnlZd3RrKy8vblBzbGozTlpOUHlxak5BdlViWE1MZk1pTlRKcDZxclc2Q1RYdEpZRFpwZzdlcHRlZkVRMmNYU1dKQkc2b3hJdUg3ZzAwNUtLSnNUdERiaGxsTEo2V0tLaTRwTXBIdFBLZmUrWk5YMXpaMlFjUjBMT0ptRldVb2hIenZrTGRIQlh1S0lRVjB0dHhVQTl2TlJHMjZuY2cxZEYrKzhsd2pTWCs4S2FoY1ZxY29ZUGp3ZnBGbE9mSlQwZmVvbmhSd20rZVpPZHdOcFhBTVJVdEs4YSt3eE5Yekx2dE5GWk45Qkl4MnRqYW5LT2FmaEI2amRoMjZXZ2ZyamI0L0Zhc24yaUNRR3V5b2hDMWlHd1lERWtkeGNlWUU2eDFMUHM1eURzOHdmbjhCSGw2TWlXU3ovalc0d2FXNVNqSEVCVTFzV1pIQ090YysvVlpaVUNkOUh5cFRSVFlOUnplOU80SCt2bVhhNU1vdkRTbE53SDlMZFRCa0I5MFpwZVZuMFZlR05YVXU0UmQrWGxoazBINmJSZmQ5SmduNWJ2clRiNjEvczkvZWJFc2pBNks2YWVxWlI4Z2JsbmoxcHBxNkFKZmVWVFIyaDZIcFlKeUxhNm1sc0ZvcEV2L2UySUJKSytCUm9ERXYzbFFkdEpQZk1GTWwreURwc2lGYmN6YTNrWE15a1ZYMWNwWURVelphcEtSM012MGxvUHJXdlEvSkFNNXA3b2xYckk1VVZpS1BEa3N0V2JsQkVqOTczUkplWkZPRkROZDBpUWNBa1MwQk13ZFJKYXk5b2orUzlYQkxpRkdYU0J0KzZIbG83dXMwSlpjb1BlWHQ5dDNXOEU1K3h0TFVQdUFmTjkya1RKR0IweHhpUTRidFlJQTNBZFFVVEYrd1lXS0YyVTJ4UUJveDRON2RHTUNJQ2x2MU9vb2ZvRlhuVkc0ZHlyRkplaHc3LzBvL21HSGpQZnpaY2ZmL2JQMmdvU0U0ZTdob2QrcGJNa0dXSnJmWmpFZUFNQnl0U0JTWjk4TWovK3FFczRpQzVsUHZyT0J4K3NuRE1yT2dPeHdHUlhXWnhsRzFEM1RhUW5nQitzSHdQRUk3K1IwOWdlOG9JTjU2aHBhUzVXODhRdlRuWmxwV1BSOWhpK2RncFdDakRDWUZPcWUrSmlQN1NtaEowdkJ0ZTM5Ni9iYXdlNGV0b1lWU3hCc0VRaVF5YWwzTk14UDUxWDNBUDBTdzNac3ZmNDhXSkpOdWFQWkQzZDMrOTkyd1dTVXhKWlEzUTlWejJ4WTZMcklGQU02dWw3YzJNWm9IS3psdzA0aEZqWTRyUjRENmErOUtaQU1MTGxFSUM0Wm5teldDTXJ1WjFtR2VtR2FtTWFtYU1xalJUNk5GN0QxZ2YyUnFEMjE5cExJTG5zQkVqYUV4WTMraUpWRGMvZEVzWFA1emlJZ0M4REIxMUNhYVlUZ2dscFhXNTNWNi9MYm5QNU1hcnNKRGtiYzhjekpubnhKR0QrekR1b0dHWjVwbVFOWSt3N0dHRStsSzhibE4ydU1KQ2JTRnN5Y3plSDFzck04bFVxTTFvcHU4Q0JzNWZMWEw3L2Y3bXZZdFVUTFZHUDR6cVJBYk1CTm9ac1RDdlpjWEFUSjZ4d2JQSTBML2p0cjBVcHRMUEZWRm16WkFSd1RsZXJ2Q29IQXdZMmRRVjFkR1NSU1lVZjNDQzZrZnVhQUw4RHhqOGJWUnVzME4ybk9ZY09EVFZpYWJGVFh2QVFXcC9NTVFXakVmWmZpM2JlMzlab1F3SGtjblg3WXZndDdkNlQ1azBHSkdSRVdZTzdqTFdJTktVUVhxYWI5L1MyM3N2TzBSWTY3L3BmMDRwS1d0YkJQUHgxZGQ3Vjh2U0xWd2YydE45VzZGdE9wTEZlUTczQVpqN0lEeVN5MXJTVVlGczVlT0NXN0VEZFNRY2ZHZTVIREFwV0d1RWV1NTBoR1BXb0FSeXQ2RlNMVU9OVWx1ZlJWcU8yS1o2MGlMcEdmQjVYUnJ1SmV0Yk9GSzVEUEt2amZLc0hXcVNrZTg3NDNZVWdsRXpJek41VUZWQWt1dmlwT0FkaEdJcXhqVWJ0RmkxbjhYYlpTVU43Q3BHMnFNSjJUMk5YOWNWSTJaWVFYVXppd2ptb3RoSnlYdTN0U1V5SzVxc1pTV2tNWS94SzMvVXpEa1h5QUxGQTIrRnUxQzMwWFFBTk9LYjZ3c2U2ek91NisveUF5OVNaNXd5ckIrdVhic2VBWHc2ekg5eUFwZVZ1bmJLZEs4d2lIazkxMGNPKy9NTjQrTEcwbm0zLy8vZnhETDhJQUZzYXVqb2N5OVBMR3ZlSC9DbEUwUlhUelpqeEJJRmhHcll1OHhzczhVSTZWTytmN3U5M2ZDNTdIM2tVUDcwbmpRSE1qbGk3RFBDelJ6bTIxZCtNdTFJS1IzV3Z2N0d2MlFta1hCa092YUhXM2JaMHM4ZDlZa1BPRmk3eUN3VVFXYTcrTVExalBmVkZuSmIxeXlNRnMzV1NMa1JDMWg5NmdsZUdVMnNqMXRrR1pBSnhiNHRxVDYyRG8zdktud3NoT2tVN3FtcXFiTFBDSEVDdENpVm44MS9ZVjZKWDFLeUJXSkdqcWhaQ1dLVmtuME03cXZxSlNveWhqd1c5SVZtRHppTTZrcnU0UVdnQ2R6R3BaempzR2c3ZEFFNjhLTmlyM3kzZ0RGSnVyNFNwbzZHVkNKeVd6d1ZuWVI2TjFQRzQ1Rm1QU3Nub2NIL2oxR1VqaTNVOG5vZ2NxYXJ6d1hrbnZ0Lzh2LzdIK3ZYTDlZeWpUbHUvQjRhTnVYQnhOZ2pNeEo0ejBQaldvZWhHYTB0RlE0THFXWGt3QzRNM3Rja1cxUWJvSlUxSkx5MDc2TzFMUG1naDgzeDBxQXk0MlgxVENLcVlRcmk5bUkwOURTdjdJaWpRMVZNNHlNQUZwVlY3TU5xSDZJTmhpa0J5UXZSNG5UMk5NVFloWithT1UrRC9vdUJoVlBIcmNHYzhNTENyaS9ObHJpL0I4ajliZm5qdHowZW45NlczSksyTDR1NG1McXQ3bTdaNzNDMTlnanQyNFpLL3JHK3kyNnZqQ0dnQ0N5dlg3SXJRTjl0WFNoYnZIbmY2SGdFMnYxM3U5M2Y4TWM3bHNYdWJYbi9XdW5yNit2YVhwVTBiK3NYRlFqNWFONk81OVhMYVEwcWU0bytlQlRaakVxdUx5K1ViSEZyYldsSUxBdEZXOWExdWJzdjYySnpkeWZOeHhXRUpLSjZtdHBUdEpvUG14TzZQN3A1NDFKL2RzWllXSmxuekwzMXhudkdsLysyTGJ5SEsxT0xSZHBpVUkvSTI3NHJaYzJkYmtZMzR3S0lyVVlsTnA0eU1TWFMvTDY4cmRuaFllN0RrdTUxZWUxWmdDN2o2U3AwcHNTMjNoWnp2SDlPUjR5d2pUNXNxV3FyWjQvazIydnZ6WlBUMzFjeDE2YUtuSFBXS0l1ZXpjUGJRelJGV1B0MGYwQmZ0bVpxeTgyUTJyNXQ2eSt0djlNRnNtY3ArTFA5VUFUNDRYOFltNndvWWNtdmYvL3ZYK00rckVRelZ2c2lYUjd0TUJHcXI0Y3p4bjE0ZjBkeE5BbnNKYyt6NTY3M2xMQWp3SHFpcXFFaTh2dGIvWWVMV09TMHZsM2NEM3d1N1d2YlFlV0pIcExsNTJnS2ZZeG9PamRoZnNjdG1RVXZ2eWQwVEFtNHlrOXJFMVppUnRPZUVVbmF3cjUzczNhcmdNRithOGwwcWhzWUJONjczWmJXdWJObGJPNnRpZktSQmQ4clVzU1k4ZEozTkhRcDA5eVlYODBCUlBRT3M3N3RqM2REM0J0TkFRRUphK25vNmN0cmRpaGR1c3BrQm1Nc09TSEFUNWMwaXBJMStMSVl1cldHYUdaVU1qZlFxb09qNndkMmxTUFdjVHg5cXlPbGZacTE5c2ptY0MvM200M1lleXBKRVFrb1NVTnVlMXR2MnIrdEdnbndkY25tSGdta0JndittSGN3QjJUdGluSVVvT3dQOU14VXI0U1hHRHpDbXZEb1E2UU82UFRTZ3NKZnR4MFdBNEU3em53RHN1NEN3RlBpbU0wTjNZclZWUjkyY3RPTlV0OFE3NUd4dFB2KzZESjNNM05BK216bSt6ZUdNL3BtcEdVSEJMWi9MeXRrY3J4RkdsUHlsL2o5YXkrc0hzWVU0eFJKYU56SEs1NUo4MDJCU011cHlwdk1rMlFaaE9iRThUVCthSHBvUjBpWTBhZVBlTlFNSDdKWXJ2Q3U3RVUrSHhEVVl4andmRVczVERQTHROVFpIRHdtMHZOYThoVFNCSWpsK2JvOEFKUFJvVVB6Y0JtdmpFSjZQSEtBa0szUTVsQjFIaGtaS1ZCTjI3WTNYMTRiQktZeUFJWTZqT3pSTFBmSFJsZHVpMXM4ZkdFRHNvSEk2RDJ5VkFzWitYcFBtVVZ2MmRmVnFYZnpac2krcTduMW5tdHIzb050OVoxR0EyMFJjd2R1eTljdHJiY2U4bG13VjlKV0dVaHBJeXg5bG9sMWhLV3gyYks0Z2pTVHRUSTdjZk9sdFRJWW5pYzV6MUpJdExxK0hzMEdHN21kdzFLd0o5a2FSK0FHZS9VeUFCc3RvVzRBMVZPWjhCNmFCSlN4eGV3QlFncmpWUUZQeEhCcCsvT1hDK3pCck1qU1llVWRKQ3pwa3NjNFBiWFZZWGFETE5ycjhzZFdZK1Voc1NyUmZzQk14WGFSMHA1S3M3bGRqVTVRVFZaRVczUHY5MDBJck1yTjMyN0lNZzNvZmxzWmQ3UFZ1aUtXcHR3VHBEVjlPRXIwRTAwUlNJT0Y3bS9ZQXNDTXBNcHJtMUtxOXBTTlkxZHhsRHVSRW9rekg5TEc2QmlUejNkVW04Zm9aa3BWSUtDZDZCb05UTklQVCtGRTlEcW16WkNROGZRNlg0K0MxdUhOZThZQXJrelJ6dGcwZmxSbzY1Z2hQT2tQZUl3aW5qY1VQWGM0ai8ycDFQRlJhNkdrQTJiRzZBbUJ6U0pKOXMwTlVNck1jd2VXVitEYis4c1lHdVMyTnhsZ0NJUjZZbFl1Vy95Nk9DSEtsRnpYMkYyWnhrTnhxayszaG8zeVptWUxtcWtoRXVEWDEvVWU4R2h4bVNkUVUveXZiRzVLUHVVM2E1QlZXak4yTm1TVXRWb0FmTG5kdk1KdkQ4VFEvQW80STNGdzlxZHFYOHRSNEVaRThUb3JEZDRQZFc4SkxGSXE5TlArRHVQK3dQckxYcEc2RmtNMUg4a3pON0RPbWxQU2ZRbG5HdzBlZVhhYUsxdDlJMmpaSVlEOStVR2Ird1N5dmg3NEhyZTMvSG8wZnpsNzIxbTd3TGZPL1dET2pBM2dLS3ltMHdYaWJZOU0zdnc5ZDFudVdwZVhXSDlkdDgrbVpDS05TVXN6TGdzMmd2ZUlwSDg0Z1grc1VCelozQU9ra1A3dGo2OEJrOUlReWFqYndEaUM4K2hNY01RZXpaL1NNM2xWSTgxYlUwNUwvOHhBdVpBNVdDeENoaXJmU0NQOXRTU0svUEVCcklnUjdIYWtnUnpEcXcvdDlScTlWZkR5bk5mcWtMZzl1NUQwaytIdnNlQS9qTUVFZllUcVZOK1V5RkJSeGpLUVVkNStaZ2FkS3NXWndSSnNUR3ZobGtySGkvVCs3ZldmYmwxN0VIdTNaWUdrem00ZExzaTFHK0x1NjR2MzNXN3FRbXZvdi9ZTzBMekhUdHRGS254NVlRdlJXeUpkekE2emUxOW5ZRUFPY1RsNVFmNmFOMHRaalZrNExlSkUrVzBWZS9PTVhOWUtBSEx6WlYwRzVXU1cxR2ZyNnBLL1pXT2MxNG9ZZEh4ODd1M3RabGtLdXB5QUYwMVNpSXpJdFAzTE8xL3lYZXZMWTdhM3o4Mlh0SXE2bXMxcG5lTzk2VDZEait5MEZsR3Z3ZXFaOWNHTnljeFRSWGRXV3B5dTVLVkRiNG5OVTRpMEk5SkxxYUF5ZWpyOGFkdzk1WmJ6a2F0ZjkzQW1va3RvcXhKbU45emVzSGNHVGRRdGdtWkttWm1oNnk2NW05UXVjN2dmTFFtZHdtc0lZdjVpZi96dHp2YTZkVnExZG92VmR5SWxZY2RlVzkxb1hsVWlsd0ZFZVl6eXVJTHlBTXNlSjdCQUdYV2NJUk9HYzRCQ3Ztc2Z6NHpmVVdjZTR6SHdXYWtaQWdLUlJuT25HR05lbTRmU2NsSU1QcHpBOVhTTHo0SWFjSWJGUEFjd1hDaTVjd0ZUcWNoUjZ2V2VBbUZDeWx6Z3ZvQklzNjNMbUhLZkF3bkxmc2V2dDlZelhMbVptUkxtR1JFMEdpMGthUC95YVdHRWZBU3A4UzE2ejdTMktXUUp5eDNMeTMvR3B6L3VJR0xIbWtXZXg3N1RsVWdPZjRmbXFWZmJ1cnN6QWVzWGZ2MTQ0Vmtad29QVE84dDdML2lKVlpzREgwOWdtMDJRZ3IzVTNHU2FwMEZiZmIzNTRCUFdKRGN6QlBPeTl4SlVST3Z2Mzk1ZWRkLzdIbkJsRW8zTU9tM0tSM3J4SVU1QUtaR2xnTUpRTUNwWm5IUUMrOFRWcXRJSVV6K1c2SGdkQ0F6MSsydHJ1NkZNM29QZG1TRFVLNWExR1ZKOVBuZG5iNG1INVpUa25ldWFLeU1qWGw3YkhrcmNYdGs3RlNPc2IyK0xLZmJ1UFJDOTB0bHdOckgway9uTTZCQ1BEcEk4Ly9pdnYva1M1bVhSZFNjWng4RXBnUnpzYjV1M283S1ZqdnQrbm9JMElRZUxvVUNoUXhFellUVFZ4RW8zVk9STXFZTnpSdW44NUVRc2FCemg1RW1TdUFqTWVDejBvbitXc0ZFTW5QZWZuemV4Um9qeGM4QTRMdzV0ZlUvcW1LWmdHdkxJb01nbU0yTXZVcmlaZVU4UlpuM3gyQ1ZBRVF5d0ZiTUJBTjJ4eWJ6dEhVYWo5bHh1eTNzaUFPc3E3U3kxdnhlaFBCRzdTKzVMMy9hMFZwalJGdHI3bi80aS8vSjRjU3J3SU13aWNkdnZhRnVudkRFQ2ZvN3E2N3MxbzRybGNCN0IxU1lNaW9aYmRDN09XTWIxMjFrZVdjNWtsTE1LNWxEUUtHc0dCc0RReGxaZVBRa25sc1VDMWc0THFoUUpNMWRLUmtZd0FVVnpScXEvSjB5WlJiY1lJTVMwYW91Tkc2d3VySlluZmRDOG5OdXNTNFVZUTdkUVNtVjFmckxCa0ZERm5NbnhEYmJ2b3Vydm5pMDZSUnFkZEx0Y29mTzRQZlBpSHlKZjFHanRwaXcxSGJqMVY4L3d0OWdqU1d4N0FqMFptNEtXc1l5VG8vMjd2dHE1YVEzYi85KzJmLzc4NS9XUHgwREh3cXRVeldQZ3BpbnIwdVVJTENUT2pOYzhEM1R4NE5sZEovdTZndUJnc2paY01qSTlHME4vc29BeHBHbThGaDlQYlN5Nkk0dnphNlVzMGZtbmZpYlRPTmZ2UjE4VGY1b21OUlBTeVZNQkQ4QmtOQ0JkTlQ1eFpDYXRDVzVLOGJWekliQXdEMlROZXVQOTYxKzgyYWJGRjFmWGV1TTdNc0Rzb3RKZHZtQ0xabEJLc1R2VlcyUHNVZ3U2Q2Ezam02OXJmTjNreTc0Um16ZXpUTDFvYjY0d3VBdDV0cGwxOGtxVjhVRW5QK2s2Tkd2ZnVyK3NmUnUwNzF3SmdJNGt6WDdrNUptZG5FVENZQzNqNER5UUpKdXBjMTA2SnE4bE04bXAxYlJlNTZ6K3hQMytnRVZ5ZmpQS0RLQlZ5NHRrRGc3MW1NMk93U2d2em1KbFpuZ3BPWnhFRW9oYTlQbkRSMkdrRXBiUkdJKzl4Y1p5cUxKUENLVmJoT1FKQVVYYVBOaHkxUTgveW1HU3h0dDk2MnB2dDd6dnlzeTRSY0FTemZjNnJBTHRabHVhWlU5cmpEV3IrUFQvdmNUcDg4NC9nR2xUa1VMNllIczFwRFc5Zi9ucmYvOGRqMjlZTW50UHFyZDZEVGEvanpwRXN4dFkvZFh6M3VTRzBxcVNaQ3ZodlNXcnVHazFKVFNSbUJYc3ZPV1lHN0lRblQ3YThoZXJncDdVSnBiSnhiMFJpa2p3WlZDdmFvaDVkbk5hQkowWmEwUEkxVWNyaVgxUXpPYkdiNGQydXM0ano2U1BwcHRnTm0yakUwYzl5dnM4Y2hqSDZSc3dvNW1oTGN4STVHM1JIc1dpb0x2NzlxaUszMDI5MnlwZkNIT1d6V2E1dFRkLy85WnQzZkh5b3E4Ym8yVHU3QnBEV1JNLy9XSmJDclkySnRpM01NcCsvZTJmK24vNTg0NDEra3ZyZVcvK3NMKzBmL3lyM3hhTElFVm55QzNzeFI0UEpiUDdDOTVYczJPNlJuTm5mOXozUm5sOXRBQUFJQUJKUkVGVVZKRE5TUm9JYTZiMDRNc0tyaFNwNkVrQjVzdGE4OXNzOG8rUmFWN283NkZXbjVsbFFvV2NWZEVUbWZYN1Z1bWJOUThUYVoxdXBIbkJxQ3Z2NGtXL2ZiNi84SkhNcENQa2phYXFUMmhHYjgxRlFOSDdzdHdXR29jb3ZpMnZqY1V5b1VGYWJrdEQ5RWdnbzRCMGlyMUhWaFl4aEVhbC9QWnE2K0tETUdWdXlsL3pjWC9zV01hZ2QvakJwYWFlYkd0TDVyNzFMQWowa0FFMG4vYnlZck1tbHVWWDdXbUJteDZQek8zYlBWN2U4ajJiNzdiZVhJODdwS0V1SkJteVFtTFIyenpOOWFFUnphdnF0eG9FWnJwLy92S3QwK3FnVXhrUmhRTWRkZHdqejRRajRRd2Y1SEcvSHZkZ3pZN3lHZEZ3VWFmeVRGVkptMGJIcGpHVDRjVmRLejdGRXRJNGEyRWVYTnNQdjRKdFlUY3RqQ2tSRkk1bVAvWEV0YjFlaU1lOVBER1ZweDhId2pyb0k5ZDROaUNybTJPREZESStYVk1OdWtkNmh6a2lhWWpWbkprSk4yUkhkQm5iYXk0VXpGNjJ2ZTYzY1VtaklabTlwOHRZMDFlSE9vWDNmZWNTZC9jYVBmN3A5Zjd0MjllWHR4dTJwYjJ3WEdzV1ljU1czcVlCNWRxL092eEFUK2Z1SVYyVjByenRvSVJXZWdka2pPZ0QySWZiM0FUblhEMjJSM3I2U0VEQXRYODJTaXVXdWFLbTFOV01KdFVmclZBZ2lmTzZOMnROQWd5dkVSV2luZ1VhSUZweTA3amFLQWdxVWxHR2V4aVp3RFlXbkpYaFhwWEc3VDdHYXJBeEYzeHZmMm1NeUMvbk9pSGhTcEFxWnZSenlWWEszbk9nUHZvSVh6dXRNNlQxRGJuRDFxV2FTRXQ1TTBwNElSeE5xeHdvbzJaenp6aHFVeDFwUUNkeE5vRTA1dVB6UDM3L3VzdVZRd1VBNW9VNk9qcTRQRldESjgxclRMc0dxOVZHQzJzb21xYUgvQ3hNRGdqUmdHY2R6bFRUUkRWOW5Mb2VuUlZ6VWprK3kvNlRxM2JjYnA1ME0wcjEzWWtWMlhqMUM4K200Wk1mbWpBeHBBOXFrcm1COFZRZkR1UEVLT2dENXFTYlVBdVlGNnR3YW1qMVhDRWFZcUZCNnZGS1UxUXVwYTFDSXNPWGRjYXhwaVdPRzZLeTcrbEdEaTRxRkFaZmY3bjFWVjJTdHhDV0YzK1A5TGMvUFNLWFpudlVwQ29OK2M3MmNzK0s0WFUrMjlCTFY0WkQ0SDBSV0ZZVG8rNGxiWWtKVDZ0SC9qaVZSaWJlK016eU1BWnduSmFwakJRUDh0UThBM0kwTDBZbVZ3Z3lEYjBnYzM5dnU3YWR1b0thTkt3MVBGUkY0ODRteldocVE2K0xVU1VGbWNaa0FKREpTU0FVTWRmNGdiUjNNOU5Rc05aRG9pKy92TjNxMG43VVN5U0Z6Z3F0YUFkOTZPaGlINEV5dzlWa3FkQ0ROUFJ0MTYzbFErMlRNZmM5VmIwY2tDMURhWmptSVNFTGN0aDRrQ0FQWEppZVJmdFZyZDVYMC90dnYzMTViSjBBeW54VzBpcE5nOTNSdmoxNytRZE9lT3Eycm10VXFPQ25KMVRGZVJSVGN3Yy9RK2tzaDhiZWRCbXVQc25HYUpYd1c3WFMvaE1BbmJ4bGwxbTM3TENNYXFxUlA1QmxQMVhjNDhhdU5xZGFIOFpKbHpuVWFVK2VYeFVIQ09zOFhSU0VLVFNuRitiWkFjKzBrdEx2aTNsVGV1dFpURkI3RkNXa1l2MTBtQTlDQWlLUDd3dXdKSTMyNlUvODY3ZEVFczM3cnZ2TDhpcysyZjZLSkxqWXRuV3NEc2p5dm54cStVaXlPcWZIV3ljZ3hPekg4dkpkRVZDalUvM1J6ZG5ydWpzZzd6Z2NQUE8wT1RwWW1tQXVIRjNwZWpUcitkQ2xSQjNkQ1ZrRW5jWEhVTmFucmY2NG8rTytOYk9ZTHZ2QnRyQXBkUnY5S2lPVlpqWWtQaGhuTFMwa1kyVE9TeGlBekwwcjg1Z2puTnV3MGpNRGxkQWlndUwrNVVzUHpoUUpUTExIVkloL2I1SVpkditEWjJCMWdzRE0rdllsNmJCMlczdHU5OTQ3MWxLZ2M0bHFuT2ZSaEswcXBKMTlKazRKOW9kSHZoWmJkMy84NDIrZk4yUHhzd0xGSmpuR3Z1ZlNFelNqcDQ3V0l3WmlrRzM0K2YwSUVyM0VjcEluOUZlblhtSTBQQ3pyOW13MDJuNXFEUzZ5TE5YWGdzd3dYcEpzbm0zSGxlNkQ3ZTZyN3lVTnMxa0ovQ0RQbS9odWdnd3MvYmtaY3NCLzUwbytWWGZUNHFVMHlNY25rbG1jOWFyOTZuU1lyQU9TRE1BU3l0MFhXN0kxOHdyaHNuanZETGROR0t1azJnQjd0MGFTdTdQd3d4UzlMZmk5LytYM2YvM0hMemNEREgxRHZ6ZXViZitpQm5za1cyUEEyczN2eUV3c0x6MUZpQk5CZHNDRmgxM3hqSmNibjBPdXF3bjczc3lZMmRNSkEwdDVRYmV6b1hMTVRpOENhNDcrK2pHWXBkbFlSZTN3blhHbVYxNXdoSUtjMmg3YnprRGtiRFdON04zejFLOHZ5TVlrMFNhTmllU1l6Y28xTjBLYU5BUWlQZm9ncFk5V21PaWdGSVJWV2U5RFlXZzN2UGZPZFpud015OHRncHFVZExmOUd2MCtFZyttS214eWNpR283WHVqM1hmSm1nbnc2TDByY1FQaHRIYkg4YmFlclBNTm9KaFBzUzhYalFTUGs4M3k2NWUvL1Q3MjU0U3l2TGswRktMMzhHRG9GTHZvQWgrWjZnMC9KeE5Ea3pUdG9ZZG9TN2lvdTNUdTIvTS9aaUQ3NUNid0pCalA4dzRaZlpBV3pLRWZBdUhkMWNOUVpDL0NjL0pOcGwvNE1DVjhXTHpqYy9La3pLVW42dVloTzczV1BJZDFydHltUk9ZZ21ZUWhHMzJxOTFqd3dDUkFmd2h1MVV1bklMVkZtWkd0S1RyVjFqNFF5TUZ4Zys1ME55aktxMmtRZkYwUmYzejl5Mk56cmwwaW8vUFczK01sSDcrUkxmcldYcngxU3JiZWs0dDFMc3VlUnNHbjlXTHNTMFBVUEZmVkROb2hzTnlZaWpBa2FFaEh5YjJ6QnBDR0MrMjlGbFJOOUFiWnJZQVhJbWQ1ZW1CTHhrSXRzWHlxOGdQbTNpaXBNYlp2bTlZRnJTTzd6VmxocWZ4SGt4R0NtMUdKTUlNUWt6STZ4MDJGazFMVUZET0JobEFDMWpHMGdWZTdsR2JhN0ZDa1FMbExYTXh5T0tmSEFDdXpWUUtPOTZPeE5ERWVwenI4R2szamUwWmp4bTJYSVdOL1EwOFljNk9SbWRpenNIOTJtcEpMVVZpUGgvSVFKK3EwMTQ4UU9FSEE2N2ZmLy83NUVhcTh0aFRLcXpNaVBuajJzY2FrYXphbVpzU2h6ZHVlRGk4bG1HWEtQZ1FlT3NWYUV5U1VWRm81aStkclVpS0N3d3ROWFNydUE5L1UrN3lrTkNqekIvTnRNNUtPM2F6VVlMT05MdUtwdUNWcm4zeE9ReHpYb0lZemZwUTZsQWk4TklFT0hCYUhqWXBVeXBnVjlwZWpicXN1WGRiQVA4M3RQYmtzN3EwNWN3L3pkVjJ6SjVsMHBteForcDZIS0JES0pRSnUyUUdvdzR5MDVYVjUvNExIbnIrc1dYMXp3UkI3aCs1ZkZ5TXpvL3NDRklpOHRYN1AxeVZsN0ppankrT2hTT1NUTEczZVJLd3RDRk9zc2N1YXdkeGdVQ2FObkFrd0JOeElDUW1iT0t4YXdUYUtNQTJZYjU4aEQrT0RiaVJWRXlSbG1oM1pzbVRjMzd1cGJGSEhXWkdqM2hxTEExRjcrTkRvSXlvMDV1Zy9Lc25zSWZueEw0WUVROHhFZ3BJVERFMit1NmVKaUdoakhXK0J0bnAwSDFmT3FJNG9pMWZZYytLQWVKMUZUM1Y0dlpaTTBFUkRGRTYzS2NSM3l3U3BieVBTTDhCcWJ0aGhjMGVTYkpNNWRTcEY2NnFyeXVnK1FybHVYejUvdmd2WmUva1J5Z2xBUjVwK1ZEa2V5U0xEL3pzSVk0cVpqalh2bFRQcytBZ0k1Uk40YmdwbzVudFBJYUVlN2NNb1Z0YzhDV1hNeTdDWGR2YjdpUzVwemJYZmdNeEF2a3lONXdkdDEwZlMzanhjTTlQTUxiZWZOTEh3cE1DcVk1bktFdVhQZ0xjY0RkVUM1OVE4cWc1ZDM1Sm9ORjhXWnQvVjhvV0xNWk5aRXRWRnZVSm9WWmVXNVNFWTFSZFd5SzJacnl2M0wyLzdQVjQvL2ZhbG1nZjB1MW16N0wwb3BoQ2FxVWMzRC9kODE2M3RuQkNXNXd3dVBUY0Rqb1BKUEsxNUlrTFdtb1g1SUZFTll1cWx2M1JLa0VidjJVYW0wd2d1Z3FBZ2pXWThCRDlWM1NobmJQWndtc0dRKzViMmFKNG5OZTU0a2FNR2RrNzFaVG90TFFkVm1CcjFhVG0rZHBnTnlWYk5rZ3J5S0loZWRTM0RDVE52SGdhb3E0M1g5cmJ0OU9XY3dFU1JmMWhlcVpSOVRQNzY2TEVmRDM3QUdMRzhQRkJ3d1ljcFBGbEN6dXJIT2xNYTZXRFZhb0RrLytjUmRGekhZdVBrM0F6WWx5MU51WHo2N1YvKytwNEN0eWhyclFNaXNsY0srb2dPcEkzOU0yTWFGSGpXZ0d5TmlNeGhVdEpwSFZmRXlIaVNLVktnK3dpbWhiWEZrZDBTNjZkWDlLMjhJc3RXSmhYcWlSUTRSVEtpb2Q3N1doSzgwNmZiWmV4OGFmdU9tbTN2ajNTaXh4WFlmM2FmMnZpc3l5ZGpMdFVDOHEyLy9XLy9DMzR6N1FGejc2VWVQcXo2RTAvcTVzYURQSkpKTW5vQW5udEtRalpuNy9MRktMUm1XVkJOcm5yczZ5OHY1SjZMSG5wZCtuMEhKZXU5Z3VhclllU1FMZGl4ZGpiTHJiUHZhWjdKeFphWEp0eithZjJYTC8vRTMzdmZmTzJQeUxkSHZyV3Y5OFVRZTdEWllvaWVtWHVCbDdjS3pqRkZOV1VwMENlWkNtYnV5SW05OHFWcC8wVWR6ZHZ5MkhwN2UxM2hpYVhsdnI5VytRczNkM2Uzc2FCc2pHVktRVVNqUnNwVE5TNGl6TjJKeUNFRXNNeGVvVThseE1Kc0N6WGRIOERuZjNsWmJ5djI5SlpkN2dpS1lHUjRDbTJNbmsxOVg0Y0pyQTFwb1ExR2krZmVWYjZzeWk2Q3FPajdmaUIycXJRcDJBejUxanVOMXN5TUdYdlhIcjU2MzBiQWZjWFhqbUsrbXJjbFJCdDJhRTJtOW9TR1Q2RnlnZE8wRmZ1TUljRlloY1B3dlZBU0xFbFJDU1lYQzJ0TjU5eG02SG5QdGpBRnVPNWh0OVgrNWZPdTRSTzROSVAwaE9yaW5MdU9uaFVPRU1sUXJ5RGpUSWprcFNYRXc2OTNFbVkvakgyU0djOFpKejhReVJEVkVacDN2MFFJdE9zZWFDaUdQVHZNSExUMG9lY0RmZ0NJMWhPaDRuU0dodG5qWDcvYzc3Y0pOL3dSR0lzL2FvSFhUMGgzS01sMk52RWtVZEdZbVMrM2Rtc1BkYlp0RHpmdm14VUluZFZraDdyTWs5NnlraDRHaDY4d0s4aGtzdCt6TFo1ZjdtMzN0NGZNb3U4eTBiVTk5bVlwdVlnTzBKUlpmSEN2c0kvWm53VGhvTmxIajFYSmpweXdkVjk4YWRpMGFiMnRDN0MrYjhIRU1nT1RlQlVRODlMVXMwSUxQVStWRDJ6Y2FUTzlLSmlBV2JTQndReWgzVGFEZWt6TmJJV0JKTVJkc243a1RKdWwxVlJyQ3FuejJQUnRtQm1QM2t0bTlwaDlXVE15RDQ5RVVUd3RTNjJWS1NVWEQ2a0ZwOFFJR0dudVpaNG9KY3dJTTZaWkRwenlsQjZPbE9HNWhNS1FuTTNEMDMxOVpCWkFRaEsyTEs3TmtlMkNhZVM0b3RvWVBCZXJUejNYMi82UC83cnRqTDB6TDFPYkdlWTlKNlhINUVoRVVpU0dKMmc4KzFLa0hVamM2VWlhOFdsVHF2aDk3d0FBZGtHeVBQaXpVNHY1MGVubFIzaFoxUXg5amlyUHUzTW1yS2tMTUNmWWVybC9mbUl2UHNTVFJaT1ltcmpPdHYzZGJRaCtsZC94TmE4WlRmamdScUdVN3RpRGprbWxWbDNBUkdZWDJ1dEs5SGU2T3RiYnkvdm1aaWF4bFp3d0k4eVJJMm9wUm5Na0VIa0lEeUhseSszMi9rZC8vZmJybjc1Rzg3NXRiTmthN3QvU0ZKRzJra0Y2S2pQaFNhT0pwR0xvMnpBeWhRWjI2c0xsQlpvM3BDMnd0bHBFei9aeTg4aDhiTDB0dnF5OXFLbzg3aUtuSnAyRmtERWJIWStMdCsrUWNCengxS2QydlZhMHpaWkpSby83STNZYjRxRFpJSWsreHI1aUtvZW5aU2dGQ2V2enhNUGNSdW9hWUlmdE1ETjY5T3R0bHpRV2ZNbmJDTXJFSWJnelp5YmJneVJnQ3VKSnZlS2pEdWhaRkppcHNwZ29BNmFzc1c2c2d6WlR0SkpaMFUyeU5hNGg0OGIyeS9KdGMvVTJMKzl6aEJPbkxicUdXWDdqQy83Mi8vd3UycjZsOTV6QjFTcjUrY3dNMXFWblBWUE9lVmo2aHNuWlRkZGh6alR5ajQ3VTBKanlSMTNmWGlpenc4SkJmV2RHcWxIQklHeHJJRkU3alZmWFE3cVU5UGFRbWJXYVdjb3VzTi92RnZBbG1PS2l2SXBtdm9ldlhUQzdGTmtYRDlKRmlubUZjSTFlNU5oRGxERjdzaldUUklyWXY2VWI5OFNORWxicmU0d3N1NjBHUnhsTGF3RXZBTmpBa2tNcHJ4TzZPajhKdzEzKzIvTHlzaTE4YkZvYWx0YTNYYUl5MGpOaGJTR2hybDZSOGtNVk5WZWVLWldWa0hOeXZRbGFXOW1UZUhOWHdwcXZMK3hiYU1mdDA1S0t1aXFjQy9pWUpKM21oc0haMEZGdW4xZXhLZGpLazlTQ1E3M0hhZkRldnZ6KytSWmhjRmlmRDFTR0NDTk50S05yWHBiUks2K2VOSkR1K3lYV0J6VDFpTWdUaFhRME1tb1VWVjRLNm1CVlZ5MWMxcDNwRUh5eVNianFvQWdxUVdPL1RKVTRrZ3FiOVppQ1FUdTVzSnhpcWRsQVVBckY4UUw0c3Q1QjcrM0NWeGl6bnVwaTJYaVI2Vzc2OXRmL1RrbTl3K05JRWF4YVdkZlovclNDNi90QmNwWk9tdHVURUY0NmN1QjUrcUYrQkJhb2x2K0pXK1lIU2QvUWViQ0FaRWNEUldIUG9Hc0JZbXNJbVM5UUw4aDBIdTdFanllL3pteUM2L2NDQjFlWGpaUCtJNzd1cERmd082eGxxa0FXNDBTM0dORjk4RXhnVVhEUjQ5M2Ztcm0yWEtXRTI0aE5kKzgxYkpKUzVqQllGY1hWSUt5UXVyR1htN3ZsSG9aK2YvR2x0YjdGYmJYV2ZNOUJaS3hjODZKVDdMM3Y1UllyYUx0UFhVUmtLaU1tN2VCQXJJNGk3MVg1b05uaXphS0g3TTF1cjdoditEUXJXejRST1E2amR2bENvQ1llenoxNGpiTEVCOExKZkdQai82RXY5LzJ4cjZQRGNVaXY1dTN4MkhZenh1aHhTbmZGaEpvWlJQUDdjVVV2VGNVZVViZmtjWjlQVFo5UkpjdG9TazdHdFd6cFlZdGwrS2xWZXhwRDhwaFBoK1JnYWdiSGEreTB0Wjg5RjNsNnlzZzdQaTVCNHRKc1NrZHByVDNUOTZlaW93YVFLWXFoK1ByM1A5ejNuaEd3bUlrTTA1OTdTZFc5TE44RGRYUkIxZ0l3MjNFTkI5TWNCYy9CTnZRaEFQbndLclB5MTg3MXdZK1pSa1VtR1VkNG04cU1GRC9LTG4zMURBS3AzcTFOMDZkK3FOazZOWjJUeTFLLzFqMTk2UkgySGFUNmNnQnpwRFRxbXBzK1U5cExsWThnVElZbXByS1FFdFMrMGQ0V1JtNFFZa01xVFpEUjI4aXhZdmJtWkJyUk1lN3dBbDNKemhTQmhGdnNqNWE3M2kwWDZ3OS9XUjQzUm1lREJMcFpKZHlBaSsySUdIbktVaFl3dTRKellseTFlQ1Fkcys0VmRKaGJqK0RxclZIaTBocGtLYjQwQnk5c1BCNjlqaW11ZEVqQktSSFJvZFFhL2RQdlJ2Y1RzRENVbWtyQ2lQWlNzV09YS1lSVmF6dFR5SUE4eWJCTFN2UFloOHhOY1dUSmwzdE9FbUtJMG84cncvRElsdkdkNW4yZkR6UEVzZXVXMGs2cHVqSS80OXNKSU1mSmV6R3pLVWxUaE1oVUhHODNyZTcvZnNnWUQ5QjFEbmlqR2NEV0lTT1dkbERueGhOYXFiMUdnOUpTVERYKzhmLytzVVIyNVJpSXo5RlR6b2JESEE3bzNEZHNLRDVPZ1htMXQ0OTUyRWlBenpOVDQ1QThQWjNBbzJMeG82NTladHpyT3Q2aDJUN0dSMjFrd1QwbjJ3RE1WRnV0UXoyb25oWUlXVEdMZnV3Y20rT281MEVLRldUUmF2QUJhODJMckp6Zm1aYUh6QjI5Y21VdFNiUWF5Q3VTV1E1NW83UXM4VzB6Yys2UUt5MmxoblhycEJrc081dG51TVBNTERUNEZqa2JDRDJkbHYyK0JOLzRPZC9pOFhoNzRSZlh0bk9OWHNPUnpDYUVzUzJ2ZUtqZ0YwV2V3b2dMWmNsOCtXUjBMdXVCdDhVdDRJMnRPVFBUdkhtSEVyNitQaTRwQmpOQ2xuVkhnaUNzS21OK2pqaHhIL2JpT1hxTGorQ2lPUWhnamROVHNXM2RYdE9OcHpwQzh2THdhKzRjVXpZeC9kNDVVaUkzVXFtcWdVZXpMRWZvUkZuUFIrZlZoaWxlc01ybWpDMWx4bUdNcGF3aFpjdDJjUG1lcjQ4NTVOa0I1VkQ0ampPMUJvQzdlU29qem9MUm5hR1lpNmxjUERubXJVWXl1N256SlRkNHlOc1A0NFZFczZGb0RsdlFQMzk1eXoxdzlFdE90anh4TFI1NUxNNnhadVlGZE9UZDVMaWdUNXVEenZnb0hRcUpqOWowK1VFcUxpei9IMFk0b0ZMbEpzaTdzTFBLa2JwMk9ZR2RhZGtGWkZJV3cxditMRko0T2xHSmowenB6RXpLMXpqcXhpZnYwU1QvSEg3aGo4dFlrU3pyYVRFOXJSZ0RDREs2L0NZREc3Ry90c1VGVzhKU2lkVFNEQVlqSXcxRXVzbk1Ec1dhR2RLcW14Sjdrcml2aWJmOHF6N2wxdGx5Wjk4N1d0YTRGVkozMFJiMzI3NVAwaUNtT1NneVZWMmJjb1pjZE9ITXpOYmNQTDAxWjQwSGljUWl0K2diMmdVL2MxbUxrK3N0RzlsVGUyMFVzMWN3OFNhVW5sZndnY2NiUUhma2ZuOS9kR3RPS3JNWW01aDVjcEpMNWo3eXVVa1ZtOHRZZVJqR1RjcXBOc0ZNZDR4SXJ4Q2dQR3pMTlRLMktUQzViYTBMWmpGVTNOM1gyTFVzOTVLQVRVMjBubVNObW1TUFVnU1BTZytnMkp1cFJ4N3YxZHZTWUVmVm9Hbm1HY055V21ZYVc3dnRuZFpsYmVwNVcrbWtyZUoxbFpZd3hTNWY3Ly95TDdnOU1rRzdjV2ZacnhnMG0yMnhMQ3lXVGl3T21UQ0E3Z0s5Y2UrWkVDMWo1dlhaTkVabk5lU25TSFZpM1B0QmNHVjIrSElmSSt5eEpNck1TUnpTT0VrRzdRZENNR0JYQnZlZ01oQkJhN2dqNzk0VUtUSUNDTmg4TXIzSUZrVmgwT2liWEs3SmN5ZDR3Q1ZpQzVJWDRBSUtwVW9MTTdlUnR5ZHduQUJBbDZzZ3dtVlpCYW10bThldGJZOU9lSFFaMEpmWUcrQXZLV1dQUkhaNjd2N3l0ZjI2M3p1YmJwR2JtZU1lOHN3bzZIWVMzakprNkxmbyt1WHhXLys4MmxlKzlOL3UyMXY3ekxldHA2SG5ZUDdSY3ZISE8zLzlOZi8wOG1Weml6VTZXNk02RkQxZ095dHljZzZRUnV1SlRQdmtlNC8vSEJrcUlnTE0zRW1rcmNnMEt1Rm1MRmdzWnlUS0NHQ0loSmtwTEF2UmJjT3lVaXFLazdLdFU3cHBCTGtOakJPLzlkdjY3ZXZDc09IOE51MEEyV050MFJHaDFwQnF6V2ZDRkFCaDhlYlllOXlVYW1LUWlCQVpBSnQ2cjFocytzV3Y2dWFFSWJ2NHN2d1ZrYjV2bi9ZUjl1WVpNTE5vdzZlOFV3bHJTOXQ3a2dxS1M5UGpic2JZMFJZQlpja3p3K01Cck1pRUdZWUdsRUZENzRFaFBadEczakViSGQwK1pYN2J4YjB2Uy91K3lYSkloeVF1M0I2ZmYvLzhycWlnMmllcjZJbC9mczY0T2FET0lqQ1lVK2dmb285K0VKZjZ3NVNoekdUdG9UT3RaQ3FBcGlYNXgwRm44YlBFaEpvdXpXcnFOQ2Q5K0hNdGtmclpRWStmaDZ0TlNOL1E4ZGZ2K1JTL2MwelFrNnFjRHhudnNxRHo2Q2VHWW9mOHBYY3Q3cEZSQUxaWW91ZmlValJHYnVndFF5UEZaaWlWS3FmQWVqZ0N0d0NOemZoMTM2UDVZaEVKaCsrekwyR2ttV0pibDlXMzJQdXkxbHgxQURNMWpkaXpqaSs2TEJuTGNyOC9mdmxQS1ZFOWN3SE4yNWd5SEphVUN4QjAvQ1p4YnRNL0F1TGpDVng3SmhqWVVaclVoYzg4Yzl2RGZiWi96S2dNc1dlcWZ0ZGFvMWpKU0VPcWEzd3hadm1tSWVMWk5scjJ1anpheEJkRXVUcVRqSy8zZlgzMHBVeHhsZFZWSXloR0JPeEl5dFhvY0FnN3pFeEMwbXdSNDJlaEl0UFM1MVJFQks2cDNOZHNVbnBDQVhVeE4zMTZhNWVhN1VodUdsOVpENXJsKzkvLy9qVkEwU0wycEhneW9JLzJvYjY3SVE0aHgreGgxUzRzZkNlbnhVRnMrWWgxUFBpelliUGl2N2FSTEMyZis4dlA5dnE0enVHZUdGOTE1YXF3TFBzK2FIcWNGaXlGcVA3ZEVKVVBMY1JaS3ZzazFwOUJRbGZvZ0lZSW1sYUJlL2lXU3hpOXVNVkdpdHF6cmErLzcxdThMZ3JMaENNZkx6M2tTM1NZVVFiZmF1WnZBREtIL3R0UzhpMVcyMks1ZWJWUXU0ak5mTW0rMjhMV2JHeUxUdm9TY2UrNnJkaTJiclprUkZLelpYRlFlVWRheUtDTWZHcnFmZm5Ubjc5S2dpTGM2SzJaOVl1TC9JZ1F1b3pWaHFLTkh4S1IrR0Y3bEIxbjc2V1N4cW1TNjlMMjN0SG1RVUk2SlFVRDFjY2M0eXNiSTdHY2JUUlZHdGpKUUJ0TEpGT1pvZWtMUG9IOXgxMjJRZTlocSsxbzJEUlNGTWNrTlh2bUpRa01CMEF6Nm1GcUcrR08vcjNoL0t5Vnk4Q1BVSThjdnZkTHhPVjRNRDBwMWFRczFkNyszRDZzMzhuYlVqRDNOT1Q5OCs5Zmc0Wk9xc2NCemo1M0NBclhGWHlhZld2Y0diVndreDk2UGRjK25aMnpJMzZuUVphSzdXd0hyL2lKdlBDOGdQV0JDZm1qNUlZcWVZelBBUXQ2NmtCVnByRCtBeUZJL0dBWm5vbkhFK0dYT0FyOGEvSE8wY3BrbURWQlBkMWtITmpXa1pHNjgrVjF5eTNkTWd1UkZ0R3lzanpSSlhkbzF5UVRuYS9YS2lGNzRiZlFQM25zUXU3dUhya3ZEYkdiV1Z0amhpNG42ZFQraUdpdzFULzN4OHgybkFsWElEOTI4b0hYL1c1Lyt2UUpGWmxqWE16TWg0emdJaUk2azdBbUNYclU2aGRsMTd3MVhNd2o0QXk4dkdyMWNCSlplZTl4MzNCN3VWT284YWdndXNsRXBCZ2hoRkhESldWZVNUeDRqSHptNDJpcHIwTElDR1VXeHU0SW16OHhXZzF5eTRqWFh4NGJtVHNITDNjSTR6Rzl4SFZ1SjRQVGMxR0MzSjZCRW9MOWJOb3hlRTh4bk5jWG1vQXUrb0s2RnFZQjhQYjJxYlh2d3JwR08zWnp5UmJ0di8vK09iMEdUNW5Ea1ZDQnRGTTZ3by8zWHg1TWhDcXc4Mkp6NG85ekJ6bmRpTmNUOFhUb0dnZU9VNFdmT3laVWtsM1AxdWNUbkQ5YWZtRzBTaEtxZXNJK01HTG1scndOM0UvK05MUGltcnorZENEcmVOQUUrZVg3T25QY1pxc1A3SXU1SXRNR3gzVW1URFZUQk5iMXo4ekl6bUZTaTN3M1U0amVZb3RiMDU0bElwb0liSm02bGF2T20rNFArMDlMZk5sU1NpTUxPeElkcTkzZWJlVFRkdmlTbWRnTmZ2dlVIbzhOelJVelZNRUhPanVmVGxYYUpyaHozNTBTbTl0YUtoeXRPRUdnUTRqSGl5Tmt4UHpaMDRaLy9CRUFMazV2V1YyZGVScUlkVDR5NnVWb3NjT3FuQW15Mlo2RnVEOUMyaVFSUG9KWGpCdUlXc0JUcnplQk1SRTV3Vlc0RUFqR1A5aFNFcHZXRi91V1kyakRZY2V2cks0c25jWElSb3RCVlRRZzZQUzE5NkNkREVUKzVMbnFvd044S1BNL0lLSDZ4UEpLeThzdi92NzlDVnhia25iQWx1WDl5ejgrMytIcWlWQU11UWtvbHFvYVlQS3BsSmhnM3lPanNybU5nSTdhWlQ0S0pYTGV3WTljbGVlZ0NDcnRJTWtlUE5rZkFTUEI1d3diWHByQTE1L3FwZ0o4UmMrU3JYNG96Nmx5bzhEKy9SQkM0SkNkZlN5TDg2aElhZ0hvU0wwLzNxWXFzUnJLRXFGVFVUNWFLS1hlMC9RL3ZXRURXVjNvU0d4cm5YTy94R00zWnZLQWhOY0F4REtMaDdNMDlIM1h1eU0yc0gweHd0d1lRRzVZektkUUljRG1QVXBFMHRxZlAvZWVwcjVNTThkZ0R1eFQ1VUtqYUo2L3ZNVDJiVjBNc0xZczFjclY1YWtueXc0MGV0Q0RWNEtQcVZZZjhkN0hIWFQyYkhHOW1WYlhYaEFiTTlMVU1YUUVNemF1VjQ4RHRTSE9uQWdoeHJHL0ZFNmh0aVI5bE14bTVLRWFQUi9ySXA1a043TlZYUzFDYlhLU1J5eXcydkJWVFpkaVVpTkJPN0szNWplMzBHUis4WWVWMklpRndzaDU1UEZoNmRCUkZPdU1aYzNFc3VhOThlUFFaUFJSM0FUMjMvNzVzY3ZZT3hEallxNHBFWnc0anUvR1BycGdyZERjeWozOFVaengzTVVZRlRBdko3QU9JbTBTdzFlWjAvTkFwaVUvamwvNUVhdisvU2ZscllFU0hORzdES08wdm00RVIvN0RkVC9SdjNtRmZyNks4OG5Kd09ORHJjZk1MbmNXRWJsM2lPd1J0TkhCTmtnQkNMbmx6ZDdXTGVqTU5JbWVtZGJZdCtYMjh0aFNiblhQelJMYUt6T0NjSnBaNnduVC9jMXk1N29RTkcvTUxSMjVZNFJ0R3kxVHhvb2JqL3h5ZSszOW9RcEQ1OUR6aUFXVDRnQzhHK2krZm1yMzlNVkM3a3NiZUc4NzhyeEdabVpCS0hucTF3ZFQ2ZncwclNCNk0yVHJ5TTFOWGlwQUFkZE93NUJtcDc5RVAvUDBRQ3JVa3dXOEc0NmdXUXdNQXJqTjlSQTQxU01IOW14eWRIak9zS2ZFS0RrNCt6MGJ0LzRTYzZBMURCRTZtS1R6enF0TW1ua29CS2UzdGU4eHVUUDRRWnh0dmVxc1dYS0FGK1dmUm9qREFhRWw1RFNBM243QXp5RUVMQjY5UC83MXYvem51bThRQ2prem56Mk52TUlGcjRxWmlaMGJnM0hUUnpjUGZ3SmUvcmdhc25naGVZUnpEdkRBN0VMcmU5bjB2N25nbWp1NnNzYjFPQlUvZGxWZUFXb1EvcTBjNG1maDViVXpNTzJxUXpndzh3Q09uRlk5UlNCU1hUSnZmVzgreE91VHpHYUU0cmUzdDZYdmNHdkpGSjBJVzZ6dmYvK25UOTQzbU9XUUlFN0pqcExwcEJsMmIydkFHaVBFVjVIdXlzMGFlKzVhTlBpZ2cvTm9jTS83N3YrcnJibm4wT0NEN1BVYzJqU0ptVG5ObXY4NXYyNjNOOTdKdGl4bEZEUDN4YmN6R1hiazJlREMzUDcrZXgvRS9ZdnI2SGgrZU9LZW9EWUNPWHowVGxNcHQ0N0lpUjFHQUFBZ0FFbEVRVlJ0ck91a1VlcmFpclpiUXMzYTVLcytvM2xyWG1NeENidWV1eVpEOXFBcmRwMkg3QitVTlNsaGpiYWc5MW5RbzlOSlYwYkJsVS9sWVIzSHRuYUZSRGRuaHpvdmZMRG4zc3ZZQVNxd0luc2JYc3RueURqVTVpaTllVGxLYXRRelB1S1U5bVhodHN1aFgvamYvcTgvL3ZPR3hTcHZGeDNHbWZaR3hkNXBnTmVrNUxoTE9vMldVTkVPeVVpU2hpaXhXQnhGZEJZbVFVTlpOeDVhVFVURm1XQk9zendzVDhlVlNvUXI4eERCZzk3Y1JJdkpJbGZBR3VCSkZ1U09Tc0NiSGhGWXZDdlpDTVZ6NlQ4QlpuYlNQNTRiWnZyUUpCOHVzd3NOS0FqUVN4Q0JTcW1yRmlkSXBWOEdXdk9aSVJtTEhzNmlHeVhOMW5Hd1JQYkhiZkh0ZnJzMTlmZnRzYmhEdkMxZnZqeDhzWjU5REdZRDlUN3ZBTEk3M2ExdmQxOXVETmpZOWFsTmxwbHlBOENXUUFjc3ZnSEx6cmpEbHZ3YjJrdSsyMnNoR1ZOdmZUTXpkUnNJWVVUWTBscDdsNzE1SkI4dnpXUE92Umt4cjBJalJUSXdZNmNzS1FPamNwWVpSbVJLd1dwZXhJeVBIV0FFdjJnWmpxa0NZVEcyMkd4OXd5ZDkvandjRHU3YTRZaWxQQjlvZDdYVk85TUdWODhYVTB4YklrQm43R20yUUVhTExBR0Vzdys3N2pqMjJTS3RXVWJUN3I1QTc3a2czOWErcE9oTXRIR3RYNUtoMHVaQUlGd3FnL1hyOG5zdTluaWhvL1ZHejZnajlybm5XcGpHVW9vcGhLWGFpN1ErdEt0cGhwQzMrOHRTeURuNHIzOWV0L2QyUWVJQUJHNzVrSnExL3VxL2YydnJReWtvVTJGREpZMURLVzduampQMVZmTUNmWEpZSzBOVW95LzdIeW9xdjVzTTZ6amxmdjREYklyTXdTenRxSlgvY3dvMEVDV05OZ0RtYmZ0aE9ocjFIK3M2L3h1bmNqVkx6SVlab0tlUTlzTW9DVjJBZkVPYWM4bDkwUHpNdXRGdks5MlZDenpMWXM2YkViQ0dIZXJudGovaGIwVmtkSmhaajkyYXBXcFBMTnJsME9hZTBxR0RQOENkOUxiRWJqTXJjNGdIZkdDbUhtQnJ0cTVWNVVFM3J5dm1iRmZwS1F6NERLTjREaWc4bVZmZlY4VjR5dmpoTmJpNTlGS1FoSTRBY3I5ZjUxRUUxS2Y3aVpJaTBnYXQ4V2F1U3YwZE5iYTd0WDdjc0tWaXIrY1JiMzJJZXcyZHltVTAzTFp1SS96b0lyUUNPSUtNcDJSejlxL3hjdHNOd1JaVWp3VFdqbFIrL3p4VWVXaVhVZVlUYkh4K2FMa2lJRE84TGk4ditWNWtrQU1QVjU5L0pzMjBMUGUvL1QzaTgyMlg1ZDZoTm5PTlJ0YzlRVDk3azBNQ044WU5JL1oxVENrR1J2Um9pZXZIcVVZL0VLOWZLdVYvYitHMGNaaGVXaWpIRkFvbFlDdU9ZeUlMMlFKU2VjbXEvbzRnKzI4dTRKOTBwUWRrd1d4cWZ6TVRsajk0L2NTcEVpK1Job1lsUVpWQ1BaWlg3c0xMWXVtbWJOUWRQV2pPWlZ5emIrb24xbno4ZmRqb0pSckIvYkdYNkY0UXhueW9pdThhcUJSdGtpdUJWR2FRNXV1anI4UE5mWnhZVmI4d2FFYWFXWFFKd291VWJrcXZZSXV6SVg1TzVVODlLUTluM0dHTitOSHFGVTU4cXVNNWRHLzYxN3BDNm8vN1RQRFJTQ0NQR2VWQ0loR3lNeHBMU25BWk44MmdHOGVtaml3UVFtUUV6b1MxK204elNXdzJhbVQxTUhObmg0OFNXOWRiOExIYzVwN2FIL3UrKzg0bGtXbG1OMlplbHVxbG1Uc2dsY2VVbUtOSElCTmhNUmFvSzRHa0xXK2ZiTnRrN1V4OHJYLzU0UTVDYXU5Ly85dnYrN2QzOWpEdGV6M3VRNXdBRVNHWVBZOUZualZaRi9Id2VGczhiSUg2WHREQkh4ekFoL2Y1Q3F2KzJRbGN3TGpqanc2QkpuTkdLeWhoemF3akJTVW1CNEUvSW12OUR5emdPUXV4RVNPRWMrTWsrYlBGZnRnNGo5N3JOZlNxN25JWmZlZFF6eHB2MFZNT3o5SHRkOUI2NUZpNmllbjRHdzd4M0x4SDlOYldDQTJ0TXlXaHdjQ3FUeVFRTjJVcUlxQ2R2dVIySmpjUEFvWUNOTE9idGFVdCtYaFJYUmc5a3ZRcWRXaTRja2hQSjhPSE14bG5lSWZzUXlpbVBtVHM2ZU5IUGplRDJIdjJubk9EU0dRNk1SWnNUc1Ard1FmWWFjWUdMaUF5cytaQWpacUJvQkVSa1RHTlMyZmFCUnNDclkwNHlVQ0VuU0h2cDg4c3luOTl0Sy9uRXI0L2VpeUw5aldWYk83Rzh5Yjc0V2sveW00K2RXQXJoTXludDd4a0V6YjVObTJtV2M5WDFKdUZiT1huMy8vMmVidjNteVlFUDVGRDBLSVB6K0NWM2Z6L2tmWTJTNUlrU1pJZXM0aWF1VWRFVm5WMXovUU9Ea3NFSWdBSDNQYjlMN2pnQlFBY1p3ZkFMbVoyWnVlM3F5b3pJOXpOVklSeFVGVXpjNCtmek9xcDdrTTNVVmFHaDV1cHFxZ0k4OGZES01qYmNleWRVdTc3VHVBajNIRTNDcjlmYnlkRTVqQW5HeEhkNXRzR0JMSXlXYnRMWlc2UjNMZHpaK0UzRmZtdkd6THdudi9oR0M4bzRZZTc5cjBxYzIrd05qcTA5OHowRGlwdS9ZSmx3VVBMU2NhNWNzM1c0V3d2VkZzMXNSTUFXemNyZXV6S2RRSXJwbm5WWmdERkVSWTRKcUpWU3RFbzVRby90Zm40MEJLSVhFSDM0bDdLUEJYVnVrYklRUjhpZTlKMitDKzVteGdPVGF5dFR0K2oyOStnRG5XTThiSDAydWZvc1FXMEwydE5OQ2ZLcUQ1SVlob3RaVFg4Y0l2QU1kWTJCaDVKc3prMzYyRjd6ektqMW1iazE4RzlUSkxGYmJDZUdpMHhXS3pLcGoxWkF3M2QxRVFMUEFoNldrSjRmWGc2TDE5cisxQ3FrU0kzaHRPaFZONXhHTnF6L3JRRmxHeTROeThLemlkV0UrdFNqbmg4UUpnOXFwVkovL0xMTDFjNHk1SmR1WkpLOXpFa3MyTktNUStaM08wS0w5c0IzQ01VYmg4TmYvOEpySHNnNHZzclA0ZVR1Ly8yN2o3V2dIclF1QlZudGlNb29obUJlSC83MWJmdnVCK2Z6bU80TUFRaWhxVFpXd3U0Q3lsMnZLa2dXRTkzUWZhU2pDQlJhOElOQW0wMlY2am5sb2hjK296Y3R2dFlRelpFdTFobndOQ0NCaUtBVk9rdHc0UklLU2VhcE1RS0V1WUlSZWJrVmtmWDMyZ0JnRmJLTkxuNWZKcFp3YldIaDFhMHlBUHg5dDU3Z09UczNkd054OGlPZ241N0RIZHNHdWFXMmFrOTZWRUFvK1oyQVBhOXZZMEVEK0tnUmdRQ1NFN3R0ODVxRFRKeXlnR0F6NGhhbzYzZjdlS1BMY2FZRWxJeGRmRzhjMzdRUzh5VGRCdlQyTkE4T3M0eTFQS3J5cm1zZVJGa0ZvWWFvcjA5Q0Q1NGFubXpFYlFiUUFzK3BYblY5T2twTTVUWFN4bSs1VUhBTDBnVy92cW5mMHRjWThMU1owQzBySnFteUs2a1FYUFVhR056alV0d293L3ZIT1hzR0NudCs3L3dmZTBzSGt3QTN6eXhZOERseDRuZjlQMFlIUG9KY0xlb2laWk8xSWRxOWx0UFdYMThBSGQwa0hXd3AxNXB0Ri9mOW5yeHZGbmxOTndQWXlzeTByR3FtQ0F0cVRaMWJKNmN3cXcxMUNKREVrcTF1K2dHOFZKbEdtTHRPQW9jczdEVTMzcEZxakdzYUNoZWFjN0t6a252RGZtNVRITXA1TWtMQll0R0RxWFMzRlRkZHFIelNGbkdEalRjbERiakMyOThHaDZpQU82L2xqd3U0RUdzNitwUENWalhDcUxaVzBuQU0rR3UxclJzeGNVaG5KdG1LWktaMWJ3Sk95UWpJa3daNjdwR0IzRTBvWFlIUFprWkZhQ1g5bjFMUU1INXZQcjBxVjAzTmdqR3pZbmFVLzhBaUFIaUJTOUxTOTVJb3Bub1hsM0pja1J3NzAyc0cwVTJ0UTNRcyticDl5dVU5WEs1bEMyYXBsUGlrcHpPK2QvLzV2SFR2Q3hUL25xdTBaaS9tVERQTGVjY3l1T1p0ZVVaNWRaVTNmU1R3ODRpL1lZMjlDRjNWM3U3NDRNVCtFQzJheWlVekJwanVKTnl3S2lzb25ucFNydWJUajZoNytoaFFkL29SbWVISFhlaGdBcjBmdUcvRDBDVnBoWklNOEpOZXdzL0NYTTNYMHl3QkphV3FTdGx3a3JoNDVwS3VxK2dER20xV3dYWWVuYXdTRG0wdUxXaTNwSXRjazhqWGJFOWZwZVV3UmFLWkdRNlRDVndiWldobmNvOFRRWThRcXExSmtsMzY3d255TDJMN2Jubld0NDBzZTU3R0JwRy8xY1hvMXRRdzU2UTBZN1c3T3Q0WFpNR3hmajNyYnY5NjM3UlZtYUxtQmk5bDZHMVpVdm9wR1ZkSjJXdGRZMmRIcmZmbTBuYUdwam1DWG5wWElqS2pMcWVTdk9kZGQ0ZmdOcTNtSU9obndKUVFGeVgydWQ0eUZjbHhoMWl5dlFXWUh3QUs5cmx0MkwrOUE5QVhhNXJsdjZ3V2M5MkRkUHk5UEw0dTY5LzgwK2Y5UE4xNXRmcUxNZ2tReXlkZE5KOEV3bFB3Q3d5MlhFZjQrNHlsSlJKbDZXM2o5N21pcjRSTkllUm41dm5aTmU5M2NtSHNlVkFEWVBNM3RuVXp2dVF1VFZ0dERMeVFWVXRJUUFtT3JJVVpzclRYRXV0VVdEdGRkalV6NW1DTlM2dDlsVERFY0lWMjJjNXhHSnN0MmRwaE9ZT0tVWlJwaWlMSkF2V2lvWkE5bnR3UjQvTnhFQW9Oa01iMktXTzZsbFNMWWtlWnFWRzBxdzFyVEwwUUo3cXVseW5sZ3NxSjdid1BHcXRtRzJKZ25CelJBcXJaRzZacHd5SnRFVlNNOUlnVTVJdFpyeEdudXBhUGoxY3ZyaFU2dXBuMXJYODdwT3ZhNjF3V2k3bnM2VjhTZ0JseTBKb3hXRUNtclk1Z3JMYnBkaSt4M1lTVHdQWnM2bEEyeU53OEdZYVVQb2JzWTV0SVdVbHIxY3VxK2VYcjFrbUx0VmNlYkZQL21XeGtSaXdhS2F6OVg2S29VNXVKTjNqTk1VU3d2STAxOVdLcnBtMTFrUmtaQWZHWlRmUVFLbHdKbUk2RlgrcFVMWHp5MXgvWlMzbDRaY3ZXZHFLWE9SYXNZV2FiUldoUUdyeFFyUTFCS0Jwc1J0aytnRHVrZUQ5VDJRcXpkSDI4OVlsSDFCSWhheFFTejcrOGZmcmo4K2ZyNUVOSFFVQW1Hb040MVErLy83aDU3LzdWMy84a3BrSk1qS2ppWllTR1pGTmw5SGJySkpldFdSdUZaWHE0d0tUUGhRa2Z2UG8yL1JMUExoSTNtQlJOWDJSY2RkK05URjJLRnMrTEJPcGZTRnRDM0lVK0kyR3I5L2F2dXJCT1FlQ0cvb1lyWTJzOUIyL1hOZmNhcFAvQzh3azRGQlQvN1J0QjRsa0J5di8ya2xNMlJYOGphc0VtVnFncGhzdDBiSjZBTWo2R1ZrYmU1aUJUcnhTcGhwdFJwbmlZa1hQUzZ4UVlqSUNwVXd6TWhKdWxIaWUzS1c5SHp1QzJ4TTNvWFRvS1drYndPSFlwRDcySG5SREhOT2JMNGI2NVNRakFrcGxCZDFCODk2Y2JMaW9IdUpzVGtwR0syNGJ3NjhGZUV0NDRMS1NzV3FiaTl3b0hPbk5iWVE1MXZiOVdBUDRtcEtUOGxsWEZJdFU5Y1NZeFluMzlyYUdXV2k1TVcwRE8yWG1tMi9RVU5nYWluSG5ZbTVYMU00aDlMRFRUeitXTlJzd2hTVTdBZENYYWxUNDZhbisvZC9pc1VaR2hJQ29NVklGcUthbmFoTzJGa0owUUlmb3B1ZFA3U3dhYWROVDZFM3B3M2MwZjNXVTR2WDhLeDcreGZFaUpNd0dnMUFnNktXWVVpMGx6cXlwM282U3pzMDl3Mnh6UitsdEk5T0g2MWRiNkJXN2ViYWZLbWFtbHViNDN0b2RBTVltZE9vMVh2YXNsa3lGaWpFQU4wWURjeXZTMi91Vkx4S2R0QlhDc2FIVHdpOVNvQlVoZDU4clJaRlllNTg0MWZiaWxuUlZYTTZvNllhVExkY3J4UVNMQy9ad0xrWHJGVk14aGZGc0RVWmwrNG9jOHY0OTIyam9HSHZpQVRiSzNaMzdaWU9NZGtXUVhsOFNOMnM5a1lxSVlsRENuY3JNMWlUTUx1cVNKQm5jWFNtRGUyR3FnUnhTSG9KU1dHUGwyVHI0cTJOWGVLQW5qUW5VdkVabXJWZ0NFaFJGOWZSMCt2SzFMaVN6SWtndlJheHZwWHFLZ3pkb28zU2ZJNnB1SUcwYytGSzE2YnlWWGwveGhvYmY2M3ZMOHZqVGovRVpOV3BDTE9OZXVvYlBXRFQ5MWVYdi9rRS80R2ZXV2p1bEx6ZEFRVVM3WVNrVU5FSkhhV0RYcXQ3dW5iSjJOUEU0YVhxTnN2cXRkMC8xYk9uN25BWWhRWmszOG5lQ2RKOEtzejhuM0dTRkgvM1BZQThaYWlXSnY3dmczajkvRWJST1hUeEV6SXVPVE5oSDBxMHRnQ28zTmJ6Rzk5Sm9Tc1VETE01MWJkVzFNczBKS1R5azZBMEpObkx2VGdhUmtLSzUwTm1OKzNDMHUyazI1VmYySUVBemtGYW02ZFR1a3ptNUNlRGo0d05pclZGb1RMaWZCVE5tYkRsMUhIMjQvcmYzTjdOemtMWTJLUS8yd1AyeGNWUDAzYmNNZFBlL293MjU2Y1VUenVtaXFHbFFnc3IyY2tLUWJGT01qSnQrbXlhV0NvUFNhZzNMMnVWWDJmMWsyL1VYeUIyZ3FWamxMeUJrTUVwOFZIMVpnaGFSTnBuWk5BY1NiV0FWdDZJOERhSHdyZjcyeGs2NUJYdW1pQURkMXA2QVJHcHZNcmVOTVZEbWdsaTExZ2lDUmIwWm1jVVptTTdYdi90L256OU5MeXRyQ3owZThDMkNocHBHR2pNelpLK2FNN2NMb3luenViOGl4TnNMbU44aFVId2p0YmczZTIrSUdwc0x5MW1Sa1VhNHV5bHJIV0x0SnVESTlEZmNJTjYyYm9OMmcvbDNsUFljMmFZOW9QckFoUkcvMVVYdjN6L2JSS20vZFFlNlBVRmxtSlZhYzNMNEFvY0RTTmpHZ0NHVW0ybXp0M0JxRDczTi9xSDZPenEyYzlqUWhyUlRXTkZPMUp4SmtQUGtGakpHTFk5ekxsbktqK2RwV1lWU21sUjN0dUd0R2wzbmtXSFFmMS92all2UXdmaU9OeFZwQXJyUGU2TzU2Qlg0WWZoaUEwQ0tKVVlMWlJBbHlYN1VEQjFrNndzS21jbmViUkxOcmpHWnBNbEVYRnRsSW1WVERPTG96R2xiK3lVVHFLdmNtNnhBQkcxNllHYXVTaXN3MGsydzNjTjJjQzBQM2Y3Z081aVdEa0NJdXhNNGpXMjRMeXNlRFNwNUdNWnR1OHM2RlY0dGNxbVprbUV6OUh2SnErYVQvK2QvK2p6bDUvWDBPZHBYMUdpRDR3Uk9Xak9DRENPMjdVb281bXNwNUJEM2RVTFdteSt5K0owTG1FZTNFMjQzOGxadk5zaGRWejhORG1jcnVXNzBBM2xqOCtqeldnZ3BWYmM3bWZsM3lEYzJyZ04zSVZGcVJHaUFsdm1ORTFqRFR6bk9jOXZVRDVZWnhwUHFVdWVwWE5tNkhlT2NYeUpHK1VXMW0vK292TFJkRlVnTWtmNTRIOHpNbUpra21WRlQ4R0lRaW1URmkwWFVSYVFlUDgyWDFhWjVzZ2laZzBpeFRDVkdLbmF2aUgza2RHbklVdm9Kakw3RWRXaS84a1lBTjZKNURrR3hiMWRldzNjbzBMNWNLNkltQ1Nzb1VocWp1ZGJhSWt2VTJ2OWZScXZJMU1qczFRM0NXbVVVZlZGdXdpd2V4aGpXRzlLMTM1dWZTbDVXTWN1VWNlVnB2dUtTb0Zta0xEeVRPTUxQOWhQNGFGd1RrZ3N3TkM4M0ozQmZ4WmpDSjY5UlJ2N2ZRUExDNExJa3A1T3RVRnhyOW9EdnZvTFRNbnk2L1B5M2F5bnJOY3NhRXBFUmtUSWdtWkFpdlF1ZWVuN3NRVkZDMmVzYzNrR0cza0pSOU9ZSjlCMFh6aDZpcEsxVzVpRko1MUJDZTk5K1hhM3JxQXhyd2h6dnVzVlVIcnJCUithNm1FaHZFSXI4RHVIR3NkeXczRHAySS82b0w2V3dSdVA4b0grM0pjejEvRExZRU1XTy9DdVlmMklvczdRVXBCeDhhV3VOOUM1NE9IN2tOa2d5UDBRVkc4Y1BFTmp2ajE1WTIyakJKamZMTld4eVJCZ001ajVaQm9yanVhaHljaWxsMCtSWjNUTGtidGh2dHAyL3pLTWYzbzVLMFJ1Lzk0MzlsSnNVVjRSdUp1UzMrQmJyQlBYTHFoYmticUl4bzFHdGlPZ2tyRFhsUWd0K01wRnE4YWNURkNMSXAxOHZOblg5ZHovTXQ4aFBIcnp4MXRSb1dlWkswWkNUbGwvajlLbmtFdFlQK0ttdGgxdUxnallUOUZFTnJHaVA1TzZPVDZGRnlOR2lOM0g2bkdHa25wZVdLS1dIMDZrVTFuVnRqNTlsekUzWG1UNzd6MytkN2tyV2w5cHNLQmtacmNPUkVDS2J0YTludk1oNERMNSsweTEwRDFiL2xnWDQrK2JET2xRZjk2VndVcEtLekVDM0ZtVmhpcVltZzRkVzBPMjRRS2syNitpYmRFbmtOa2I2enZXckFibE1FNkJrZHFGUnU1bTFxK0Q3bytBZUxFTWg2Q1FiMVhDczZ3UlFmL3pwWEw5OHZqNUtTR1VneldIaTdJeldnckhiSWVwd1dicTFtOHhXR2JhaVB3M215cXhtZEdzbHI4MnpQMGZBcks3bWhkV2RHZXMxQytvdmJwZzhrNUpQSlRPZFZQcm9ZZlg2djNlaDdaRDRTakF0R3hoMUE0Sy9Eb0g4VHJXTUNrUW9FWEttaGFvaHdhak5RRXBFRDAzTFJJVVpIUzJwcytjbWVIUjUyLy84My85eHRhenJJYjJYdDhLS0ZzWXdkUnhvaXFCUHZGcDVmclo1cm1aeVpWS2lPYWRWNUsxblpaUGljQXNIUlFkeU1kOEluRGRaR3BXUnpMUWhmeHEzWisraXNIbWV5OFNJQUUwdFF4cFN1ajJGSHVNZi90dkw3OWRMS0JPMVJWNXdKQm9tV2RVeU9RMklvZXZxdGdwNk93ZDhxeFdqQ3lXY1hZS2lCSzB3ZDl6T2ZqTWVzRnowck1kK0FuWXJwQkhTMUhmSkhnclQxTnh3cTF0NVpTMTZzQjgwRmJPdnNkRGR1SzdKT1ZlWU1pMVh1bWV3SU5jd1QyczJpRnFLSVdxZGtGRTQ4alc0K1pKYlVvQWhYKzlRYlN6VHBJbVJkR01iNWhFS0ZUcVZObmNjZVhNTDN3QVFodGhrbUhtUVI4YUpDNXhKMlBWWFBQd1FkWW1rdVUyRU1sb0oxNTNrVGJwN0tRVVJpVnFLSTVHZVNxbXVEMnZsYklhWGFXWW1uV1VxN3RDZkpsKy9YTzM4eUxyeWJQa1FMM0RHc3Y3MDZiUUMrZnQvZWZueEI2MUkwQnp5Smd4VlBtWk5UcVk5c0h1d2hRaGtNM1VRU0c4QXBpN1gzd3lGelExR1lNMW14VnUzZS9KbTVodE9sbjdBVndtd1RNRzlabGt4WGRMQ21ZeWEwd3VxbjA3MWV1cUxaMG8vVFhJTG95S0x6MWpXMDJUTDg4UHArZWUvK0YvL3AzLzkrazhWVkZZQVVDU0pOTUxXRG9pMDNsQjVuazRGZEk4dm1xWmFhYi9xZkhxSjZlRXB2cTV3Q0dXYXkxSVRvT2ZlMUkyOTg5U2F1WlVuTFppdkYvK3hYUE8wSEVBRkxMUkZxOXlBeWVKUE1LY3ZNbFJNRU9sVW5rSzBKSDU2NEhPZXNCTEtKYjJVVUp1U3hlVTAvZnAzbi85Z2xhQkZwelhwTUNKb0xkdzh6bjVmbjRDM0h1VjM5VFY0Mzd0M2IwZjVUbnV1YnU2MEdnRmRqVkVCNjdHajJFSVRKVGVMQ0RjRHc0WTgxU1F4RDJtRDNkNGxmbEF1Nk1aczB5TUhLSXo3Zzc3UFlDd2U1a3AzY1V5TWxOYnBZZjdWS2d4clRHYXdGdGFEYkp6Q0pHQXpRaUhCbVptTnlVakp5c3FUdTVaNGNKY2ljQ1pQVDc2OFFCRXdMMzkxL2ZXbFdwcnhjZjVVTG5NK1dFN25rOVhINllkUHNXak1jYjNYR290UzFPdEJEMjhDZ1RjSDRURDFjamUzYkNHYVNCNDB4Ryt4dUttdFU5MDJlME1rRW9hQmNkWmNETmFiQUJCaGNIZlNXeHcwR0Frb1VLOWhqcGYvNTUvLytkY1g5K3k1Qk1kODRnT1FHaVRPNHNOWkZTODFaV2xNazlhb0FTOHo1RnpKTXBkcjVjM05Ic2NnMXJhZ28wMmFyRXh6cWJHMmVubklrSHRBQXNDdUFtZ0ZnNkdZa3ZSMFRCWlh6Q2NLQmZVYWpVaGlMSTF0bTZqei9QVWZmN2FIU3l4aHlEbzYwQ1lEMlYxZnJiV2N2SW1PZUZ0YXlJMnJnL3MyaE41VXJiKzNma2RMaWJnWm4zVjZxKzVkK1RtNnNJUGJubFRLdmFCbUIvWWFtNjkxWWx4WDYrN1JIb1haOW1NY21rNDc1dlQ5dGFpYmJuYjJXMkFLNHJmdTk5eW05YnJ4VTR3Rm5NTnFraS9MeTZkUGo3ZytyNEhNNmwxQWtUNmNENUNRYzlUY2dyWE5yWkZaekJaenkwaW1OVHpQNzVmMDR0V1lTRTVsUG1tYUU1V0xuWC8zZzgrbHNzWjhlaXEvUHNhRHArSFU3WW9tbUpTNW9xZVgzUkNiQnp4Mld3dk5CMDRpZDFuNDNvemMvZlI1OFBIcjJNVWRVNUl0YTdDajVkY1dobHdIR3ZROFd5VG85ZUF1SVBiclpvaW1XcGNhSkY1K3JXbnpySFZWZHEvTDZCUnNaSlorZHBXdm1KNnVGWFZOT21nc2tibFlMT0hlY0VadVRxMHVHaExNajZZTkRyRE1zemxqNnhyMEFkZndGVVRycDRZSmdOazBSY3FOS0NlK0JNb1RxNVc0WEZMUmFDRGwxQ2Joc3Q5ZC91NmZIdWN2eTh0TFRsYkhBcGIxaVY1Z0oveDkzN1dWd212TTVDWjkxTHZNcWJ2MU85NW1nYmVVampjUlN5MjNzK1dlS3dKMGhSSTB6NVloT25MMlRDbUh4eEM5ZW05Tzk2ejd4T3NWalBlcCtuZHlhTER6LzI1b0VSOU5rZTh1eE5zSVlic3dsdEN5QnZSZ3NWd3huZGJ4bHZVeFkzODZ1VWFnRVhOUUFHTUNHVEM2YVpVOXpLdVpHNFZIWCtxZlFqQUtrMDN6ei9MZmdSSFBwd2VxalJDbjg2UTF5VFVpdmIzUEprSUtwVmFhbTVrZGVSSGN4NjdnM2VoSU4rZnpvQ2MwN2ZCVzhlaVlZTEZaQlE1bWxYN01aVjBqbWFsaHFLZThtR3B1N1VBRU1nT1UzSzB4UDEyTVhGZ0Rwb2lUZVYxWGVkM0krOXg2aHJ2Tm5WU29ZRmxtZE1TTjJtMEZYNXU0TVUwUkZaRUZ3RWZEUjIrVlNCUG0wZElPYm5FcHRIR1loL1NGQkdGZUFIb3hsaGtYTDArUDE0VmVYMVlMeVJ5UmhjZ1FmWnBlL3Y0ZjR6Ri96YVZ4Um5MRVBuS3pHbzlHRllodjJ3RzVRVW1PQzA0anlYQnpsYngzQWg5OGtsdlczK3RtR1BlMHcrTzhLUTE5M2dWTHkreDZzSUdRSndYUFhFVXJPZG9MWW1aSy9pcGdYTi95VHVsKzhLRWpqcEw4c0ZYSDQ3ZHpHQ3ZkYm9OQ1dsRmNjUDNCSHBXTGFFWmtia21tRFpDY0lxeGxuTVBwWkdUV1dDcEptb1BUdzZsSGRldkZIK3N2ditDcFNHN1RYRjVZSnE2aHgzbUt6L1d5cGovOCtNbldkY3FzZ0x0akxCVW9VaEROM1cwclRuam5TeDJBSFcxVCt6MjZjcU5lN0xLTkVYdS9sUi9IVnlEM1RRSW1LdGRsRlJFMXVaWWR5QlloTkROQW8zQzF5cFNGR1JGMHMwYWRWSWFYZWFrWmNHL3o4UjBIenZ2Ym9hYXpYWi9qb2ZTQ1BTR2hGRjVKSzZveFIxdzRWK05BSkwzM25DM0RMTE9vWGx4dUE3eGdXM2pITHBoc1ZYK2FzcGdaV0lxeE1PengwOVAwVW9QMXFpbTZqNkJVQ1BSNWl2L3lYL253OG5XVm5EWm1VSHVhajdxbXRmdGE3Yzg0ZjIveWRabDNDL3lqRTVoNDZ3VGVITlc2ai9rV0E4VVkwenF5eVRJanNtZWVzaXZJVk5OZzBWc21sZGt2VlBkMTczWUM2NjNQUzkxZTVzZG0wWnh6SXIvUlZ0M24yb2NhV3NPbE0wUmFpWFJ6YUltWEgzNzhxWHl1cXpWREVyUHZjTllVOFRoUldrSTBLZzJwdUdyTjJTZy96OFdiRXR6ZEdLY2Z2ZFRGbVduelBKa0ZxSVQvTkpXOFBDK1IwK004YThXVHM3SVVuelBiMnFjVUxabk4vU0RWeFVqeUk3WVRHTnhKd1QwSVlDelVteWphblZteUFWNGF0WmticExLNXZORGQ5OHU2aGhEWmd3clVyYzhOSXQ0VmdPWUdpTUhHZERNekUybFhjOHVXeEF4WUxCcXMxcHZ6YUs4aVZ1UHo5Y3VjN21wU0N4SUZYQVZNeFM5WEVXdFdtYjdoZVEyRVlBaEhWYkZqb01jT1pteldaK3VpU21PYUZmTnVVSmJzL0RSSEpTNnJQSHREdFpRMHAxRHp2LzM5ODQvMjh1eGhFM0t0ZVJ3RDlZd2dkcCtqY0Vnc2VQL041QzBhcFV1bDdIRHNmTlRFNHFzdXoxdUs2ZGNuc0RWU2hRRHI2ZHBOQkpzOWthKzE5VnZzVzIzRE4wSmtIY2tXZHpqNHJZbjFJWEhuVUdtMG9EM0liR2YyZlBoc3VlVzBiaVNtdzFiWHpwRlcreE9LYXprL2ZMS3ZxeFJxbmV0K0wyaEtlQlczSlhHZXlsS3JaT0ZNT3oyVURETnpTMlZkd1hrMlE1MmVmbnkyQk15THdVS2tUenpQWlYxOXB0bk1DSjVucFpmSlJEUnBhZ05EbWpVaWlMcHdoanQ3WmRkbEhVQjJoQ20zbU1jREg0a2o5VGNCN0RGUzNBL3JYU2crVEdNUklhelJrUDlqQ21RS21XZHVZaHF5SnlVdFNvRU55a2gzZ0o0MXA5bVdOZGJyM0svTFE3cWZ2VkUrRWpYazlkZHJuZEdnb3BBMXdlTnpFYjM0a3VFZTY3QnNwRDVRM0ZGK1NoRElhT3RnNUtodWM5YXRSVUJERlVINE5HV0FDdW5zVTdHNDVzeExPSllrVXpRdlh0eldkYzIveGhPdlZoWVpWWmQxdUgwNFVnMXpJOFNKUjR1NnZtMnllZi9pcU85b1FyL2pLM2pYLzhBZVErSjJiSkttVW5zTFJWSjRVYzFCQUNlRG95T2FmbFBjMzZ6Z3QzK2xvOUc1SnpsbEc4MXJVeGg5VTZaeTlEYnNHbkZON1kzbjNJaExLdlVyVG1kZG54dlR6ZzFVUTJmM3c4dnBQRDM4b09zWFpXTm5sWWNmcHJxdWF5MHo4SUFhcThuKzhrK2ZIeXhqblNTWVFWOWlmaWkrY0MwMm5ZRHl1Mm96T0Qrc05KOG1yVFZxd00zVlFLM04xQ1NsNHo2Y1oyUG9EUC9xbUI3cGdISFJnUngxU0xEcGNyYTNXcCtqd3NtYUliQ0dBY1k5RmxhZ2w0anhkU2ZDTXVDdXFFa3YxVnUzNExTc2NITzlzS3dMT09QdWJqN01xOWFiTkxOejBlbGhhdThLMU13SlZVOFNQRm05bElqZ2xrUDdmZ2xObTgvSmxRS1V0V3pra3BHVXlRUDdnVmhCaDVVeWgyY3FRdWNDcEZaTlJuZ3VUWmRVNWpLL1BOVDQ0Ny85Ynk4L251TWFaaThDSXJMYkJZbTF4M0cyY3d5bzJNMFRnRkQ2dHBQQUNEWm5pOGZjWTJkYWlkY3dpRHFvSncvcjN0a0FBQ0FBU1VSQlZCcklhdU5BOXhONlVPZ0kyMXAxUFUydTRSYTNRT3cyMXNqc2Q5dmhIakRVakpJSk5NNHZKNUpoYXNIM0RlQnBSQVVkaVVnakc4bThud0NSVzlqV1VSRTBmcTVDS0Y2M1RjcUVnSFdvSGEwaEYzcDBZcmJmQjZTS3hiVmE2VkN4alVxWWZhcHRUYlJtMm9rVUpJeGdTeHl1RUtDRXg1Zm54MDlUdUdDWlBFZFVLU1Bqb1N3WFBqNVlYaFovT3VmanRhclFTK1NwMk1MejlJejV6QkFWZ2JWaVNYeUZQRmROVHljRm5rTGhzeTFlYVA0d1A5aFpwb0pMVkRCa3ZxSlk5bXlQYzZZTTBZcU1mbWt2YWtrUG8rcG9jUWI5dFRSajdRdTY5Z2Q2UTJYVTZONzJMMkRMM2RvMUtld0hkd1hOcHVmcllwbXNhVTBhYmU1QnJDdEwzZjd0WUprWVU5U0dyWmI1OGxYVG1zd1Z0QWV0bkdxMEExZTVwMWlhUTVLdG5ZTThyVlh6UTZtb2FhY0NjTFZwQmZSaWp3OXpsWit6MmdPa05FcHBGbjJEc3ZzZVVibThsS2Y2aTdmNWhHK05YTG8za1V1dnZMckhaQUpzbW1jdXAvcWNwN0plL1dTOGtPY3Z6NnZGYXFwQkw0Ynk5YWRuLzhOLy9iLzRNS0V1VWNPOU05N2ZPU2Q1MkJYdkRrSHVDQlc5Y1JKLzUyajNsUmhUeVlNN2NzZG1iSWZWclhxMlJhc2htcUMxb1ZxUFdjQzZMY3lIUXJqMHMwRjNGRW05SW03Z1JqS2FEZXY0eXBMUlJpT3BVU1VPeGNkdjBKME5nU0cyUFBkKzNFZFYvSGk1Sm4yZS8wUXFVbGEvQUhZK1QzUTh4MDgvbG4rNDRQekRwNUxyRWthVzZhSGthYzZsMm9OZnJoZjNGOEhka3RYS1BDM3IrbEJPSjY5Vmxpa1RjOEJWQ2xFVjJUY244OXBQV0dQRFVQTEFSRHZHaG5hODNyZzVmZnlRRDhOa3ZYZmhHT3AybWhUTHk1YmUwd0pSN0lzVUNjdEQzMi9NbW51ZEdvaE1HNEVIT2xhODNMczZzYytETjg1MWhxeVVTc2pGQ0JseXRVVkY5bW02NW1HTXdGMllkNnVJRnFLVUtUNExQVU5xMzhDNmYycmNOa1l5Y0tHN1lRR0ZxRlQ5aTlscmhyTFVkUmtUWFNXajZPcVBsNy8rTDMvMU80djFXaVUzcXZmbkIxVC82TGh1UXVGTmYzUkQxMVBQaGJpN3oyOXhjNzloL2U0Mkh1emdBRzZIcEhxbmN6RE8rTXFhdS9GUlNyYjhoN3Y5Y0Z1ajBWMTR6UUxUaFFBZkxHRFJ4TlNoUi9CT1lHUWo0dXRRZFh5TTFieS8rWThtWU5POEtUcHpUQW5VS3hZUHVoQzF6bWVMYTlWajRQUjRKb3Y1K2RPUGwzLytVczdUMHgvc0VwZkZuU3cyOFRTdEszZytlVnhsU3FXY0htMzRVNmJUdWFUb2ptU2hZZGRpdDJRTUk0Wlp2NEcxeUdabzRqYnU2dEZJdDUyZ2prRy9pWTM5Q0Y0MDRxWmY0M3V0alZ0TW1iRzhiTjgrR1pHd3hReG9kRDBOZ0ZPdkJLMkJQOWFzb1dCdis4YWRkcGwzLzJOb1JBTlVSQmVRdHk0Q25UVnJaWEMyK2RJYWFHbTliUW5kcTNQNmJoRit5bCtHTWx4YklwRnZXZWp0NTQwVWUvcFVVR3U0T1JTd1Iwc2xWUmxSQjNkY0NaWEhuLytEL3gvLzhsYzZ4MUlqNFVKTENNK3U2V3NHNjkxbk1ienJ3aXVvL242ck9kNEpqMU1SZnM4NXJOc2xlWE9sT3Q0enVFbE43NElQdW9HY1RpTktqVzVoT0xTcmIvcGg3TGEzN0czcWo5bFlyYncrdE5PNTQySnVVQkpkZlJCN1RvRHdPc0x3S05wL2hkdHRtMno3Qm1KZzZBVFVLL0lYUDAxMXlYbytQY3h4ZWI3T09UK2R0YXduZnp6eDVaZnI3MzRvaTZlV1hITStNYkdzTmlXc1dISGoxY3BqdElDZmg4d2xNUmN5TDJ1MWgwbm9WdjMyRktxYXlpWElyQUxZTWh0NzYybEhTN1pvcy9FdjdzYmpVUksvd3FlK1BZYmt1MG84MHBTUU03cDlxR2ZQb05NNlMxR3RJNEIrbitka3IxOU1nVlNMV1IxWkRLbWI0UEZiQlZuL2I5QXlheUl6VXl6ekY1YjIwMjArVDVrQms3WEhwRTBwY1F1Njd2K3ZvdFNWcDl6QWkrMVBHZ2IrRTVzbUdiQ01ianNoYmFKeHFxalZpclFtU3hPdUt4SEtFdWZsLy91LzhZZG5yVXRBN212bXVqYXJVak00Nm1qVGZMOEcwdHU2aWpFVmdkNzJIcngzQXU5NXNUU0RyRE1CUnFpcmRoZjAzYTVBcW5HZmliUjJSZXJkYUJ6Q1RIai9QdTA0bW0rRm10MUJKczFzNjF2cnhsVFJsWm43TUZNZmhzdm9qU2xWUS9JSVcvNXE2eWJtQXNiOFVDNHhQWnp6dXJqTXJ5YXNOZDJYV24vNStZZi9aZm1EL2ZKMU5Wc3huYzVhQXNvd3pBNURPZGVhbHV1eUJsQUN1WWJ6TXM4SVRDZVh2SGdYVHJYR05nUndvbUNCYUJFcTZ2VE56WDBIOWZXN1JRTnZMZW5iY1NGZlQ5N3VON0pYT2JQYmNTNW9Ta1hLeStoU2h6eEp0M21hNGhxTkVMSkpYenUybDRDc21XQlpHK1ZHR29TU2ZXeDFweHphNHoyVXNib0xJZlByVk5iTE9rMW5uWEM1WG9NMHM5U1dWMzIvSVF5VmpWZlpKS0hUUHprbURqYjg4bU1lM2xITlZZRFpyTWkweVJ3MXEwcFJmazY2cUtad1U3STgvK1hmL0o5Mi92ejd5K1dhRGFtRk5qSWRGdXArQW8vcUw0NW0zR09oZkNoNmIwclFnWXg1ZDRGLzQzYkVqWEpQYkorRHR3QmRIay9FOWc0a3lMUUUxa0JwOWV4aFlIUHoxN2NqMTlyOUtPNHFxdHU3MGY1OGo4VTRyYzIxWHhYSUJ0UmpBNWI2RUZCNWc5dmxtTU1QZ05BT2dsWFNKNjdyTmVhcHZEeGZNWlVINS9tUjlmVEQ1ZDh1Zi9qcGFUN0Rwdm1hTms5aDU3S1lncXFnNFRIVFBLL1hGWk41Q0RsWldXTmRsclJwc3NrZDZtQ3A5aFlYVTYyUm1ydGZ0TVhzOHRhazNjWjM0L3pGRHJIYmVnKzh4NWU4dFhESGR2L1dGdHA3WXFPNVlOdG1uZ2tiVHJCTVdQK2Uyb2ZKY2JUUWUyeENZa1BCNnFCWXZVRXNiU0xkZ1pmRmlwTTh0U0xMK1hSWm81d2ZaTmZyaXlicmd1TXVlc3A3ZzhET3VNemdsQWdhVzJZWGM2dVhzZVhjZFVCOCt6WE5qSmNhWmtZajZhVXM2NHYxa3IzdkRNWC85ajgvLzlIVzhueFpqUTB2MU9hTGZVak91eW92QjlIaEpzRm14MkwyWE5kOVI5TWU5UFRkcUNuZTVBT1BYR3h1M2R1eCtZOGErbjdzY0hBN0tkS3RaRitBZDB6THNSYTMyMUIyS0I3ZWpVRWRLYTI2VTBueTdwNC91cWUybTJ5TzBkNnY3M2p2bk1DKzU4VDJhUllOU1p2elNtRjkvdDBKdnZEaDhVYzlQT1ZYbkQ3UDArLy9oL0tuZjMzNFdqRFg5TWVnSzFHQVlDUktTUlVxWXAybWVZN0VLak1GeWc5ZURHYkRjYlY1ZW1FdHJTU010S0t0WkRtUSs5aGtCdzFuTTlDc0kvZnVxSE02bEtqQyt5ZndHLzNScGdvZk9iUE11b3cvWHlMb2pxaENocG85UUszSkJyVTU5V2gxYWRNQWdoWTdCNDA4OWkyN0syRmtmYmxFWTgzSjNBTGthVEtmTkhtV09XSmgyV2NtT3FRSzhiQ0h0eVpEdXFvS1I2VE1LS0diMjQ5a2FaTUg5ZlI1cXBUSkhlQmFwNU5aYTdWanZiUzBabU5MSWdYS0QvLzd2LzVINlEvMXVpUVVFZWUyYTlpb1J2YzArYjVEYkhrM2ZWMXA2ODRlSnZHOGwzRy9zeHkrWmRCcGxMcjk0anZTZDhFM1dqNzd4VkhOZlRHdUZaTW4xbjFrZTdCRGRGa0hFdldRcDh4REJQVmJDL2lJSU5CQXU5d1Jqb2NKd2ZZWFZ2ek43dWN0YStuWW15VUF6cXZtVXBmUFQ0Ky9YejZ2NTZkUGVQeHhlZjc1NTEvK3gvOFF6OFRwSVhTYUw0c0ExYnF3ekVzaWx0QXZ0T0pZMDZlejV4cVlhc3JPNThjZjFzc2xXaENQUWkxZEVRUldValF2aXp0b1l1N1MwTkZtRnFIZTBlb2VFK05HQmIxRkhYWXQ1UDZmMThiOWQ2MW83ZWl0UnN0WXJxTXpXRklnc3E0aUV1NWJaSTQxbHpKR1luZTdwZzVHRmJlMkNuRURkOUZOOTZsWnlveFpJMlhVZExvdWRRbXRPWDA2czE1YVA5TkdxQ0R6enV6TWxwS1psQW92eVpJRFd1SjdTMGtBNlZBYUdzZWFaaGJUTkxreVRXRWtjUlVJMWFVMHJWQlp1clRLVVgwcForUXZ5bVdSc2RaYXV3RWFNUGVtZlZkbk1tZjJYalNqWHhvYllUK2p4U3Rxa1BSWmFXNFlLcE51aXRnQVg5cXdLMDFJbFBJRGRMc2ZPcWxPa2dicFFxWkVpM2JHZGlwakp6LzJTUGxlZVk1dWNtZHBPdG9vMEpBeU01U1QxYWE3SWpKYzBZVjJoOER5NHpMdmZtUnVCVVJxaUFhTnBOeVFzYmRXWFFtandxekZZcWZvcFhmbmV6ejVPOExSQWNUcXNaK0pRcW1RWnNYY2FEQmpSd2ZBUEU1bnJIWTYvWEZhUDY5UGYvbjd4ek56K1pkL2lmLzBtSm5KMHljdUZ6NTRYZWhJdUFkZzgxd2FqZEtuODJuMjRxZjVORTlHbXlmT1gzOWQvRlJBME1yazFxajN5a0t3RkdzRWJmWWs2Ulk3MUZ6b2JQMW9iM0cvYUxraHJYUGRTSUhjMys5Mlh3eWswMkF3N09tSEE0dGJPeUdqNzR6cVA5ZXkxb0RSN0JvelA3L1lTMFlEWkJNUk1NOUhlNzVPcGR2TnN4UEVzNTRkYTVhSkFRaFdHaDgrYXMxVXBqTHRockJIRmpZU2NVZDB0L0tEWGh5cUNVVmQxNUE1Zy9PNWZzMVRDT2FJTlp1QXgyRG1QWldMTFNvN0FVdWxnakNibmhBcUU2SFdQdW5oSGNaRlZHcWEvNGpMd3JuUXBMU3BPQzBERTJ0cSt1UXZhMW5UVGg0VkFXczc2MWY1dzZPdGwvWXJxNlV3OW1DZWNYZ3FvMnVoKzRhUndWM21SRWs3RytzWUZ2YXFJdnl0OEEyK1pWOFlES0ZqdWZKS0dmYUs4TkJLZTVwbGI2aWwrblZ1NTFpOXRmbVAxSGE5TXhXelVhZnNMVzd1ZWtqeTN4T1dkZ1IrbExaSmNBUmhyL05VdkRqT3hwbVRJWEZkcjVjZi9qZ0JrUUk2L2QwdVVhZmlzVTQwZ2NWbUdzM0lGWkRCc05yNVZKZEx2YVNmVDBWUmlGMFNpWWFrRm5JVExQY2hKM2NjSVcvODN0eHRsZWdEUEI0cUdzdnNNU1g3SlhSNFlmWEJHNktoZURSTFJheHIzMlVWU0hlSG5uNDMrZWVzdVNjeE5HM0doVmxORGFiUXkxVjRTbXV2MC9oV0MxWWNuT25PZ2hJQzdnbFZqS2U2UGh2bUpTeGJtYlgyUjFVYTZVYmQ1emdTZG1RMDBLZlNsYjdwT0RRYVNCQWhUS2VUUkhjZ1EwckY3RFpGekE0OVQyZUx5NHZTQ3V0cXpjTUFvRnp0VklyV2w5ekEzKzBmSHdQWEl4WEhSbzgyVVhvRDBuVGtadTdsaDdXLzcyQ3dldHZWODFGczZNRnUrcG9oZE93aTIwaFRlOHNkMUN0eDYwREJpbzZOMkJzeUl4ZnRiWUhCYXg3bXZVME1iQXF5UHBuZnpRbTNPYm5ma0RLODkrYXF6d3NqQ1NwNmlBSlkzSXlac2NvWUZ5L3I4eFUvL2NmYU1wSVFuRURaZEtxcjVrSllvOXVhRFluNlVCUFFoWURXY2pwTlRHL3RIMnA4OXo3YUdteDlUWk5lOFFTUFdwcEJsdXJxZmcydnd2QWtoSFRnZHFvbisrcGpqTU9BMFZoN1l2VzZyRTFoUVNFeHp4Wnhtay9YNTJ2MDU4Q3g0SEV0QUsyL2pTMGp1a1Z6M3BMRk4yYmkySjl6OUMvNmxUL01EYkZFeng1bUxyL0twNGhDS1d5Lzl0NlNMWFhjRTNyL3ZxWG5sRU5ERkRSNUc0WTlCSjFtZ29pSXRHSjJUbWRFT1oveStUbmN5NVRyNmpIQ2tJcWtXQlZqNFk1OGw5eENtaURBT2tocHk0YmJqeHZMVnF6YzBBT3AzdXN4NHExNThIZnFrR0I4STMyTU4zZk5ickpNdmJOK056OTRFcURSbFZMSHhnNEJlNVBTdmYwQ2NlZWQ3ZHVRYnJ2VXhLRWJ3UEhMdGozaFczYkM3MW5BYkpMUkZpdVg3YVdiNTdrUUViODZmRDVoaVVmTVpYNmExbjV3cUJqVGFPZVg1NldlVGcvWFVoUnBIWHcrN3VSRXlUWFRmNEM1SVRtVlMyTkxqbCt4WFJWYVVIdERSUXhhMzBhWnhoaWo3UVR5TVk3aldOenFKMnlEM3Uxa0I3WDIvVGZnNE1lUXVFamt1dGEwN25OeXdTZHpZWTBsOTRmZnZpc1h3Mmp1cGladjdjZFUxbmIvRzIvWDFsODhCbm9leWlwU1lsSkRkRWVqVkM5VGRnand4cnBXWTZrcGozRGhiUjROSWEyUisyMzNUcllmT2dFVnBwb3M2WlNtd25XSnlQUTVGTFgreGNtL2ZsbE9Ud3NSbVhxZWtBWXFTNWFwYUZsV2I5dFJhNG8zZUprT0FXVjNZNWN4M2QzSzEyTkkyRHNIalBpT2VmRHQ2VEcyekZsOVhFTGZNdlAwMnZhblhUa0c4cmo1dEN2MG1FdSt1WUxIM0JudjdFU0VRSXREVGExdDVyemhTZlh2T1lHUDI3bGdwalNhRnpjakU3OCtQcHpuT2RjbFdLYndTMjJPTklZVDBiSnRuNWVMVHF2QjIxeEZ1K1dqelV1U1Bqa010UUkrNEVMajNXcmJSbUl3cXphTkUzY1A2MEdHMFU4WmRBRXJSL05wMy9SSHBKeEdnRmJUaHVSZEt1R05PM1REOFFocnNoRy8yOTlDcjVrUkxITmNyalpuaklkdk5ET1Rwc0kwWkhBYitSR0tpQkdsZkFPSTROYUFwcVBGZ0czS0tOV1FZTm5kb25KR0JOeUlPdFE2TFoyekZSN2w3aUczamtLYTkrVStIb1Ixdi8xRVRqVmUxa2Q0bXdWTWJsbFhJMTJCR2srenZxUUl5MlhsS1dLV1pKU0s1cWZUY3YxeWVjQUl1Ry9PeTRab2JNa0EyVnZTd29qMDIrYlEydzU5SjVYRDdRUnF2enIrbHBPb0QvUHV0TTQzRmR0cnBzN2JuSjd0QjNmTXRVQnJOZ0VlOWh5OXVZRHU5NURiblVnSm1pSzVBYWt6QVdiblRONEZFZnc1SjNBMmNRSnNLOVZ0bXFtQXU5bXY1V21hQ0oyOGFuSmRldGZGRWpBNjgrSVA5bng5dWZyYUVoMjJMS05lbHNnY2tHcVVVcWhjdkhmanVlVUl0NlZUTzh5NDAyKzJMdk5COEhCelk4aVJOTDVGblRURm9HMWpzYWFka1lnTms4eDNIYVlqWlRJcnJLTTJldmk1bEV1MTgwK1hLeWZzRzJrZjM4aElaRlV0TGV4WUkvNUZPQngveCtDZXZrSGJIci9PZ3h4eE55NmJaV1FiOHRXaFZtaGs3akhadk5uNDNhaVF0SGJWUyt4MWUzT3BGNnNSSzAvdHF1RHRnNitjQ0NWc1drMllNbCs4MXZCenJuMDhFK1hURDAvNTh2azVPcU83TzRJaVhKdm9XbU1OS2FYQmY5TW1uS1RkWU1GMGtMQkIzN29DZjVUTVFKS21POHJCL1FtOFdkUnVUcmJiSTFybzZjaVFhb3hycFJrVncyVDRoZy81VVByYy9QMTMwdTdHUnUraDhFMUN1Mm11OUZ0RDB0NjVBNU10ZEJraHM1UjhPdEV6TTZPeUZNOU16Uk1DelBBaDkwcW1HZEpvWnl2WFlJMlczdGpWYXlZMTZuQkRlNlFCOEI1azNRMzRtMEZWYlNIMGw3ZTFOZlpwTUEvaS8rMit1eXZjTnNsZ3R5S2dZeXZIL08zQTBuNVh4TG8xcGlKQVEyYXlaa3QvcEpVNUZwVHJLaXJUWXFzY2xObW1GWVF5V2xva3JYYkgycGJscGVPQnM5UGxjeFBzdFRsSmcrbnRXT08wQ0JFWmZYd3hEQWJjaEU2dmswdE1iUG55eVJ4dmZXdmdvNG16c3dzdDZReEV5THl6Mm9xdFdaOXpabkJxc0lLMU82dkxUNS9LbDY5ZjZ2Umk3dDZNMVVwRzY5eEJtTEwvbnB1RHcyQUhYbTIyQTFsM2NYTnR0OG9qQzByOGJUZEJka0xCeDZ0ZzcyZCtVSjJPQXJwSGFmYkxxU0VWM0dXYmJ4N0IvZmc3Y0oxdmY0bHNkaGZ1UDJHcm1EOTBIMzByWi9pMXU0TUdrV1lRek10c2lveGFQejA5ZWNnbVRTVkt5dzVzRVA2RXdNeUhXalg3dE9SYU9VM1dyeitOQ2RaZ3ZBbHlRc211djl0Vk1udExTdjBDdmxmeXgxMlVoK3A1QzdiMTBTYnVMa0hyaXQ4bUhkNVVPcTNVN01sQ2R4VEUxdzgwTTQyV3lyVGFubVNXTXArdVV2NEpRTlJ1OG1tYmRvYVV6clpyWldhQTFydkYrOG5MbzgrYjNPUkIyZUVRTythSXUycEhnS3JTSGJFV3YvblVrdksrMFFvQUxROWl1SS9DTm9pZW1aUEo2c3FRajczRXFCcndhYVliNlhPeCt2VUxIa3Q2V2JWRy84c2dsUi9qbDEvVzg4dFhxazBhbjBXRVpLRk0wTGdjcnJXQ2RRajZOditEb0s2dHl6WTIyTWNJWXlyRm0yRkR6eHZObzFkaDd3THRQbGxybzVEb2FxeEJXaWhzUUkxeFdrWkRwOFRROTNtMlV6WDdEKzFkOGlIc2lIUkRHamtuakFaTUdSVXdxOE9QZXZmT2RDV1A1MDZmM3VZaE5MTktiNUZ5Zld0d1ozZ1F3K2lleFVPMDVuckNIZ0J0ZDBWRm1sazdDZnZKNEFyQlVvNnM2ZDVlK3NKNjhqWGdOc0Zad3g1UXYwNCtLVTVwSlRFQklTdXMxUURtQmJnQ1NFemx4U2JsQ3B4N1RWL05NSnA1VUNCQk4wVFdsc3FKdFgycTRkUGQ0bXl6TjZGajVINzBSWjBONTY0Mkhzbnd1NzI0dWR0ZzBiVWNUZWQzYUxQMzUreWJOcmsxQUtObk9MVzBHaVBXZVBtWDUveHFOQVZLV1pteWtvREhSUk5XN3krWGtRQ0xJUk9xYVNHWUZER1BMSWIrdlZkelNPUnFwZ3l6QTNHR1FuQ3UxU2F2NndSeHNsZ3NrOGFzMXZVQ0V3V2paTmtBZ1owcXVZV1NXWWV4elFjaGtwblpha2JSN0Zxc2VWUmVxbnNwMC9tWCtxQ3Y1ejk4WG5ndXozcndlczFpQ24vNXFyTkQvdnl5TWxhbHpKRVpCWmN2bDFwVkFtcFErSzR4SGIxZXZ1ZlAxTDRKdjUzbStsdnFSTDQrbWFUV1BUeVEwTFM3Wk84UHIxSFZveXBCTTF2eHp2blg5aFh6OWsyVzlzc2U3SUhmZVRLeTVadGJ0MzIwdnNBV2h0UXBSTzNTdEYvaC9sMEZkVHZrMjRhaXFBQ1lpYk9weW9zTkIwMXJ4NXZmVlNJc2FtV3lXaE1WQm1SMmVVWVh4R2l3VnJSckFHN3d3Y2RaM3Q1WWFrVVFjZTladUhjMmo2dEhBNDVyRU4zMnByMTJqZnVHMHVxSlZyc2UxWXdObWJDWEFZRTVHVTJINVlPa2wzdmwwS2ZYR2RyTXQwZkRnaURKVG1STFpqNTQxTnB0eUNtem9xb3BpVlBkaDRVM2w5dys3czJiSml3QWI0VDFHNHFjZWpQQ2JISWhWeEtxY3F3eTgvTnFZZm1Tb0ljWHU5WTFwcGwyV1dYdWlTL0xKVHlVM3Z4VUtQbmw1MURWRkQySXVGTVh4aGFsbmtLM2Z3RHFHREkxS0pNZkQzVHZGdXZyK0ZlOXBsd0cyaXE3Z1FWemkzdzYxS2RkdU5UK1RCVzZMdmU5Qlp3RXZXV2pnZ3pwejFwWVkzUGJWQXE5amNNK0kyaHpaN1dlbHJQWGplODM4ZmgrUS82d09SS0Z4WmhabDM2aW5PT0tZdGJIczJRMCtaTUxCM0lOcUZtUm96d3pzNVk4TEdzeUp4cWF3R0pyTWVuK3lxTTNQdWdZdkFpQzkwN0M0SFcvMmphNW1jZ1NXMk8wYS9WR083UmpLcW05UDJ4Yk5zT1dZRlRYTUE2ZGZoWlVmOHhZa09ZbUhyVFV5b1kwNlZlb1RObHhhclZiTWxKVUlXLzh3ZjB5UVJtQkxKTXVLbHd4Tnl3MWVmKzJTNUlkRklHSFY1UWFMTGorVGJnRUtRMWxuclJXdWFXcWVhNDVtVTVsUmNHemd5d0ZzZFlWSWVIemtwTmIxRXZOSHJLQWxETEw5Y3ZYeVpYRlNHUkgrK3ozZTcyYVozVzE4V0dVTkJ5ODMyWDJoVjR6RjNnbmhlMWZZTGFFNWtOaVpCZEdjVGNTY3AvZmphMU4rOXoxemZhdklCaGRXYlAzV2orVUFMMzNUN0JodUoxSFVWcFAxa0p1YlU1akkxUnV3eFQreGdYTUd3c3ppOUc1SUN0WUFPV0tVRGpOVzRvb2V4eE1BOHpyb0p3UytpYlg3QlV0Rk0yOFQxWmFrYitGS0x3bmFOa2hJZUx1M2RuOXZsdUQvblVxeDRGYTM2L2YySnh1eDVkQXJ4VjlnSTEwVWNveWFoZ2JOUitDcWRwSkYrL2QxTnIvRHQ4NitJTkhPN21PMlpZSGNxeEVKWkdadSs1Z2xBQnl6MENaVDg4eDUrY1kyMVBMUVNMM0hHa0plZHRNN1dEK20zQ3dUZ3RSanovdDgycXF1aEltNVhVMjJCUXZUUE9UTFY4cE04OTEvWncrVXhHWEZsalp0UTJKOHZVYWs3SEY1bTVEZ3RmcjZ0VWEyTEVsMmhCWDMyWFl2NXY3OE02V2R1ZTczV1BkOW84MHRNZ0g1bXh2eVd4bW1maHdBMkcvbmdmTTd2V2UzOTljc2phOVBDUUwwSnFaemRpekg5a2JYTElON1BTaGNQU2pmbDNuWXRQZDJpRldTUURWQ01XVnB4RXdDa3BKbGsxbE9rN0VWdTM3VUlkS3BCVWY0bnBycXUraExhRGVxR0MwVDFyMjlMS2I1L2pXN1FaSHpZSzhrZlY3RjN6endPTkF3dHJFUXIwYlRsb1ArMm1veWV2U2tkSWsycnFEK1hscEEySzkzcmZiMzJ0R1JMMk5VY0VPQXdyeVZyQnpLS1ZoNWZSWTBxNGxlNVlyV052ODUrNG52YzZkamh0eFhyOTlaR3Q3VmhvYUtUQlJhdHFjdG9Zb20rdTE1alEvUHZ6eUJYUmlxWEUxaDJwZHI4YVNpbXlLVExJOGh5T2g5UjdHUEM1eU8zVDZydlBiRGY4Y21HNStuODdxL2dUbTNmRytTNXpNVy9kK0d5OXdMNy9KZlFUWmI1b2N0cTZlbjdQdktXOGNhWXBDbDlSc1pSL1lkTjkzQ1htYjdJMko1cERZVWJCbTJlR1E2dG1tdURFaC84d1NlbmRoV2NkVlpiaTUwUXltRUl1YzFyUnYyUlJ3SGEwNDRsMTdSZERQb0dpSmQ5NlV1K3BTeFYzT25idzF1bzg4OTMxbGE3TWo3UmFjdlJId1NneXpuejdaMytKc281a09teDZnOTIyeU0zUnlMWGU0OTdBdDF1dkxTbHM3SWxHV1FseUxlNnhBUk1QYzlxWVp1L3VpWFpib1NnM3JQWThTVU5JZDFxeWFjZmV5RXBudzRwcHp6WktaUmlVSTE2c0VvTHR4NTZDY29xTjVqa3VyZngyeEtxMndDU0Y3Smg4TkJiQ2xUR1hpTkw4QVJMMnVOREpScTdrNU5TVEF0SEtoclRWUnJWa290M2NvKy9yTnUxTDBNRGNUMVVYcmUzalZkeEJ6M29wRGU2UDdZZWFLbzBWMEI2VHgvb1Rncld5Sng3MzgxWThucFdnb2t6WlN1dGxEdm5jcEc4MlJMYm03eFlpMXVUVkJnMmZZNXJsc0VkcW1MZTN3dlFVcThLTTJZRnZDS1ZpQldGUEJVdURPckhRdDdVYmJXcUtrRHo5eTdHTWVtZm9HMHVKQVRkeTVqeHBERSsxK2pPTVpiR09kYjhmSUlUditWUUhEWXpNU2gyQnZSQXMrM3k2Y2grYmtEbnZybTN6VERIR0Q0SUJtTlM0dnRhQVBUQ1VMV0Q2ZkhndHlDQms0VnI2WnQ4MGtzL1c5YThSTmpiWGhRN3pBa01mM1lEQ3hyQ25JcmM3NStZV29vcFF5ZjhpSVBMSytlQmRYM1g5MUcrYlNWL0k2RUFxVVlyR3NzRlZUcVJVc0ZST1dHancvNkpmcnRVYWJvUlRuWkt6Q1RHOURXMnN5bGJJYTEzQ2thRzFRZlh2dk9wUk50OUxFTVRNYnFybmZkb2JwZmdXL09vRmx6cnZRVzk3dUFYeE5JdHNVUVBoQVhzc1dtVTFrUm01K2xOLzZUOU1FdHpkRDI4Mmp0UUk4ZDUxd0M5UExnMXBlZjVZMGV0eEFKWkJPb3RiK3pLS2lrZWxoRG9ZTW9Ia0FCMVRteUtVWmR5VU94RlRDV29uWHNQZG9McGt1OHI5dDgxT0hpQXJzNkxuT0ZCdG1OYndaRVMxdTUxbWlRUU8wWWM3YUdHcm52bS9KREFEU2JIRG9STklRYXhYWkdWU1FCYTFXczRIdnJSaWUwTTNYM3IySjJWUEE3bFNEMkdsOGplcS92U1c5UU02bWRiSDQ4dlZzaTNmVHdDbHFkNWJ1Zi80WS9qTjZBdDZscFBkeXBmVDJiN2dqcnF2UDE5bE0xVkNxb0xoR2VUaGYvdlFGRXpQa0RVZHZvQkJ0cG8ycGZVSXJXRU1JT3ltVnRFTUs2QmhsNlZDeUNpaGRMZElhaTRhV2R0L3NXaUNZTjRJN0lEdVdTRGRDeDhPQ0c3K3VVYW1qUXE5RlNMTnZJOUU3UkFrRGgwOVQzTEN3RGEyUzZVMENhRzJFc0NGeU5xQzROM0dnWG5xbnpIQkwyTmhjdi9jbjdwWmwweVdHQmpHelR2M0hMVFJ6TXdZc1VpaWdLUVBHZ0RMcGdRTnFRbnhsQ1U1c3pMcmVWK2xPdmdEY21WT09USWxVd0F0S2pWd25RNlZSRlFXQkNjeUNkR2VrRE5hK3RhYkQ5MngxaVkyd0JMU1pxOUtJbEthbU9pdXQ0cWNHR0NjMlZjSndEUUc3clhEM2VQdiszTlRtMm8xdk9rd01OdHlGb3BTaElncTVNeUJxYTRlM2lseklaTE5vQzJvU1JOS0lxSlpmbHlrdkZuUkRpS3VRUGoyV1N6bEhEdmVJV3UycWxDWlZCWkp0NmxvMThxUjlhSkVGbWpGTGhvd1prOFNhNVlSbVd0TGxWSWlVUFYvWDZSSEpDUUV6NDJwUUl0Y2ZGNXhzaWJLMG9HMVlxRGhTYTZ2OWNaMW5MSUpIQS8wZ3VzVm5IbExoWmEwb3FPZFlhb29XcTZaQ1hYWGhkYW51SFltWko0ZUNmbTFkTWJVa0NrVVUzWUFpUHJnTTZoRGJkaU0xM0JmSW05M0w3NVEvRDNqc3pXQnRWNjdkMTJtYkdnaHFNTW1lb21LMkp5RGV0eGp1bVArL3NXaldiY0hnUm11aGh4c0FnZzFoUGZSWTl3M1lmWjc5bS9Sbzk3UzBMZ283cDRVSVp0L3lHclVTcHVhMVY0K1IyOGtaVU5kUDhpWmVrcnluTW83RU1WRk00cU5nNUEvYmNxTXBwZTA5WVZjaTh4WDVxdjNFNk5wckhzSG9QV0srWFlRVFdwYXFqcnR2R0FIUXB0TkRWWVBTY010MWJiVkNsWkp5T0tuVzQzclZ6YUVrTEMzMnFKRXNmUElscmJBb1Bsa2JyVS9wWjF2UzIzSUovdXFzNWs2NFdWUjVueEJsd2dpeEtWK3kwYlFweXJ2UmdRZlRodVVXRFl3MTRJS1Z5eXBxa2ltWFpDbE1XcWFvbCtJcXhuTHRGVlgwbVZ2cFFacDVXRFNiVGU1MmdXN2RwRGU3dHRzQzFrMkkyWGVMTzE0djRIRTN4Sy9DOVFBQUlBQkpSRUZVTzU3Wlk3TTVXcDRTQm1QcDJSZWJWZ04yaTN6WDhZM1QzYjcwUFovdjF0ZmZMQ05TN1dkUTZkM2Q3cGlXait2NkJnVDdEYkhsOXo4NmJWZUxaai94eUFncHh5UyswaVRKQmxza2J5anJlOEpmYnBxNnd4cDhrd0YyYTRQVTY4OC9ERUo4MTFDbVEwTGVhT2tPU0FTMm9DUWRRWlhqV2R1KzQyWFhBRGI3dy9WbGJSR0VFSzFZQldFK25aNVZIYUpjbEdVT1Q2QmkrTnJjSWlMM01WRy80L1RYbjFYTkxKMjBpWmFyVWw0c0VwbVJGZkYwTGVkUzVkbktNMVdVTXAwOXJvVnR3eGpTWW5NRVFldHZib3VkVms1OVIvT09SbzJ4UldicnFVVW96ZDJ0UkYxWTV1dWFhcUFHUTlMOXF4SlIxdG9QSm1idis1WElRV3NFUHp5QkQycGg2dTBGUEhyRnVPTlZrZCsrSTcreGdMVy85am9ZeS9abWp3QjR0aHJPYzgrTUdJRTc5L3hoNHMrMzlkMExWYXk5VHV3MU9MMXZZWW5EVkhxQUFuVFR5dm1XQXZ5MTlNUnl3N2lpUTR0YWMwTlpPTEtyR28raE1aQmFGOWtPQ055TkpTcnBKcyt4RGI3ZW9FQUNkeW1DMHF1UkVqdnRsbTlPdlhTZ0MrYldZTkpZcm4zRGx3NzZJUERtWkZlWGdBaHF0Q3RtWGRPWUVzM016YW9NeXZYU3pSRnBIUk9xbS9DTnByWGRRVEtiVUVCN28wSm1CbDNtdVV4NGVaNFNJcFNWZ3VLeS9DRE9RazZoOXVUTm5mTmNjbEdDUlJweUVabEZrQ1BFcjBWVVdsVTBod1FQSnpCbFlNdDhKSndpSFN1S1JYV1hheFZjSVZEMGg0ZUxvZXE2THE3MkcwWTJtMDhKZGNHeXR2emVieXpmdDRVWHR4TEw0NDFTZjc2WlR2dVBQVnIrMkpSWHJRdk9rVkIyV3pHTE5ONEVkWU52VGJkMTF6WDljUHU2VmQ1MHpLR05BKzBRNmQzYTBhM1hCZWpmZFFKTDJXUmRYVG5ZM0UrMXNlTmsyL0lpQUpuTTBZdVBlNklQOXc2OWJoL2dJVnBFN3lrNDNtZ0xraCtkd0xwREZlMkN5VFlDSHZuQXVra002RkwrclJNekJvY2hOOUpTS2JQTVRQZkpnYWp0OUtxMlJFMmtWcklia0k1S1FyUld4SUVRSTIxamVtNTFVaUtCbEoybUVwbXN5QlNuNHFxWjJVUjcrNjVhSVhsS0s4cVVhN3VZOUV4WGFwMjJVTGZZTGhJdEZmallsUlFpbThHMUJXZXVWelJRYlpab3p1Y3Bzc0pnQUxKbXJkYXhyR01zV09Jd3FUc2V3ZS9sOWlidmlCaDNFNkxzRDl4dUgvUzNUNTZSaW5abkEzeDliOVFRNFhHZkNTdUhxbThmL3ByZmRxTGVVVmJpdSsvbzkzVnQ4dys2WlhUNzJSYm5hRnV1MnlhVDFYZVc2Ni9vaUV5bWdMVHVZTzk2UXV1NDZkZ1B5eVFrbWRCY3NOaDUvNGRtOUNDSXhGNWFrN2FqVTNUdjFzSEd4bm5iTGZaT2wrTXdtOXUwaTlwYXd0aitleWlkUi90QTI4ZnBXMU1TeklaU3hiTEttTUUwdG9oekduT3Q5YlRXQ2dwcjkvemVnTXNGWk8yOHZlTkhOS0Q5ck42aVk4b1phNTQrUGZ5c3FEV0ZCS2RUWHE2cmRGMWwyUWJoTGhGWmlTaXdUTGZSM0taUnNsT3M2aElRS0RLemdSM01pSXQwU0dJRm92WDUyb3lQZFRtN20zMmFxcVdDVUhwR0pMN1dTdjcvdmIxTmt4eEpraDJvVDlYY0l6S0JxdTRaenBMLy8wZnNtVGNlZHkvOEVGSldLRXZPTE1tWjd1bXVLZ0NaRWU2bStuaFFNM1AzaUVnZ2dWcXlSbHA2cW9ITWpJeHdNMVY5K2o0b1dyS3Iya0hkSlo5OE5ybmNQa2pnTFJEck1XUGpLQnM4RW96ZU13bmZIdUJtR1RFQ29ZK25EUjBlN3pPTUtGT21aRTBrRXcvNjlpM3ZnUWVlL2Z0YkJOeWliREJMdldIdCs1UmsyR1VBV20vL3ZtL2N2cS9BZzJzeGJGRlRocWVIRVNaOUZFR2hzYlgwcVE0YW5VZW1OUjBxWnJONTQwUHE5V0UrZW1TMkRyeEZsOW1qR0RzU1hUTkM1cFpCbWZHMWFBTDN0Q2hTMVUwYkVReTB3R0c2ZjdtR2hjZGthV3FCa3lRMytSSTFZQ28yQXZieU5Ya2ppWnNFRkJIN08wVkYwM1JqZFBzZ0pybXVWdzBWOGRWdDhxZ2VsS2dTcnhYRk5iOFFDV2RCL0h5NkxMUlNkODNwNlVQMTdqZ09yc05Fako1M1JiUDJ5bHprQ0hZamR6UHc1NU5jcDlPRWxSUUh6SjJxY3IwR0ZZQmFvTHRFNVlrdC9Dck0rTENGZm54dytmdjhGeDhkNEdSODM3cjRINS9BNkpockxrbGpHR1kzWGhTK01XQisxd3ZITFRZSERBZXk1Z0dOOWdBRzlyRGdqN2ZRQ0FsTGcvS1VjalFZVWJzdEFiZCtvUEZVa0F1TEZsNHBSMnBGRUR4YUVIRTBMdmNuV1BadWdROC9mSHlsaGVZdTYwaUhLbVZNdngzbW9oRHNlK3ZDb0trMWVlY0FacUNxd3ZDNHBQOXFxakZVNVJTQzBESzlWaGNGWkVKZmhtWVQ2SDFGa0hOdUhQRjNKdmVtdlhHcUVqSk44R1ZaUG9CME55dk5pU1BBeFdGQmhBQ0t0WVVsZXBucVMzMHFkU3pMQTlOVHZXYk1LR0dNeUNRRzdodElOQ3NPcEVsbmVvdGdGbnVlbGxpZEZ4Q2tLTllxeFdTcHhWUjlMSFE1N3FpU2FkYW1Jc0lxdWE5VU0zamE5SGJtOHNZR0hBNmdTUktNamJtMXdmOURKVCtrQWw4WDVZdlFicjB0b1NiaFErMnl0WlFHb1h1WDIxZ05teTFxOWl1aFRiZExaYWdhNllQenV1TjBwWWtJdDVyTUErcit0ZnlUdEJwU05IOXFGcS9VaVZKU0l4ZkZpZ21qS2lQRWdHQ1FJWjRwYk1taEhTZ29ieGxvN1hXMHZXemJqSUZoVUVYQzNoQVBQMDJlWmxab1F2bjJkU0ZuZWxTelpoNUxYb2VmWkJhQnh1N0gxRkFmeTJ0ejg5WGU5TW9naUNySGhjOEJHUXJaRVFjQTRKYjgwZkhSYlUwUm94Zks3K3JiNzQwTXRzNC9YSlVRTlZzeWRRbXVTa3l5VkVRbHNCQkZWVVhtY01ja0Z6VUp3V3h3OTlSRlpuazFFZEpiQ2pDcDBaOU1SZnFXKzlxQ1NCaHFRbk5ZL1VUOWFRYldBTVJNUXJVNEZqbTlYazhyUk9ndWFpWjFnY2F2UmFmclJkYkdFQVFuOWI4UTNyM2lTZ2tQaDBVMEk0eW1ySUpFdGROSlA2L2x4THFXYXhTK1VsNC9yNWd1bHJDbFZESGFXVitwQ0xMQVhRaFRjZTh0VHNrT0xlUVl1Qng2cy9ZY2RpTTlzTDZISTBTM3VNZDNvcm8zMzUvZi9qdVBabExzbnB2amVxdDVjNzlaUnZHalc1MDkrV1lYbTlDSnZEZS9FNDdMOFBkcFBjQWJ1UnB2WU9MYkxQanRSM2txbnhvSHQrTloySVVxNDI1WEpNUmdzTjF0enI3eUx0eWxBT0dXTTc5encrbGVJSHlqbUEvdWRScm1XOHZwNnkreUZKRDBaVmtUc3l4cUNBRXFDZk9lMkJGU2tsWW1BZXN4V1ZCaFlMT1JJTklKSkMxMk9sbExJMUhzREVFVGlwNCtHR0N4T29zVWh4OUJ6Sm9kZEZWS3FIK1o5cDFLQkk5SWdZb1ZrUWpmWjBsQllMR3lXRGlOUUFoaHIwdWRaME1WVDBhN1FiRld6TzRlWlVha3EzNUhZRVFLMndBL25DYWErZFhBWkhDak1la25HQng1VTlrTy9HanYzUFVOZDEwcU44Zkx0ODkzeTVqZWlDaTdnQlQxaDJzeGpFQmJlV2djLzlXVHRrVWpkc29oTzkxaUY2M1FOMnA0MXdYMTZBUnZPNDd0TzI2SWM0UnV2Zjhoc1NVYVB6RXdkcWtCSFI4aGRSZkl2VmxBY2FzTjN4aVpiczh2amdQeFRXdU9YVWpWbnVsekQ0cnB0cEx1d3FVVzE1UDdzQ0trY0wxZWx1VGtxWUlyekJaVnBkUzhmektKdkVSNklDblN4aFVLSHg5U1R3QlJCa1YxV0Y0cFRFc1JRbW9FVlY5OUVyVjZuWDFWbGFKUUU5Tk41Z1o2d3krZDA0ZjZSVWFJcDREaHc1R2srY2xBNXlMTE5UREVlQkFyaUZocEpTaEdqYUJvc1pENTZWeXJleUppWmtvdjVmbXlMQ3hQMU10SWgyd3R0TjZheGpYTkNIWWl3ZTdyT2FRVW82S3d4ODdqbGlLQjd5bkM0SU92U3gxdDl3bDhHRWVKWnZmTkRaKzZ5Zm9PUEx6cjVmdGY1UUZINDZqK25vejFGS3lOa1NLZEpFY3RwYndSNmZYbVJMNTVFemN5VW1NSGRsakxHOHh6MkU1VFJHcmFPS0U1a0VzTStlanU1V1BUQ1hPRHNJOHhtKzhzd1hwek1mTG1CTXNtUGVYbTZkNG9ITGYzR2pFZSthQkdpTG9PVm5JUTR0ZkxHcHJZUE9sQThTYmN5QnZQS2RvSUgyM0hwUkVVSnMxS3RLTm9ncjc1YTNwR0xKTktoRUpJSjRERkZ3dEdOY2RrNHZ3QXlyVHFiamtnWXVwOEx1djE5TGV1bC8xNmFyZDJDWUlNbFpBSnNXTFVBRmFncEh3VEUwSlVZNlZPWlRhWkozSHY0NTZyNkdrK25VNWZXRThueGtKbWltaTdIa3NDWXNlczhpM0JPMFdDZStYSjNxbWhpekovVDRBSTNySjg3NTRnMzFyU0lqK1N4cG5leGFneDZQZDdiUTdiMUs1RC9MNEtmT3dQSWJYRk1BZXBxbVJLVkZvZ0FiOURKNzNmbytPNGNPK2JGN0NaNTBWVTIybkVPNitsT2Y5cWlDVC9UOXVzdmRYR3pRNWg2SVM1aCtPUGE4cXZJSHozamllNHMwWWFGS0Z0eXRpdHBZNmNvQzN0c1JtZGpQcVFyWGtJb2JGZVYrK0JJUUt6cWF4N1grcmtURU9ZbUczemc2ZWpwVFRCR3RvTndFd2xQSkJtZDZxcUVTdnFLWDF1UmVraGhDMHhmWmpXcTg4YU5zMUYxNDBRcHlUNXMzeFppREpmZG84dFZJWXNNYkkxaDN1bzdMUmVFckdhRlpOTFNORzFBZ3hSeE5VbTgyWDFvaDRnYUF5ZFRaZjU1S3Noa083MDRiSzEwQ0xRbzIzcUpzZkQxdVAyeFBMUjBXYittRFUxQWJzRDhIZlhOcnhoK2Q2NUMyLzg0ZTdHcCtQZW0wZkNKZUxoZ1c5T2UvSWpoczNOUEpzUU1qUjYxbDEzcTk1MWljMXBhaFA2OG5zcThJR1B4TkY5dHY3SXQ2aDVqSGlKL2lreFJGQ1ZsdGFnMU5nZDRPUVNEam9xZkU5VDI2SFIrS1pUQ1I3NGJ2RG1BdDVWWU5uMDJ2TFl4WWhiaW9hMkE2aEtwRXJRUmRUQ1g1dGNBaWF3VWhTT29BU0hsMHdEajFoeU9TUWhDTGN5TDZTSW1hMk1nQUJtY3hHdjFmTmI0ZU9FdFVwb29LMW1Fc01WaHM2VGs1K05UMXJLY0xWMGdCNFVxNVRyWCt5NnF6YVJJcEE5bzFETjA4SzRUVllwczNHM3lSRWhFRlo2TFFVcjFJcEVzV2oyUkVCSXpMS2M5VHdKWVUvdWxWSEhiVkQ4NWlhTVhwVTZZaVZqQVptcm5qNEN0dzhsa1BSNlBzSlczbG1CM3lBNVprRExWeWRna2NoVEFqMnVzUVdNQ3I0eEErOUFyQWNFaG0rZjRNNDljSWgycmhBWmdxVHlOV3RvOUxmdnUvQXliakRZd0xKNkY0clIra1RnRWZFeFhUakZBNkpxcHBDSmlGMCtUYjVLOUZsNDYzWjFVekc4eFgxK1dJSjVzNmJDUXhCck5OR3lMWkx1NmpkMkV0M21hS2ZxbTN1RDJucjlvdWJDVUdpRWxSSlZ4UmtNem94dTNVd0FXbExVSUE2QWVuNzZKVHhFdElSM0V6OEhLTFppVWdoWkprV1BJUU1ab3NEcWdoTGhHaWhyQ3VZMkxyeVpDbUVYcC9tbll0c3NINGQxU3NZTVdwazFIWWVqa1FhcGlDcU1nSElOaDVBeW5ibWNpcFpDOTg4UklaQmdrZFZsc2k4Ly95d1ZpcysrTEpWajJTMGw3ZzBFZCtNYWVOaDVZbkJaeDVZelJsN1BqeDFnR1pETnc5YjFKblgzd2F3NDVORTNzM3k2Wkx3bG91bU1yZS9YNWU0NG5RU2xFTkhUTUVVWTgraFVEcGpRd0RpKy9mMTMwdEZHdlVLWE4yVW1xaUR6a1VEY0UweTY0S2lxQ1JVb0lIYllRR05NRTlTdHpkOVRWWEhUQXI4WGhLWTh1QkM1bzROUTdqZjZPSUJZWGNnSkFLalFORTFzM1lNUmlxaFhpNmJmOGRCSjZuSU85NHdjeVdOdXFmdFhheCtKbTBMMC9PRkxqVTRVaWVTU1I0VUk2anhOaUZwL1BaZnF3b0RTTkJqelpMNHNSRm5yVlJ5VEtvdlNSMHMzMlN3ZXFwK2g4N0xHMDlyK3hJSytoM1F6T3NYc3lUT1h1MXNmdWtMVzZnNVJMaFdUS2UxMGpzc01Tc0YxemQ5S1VJdXl4ano5MC9TenJaeUtWNGlFZFl4RlNvWHVkYzhDQ1FJbTNxZzdzYlVNMnFhTllGQzBhYTg2Mlc3ayt3N0taZnQveVllVVJIWS82QnVGY0xOQ1Fibkp3R3ZFaEVSWkpacGJEQVlCN3dyQUk3WDBXWmtMcE9tTDJSYVNLdWswSHhTN3R0emEyeWZVSDVUcmZjTzNaUjQzcGs4M1doUlJ0V2pNRXpVd0tUZ3g2ZXFxR1ZRUjNMZWVyWnZpSGFHbDR4eVpDMkFSUVMwQTZJMmlaQktMKzFRYUM2em5Nby9YVDZFRnZaaUtTODlpeUtzL3FGQXFHU29hM2Q1bXUxM3FtRGs3UVNRUFZtMWRmYlNuc3ZUM2k0UjJFYVZzejBzam1GQWpJcExVbis2N0dkNHJ1eWN1UDJlazk3czNUS2Fsb29ocGNzWE9pL3ZMbi82OEdPa3N4WXJWV0thb3F4Qkt5Z3NVWUlTcm1lWUlFVFdncmtKZnZyQ0VpSEpkTlZWOFJnT3JBR1dhZEwxV3FSU1p6bkdCSU1nUUxxRFA1K2t2QlNLVFVlYXpmTDZnZ2tJenMxREdhLzNqLy9IODIyODg4L0twbW9rSGpJRGwrOVhVUnhHQkVuVmg5UWhhTWE1K252VVNqc2xNb3dTanNDNnp4QmY3K0hlMlhsNktJbDVLaVpWV3VFU295TXcvTGY5eSt2S2J4dUpGVmplMG5JdWlPMUJueDVuRnJ0VDBtMFFrSk1xbU9McjFxanhTZVBnTmNSTyt0dk1GRGgzZWU3N3dicjJVM291N21RNEVhRllRenQ4ZGVZS2pOSkVRcUVIYkJwQ01samVqMm9OMTN5cG5iMk4weENPdzZQaHYzckRndUhrUFE2REpJYVlNMVgxUDhFbTFlK1pheWVZTWVkT04zNjU1SG9OODVEMS9kcmVHaW9qZzNzaHd4ODlpWjlJbGFaaENpalgwbU0zdExHUEFCVFdBZWwwMUVXYVJSY2x3TWQvV25kbG5OM3NIUklaYktqM29pK1FtaVVLSmNCR0lDMkhUUk1pNnJDdi90dmcxVnAzV3RqMTJDQjF1RUs0MVdHYUVxcG1leEJsQ0R5OWlJbXRRVnNicTNXODhEZ3NUWkdNZmtDczluRnZvWVdXMGV6L2ZrRk9Sa0hwZDU5UDVkUTJ2UlNnbVprS0JJWllsS09XMVRtY1BRR2VwYlkxWklEY3lHNHdBd29ORVg2VW54RHcrVnJ2V0QwMG1mZEFYUDJ6Qkh2MHB0bHpnaDl0STNPU0x2dkdQNXJPNjVSTTMzVW14SWg1c3NWVDNGZmQ3dUo4WS9QREVOUlcxcHlvUG9YYi9PUmdMcys5bzFvK1JIUWRibGk1VzZLWnB1R21tKzJZb2tIUkw5amVnbVM5YVgzZmNVTnNWajBlaEExTXJrd3QyclRNZmo4ek1aNFlQVUcwT2tlaklVd29SWVJuRzFKdnZaY3JuQ3RiUFYxc2pDRERxckhTbytmSDFRTEVGN3ltaEtrSElzczZlVjRLTE1JRWlkNWlWcCtWMVdVUDVkTktYTDFXVk9aK3dJbVdjWWlLMWxsSllDMVRrekJwVlFqVDhOT3ZrYnRPNkJPWmw5Sjg5RElqZDZockNtbzJySUpJWnRqYUY4eGJ4cUVvVFZselBUL1UxZkoyY1Vrd1RsZU5sbVpmMXM2NkM2NXEyQU1yOFpRdHV4RDZkb001ZVNHOVlGVHlJVlhpUEdXOEJxL2hhNGVVYnRyVVllUGNPdzd6bkhiMG5VaWh1Z2xIVlRBZ3pJY2pTNWdiLzRmT3I3ZjF2VnkvVUVHTTZEbXl5S1d5bkY5K3pUVHBVdFoyYnpXNEhMeU9oSEh0TWY3ZWNjVkE1RXZra3lYUGQ0VXFURHJLWExWbHJ5UFZCQmQ2LytOaFY0SzExNXFGdjJ2U25PZ3lCS1R0Y2ppTFdyaDl2bDMxUEt0eFJjaTBwWmVxWGwzcUtpSlFobThucXlTVGR4Tjh0eWtRb0Jjb1FvVGxoY0Y5YWFnWUJnODVsOHV1MXJseWZHYlNKOGpJOVczeGFyR3MvSFVxSVFtRWljbnFXdFVLOU52V3V3S0RsZWFMWDhvRlJpM202RGgxekN6Qk9UVFpDZ0tnU1VkdnpSOHExVzBVUnhlWUp2NjNMNjFVekxVaUxzdEtoNnhwbmtBRzExV3ZRMDFJS0NoVGwwV09qell0ZDNMSzFhaU41Ym1NbDhINEhnRTZjMHBzTXBNY0grZjRrWXJCcXh3L2duUWIxSGVlQU4vN1RKTlFLeEJWOXdjeXY5L2p2S01HOWpHZ3E4ckJUekdtYTNmUWZCcnhWZjc4YWE3MnhJRWtHZExPejc0YS9aYytGbG4yZWJwdUpRZXFPYTlxWjZkSHVIa05EVG8rc21ydlUxdkY5MjJjeXNxMmFzaWp1ZzZIYm93THRVL0xPSVBqZ3V6eW84eHRGdWd1L2RVUWVncGZQYTNOUVVyQk1GalhMVy9mYjZYTktvdkhwcnlzQWJJTDJPTEhFZXhEK2JJS1hkY1ZQMXlxbWpNdGtJRFBwbWJsWjBlUjBUb2dhUGdraEVYeHBJNHNDYWxNRW43aStBakxSU2RLbmd6VTltcGRhdml5RmFOVUd2clNaUHpxTmtaZ21NL3NvWHo1Zno0bmRRRnNjS2lKV0YxZXltbFVQZGhkVVJjR2QyalpYWUxKUGJjc2JGNXRnR0lOOWQxZ2diL25JMzB6RnhSdHJDbXhpRFl4TWhwdFcvRDJWN0c3VDJLa0JRUVlCeDljTkRONkJGbmV3UldDbUk2NW5nRkFnQ0VTZ0NldDM0WlB2YnFCMzU0cmJkaGpZL0dvS21ZTFNBK2pXWTJFYmV3c1F6ZE8zMlpva2t0c2VoRzJVYUk3ZmVJUk5VQjZFSlcvU3dEdURXZTR1M2VoZlBwNGZOUDA0MHp4V1JoN1lXQlFEWnRyeWc0dSsvUFZUNkNwQ1ZhT1lkcjFhaE1DNlNXWVhMNDBYWjBtOExBRnQ4Y1FxWHFzOFVhMTQrSXVIaEFlbjVWZTVlcG12UGRGRmk1Qyt1QmxRMStWdnFwb1FaVUhHV1Rpd1hvQ0FSYXcxVkNPdGJiYXRaNzRmeG9SRitybXBXbFNLaGllanFydWVZSEtkSm1IODdOZEFTeHdnWVVaU2RKSnJLOVJQSGs3dEthcEFhUWR4YTQwMDNWTDFoay9mVTNPNEg4R09LbUFaRkIvMkZjVGJzMVFYcXVBUmlEVUNoM2kzZ0JpaTIyL053RzBQNXR1LzAxUHZIczYwWHZ3OVlXUGRIbzRpb2xhME5rbWphRkpxK2wvelpobENmTjhFZkp2RzJyVFJZNUwxelYxWUVYZlJSUkp0L21WVE5FUzdVNjJWdXVhbkZyUk1vRDAyQkkvc0hMb0cvOGJSbkxzaDUvZ2I4bWlVZE1BOU41SjRxOERhQjVIMkNHVHlpeG8xbjRhQzVaOS9GWDJ4TEV5ZU11RlU0NmtWVzd1TXRJVU9Wek5LV3VESENoRlZrRlJkQ3hRZVhCRXVhdmFxUWljd3JkZk1PbWh0UTVtSzFEVWdZcE1zcjVkUGZncXVZZEc4TW1OV2Y0a1p2dGFYQzRyVkdtRks3WHU1RE1ZU1FZUno1KzlVSmt0MkpXTWpBMllWVllzUUxyV3d4bG1LRVlFaTBCVXlUd0trSVlFcVdkb2VQYW1VeDBJMGNsdmtlRVN0cFdEZ3E4M2ZSdDNuYllyWlc1UHExd2crZlBDMzhONEc5MGdWeUhWR3hBbU1FTlhTVmRRL2ZJQmI1WUVBYWhyUlUzRHlka2tVbWhKTjJQVWpuQzk1UzgyTTNrUzNRZHUyQ3RvckFFY0NTbmRlenE4cU95b0w2YmwyVVJ3c2RmQ1YzM2xIUTk5dmRCOGJJekIzanRqNTZ0eWE1cG5zZ0xTZDJ3U2JRcmZMOGhUTDU5ZG5XWjVFUkRVUUZjM1RHckJwdHZVSTlzRjMyVVRleEE4VXdZcGlKYUlsQzZuVW9oUk1Fenhtdy9veXQ3ZXFtRXJFaWhQSzgxUzUvaVk4UzNYTWFLYkRwalZzc3FWY1g5ZnphZjRsNDVYWk9xOWR6eGd1a3I3VkFzaDUxbG9UWmQ2WXZCU3BOWWtybjY0eThXcEtsUWlCMWZDZ1lWNFFUZ0VqVzQ3T3VVY0ppZ29NTFllWGs1Q2lodHBtWFd1V3o4cE5YOEtXL1BaQWx6YnlmNjJoR3hpMlpGc0FpZ2hRSUZFRER6NXo1b0dRelN3Smd5dEVRY3UxNDdhU2FNNURJcVpEZ0N5WkhCVGptZkhjWVNLQ0ZBVEI3TkJlUE5KRnV1MXJXZ3p6M28xVDlwQzRqbUJvVU54ZHFRSTZLOHhyaUxKNTFQUlNaT0dib2Vod2NtUkxlbzZCMElJQzB5SEFIdW93Q3daQlhtZlRmR0kzL1NURGUyTEJwdVBaT2dPU0lTZGsvc1RVSTBmUUpNM1o0Sm1ESWRUV3pBbjdETGNEclVESm1NeWdTRzMvc3pjMHdoc1FlUFJMeDZDTzFpWTNickdvaVAybzFGVklpVEdPZlZ1K0wxQ0Y4T1RNKytVdi83aGd3ZE9pQll1WEtXMUtZS1d1RHBSWjZPbFVFb0dpRW9iSWlZV2syR21hTGk5dUp1dFRmY0ZVVkhCNWNTc1NzOUFNcUpnWU5SZ1JnV0tpWHZUTHE1eXQxT3NIdyttUDVTKy9mcDVSNXV2TWRYNnV2NVZGWlpwS21XT1YyZnkxaW9sSitLeEtUemNORllxOHRqaXFmbjM1SXI2R2xaSmhiR0dwUm83WFAvNWtja0pnY1phWmJnRTFZWDE2V1luNkVxK0NhZEphbzE0RDFhYSs2Q2hkQjhCSEswQytNVnZ5MXVaMUU1Smd5OGg1c0RZNjVNM3lmVVdaOTdGTjkwdXNiMUgrUnBzWDNCdC9NS0pabkh3L0dwMjFEd0o0RXBQSHVXbzcxdVBzanJkbjk1R0srN2pvYWVRMkppR2RHL0l4YnBuVFd4SnY4M1RaRU9qZERONEJwdmF4RFQ0ZVlyZW5HMTZna3NMK0lXUGJiVXdlRUhRb1lFT3o3L2ZDdDh5Ny9aRnYwWTdOMmtIUmFJa0tTdURsY3kyb3E5eElRSmNJTXR5N0JpVEczYUF0dkV1SVVxWW5pVlVrZ2piUll5clFqSFRzMnAxdXJ0T3VrYXJUREkxNVdzUVhQVUY5K29sMHdXbWlUYWV5Um9HbzBzdmw5Zk55U2dTekJRa0VCWml3Zjk1M2hTNHljdGpiRG9CS3VpaWV6eE1Jd013RjVxeHFzOFo2RmN4Z1hidzAwY3l5cmpRdFNEQld0ZVM4MXBLUXNlVUc3TGdhNExIRzNrWUpiUlJka1EyRzVsSGRkNXRDK05ZbTZCdm5keGRRZUVCSDhUWENSVXE5bTNPSVlJdHJ5VUVRMzUwTTAzRFl0TzhtcFhiYjhURTNFQkJsR2c3S2podno4S0lZSVdIYlNUK3NhNVJrQk1WTWo2QlMwbXZiK2dTNzNFK0lRNmhFVmdKb1VxQ3hFV3lpZlU3Vy9pZmI0TzJENTA2RHRMaTJEV3ZzOTlBUFB5NXVTZDY4di9qN0YrdnhFeHF6Y004ZVUxVkFHS3NWSVVTV1h6LzVWR3ZvRmtFdUlwU1ZCS05tNmk1M252K1pIYk8xY01nTTVaaFAvcktLZWJTTEpEb1J0emRmZ0FrcFdtWVA1UUxCdWJEV2FlWnJaYWhBVlZBV0FhYTVSRkU3RjR2cUt1SVVCQ1BWK3VsUTFuN1BuYTFiSWlTc0tLM2p0cWdzNVdsdXhzZ01WM0l0UVNsY0YzT21hU3dsR0JHMWVmQ29nb1JxQ1cwaGhMdG1sZnNGZ1pBUGtrQmtpLzdjQkFmWWtXTDhIbFE2YUZEZXBzcHpMMnE2bzNJOFFwNitScnZmYjZRaHpkMXhxQkdpVDdFL2hHSXBWS050TjVmVU9DVXEyRlRvK3hmTHg2YVlXMElxZG9sUHV3c3BlakpRUkRQNTM1K2c2QzNQQmgxZ3l3WVRTY04zMFVCbUlxV2pVeGRIWURPNzJmRm45cko3R1hxd1VJSVJzWUhoSk1rM2wvMjNuOXRHM0pCYit4UnNSRTlKQ3lLa0V6c1k5Q0toQnY3MXR5dmdZYmtmYW1ZK2JEWFdGeFZBb3B0R1pUNFVodXNQSlh4ZEE2THFxcUtJeXVvakpUZUJ4N3dJSTVOV0FuV0pFblZac0N6K1VXcWRTNVNwTHVwQ0o5Y1ZFOHFUTHIvVjZlOWsvZkppcXZTTWhZWnBYblJrcERYU0hqaHcxNkp0ZDgyb1RNMTJtVkdGb2ZCd01YbzkrZFZsS3ZBSUNiSFRRZ2hRcXdsRmtMblVtY3AyVDFiZUt2Q0FIbzhpZU82UWtySHdHRDZrM0FKdnZ0R0E4cDBsK0piR2NVZkYrc29QdzQ1bXQ5RzhlRUJsZmt5QXdkWlU1dmYzdk16eGdLZi9qU1lmeDRnLzRJMWJLcndjWW1ZelY4NTFwQ1h2cWJDeWViYUd0aEJHYU11VzRtYXRNNEpvV3VKQUM3cmE3R2UzR1lST3I2RXlYSjNZa2ZFalUydklQSG1YZ01GZHliMlRSZlRybzIra1lNaGJNc3hrL2ZPcmFGVE9GZEF0ZkpKaUZFaEVzL2tqV2xvZGV2SndUdFJyTEF3UkZTbFJZMkpjTFlJTXNIQUVkamRxcHlhSXNhelRxVnhkV2JsV1JqRmxtY1hiM3d1b1VFM1dQOW41cC9NaUVvcUFKNWhzNHQ0UkZlR2VkcHZoYmdGU0lSTGhrZFoxODJsS2VxdUZHZ1RLQlE0cWlHTG1TNytIR0NZcXF0SFYraWd0U0d2NDZQSVFJdkxBK29RYnM1Z0RmZHc4ZGpycjROWXZPT1M0WHVUYjUvY1Fzc1FiVC9Wb242N2ZGT0J2Qzg4aGgvR3VMOElnNzFUcVBxcWRZNnVHQ1FnRUVEME5Ec2NZbWdEZW9wNWg1eVZEdmFuQUhVMEh2UmExd3pYR0FHdmJBbUdyY0JoOWpCRGFGS29FTkZRSWRPUXdGeDJ4c1diUjNSRjJvZEJiR2pCRHdpTjZQb3J2VmNxM0k4c2JKTmpOQXdnM0hVZ245TExMSHNReWxWREVCS2JYMy83cEFsWlhiV0hCdVJYYktEazBCVW14RmorbkRjT0RqcGpnbE1NVVhsVlBTMlZxRGpiejYxRUcwdGswUXZEOFBFL2xxbVpPS3pPclRGTXN1YnEyYVE2dnNYNzVWT1FENXA4Ly9EZW5LTUxuSUNuaFUxUGEzRzQ1QW9yc3NudW9URWlaenVmSlE4VUptUkNpeHRkcG1pYUw2MDkyS3RkNnJTZUtLbFNyQ015UU5NKzAxR0VLVk5ySGVDUHdwQWpiWUQ5czFBZEZhTStDNXNEOG1qb0hkNDAzYmhsZjhvalV6QnRyQjdsYk93cjBCblRpVjF0b2dRaTgwUmtMR2Z1QnhDQS9STWhxb0VuMG5xVzA5cFpOcFpkT1MvdllVK2piZTdOeDdIaGJnWFZVZXE5dWUwL3ZqRFYxRHIwczkxaGtOMzlwT21rRUlFb1o0bURlV0kzeGlCTERkd2U0TFU2WTBUR2JhVDI1VVNyMVpnWitnRjFzZXpGc0tQOVdzWk5wb3UwQVkwQkRBQUFnQUVsRVFWVGY1dlpHYUtFVytmVGZmNkY3QUd2WE92Ujd3cnRwbkdxUXF0NXZ2RXhHbEZDb3dteEY1aWJtVldXa0tqWmlDUnNncnBSZ1NFaUV5dkpTcGpNKzZUeFZUZ0xVMStscC9qVy9xWnBHcmU0THlWaHFSZFN3eVZiNXVGd1pxcGtGR3ZjdFhock5ObDg2VVJOU3A2ZW5rd1lwYTFqbzVCVUY2OGtzU0V5UWVsM0R3RjBGaU9ndWRpZ0ptYXBHbXoyeFNjcDdFYzc1cDNPTE91cDhXQVBpMEJiM2hSTnV1YjFINXRaMzRiMEg3QmZRZDU3ZmNlSDNuQkdsTjBDcjI4OFMrK2pxNzVFanBUdzMyaVBSeFBLZHNNYzRqQkZOWFBDR2RnTzc5NjVyUVhxQUowTlVVaXEzbzB6MkVsb1Z5czRGMkd4OWh3bDhBaVhSMitxeG9JeWplbjdzamoxNW9mRE4wcmtGaGJkZzdqNUF2TkZDeFNZWVo2ZVM1SCtTV2hxM3NPellaK1JJYmxBVkJxZHNpS0ZRS2ZYTG55OGFLd3JYK2JBeklUMEp5NXJNWXQxY2pITFBDeGNGMWV4RkRTbENFaUYxdW1SdmN3QVpJWUJWRDBjd0psM2NmNXBPcnpIcmxkTTY2L29hejArL2tBeEhVYThlb2hLRXYzeSt5Q1IrK2pEVjZ3ZjFWZFFzaEVFUEZ0NW9BS0RodWNmTlBiZUhsbWt5QmxuWHFsckFBTXZIeVJkUk8xbjlzcnl1cDZkS1JvaEhZU0M0K3BRS0ZTbXBUWW5vMkYyemZPZUM3U2Jud0tUWU9mbHdFS0tiSXFvNTBLV25hWC9NZUppTlpQaUpTT2JKMnA3elBVWTlOUlU3b3k1VkRqYXRlY2hXVlVTbzZBN1liS2w3aDlhNkNMdC9ESlRoL2NPcVhkM1NHTE5yNjNPMHZiTHVVeHpwR293SCsrQXQxWTc1UUdRbVJGT1R0OSswUWxQOEtqQ1RpQ2tFRUk5dWF4SkRWNXdNSk1tWU9pVkNRMXhFUTZVSXJwb1owZk5hMXlsWnpjbjNiNkhJeUtCb01ZQTFMUjhDRkZoUUVReUV1RkJqQ25YelRRZytTcUhuVjgzajk0enVRWFU3ODhkbTZMVGI1NUtSQi9zNHJHVHF1NUVCYWxMQnFHd0pFTkJPdDBkV1NFaHRFc0tBT0dHbDY1cW40Tk4wdmZyWnFiRnFNZkgyMWdXZFFDbGNISlBZNmpwNVZIR3FncXQ1VUpIaFlNNVNUaGtySHQ1V1RZaFFzMjQwbTFacElhcWV6SEFWQ2RhTG5rcFJoTEh5VitocGZYMCt2MWJWZ01ZYTdpZXVlUEsvbnVQVlA2ckNOZnkzMEVKdnNhR3FpSFpnSEVaaDd2NE5LbEttU1dKeFo2ekZYei96YVg1OUZiT3FrNkhhTk5XWWlzeC9WK3R5NFd3cnlKb3U0OG5BRVMybWlDajZSam5FRzZocFpLUkZNeUhkNk8xTnFQYjdkYllaajRsMHJYK1F0ZFVNZmlsdlp1MjJyRmtCRkJvaGNTdGNmbnNIamU4amZOMVFFUGNCMkwzTjFTYXVpb2YrRmhnczdZRVpBRkFxY3pHRUpzZlA0Y1pYS3lFYXl1M3lFNFlEQ29KeFFDSDdTTnZnR1VvZ05MUVRoUnJhREdrbUUvNllDN2ZiL0xUZzdpRnEyVnI4UFhOczMyWUU0a0JONGs0VDNKenJnQjB4WlhOUGJMOGZSVTZMeU9XdnY3eEV0M3RNZmlKVm00dENTQW1IMGFPWi9tMjFRMEhBTkVDdlBSSW9HbnNyUWhTN3BJWjhkZEZNRm9WRktLd3ZyeWUzV1VRaVZrelBNbEd5UkFJdzQwbzVsUWhNWjMrU3FOZlYzVGY4WUNQTnRhTVNmU3ZmeGFoT3VwYjUrY21yU2xEbzFGaThrZ3pDTkdrelNnQ2wxbGdOQ0FlRTJ2UEpXVnFHemwxSzMxdWJsUWZBeFVOK3dvK0tCRlQydWJZOXMybjM1OW9XYkc4MHpuMlZGVkRBb001QWZJWC9pZHVqZmJnb3ZuVjJjYlNnR2Fqc0ZwYW9yZWNYdVRlSjZ6bTRYYnl4bVZVcGR6djV4ZzBHRnkwbE5JM1hOc1ZhdWp5TnM2R2JZUWg2ZnZEMitrS1B5d0pwVC9MZE5JemI5NmRyN0NtM3dhMkh4RTV1dnNPODQ4RGlxSHpKeDF0Vk1aeE9HcnNFbU5obHhwQ1hmLzdybFkzVGtYNVdHWWdDaUdpMWt5eVlCYUhranFYVzN2VmtPZmlha0Zpak9xdTFoSXc0NkpQNzVaaWdDYUZjNG9JWnlsQkk0S3pyYjR1TFlrYXBDbHMvWTUzaDdtVXl3K3BoNGpIUzFJYzhzL3VPVUJocFk2NFE2Nlo3WlhyK2FiNEVIUjRNZnFqdTFLZ1YyUjFwaURBQzVneENVRU9VRUkyMm1TczJzRVE4RU8rOHRVSzVZUkh4bnA2Qjd4OTFkMWQzZUV2aDB0dUQxdWdFK2pZZHBFZldkcU83RUQwU05mZzQwZmI0WXQ4UmFZemJHWDhzTGc2TzhXUUxZNVpINWlJN2dTOTJYOWRESDlqN25MQ2cxN2dYZVRFNlI0RzdiOWtsMlJhaW8vaEg2L1pCYVJZNUloNEVkd0hWWGE4d3FKenR2MzFJRUxEWDlYWm1GbmZtUXhCd2dHaTRRWnV4VXpPZ0hXQU1UNUZPNlZCdERoMVlmY0x5K1NLZWlUYmFRYjdJeEJnRjhTelVzN3ZmZURJRHdvajBzQ1JWRFl4bTZwUEpJeTJsZHIrbkRtMGJVTkJqS2hKOFViRVNSRG5SbEsrZkJVWE1yRlJDcnIvcTFhTFdLalZXV1ZjNzRib0NLanQ1NW9ENHNUVWdUVUdZaXl5ZFNsRUpXUkFDaWFnMVZEeGNsU0VoSGd6U1VaMmltUjhReEthNExiS1QvZUJkWGVQdHM3NjNtY1h2N2FCYmdFNTRkV2ZhQTk2MTBPeGhXWTlFU1VQT3FGQmhEcGI3bGhrM2UxcThRUkQ1bHV5NG43WkhycFlZMFpzWkk1d2h1THpkRDI5K0dQdVB0dkhHdTJIWVlJTW91Z0xubGsvWmtxMDMxbFRIcFNGS2JkTjJmMG85UjJnNnRGVXh5bjR6M2plODk1OExkbURsaHZyNVNDaGtqNnc0SkZ6YTdVS3Y4L295Y0JBampZMFliSFJSczQ3RmV5bjE1ZFhwY2l6OVZSVW9xc3FwaUliUE5TSWkyL0tOK1JkdXJqQ0F0WmhFQkZRWURBTkpGZWpleUw2QjZ1emhsMUFYbXlKV0VpcG5KUU1SazNnb2c2NSs5VklEUUt4cnpMTEc2WmwxMmNtYSswYVZwQlNNVDY0L25NejA0WUxLRUlBc0Z1dWEwNEVUNnFwcXE2aVJ3T0xNN1ZFTG1HMUNhUlp1V2VuZ2JhdkpSM3JaRy9mSEE1T1J2Ni95OW91VHJRSURlK3JlYnAvOEZZdXAxdEVubHkyYXRtUm4rUDQxamRTaEFuL3pQcnRMeithaGtqWVM4dWI3OTZpQnh5WjNiaWFNcmV6bWwyY00zNFlmMW5XVzQwSzVKUkN3RzROaXc2QUJNTjMwdXNSTkF5cTVVNGhtS2RMWE1uMEd0dmJBK2I3eTVpaUFzUi9hVXdOVHVNRnRUYlQzN2J4ZjUybGZrN2N4STRCOXpBYW9La0Faek03WjZxYy9mMTQzRG5RYjMwTUFWVU5Cb1h2OU1tdlhUR0piQlRDNjFwaFZGRjRKcFFUN0xueS96c0p1bHc0STFDWlphNW1jVXFrU3N5MDRTZFFKMXdXcm5GWTRBeWZxbEsrcDRGck1nemZMaG1pc2ltd1lnSzNzMEVtUk1zL201Q3lvS0lXNGJNTmJKR2R5SW1tMkVCQ0dVNVVSZ0twQ2hWSzY2dWVXVVB6V0FlWWpadFJYakNhK3R5WkRWQm55SmxPS20rSWZmQ085akdqWkpxMGQwa05pdzlmV1Zic1I0RnN0OUxCNmZDeWU2R1VTeXNiRnZnZXhVdWllcWJuWWxVa0txQURvVGY0RVNpYnMxVXVCS0hWM1VXWnVOR1ZMUzlvaFZJMmhPQnptTk5kWkxhOFRMYlowUDhoV2poWHZMWE8wanlYSHEwZzNEOE1kcit5T0M5M2ZHZVZHdDhXb2dDMnZGNHBRaGFoWit0TUpKbjM5eC8veEpkaGJrbWhlcHcyTGw1aEtWQzFScTJzYUNLS0ZmTUpVMUJQK2EvcXJGcEJPb1ZqeU5iWmZBenM5blVCbzgzTzlWQ2hWNlI2Yy9UcC9LQkZUK0JMa3FZcE84d2QrRXBVUW0rcUg4a0lQV0hPT2pmM2pPQjZGYktPU1ZaSzBMVTVQb0V4bDlhaGlwS2I4Y2FwVzRIUldFeklRYy9XbzhLQXBYRVViZElCQ2poTjhld0R4cUpYcTZKSGVGR1c4VFk3OFBoQ0xxdEdTZlNseHR6dnRKdEJ2VlhvTUliOXVOS21iNSswQVZuMmQ3OGgzQU5CM3M5NysyeW9QeVkyOEE3eEhjODNCY042TmN2azRkTzlDZWtxZGZFK2NTRnp2RFpwWG8wcGpFSTU2Tm9JMVRyRXBEOVN2Mmw1a3I3elRxTVFwNHlvMzU3ZGxGZzhUTHozNDV2S2VFNGN0TXFjMXoxdHd2R3IvanpaRkFCVFh2L3dsU3NSZXVKSThkSkNVYWhJNGMxMXFpR3Jzbmd0b2dYa2xTWG9VSzJDMHRXQ21PaDhMQkFaRnQrM1h6eC9XbDZwVlJLVjY4SUlGS3B3blZ4V2x1SlQ1L0d5L1JEaGgwNnM5eDJ2VktUdXUvUUZPbkpMTnVzNjdSUmdiNXEyek9pRlhYOWV3V0V6Q1E2Zkpwd20rdU5kQTFLRDhsRGt3ckdrazJsRlMydDhnZ2dJVXhaWUVtOEJDOXhNTXhrQXZXMGt6amR4elJyQ0ozRUtnMW5MZytxY3ovcEUraWZXTGM3c1F1Q2MwS0ZRaE1EUXlPTGR1cUtFYitUNUFKbW1iMDgxbUFPMjlZYVpacElWeUE3Vkh5aC8ycVVzM0VncUI3a0twcEJzdFBUNm9ESUZOVXl0eDBSZlMyZmtycHVRQ0RaT2Q1TVZDKzNtTlRrNXVSVXR6SHdvWGlxcWlNSGZHNlFCazFqRW5tQVpPNXRiNHpzMGdHSWlBVFMzdExYdkE5bnVRZTUvUFhnejY2bnE4ZHkxSExscFAzUmxlRUZVMVJYOGtKQmpoNFVsMFN1Y3BjcE5tZTVJcHNpNXIycUxtbXF2OWp1Mm5XYXJ2OHZkTHgwRXpGUmlncFJRdEZ0UDV1bnlNMTMvL24xd3ZoUXJuWkZJTndZSlFJUlJlRnlsRjNGSFBrM3ZSYXNnUFhGWHA2MXBQTFZpNVFQUjBubTAyTkx2YkhPUzltYzAwblVhbVAwOGZQdHFLRC9MSlB4aFlLMEU0SjYwOC95WlQ0UnE2R3V2OGNaS1hKU1psK0lmcmRjWXZuMUV6cFRROHFLclpjV1NuM2toMlNld01VWENOY3BwUEUrb2FjbG5kZUZrMHUyVHhHdlJsWGQwWjYrc3EwRFZOYWMrV3dBbHNNb2hvZ1JqdUhHS1BBTkZtcDVqS2lZM29JN3NnYjdLUmozNG5pQ1dQYldOdjgzWFhWc1NNakVmV1ZxYUsyTW41NUZZVjhzMVduaUhmWEd5M3lMMUhvOFliZW82YjlKQTNxM3lxcEhoWDVpUG5BMjBCNTdLTXV5MVR2TDdqblg3VS9mZFZFRHZDdHRuU2R0MTQvcCsxdkVUOUdwclFKdEJEYk9nV2M1bE1zN1M1UlJrRldiUCtpbkVKbGZOZkxpbzY5NzFYS0pSUVdwSk5JczR6dkM0dTUzU3JRemY0OFZ3ZTVnVkJ3YXFFS3VYcXVlbkIwUlYxMzBxVHJHcEZHUkdlZERBcUJLeFN0ZFlwYVNZd25VcnY4Z0N1bGI2TE9kR2dxSVJiRzZPaXVRM25tNXVUdjZJVTlXV1NwSVdNN0lLZ1FxNFhWYVY3R2dXc3J5Nmk3akVOdWdTRXdVd252R3VWKzBwOE03RWJTUXFEQ04vQjBVMk5TRDZNODN5dkttZVF2U240dHNCK3pjTFBtUjcrWUJTMkc3VDJRTVY4MXl6T1EyWVVIbEsydThEdWpoZ29mc2YrZnJBNkdwTXY3dHlEZkRndDlLMVlObVUxUktNVzNYR3NJeGp3WWhKVTIzMmpqYWVQby9KK1MwUERZU1RZM3poTlg0d1Z3eDVOV21STXkyREtZVksvUWdEQXlGL2ZDOE41Z1A5VTByVk9wV2RLcVJrZ2doSlZKNHMvL2FZdTViWDNqS3FhMWpXU0lROWdzTHJBUUtVR0luTitHajhNcUgxc0NGK3BqSmUyUDlJMjZkOXFURlEwSkNvbVU2K2tpMUJKRllQQW5YUW8wbk1yMTVRZERWdHJ3U2xxeUlIRTQ5RTh2SVprTW5weUwwTzB6RE5SMVRUV2ZxKzRRanpNVUZjOW0zcUUyU1Rra3NZRzdRV0RxdGt1RklwMlVmTjRmNGUrbHhqYnVZQWMrQUo5V2E2OUN2M2cvUHNJSkh0MDh1NE1BVkk2SUZPZzBoL0o5MUxUelVjVi9oMXBZODBHRWw5LzZkelpsaC9yV0R4Y1R1Mk1NN1ptUng2UjNvSjVjTGo1ZllKQ3FaVXFybE50UDlWRUlkSEdqbnM3WjVFSEJ2b2N2aDM3dlQwTzc3TU1Ra3krQzNhY2ZQdkVnTWZFODIzSzNlempoMVhMME80M3Y3MXNLdnNmcWhXRmtKaDhmWHFLZi9qN1QxcDlxcFBBdENERHpvYXpMblFOWjJncDVpNElEMjFhU1dPUVVLbk5ORzRLVm1lRVM3clNkYmNkdlJuV3d3VENjSlZZVjdFa1haS3FBdEVJcm9uc2l4bGp2WTRDckt1ZVBrN2wwM1did1ZJTzJGbFg3Ym5UU2hCVWtCR3FaZkpHOTIyRGpxNHRPYlhDVktWQURBb0xoc0tZSnRXYkhGdUFrdG1wdkpYLzdJZHczSUUwN003Y1EwSWp5bVl5L251cGxIaWpkTjVWMkVHM2VmaVhxNHFKaXF3LzNzb2ZicVZiMEN6ckk0TnlsQ2Zmd2plOFk1cHRJTUhBOUI5QjNuMGQyMjdzenFpTTZpWmo1Qll4Z3NGQWlRRFpjcitQQitxUmRIb1RjUjhiZzdTamJVSEQ0Nk9nY0dvdnFLdUhvcUhJZkxoYjQ5NWtZL2crWTg5UzR3QUIwbkZ1TUJ4VVRVQVJBLzR3LytuLytkTnFkRTBxeGdTdi9YeW9Va1J0RVFwTE9WVjNnU2RWRVFJcGRDY2piV3NKVllhTFJCajBtUGx6NHlQbFlnSXlyaEdYaXFLTzNQZTRLRVNVaFZXaEpoK3dYaFl1MU9peE9oYStWODVudkxqdEtNakRKandIaDd3OVlEUG9NalcwQnBhdngxY3Jxb1E5VVdBVHVZQWtpa1lqTGJlWVpDMjhwUXB2bkVJZTBjT2RWbng0a1d5UWtNYjdiQzM0alFwc2pabnpxTnp0MFcrakNCV0l1eWEybytYNjFnejZMckQ4ZmFtZ2JITmM2SHNIaHU1TDFVc092L2JORzBvbmFLMHFSVmpycE01RWV5RlNFNnFIMXJZWWZMeFd1NXNpaG83N3BqV3dabmZoN1hPMTVwOGRJL3l1R3hpZ3A4czgyZ053WjlCLzhDdm9PM0kwV1NnNjhXckhsUVVnV21INnZQNjNmN2dpVEZnaWozdFhwL1NjVEUxbUhpbmhhajBLQzRCbGp2MXVOeGVoc05KMVd4MmgyRkxyOTc5QWlJc203VmcwdFE4U2dBaE9WRE5sL0VHdXZDeExUTzBDZnZMbEt2Uk9RSk5ablVGTWpkbEczM2p2Q2VvUmFwQm93RzlyWm9DVHV5aFlSVTJEMU9KRVVYcHRKazRkZi9abTd0aVNHVzY1aHJkTklZYTN6NGo3YnExSytqS2hrUVdEMzcvM1BUN3FoaDBVL0kzRG8xcDBUZVBzUjlOdTF6emMvYnozek1HUi9JZzNmNStCQXVTT1BuajMvZmxnWnk2N3ZQU0h4TFc5YlhaaXBZUEFwZWxzRit1cEhOZ0NQWWErRmdYREh0QmF3RHZvS2czNGNheWNLYmRNSUtYYmExcURadGZoU0wzUDJIa29nc2xBVkJ5KzdmRTJSRm8ySm95QnR0TE03NmVOWFRtL0NBUy8vYWRmNXZXaVdOTWd5OFhUdndBbXFyWHBEWnVUWnhxK3MzbVB1SWdTcExXam9kR29aMjF2Ri90WHh6M1JSNFVSb0hxa3A3Y1l4YWIwUDRHbzJGeGtpV3ZScVZhdmM4T1V6bjU1dmFKWS95V2Z1UzZMbU9YQjQ0alF6ck9rQUoxbUVqTXJZTDQyaFE1T2REdHBlQnBxTWFxTHF0Ykt0SHIzRFF2SVRVM3BqdmgrODNnR2psdk5uUnp3anVjcEFuV0dRTzRmb08vZUF6KysxdS96ZFJraVdzb1h4a1BzV3hXVTFIUS9yT1RmUE1DTnltVmY1WFkzcWNoRFdoajRpR2F5Tzc5Ym80NTdSTHE1QTJ6cjR2NVJkSW9wUmpHaktzQndOYTM4Qm5IdVdHeHVmS2ZiVlpEbkszSnZtUWNhVVRPUklJbVh3MzBPb205MEhtaFE2YzZmRzl0ZWZtTml0Uk9NQVk0cFFJSE9GeUhqMC8rM2ZMaDgrWWhxS3NLb1VTZEIrazhrMFNwY1ZCUm1JVkFOcUdkTHBHdjMyV3BWWndaZHlDaGtUeFI1cUxjelV3cERUT2t1R2hFS3d6d2ozSVdRSEZ6anVqNU5XblFabEs0eTVkL29tT0daY0RvbXBLZFBUUGxtaDVJS0ZXZ29GQksyTG1YU3VtYjBHVndvMDlPSnRWNHVMRVY4b1lxS0w5QkNyWXpTV2hwck5LWFNTT094ZSt2QkhaQlJtdHpYZHVTYTFOOWl1Mk5iczBKQjhmWUIrODBiWkcyYzk3Nno3NVlvTzVZaEFEaFVJdS9oZzFXT3A5QmJ2SmpVU05FZEdKNXI3R0NIUzBaQWVYVG5uT1BpNkFFME5aS3pXd0IwZjcza0xxZzU3bWR3NU91Rk5NRmVNMFVkRWdQQlFHM1Q3Wm9acmJ5enoyNW1mMGxqRnpPbER5SUttRFQybmdtVFgxZUx2OVRKSXFENVVFTkFGNkVSWW9EMzNhN21Rc1FiQlY2REZGV3RsRkFvT2s4ckdycFpHRUVZbWowQm9wTDVFd2dVNTB5S2gyWnVNMlFRTU55QUxySWhDQU9CTkQxV1NIS0FwYjFPemQxSkh1MHhjK2R6WUZ2dXNwVmNlOGUvK01kLy9iUys4cm5LREpRU2krdEVPMUUwWkpLYWx0UWVOcCtMWFV5cWk0cVJxaHByZTZheGxzSktteThwRGxjWEVxSnRrVU9hTUpxM3RvRzFuZ0lVRmNycU1oWFRrS3J6eGYvNDVkTlNqQ3krVnAwblkzMHBxTFhLcWlLaXZNcno2ZlRUci9JdmY3a3NBS25MVC9OS2xSY0Q2SVEyRXgzTXRRYkVhSjh1Zi9lM243Nzg4ZFBIcCt0NmZyWmZWSlp5bHRkYVVOMWkxWm1yRnZmekh6N1V5MnJ6WmJKWVE2ZWNOeExHTUVxVW5WWHY0U3JHZHkrQWJsQ2NCNkFRQmlWRjhMQklRQ1EwMm5pZnR2SitsSXYwVnF5WllIcTJsUUwrS0FXN296bDhhem42Vm9XV2czTHQ3aDNqVGUvYVladGJZQnE3ZmN2QnRBTzlJdTVMR2dHR082akNqS0xkQyt0VHBJVk5zc050dXRBRXhqdndUTmxaM0hCUUpmZHRTcTRhZTFLbnBsbWs3amlrK2ZYTjN6UWFpVEtHejUrcTJ2Q1gyOVpFR2F1bkkrQXBPK1ltbndJVVpxb202N24remZyL0xuODJUeCtCWXFZUmFuWXFKRVZXU0FFRk1wMDBxYzRLa2RVbHFLWTdEOHlzSnpTR0JHOFl3eGdPY0cwNUk0ajJHUmd0UjBOZjV0UGtueklsVkVBb3ExUUdYRHhFMDI5TXlNbG1lMW5yMlpjZ3RLUktXeVV0ZTlPYVRFSmtEY0kxY0MwZkpxZ0dZcTFTNC9WWjRwSjZKTUJmdUZKRUlXb2ZjSEU5b1NwZDBBT2gwSmd5ekFKNzMyYmgwWHJuZlljRGJ4NkR6YTcyN3ZqdUdocHYraGxydllnZnVNZmRDN0lQbTQwUWhQZG9ENzUrZ3VVTmdmR2I0Z3pzU1M4UC9BOTRKL29ZQ2djT1JVNVQ1NkNGR0hIQSt3ZUJ1K3lOamlTOElyTVVkZ28xa1JaY25VMTlLbndaUVIzQnI1M2pQeEpzZHdZTWV5ZlpibW1wclhhM1ZZK1FJanBXbjhxdDB1L2RPUU9qUFZaVFMyT0ZOSXZNVTk4T2NMcHloRVEvNTQxcFp6Q3pZckk4djg3LytULzZ5MU1FdThSSUJWck1hb0J4S1NaS2lwVWlLMlVLbUlrekVLS3pTbzJPdDJXQkRkMjdiUTczODZSV0F0dkdLeEFxMEhZeW5mU2x6UGp5NWVPYzMwbFVlWTBsUXBJaTE5MFJMMVptVTMvOWNFM2Z1V1hSTkFTT0RDTnRmdThJMVdDSVhUNmNUZ0pac1NBMGxsY3F1Vlp3RGt4OHBaNExsd3JNejc1NFVVR1JGVkowbUZHMHhKUnUyWVBEMmdNaWQ3TU4zMW5mOEZZaDVHSFN1cGtKaHlJRm1ka0dPVGNwSUE2dkM0Mkp2OG1XdGxDVVZqZCs4QVIvcnpXbFlaZld1QkVTNzlHeXc2L2RQSTEzZ20vdHZheHU5S3M5L0xTbjJDZXpDRzVoZ0lTUzJOdGUxcUd2QWJHbHhGRmJxNDdnNWtDNFo2bUFnd201TlRrQU5CblIyaWhTdVZnLzdxYllGSkdEa2RVc0VOdHVsMXVmc2hONUROK3FCSkxOWlBCczFick9aanIvOG0vL2RINnF6WXE2Wmd0ZjFSSE84S2dKaXBjYVpKRW1TUlFCeElxNU90TUdMaThlSnZkem02Yll3d3hqWi9vcTNTZXJrMGFCYWxDQlRYWTJ2WG9vQXVMVlZ6SWl3d09WbVhrYVZhd2dhbkpRZWJYSkdZbWhVTUlRYkpNaGhDNkk1NC9oRVV2VXlTYWxWeFVKbWxuWVNWNXgrbGVsZnZyaWdNcGMxeHBSM0ZYTE9ML29YcUhsRGZoQitHTU45RmVWUHRKRElJOThuWTNOME1NdkNTblJCOFlqd3RVZXRTT0hxQitnSHppL1BBUko4TjBWR05zWFA4UzA5VkhSaGdJTURkNlU1bzJDVDVYaGVudWI5ZGZhNzRnUXRReHEydUZST1d3WWhCNHRhU0ZMUUFlOGxSQTIweG5paUpxeko2SHRGdjFvWVZTUzJTYWFxREY3S3l4M0NSbGRsUVFBc0JaeFZNWU1qeHNCZDdxbzVjUkxla0ptYWsxY3BmZ1gvK0UvODR0NlkwdUZFQ0VoWGhtdTBFa2lLS3FWT2o5TkdxZGdBRVdEWnAwSTNnZ2JGR0hVTmlSMDlUTTN4bTZEdXNpUno1NzdiUWhEd3RRdmdsUGhVdGRNNHFqaHphUFQwRXFpOGVOTW42WjVlbGxDamF4U1FaQ2NrQ2wzNk1ydGdKRFZwMU81cm5XTkpUQVZzeWxOdWRSQ29DZ29UN2FZQ0d4OU9xMS8vY0lKSWQyWE1rMmxHNXBlZU5jdkU0L0V0cFEzWUx0N2xQWHhhZWR1K1FMY05ORFl5TE1ZZXNFYk5uR20xVEY2ek9aWWYrMUp3L3pmVllGalR3WGNZY3A3Zy9QOU9pNHlJYS9UWWcvYkxtRXpoZDljUGxzYUtiYmhaVUNHRE05aW9rTGRPV093YWV6WUZHelp5TmIrd25xZis4QVNESjIxc1N2QTJ0alEya0dydmgvWUd6bHZaS3RtRjk5V3UwQ2pEUFZ2dThuMHVsZzZ4MkVBMnFFeVVWVzFBbEdvY0k0di8vM3owMS83ZkNTYWtTZHd6L2ltVTBSMVVWdFFuai9hY2puWFNvclpZZ1ozYi81RVNmbE1WL29Pc1EvSFpNaU9ZTUlVVzQ1aFJkc0MxMDNySzhDTHI1VW1GZXpvTzZNWmh3UVZobmdWQ2VDNlJJRjRsQWd0Q0NuTndhc1ZpaENIbXJwLzVPVmFhNmlLaUZObUQycFpLaUZScmJEK2RZb1ZacXd5VDlmTE9ubWpSelNPalhoTHZ5eUROWFBZTE9CT3ovdFdwWkd2TFBMdktKSnAyWVREMUwzRnNxQ05WRUtxZW5NOFBxQy8wR1pLenhRTHdqVGtFSVQ5TzBHczkzdDdZWjlMQWJtVFUrcU5leDViMnMvdFRyUVROZGpPM1M0akR0dkd2Uzl0UVF0eExDQ0VoZ1BIT1FTUmR0OUF4aGNFcldtQjB3d2IzWU93LzhiWWdWaEhXclJvZTB5N3QwZ3I5MTJlS05wR241UVZZMUFoMDNrZFExL1I3Z1ZvM3lOckNoYkF6RlhlbUpGUU5iWFN4cXFQbC8vNzc4c2x2TFQzcTJub3hNTTlRb0o1bmxrRTlUWGJ0YUJJMERRdVFXcVgwdmZucmhrbTlBbVl1eVFhR1FGQ2tWdUJickpBU3BuQ0EvRjZsWXJ6Rk5maUxtbFlTbEFWNWg3QVpMNnMrdFJVWTRnVUg2a1VYY2V1UlpIT25GTE90bDVQeTdXYVl5NmlOUVFXRlNlVEZWRmtsY2t2NjlPTWt6S3VuK0xwdWI2U0tFVDM0eUFSN0FIdnQ4TWJqMU1zRHFqcU80L3ZtN0ZIZVB3Vk9JaThLUUJxcEZJeDduaVdJOHFQZ0tiY21kLzR1ZThGc2I1bkJoNnhRbmhJbU5DYjF4UGFkYnZIOFFUUnRMVEVRZnlBbS9lem4yQVZaMVdscXRCMHY5NmlCSVVCQ0N6dGZVT2ptOWx0QzBEdXFlVFkyMmNBMjVLTkZnMSs3dE5Kc25YR0NVQWJmZm9CN3NwUEhVeFlxQTR1T3RoUDZuYUFDYlhKUW9iYnBLcVpGaEdDZ1E4di85Yy96WDgrcjl5Vzl4QlF2TEl5eEZVTkdzRVQxNHVjbnFaTFJBakRUU1JXaHlIdDRLVGJvaGgzN0N2ZU10TmJDZDRlQmJqazB1OTVxbFpZcnl3b3AvTzFTamhNZXl3ZXhHZ2laU3FWTVozZG5qNjVNNEtvSGhPZzlobkRKZ21pakJQazlHRmFTbG0rOEJ5WW4ycGRIZE1Kb3ZNOHIveFNOR1JpWFd3K0dlckZYMS8vOXVQSGVNbnd0bzN1R0kxbFVMcDVtakxTSzc1MWRUYkkvSGtWWjlYSVpKMTlhNnR0cjl2Zm5wRDlvblZJbVhiUEQ3YW1iaU9DOU9lS0duTFNXa09WaFJCWjIvY1BnRTRXNmhRTVNmcFpyRlZGSlViWVFnNGNrbmw4aHc0Y2tZVFlhR0lKN0FPbmR4ckd1QkZUOFBCUkQwTnh3V3h4WGNYU1ZOc1VKMTFXRVhvN0JHRjBVYW10dFdRQmdnQ3kvVlZwZHBGWVU1ZGlDWFlZMHJ5ZGtaWEh1cDVYaEduMDdBS05DcGxoSXQ0YUdvZzRWTGh5S2ltcGxncVZxQllPelNTQTVuYmM4Mi9TejdrYmhxaTBtRjlCdUNnTXpPWlpReFBwT2JFYnRiWlFFRUFvcHQxNVVLRmdlTFNMTlEra1pwK2NJM0EySUU0eEU5WlpSWVNoZmFZMk5ZaHFXYS8vNm5MNjUrbmp4Ly96RjF6c2w0OHJNaVVPYWdqQ0xGWXFLVnpycVZUYWFtcW5NNjhWUW9mTzY1cU9wTTVOc1I4N0RORWxWQlJ3a0RiRmRlNEpFd29HZFZwVkZCSnVxMHgxZWZxNS9PUG5uejdpODhWVzlmajRnVzRScEdpbGlNSURRcG1mdEM0WDBrL3hxMTlzcmpiWEpiU2N1ZGEyeGZLU3dpblYyWXFJelY5aUpxZjRmRDNOSUNFNm1kS0tXYkRNOXZHbkYxN2xxYWorNGVYTHIrdHpZZlBTaCtkOEg3VUJkT1ZiMjE2TzhydWhQVCttVW5qUEYrTEcrNHJqQldCRXpmQm1GbjFNalB6OTNpRGZtSUc5ajYzU2p0NFdKdGt1ZEJXTGd5TzgzSnZwUFJEbEVqZTJueDMrRy95c3hzNHpIcHNUa2d3RzloZjF0aU81L1VuWUpVSWZsQ3c4c2g3M0dnWEJ6Y0s5ajhpTjE4eGJ2NzIwQmhJUlJLdk1CYXFLMEFJUlViTm1UU2xxcWdMRFdlSmFQdnh4L25mLzQ3S3U5eUdYT3o2MUFob2tvVllvcndvbnd2cEEyQ3VDM3B2YkhuTGtlR3NhdmlXbmhzN1BmN2lVYVM0NUdPaWdIQWQyVGN4RTQzb0o1L0psV1M0ZHBGZVlNTHp1UzVsQ1VBVGlTWlVVRVlFVlJTenJZcTFSVWhFVkQ2N2U2dVpaRjNYTVYyd3RBa1U0NVZvQUFBSVFTVVJCVkhadGNua0g1Wmg3dEdtWUN2L3cxdlZiV3FUOGlUVVRkM3VNcEVCRklrdk9qZUwxdmkwZFEvZi9EeTZaYi8zajNlbTh2UmZGSW5aNjdvelAwUXErKy9KNnJEellyY2gzOGFQaHQ4WUVtcFN1aUV6SkhzQkdhbWlHUFNCaXc3SFFPLy85eDlLV0wxdDY0Y2JoNVpEM05vTjBVZTFEYm9zOFE1ZTY5VnNoQitKKzRGTFBheERLQkZDMFdMVDlzT1VCVnN3UWZQajUxMy96WDFkZjVXMVp1QkpxcEtnR0l1aDV0VGNWUHcrdy9UWWtZaHNBM2lJNGJNNTVxZGd0Y3ozTnJtMHhCbHRpaExvUmhNUmtBaTZYQ2JHOGxCNy9LVkpnaVBCbDUxMG1NTWdrNGJBaHFzcXh1MGI5bUV0bEF3VEs2dUZjSjFkbG1aZXI4eFFaTnIzRkw3Y1hYZDUzNm9odFZ2MjZGT0J0cnlwOE5YSVVHeUZHUkVTcVFVbjN6b2RVSU5LbmI1ZHMxUnVDaDhIWi8ydFBjTlNtVCtrenNRWjlrNzVMVUxSbzNCVGdIYUorV084K3JoREhra05wL2hZQ2hnVHNzR2RTMFNBUnJ0MS9hRnlKRGZ2VmFHazQwbkp3T2F6amovQUdENERXNXEwaG5WeWMvWGZLRG9pMHBVeVBxaHMzZk9Uc05ieGtJRFF0UUtkNWFkSUNlMEtEQUZpS3pjWDRYLzdETHg5OG1jdWJWeDlFMUVSQ1ZSeVhXRlFwS3JCNitPM3YxL043M3B2Y1VHRkdEOWhTMWVzNnYweGxtaXgxSFFGVkMrNXprWmsrbTZSb0FhcGdpZ1ltUUpVaDlIN0F3aUE2YVlobWhGYlBGYitLd1FDd2VoaEZUNFFxNm1vbWs0cGdGYWpXa0ZOZGU4T3dPYUNSOGo4Qlc4dXozTUhtNWNJQUFBQUFTVVZPUks1Q1lJST1cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/images/jocelyn-faihy.png\n");

/***/ }),

/***/ "./assets/pages/index.jsx":
/*!********************************!*\
  !*** ./assets/pages/index.jsx ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _description = __webpack_require__(/*! @components/description */ \"./assets/components/description.jsx\");\n\nvar _description2 = _interopRequireDefault(_description);\n\nvar _history = __webpack_require__(/*! @components/history */ \"./assets/components/history.jsx\");\n\nvar _history2 = _interopRequireDefault(_history);\n\nvar _navigation = __webpack_require__(/*! @components/navigation */ \"./assets/components/navigation.jsx\");\n\nvar _navigation2 = _interopRequireDefault(_navigation);\n\nvar _presentation = __webpack_require__(/*! @components/presentation */ \"./assets/components/presentation.jsx\");\n\nvar _presentation2 = _interopRequireDefault(_presentation);\n\nvar _skill = __webpack_require__(/*! @components/skill */ \"./assets/components/skill.jsx\");\n\nvar _skill2 = _interopRequireDefault(_skill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_reactDom2.default.render(_react2.default.createElement(\n    _react.Fragment,\n    null,\n    _react2.default.createElement(_navigation2.default, null),\n    _react2.default.createElement(_presentation2.default, null),\n    _react2.default.createElement(_description2.default, null),\n    _react2.default.createElement(_history2.default, null),\n    _react2.default.createElement(_skill2.default, null)\n), document.getElementById('root'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hc3NldHMvcGFnZXMvaW5kZXguanN4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2Fzc2V0cy9wYWdlcy9pbmRleC5qc3g/OTFhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IFJlYWN0LCB7IEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgRGVzY3JpcHRpb24gZnJvbSAnQGNvbXBvbmVudHMvZGVzY3JpcHRpb24nO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnQGNvbXBvbmVudHMvaGlzdG9yeSc7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICdAY29tcG9uZW50cy9uYXZpZ2F0aW9uJztcbmltcG9ydCBQcmVzZW50YXRpb24gZnJvbSAnQGNvbXBvbmVudHMvcHJlc2VudGF0aW9uJztcbmltcG9ydCBTa2lsbCBmcm9tICdAY29tcG9uZW50cy9za2lsbCc7XG5cblJlYWN0RE9NLnJlbmRlcihcbiAgICA8RnJhZ21lbnQ+XG4gICAgICAgIDxOYXZpZ2F0aW9uIC8+XG4gICAgICAgIDxQcmVzZW50YXRpb24gLz5cbiAgICAgICAgPERlc2NyaXB0aW9uIC8+XG4gICAgICAgIDxIaXN0b3J5IC8+XG4gICAgICAgIDxTa2lsbCAvPlxuICAgIDwvRnJhZ21lbnQ+LFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jylcbik7XG4iXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./assets/pages/index.jsx\n");

/***/ }),

/***/ "./node_modules/@fortawesome/fontawesome/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fortawesome/fontawesome/index.es.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Font Awesome Free 5.0.13 by @fontawesome - https://fontawesome.com\n * License - https://fontawesome.com/license (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)\n */\nvar noop = function noop() {};\n\nvar _WINDOW = {};\nvar _DOCUMENT = {};\nvar _MUTATION_OBSERVER$1 = null;\nvar _PERFORMANCE = { mark: noop, measure: noop };\n\ntry {\n  if (typeof window !== 'undefined') _WINDOW = window;\n  if (typeof document !== 'undefined') _DOCUMENT = document;\n  if (typeof MutationObserver !== 'undefined') _MUTATION_OBSERVER$1 = MutationObserver;\n  if (typeof performance !== 'undefined') _PERFORMANCE = performance;\n} catch (e) {}\n\nvar _ref = _WINDOW.navigator || {};\nvar _ref$userAgent = _ref.userAgent;\nvar userAgent = _ref$userAgent === undefined ? '' : _ref$userAgent;\n\nvar WINDOW = _WINDOW;\nvar DOCUMENT = _DOCUMENT;\nvar MUTATION_OBSERVER = _MUTATION_OBSERVER$1;\nvar PERFORMANCE = _PERFORMANCE;\nvar IS_BROWSER = !!WINDOW.document;\nvar IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';\nvar IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');\n\nvar NAMESPACE_IDENTIFIER = '___FONT_AWESOME___';\nvar UNITS_IN_GRID = 16;\nvar DEFAULT_FAMILY_PREFIX = 'fa';\nvar DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa';\nvar DATA_FA_I2SVG = 'data-fa-i2svg';\nvar DATA_FA_PSEUDO_ELEMENT = 'data-fa-pseudo-element';\nvar HTML_CLASS_I2SVG_BASE_CLASS = 'fontawesome-i2svg';\n\nvar PRODUCTION = function () {\n  try {\n    return \"development\" === 'production';\n  } catch (e) {\n    return false;\n  }\n}();\n\nvar oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);\n\nvar ATTRIBUTES_WATCHED_FOR_MUTATION = ['class', 'data-prefix', 'data-icon', 'data-fa-transform', 'data-fa-mask'];\n\nvar RESERVED_CLASSES = ['xs', 'sm', 'lg', 'fw', 'ul', 'li', 'border', 'pull-left', 'pull-right', 'spin', 'pulse', 'rotate-90', 'rotate-180', 'rotate-270', 'flip-horizontal', 'flip-vertical', 'stack', 'stack-1x', 'stack-2x', 'inverse', 'layers', 'layers-text', 'layers-counter'].concat(oneToTen.map(function (n) {\n  return n + 'x';\n})).concat(oneToTwenty.map(function (n) {\n  return 'w-' + n;\n}));\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar initial = WINDOW.FontAwesomeConfig || {};\nvar initialKeys = Object.keys(initial);\n\nvar _default = _extends({\n  familyPrefix: DEFAULT_FAMILY_PREFIX,\n  replacementClass: DEFAULT_REPLACEMENT_CLASS,\n  autoReplaceSvg: true,\n  autoAddCss: true,\n  autoA11y: true,\n  searchPseudoElements: false,\n  observeMutations: true,\n  keepOriginalSource: true,\n  measurePerformance: false,\n  showMissingIcons: true\n}, initial);\n\nif (!_default.autoReplaceSvg) _default.observeMutations = false;\n\nvar config$1 = _extends({}, _default);\n\nWINDOW.FontAwesomeConfig = config$1;\n\nfunction update(newConfig) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _params$asNewDefault = params.asNewDefault,\n      asNewDefault = _params$asNewDefault === undefined ? false : _params$asNewDefault;\n\n  var validKeys = Object.keys(config$1);\n  var ok = asNewDefault ? function (k) {\n    return ~validKeys.indexOf(k) && !~initialKeys.indexOf(k);\n  } : function (k) {\n    return ~validKeys.indexOf(k);\n  };\n\n  Object.keys(newConfig).forEach(function (configKey) {\n    if (ok(configKey)) config$1[configKey] = newConfig[configKey];\n  });\n}\n\nfunction auto(value) {\n  update({\n    autoReplaceSvg: value,\n    observeMutations: value\n  });\n}\n\nvar w = WINDOW || {};\n\nif (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};\nif (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};\nif (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};\nif (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];\n\nvar namespace = w[NAMESPACE_IDENTIFIER];\n\nvar functions = [];\nvar listener = function listener() {\n  DOCUMENT.removeEventListener('DOMContentLoaded', listener);\n  loaded = 1;\n  functions.map(function (fn) {\n    return fn();\n  });\n};\n\nvar loaded = false;\n\nif (IS_DOM) {\n  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);\n\n  if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);\n}\n\nvar domready = function domready(fn) {\n  if (!IS_DOM) return;\n  loaded ? setTimeout(fn, 0) : functions.push(fn);\n};\n\nvar d = UNITS_IN_GRID;\n\nvar meaninglessTransform = {\n  size: 16,\n  x: 0,\n  y: 0,\n  rotate: 0,\n  flipX: false,\n  flipY: false\n};\n\nfunction isReserved(name) {\n  return ~RESERVED_CLASSES.indexOf(name);\n}\n\nfunction bunker(fn) {\n  try {\n    fn();\n  } catch (e) {\n    if (!PRODUCTION) {\n      throw e;\n    }\n  }\n}\n\nfunction insertCss(css) {\n  if (!css || !IS_DOM) {\n    return;\n  }\n\n  var style = DOCUMENT.createElement('style');\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n\n  var headChildren = DOCUMENT.head.childNodes;\n  var beforeChild = null;\n\n  for (var i = headChildren.length - 1; i > -1; i--) {\n    var child = headChildren[i];\n    var tagName = (child.tagName || '').toUpperCase();\n    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {\n      beforeChild = child;\n    }\n  }\n\n  DOCUMENT.head.insertBefore(style, beforeChild);\n\n  return css;\n}\n\nvar _uniqueId = 0;\n\nfunction nextUniqueId() {\n  _uniqueId++;\n\n  return _uniqueId;\n}\n\nfunction toArray(obj) {\n  var array = [];\n\n  for (var i = (obj || []).length >>> 0; i--;) {\n    array[i] = obj[i];\n  }\n\n  return array;\n}\n\nfunction classArray(node) {\n  if (node.classList) {\n    return toArray(node.classList);\n  } else {\n    return (node.getAttribute('class') || '').split(' ').filter(function (i) {\n      return i;\n    });\n  }\n}\n\nfunction getIconName(familyPrefix, cls) {\n  var parts = cls.split('-');\n  var prefix = parts[0];\n  var iconName = parts.slice(1).join('-');\n\n  if (prefix === familyPrefix && iconName !== '' && !isReserved(iconName)) {\n    return iconName;\n  } else {\n    return null;\n  }\n}\n\nfunction htmlEscape(str) {\n  return ('' + str).replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nfunction joinAttributes(attributes) {\n  return Object.keys(attributes || {}).reduce(function (acc, attributeName) {\n    return acc + (attributeName + '=\"' + htmlEscape(attributes[attributeName]) + '\" ');\n  }, '').trim();\n}\n\nfunction joinStyles(styles) {\n  return Object.keys(styles || {}).reduce(function (acc, styleName) {\n    return acc + (styleName + ': ' + styles[styleName] + ';');\n  }, '');\n}\n\nfunction transformIsMeaningful(transform) {\n  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;\n}\n\nfunction transformForSvg(_ref) {\n  var transform = _ref.transform,\n      containerWidth = _ref.containerWidth,\n      iconWidth = _ref.iconWidth;\n\n  var outer = {\n    transform: 'translate(' + containerWidth / 2 + ' 256)'\n  };\n  var innerTranslate = 'translate(' + transform.x * 32 + ', ' + transform.y * 32 + ') ';\n  var innerScale = 'scale(' + transform.size / 16 * (transform.flipX ? -1 : 1) + ', ' + transform.size / 16 * (transform.flipY ? -1 : 1) + ') ';\n  var innerRotate = 'rotate(' + transform.rotate + ' 0 0)';\n  var inner = {\n    transform: innerTranslate + ' ' + innerScale + ' ' + innerRotate\n  };\n  var path = {\n    transform: 'translate(' + iconWidth / 2 * -1 + ' -256)'\n  };\n  return {\n    outer: outer,\n    inner: inner,\n    path: path\n  };\n}\n\nfunction transformForCss(_ref2) {\n  var transform = _ref2.transform,\n      _ref2$width = _ref2.width,\n      width = _ref2$width === undefined ? UNITS_IN_GRID : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === undefined ? UNITS_IN_GRID : _ref2$height,\n      _ref2$startCentered = _ref2.startCentered,\n      startCentered = _ref2$startCentered === undefined ? false : _ref2$startCentered;\n\n  var val = '';\n\n  if (startCentered && IS_IE) {\n    val += 'translate(' + (transform.x / d - width / 2) + 'em, ' + (transform.y / d - height / 2) + 'em) ';\n  } else if (startCentered) {\n    val += 'translate(calc(-50% + ' + transform.x / d + 'em), calc(-50% + ' + transform.y / d + 'em)) ';\n  } else {\n    val += 'translate(' + transform.x / d + 'em, ' + transform.y / d + 'em) ';\n  }\n\n  val += 'scale(' + transform.size / d * (transform.flipX ? -1 : 1) + ', ' + transform.size / d * (transform.flipY ? -1 : 1) + ') ';\n  val += 'rotate(' + transform.rotate + 'deg) ';\n\n  return val;\n}\n\nvar ALL_SPACE = {\n  x: 0,\n  y: 0,\n  width: '100%',\n  height: '100%'\n};\n\nvar makeIconMasking = function makeIconMasking(_ref) {\n  var children = _ref.children,\n      attributes = _ref.attributes,\n      main = _ref.main,\n      mask = _ref.mask,\n      transform = _ref.transform;\n  var mainWidth = main.width,\n      mainPath = main.icon;\n  var maskWidth = mask.width,\n      maskPath = mask.icon;\n\n  var trans = transformForSvg({ transform: transform, containerWidth: maskWidth, iconWidth: mainWidth });\n\n  var maskRect = {\n    tag: 'rect',\n    attributes: _extends({}, ALL_SPACE, {\n      fill: 'white'\n    })\n  };\n  var maskInnerGroup = {\n    tag: 'g',\n    attributes: _extends({}, trans.inner),\n    children: [{ tag: 'path', attributes: _extends({}, mainPath.attributes, trans.path, { fill: 'black' }) }]\n  };\n  var maskOuterGroup = {\n    tag: 'g',\n    attributes: _extends({}, trans.outer),\n    children: [maskInnerGroup]\n  };\n  var maskId = 'mask-' + nextUniqueId();\n  var clipId = 'clip-' + nextUniqueId();\n  var maskTag = {\n    tag: 'mask',\n    attributes: _extends({}, ALL_SPACE, {\n      id: maskId,\n      maskUnits: 'userSpaceOnUse',\n      maskContentUnits: 'userSpaceOnUse'\n    }),\n    children: [maskRect, maskOuterGroup]\n  };\n  var defs = {\n    tag: 'defs',\n    children: [{ tag: 'clipPath', attributes: { id: clipId }, children: [maskPath] }, maskTag]\n  };\n\n  children.push(defs, { tag: 'rect', attributes: _extends({ fill: 'currentColor', 'clip-path': 'url(#' + clipId + ')', mask: 'url(#' + maskId + ')' }, ALL_SPACE) });\n\n  return {\n    children: children,\n    attributes: attributes\n  };\n};\n\nvar makeIconStandard = function makeIconStandard(_ref) {\n  var children = _ref.children,\n      attributes = _ref.attributes,\n      main = _ref.main,\n      transform = _ref.transform,\n      styles = _ref.styles;\n\n  var styleString = joinStyles(styles);\n\n  if (styleString.length > 0) {\n    attributes['style'] = styleString;\n  }\n\n  if (transformIsMeaningful(transform)) {\n    var trans = transformForSvg({ transform: transform, containerWidth: main.width, iconWidth: main.width });\n    children.push({\n      tag: 'g',\n      attributes: _extends({}, trans.outer),\n      children: [{\n        tag: 'g',\n        attributes: _extends({}, trans.inner),\n        children: [{\n          tag: main.icon.tag,\n          children: main.icon.children,\n          attributes: _extends({}, main.icon.attributes, trans.path)\n        }]\n      }]\n    });\n  } else {\n    children.push(main.icon);\n  }\n\n  return {\n    children: children,\n    attributes: attributes\n  };\n};\n\nvar asIcon = function asIcon(_ref) {\n  var children = _ref.children,\n      main = _ref.main,\n      mask = _ref.mask,\n      attributes = _ref.attributes,\n      styles = _ref.styles,\n      transform = _ref.transform;\n\n  if (transformIsMeaningful(transform) && main.found && !mask.found) {\n    var width = main.width,\n        height = main.height;\n\n    var offset = {\n      x: width / height / 2,\n      y: 0.5\n    };\n    attributes['style'] = joinStyles(_extends({}, styles, {\n      'transform-origin': offset.x + transform.x / 16 + 'em ' + (offset.y + transform.y / 16) + 'em'\n    }));\n  }\n\n  return [{\n    tag: 'svg',\n    attributes: attributes,\n    children: children\n  }];\n};\n\nvar asSymbol = function asSymbol(_ref) {\n  var prefix = _ref.prefix,\n      iconName = _ref.iconName,\n      children = _ref.children,\n      attributes = _ref.attributes,\n      symbol = _ref.symbol;\n\n  var id = symbol === true ? prefix + '-' + config$1.familyPrefix + '-' + iconName : symbol;\n\n  return [{\n    tag: 'svg',\n    attributes: {\n      style: 'display: none;'\n    },\n    children: [{\n      tag: 'symbol',\n      attributes: _extends({}, attributes, { id: id }),\n      children: children\n    }]\n  }];\n};\n\nfunction makeInlineSvgAbstract(params) {\n  var _params$icons = params.icons,\n      main = _params$icons.main,\n      mask = _params$icons.mask,\n      prefix = params.prefix,\n      iconName = params.iconName,\n      transform = params.transform,\n      symbol = params.symbol,\n      title = params.title,\n      extra = params.extra,\n      _params$watchable = params.watchable,\n      watchable = _params$watchable === undefined ? false : _params$watchable;\n\n  var _ref = mask.found ? mask : main,\n      width = _ref.width,\n      height = _ref.height;\n\n  var widthClass = 'fa-w-' + Math.ceil(width / height * 16);\n  var attrClass = [config$1.replacementClass, iconName ? config$1.familyPrefix + '-' + iconName : '', widthClass].concat(extra.classes).join(' ');\n\n  var content = {\n    children: [],\n    attributes: _extends({}, extra.attributes, {\n      'data-prefix': prefix,\n      'data-icon': iconName,\n      'class': attrClass,\n      'role': 'img',\n      'xmlns': 'http://www.w3.org/2000/svg',\n      'viewBox': '0 0 ' + width + ' ' + height\n    })\n  };\n\n  if (watchable) {\n    content.attributes[DATA_FA_I2SVG] = '';\n  }\n\n  if (title) content.children.push({ tag: 'title', attributes: { id: content.attributes['aria-labelledby'] || 'title-' + nextUniqueId() }, children: [title] });\n\n  var args = _extends({}, content, {\n    prefix: prefix,\n    iconName: iconName,\n    main: main,\n    mask: mask,\n    transform: transform,\n    symbol: symbol,\n    styles: extra.styles\n  });\n\n  var _ref2 = mask.found && main.found ? makeIconMasking(args) : makeIconStandard(args),\n      children = _ref2.children,\n      attributes = _ref2.attributes;\n\n  args.children = children;\n  args.attributes = attributes;\n\n  if (symbol) {\n    return asSymbol(args);\n  } else {\n    return asIcon(args);\n  }\n}\n\nfunction makeLayersTextAbstract(params) {\n  var content = params.content,\n      width = params.width,\n      height = params.height,\n      transform = params.transform,\n      title = params.title,\n      extra = params.extra,\n      _params$watchable2 = params.watchable,\n      watchable = _params$watchable2 === undefined ? false : _params$watchable2;\n\n  var attributes = _extends({}, extra.attributes, title ? { 'title': title } : {}, {\n    'class': extra.classes.join(' ')\n  });\n\n  if (watchable) {\n    attributes[DATA_FA_I2SVG] = '';\n  }\n\n  var styles = _extends({}, extra.styles);\n\n  if (transformIsMeaningful(transform)) {\n    styles['transform'] = transformForCss({ transform: transform, startCentered: true, width: width, height: height });\n    styles['-webkit-transform'] = styles['transform'];\n  }\n\n  var styleString = joinStyles(styles);\n\n  if (styleString.length > 0) {\n    attributes['style'] = styleString;\n  }\n\n  var val = [];\n\n  val.push({\n    tag: 'span',\n    attributes: attributes,\n    children: [content]\n  });\n\n  if (title) {\n    val.push({ tag: 'span', attributes: { class: 'sr-only' }, children: [title] });\n  }\n\n  return val;\n}\n\nvar noop$2 = function noop() {};\nvar p = config$1.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : { mark: noop$2, measure: noop$2 };\nvar preamble = 'FA \"5.0.13\"';\n\nvar begin = function begin(name) {\n  p.mark(preamble + ' ' + name + ' begins');\n  return function () {\n    return end(name);\n  };\n};\n\nvar end = function end(name) {\n  p.mark(preamble + ' ' + name + ' ends');\n  p.measure(preamble + ' ' + name, preamble + ' ' + name + ' begins', preamble + ' ' + name + ' ends');\n};\n\nvar perf = { begin: begin, end: end };\n\n'use strict';\n\n/**\n * Internal helper to bind a function known to have 4 arguments\n * to a given context.\n */\nvar bindInternal4 = function bindInternal4(func, thisContext) {\n  return function (a, b, c, d) {\n    return func.call(thisContext, a, b, c, d);\n  };\n};\n\n'use strict';\n\n/**\n * # Reduce\n *\n * A fast object `.reduce()` implementation.\n *\n * @param  {Object}   subject      The object to reduce over.\n * @param  {Function} fn           The reducer function.\n * @param  {mixed}    initialValue The initial value for the reducer, defaults to subject[0].\n * @param  {Object}   thisContext  The context for the reducer.\n * @return {mixed}                 The final result.\n */\nvar reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {\n  var keys = Object.keys(subject),\n      length = keys.length,\n      iterator = thisContext !== undefined ? bindInternal4(fn, thisContext) : fn,\n      i,\n      key,\n      result;\n\n  if (initialValue === undefined) {\n    i = 1;\n    result = subject[keys[0]];\n  } else {\n    i = 0;\n    result = initialValue;\n  }\n\n  for (; i < length; i++) {\n    key = keys[i];\n    result = iterator(result, subject[key], key, subject);\n  }\n\n  return result;\n};\n\nvar styles$2 = namespace.styles;\nvar shims = namespace.shims;\n\nvar _byUnicode = {};\nvar _byLigature = {};\nvar _byOldName = {};\n\nvar build = function build() {\n  var lookup = function lookup(reducer) {\n    return reduce(styles$2, function (o, style, prefix) {\n      o[prefix] = reduce(style, reducer, {});\n      return o;\n    }, {});\n  };\n\n  _byUnicode = lookup(function (acc, icon, iconName) {\n    acc[icon[3]] = iconName;\n\n    return acc;\n  });\n\n  _byLigature = lookup(function (acc, icon, iconName) {\n    var ligatures = icon[2];\n\n    acc[iconName] = iconName;\n\n    ligatures.forEach(function (ligature) {\n      acc[ligature] = iconName;\n    });\n\n    return acc;\n  });\n\n  var hasRegular = 'far' in styles$2;\n\n  _byOldName = reduce(shims, function (acc, shim) {\n    var oldName = shim[0];\n    var prefix = shim[1];\n    var iconName = shim[2];\n\n    if (prefix === 'far' && !hasRegular) {\n      prefix = 'fas';\n    }\n\n    acc[oldName] = { prefix: prefix, iconName: iconName };\n\n    return acc;\n  }, {});\n};\n\nbuild();\n\nfunction byUnicode(prefix, unicode) {\n  return _byUnicode[prefix][unicode];\n}\n\nfunction byLigature(prefix, ligature) {\n  return _byLigature[prefix][ligature];\n}\n\nfunction byOldName(name) {\n  return _byOldName[name] || { prefix: null, iconName: null };\n}\n\nvar styles$1 = namespace.styles;\n\nvar emptyCanonicalIcon = function emptyCanonicalIcon() {\n  return { prefix: null, iconName: null, rest: [] };\n};\n\nfunction getCanonicalIcon(values) {\n  return values.reduce(function (acc, cls) {\n    var iconName = getIconName(config$1.familyPrefix, cls);\n\n    if (styles$1[cls]) {\n      acc.prefix = cls;\n    } else if (iconName) {\n      var shim = acc.prefix === 'fa' ? byOldName(iconName) : {};\n\n      acc.iconName = shim.iconName || iconName;\n      acc.prefix = shim.prefix || acc.prefix;\n    } else if (cls !== config$1.replacementClass && cls.indexOf('fa-w-') !== 0) {\n      acc.rest.push(cls);\n    }\n\n    return acc;\n  }, emptyCanonicalIcon());\n}\n\nfunction iconFromMapping(mapping, prefix, iconName) {\n  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {\n    return {\n      prefix: prefix,\n      iconName: iconName,\n      icon: mapping[prefix][iconName]\n    };\n  }\n}\n\nfunction toHtml(abstractNodes) {\n  var tag = abstractNodes.tag,\n      _abstractNodes$attrib = abstractNodes.attributes,\n      attributes = _abstractNodes$attrib === undefined ? {} : _abstractNodes$attrib,\n      _abstractNodes$childr = abstractNodes.children,\n      children = _abstractNodes$childr === undefined ? [] : _abstractNodes$childr;\n\n  if (typeof abstractNodes === 'string') {\n    return htmlEscape(abstractNodes);\n  } else {\n    return '<' + tag + ' ' + joinAttributes(attributes) + '>' + children.map(toHtml).join('') + '</' + tag + '>';\n  }\n}\n\nvar noop$1 = function noop() {};\n\nfunction isWatched(node) {\n  var i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;\n\n  return typeof i2svg === 'string';\n}\n\nfunction getMutator() {\n  if (config$1.autoReplaceSvg === true) {\n    return mutators.replace;\n  }\n\n  var mutator = mutators[config$1.autoReplaceSvg];\n\n  return mutator || mutators.replace;\n}\n\nvar mutators = {\n  replace: function replace(mutation) {\n    var node = mutation[0];\n    var abstract = mutation[1];\n    var newOuterHTML = abstract.map(function (a) {\n      return toHtml(a);\n    }).join('\\n');\n\n    if (node.parentNode && node.outerHTML) {\n      node.outerHTML = newOuterHTML + (config$1.keepOriginalSource && node.tagName.toLowerCase() !== 'svg' ? '<!-- ' + node.outerHTML + ' -->' : '');\n    } else if (node.parentNode) {\n      var newNode = document.createElement('span');\n      node.parentNode.replaceChild(newNode, node);\n      newNode.outerHTML = newOuterHTML;\n    }\n  },\n  nest: function nest(mutation) {\n    var node = mutation[0];\n    var abstract = mutation[1];\n\n    // If we already have a replaced node we do not want to continue nesting within it.\n    // Short-circuit to the standard replacement\n    if (~classArray(node).indexOf(config$1.replacementClass)) {\n      return mutators.replace(mutation);\n    }\n\n    var forSvg = new RegExp(config$1.familyPrefix + '-.*');\n\n    delete abstract[0].attributes.style;\n\n    var splitClasses = abstract[0].attributes.class.split(' ').reduce(function (acc, cls) {\n      if (cls === config$1.replacementClass || cls.match(forSvg)) {\n        acc.toSvg.push(cls);\n      } else {\n        acc.toNode.push(cls);\n      }\n\n      return acc;\n    }, { toNode: [], toSvg: [] });\n\n    abstract[0].attributes.class = splitClasses.toSvg.join(' ');\n\n    var newInnerHTML = abstract.map(function (a) {\n      return toHtml(a);\n    }).join('\\n');\n    node.setAttribute('class', splitClasses.toNode.join(' '));\n    node.setAttribute(DATA_FA_I2SVG, '');\n    node.innerHTML = newInnerHTML;\n  }\n};\n\nfunction perform(mutations, callback) {\n  var callbackFunction = typeof callback === 'function' ? callback : noop$1;\n\n  if (mutations.length === 0) {\n    callbackFunction();\n  } else {\n    var frame = WINDOW.requestAnimationFrame || function (op) {\n      return op();\n    };\n\n    frame(function () {\n      var mutator = getMutator();\n      var mark = perf.begin('mutate');\n\n      mutations.map(mutator);\n\n      mark();\n\n      callbackFunction();\n    });\n  }\n}\n\nvar disabled = false;\n\nfunction disableObservation(operation) {\n  disabled = true;\n  operation();\n  disabled = false;\n}\n\nvar mo = null;\n\nfunction observe(options) {\n  if (!MUTATION_OBSERVER) return;\n\n  var treeCallback = options.treeCallback,\n      nodeCallback = options.nodeCallback,\n      pseudoElementsCallback = options.pseudoElementsCallback;\n\n  mo = new MUTATION_OBSERVER(function (objects) {\n    if (disabled) return;\n\n    toArray(objects).forEach(function (mutationRecord) {\n      if (mutationRecord.type === 'childList' && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {\n        if (config$1.searchPseudoElements) {\n          pseudoElementsCallback(mutationRecord.target);\n        }\n\n        treeCallback(mutationRecord.target);\n      }\n\n      if (mutationRecord.type === 'attributes' && mutationRecord.target.parentNode && config$1.searchPseudoElements) {\n        pseudoElementsCallback(mutationRecord.target.parentNode);\n      }\n\n      if (mutationRecord.type === 'attributes' && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {\n        if (mutationRecord.attributeName === 'class') {\n          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)),\n              prefix = _getCanonicalIcon.prefix,\n              iconName = _getCanonicalIcon.iconName;\n\n          if (prefix) mutationRecord.target.setAttribute('data-prefix', prefix);\n          if (iconName) mutationRecord.target.setAttribute('data-icon', iconName);\n        } else {\n          nodeCallback(mutationRecord.target);\n        }\n      }\n    });\n  });\n\n  if (!IS_DOM) return;\n\n  mo.observe(DOCUMENT.getElementsByTagName('body')[0], {\n    childList: true, attributes: true, characterData: true, subtree: true\n  });\n}\n\nfunction disconnect() {\n  if (!mo) return;\n\n  mo.disconnect();\n}\n\nvar styleParser = function styleParser(node) {\n  var style = node.getAttribute('style');\n\n  var val = [];\n\n  if (style) {\n    val = style.split(';').reduce(function (acc, style) {\n      var styles = style.split(':');\n      var prop = styles[0];\n      var value = styles.slice(1);\n\n      if (prop && value.length > 0) {\n        acc[prop] = value.join(':').trim();\n      }\n\n      return acc;\n    }, {});\n  }\n\n  return val;\n};\n\nfunction toHex(unicode) {\n  var result = '';\n\n  for (var i = 0; i < unicode.length; i++) {\n    var hex = unicode.charCodeAt(i).toString(16);\n    result += ('000' + hex).slice(-4);\n  }\n\n  return result;\n}\n\nvar classParser = function classParser(node) {\n  var existingPrefix = node.getAttribute('data-prefix');\n  var existingIconName = node.getAttribute('data-icon');\n  var innerText = node.innerText !== undefined ? node.innerText.trim() : '';\n\n  var val = getCanonicalIcon(classArray(node));\n\n  if (existingPrefix && existingIconName) {\n    val.prefix = existingPrefix;\n    val.iconName = existingIconName;\n  }\n\n  if (val.prefix && innerText.length > 1) {\n    val.iconName = byLigature(val.prefix, node.innerText);\n  } else if (val.prefix && innerText.length === 1) {\n    val.iconName = byUnicode(val.prefix, toHex(node.innerText));\n  }\n\n  return val;\n};\n\nvar parseTransformString = function parseTransformString(transformString) {\n  var transform = {\n    size: 16,\n    x: 0,\n    y: 0,\n    flipX: false,\n    flipY: false,\n    rotate: 0\n  };\n\n  if (!transformString) {\n    return transform;\n  } else {\n    return transformString.toLowerCase().split(' ').reduce(function (acc, n) {\n      var parts = n.toLowerCase().split('-');\n      var first = parts[0];\n      var rest = parts.slice(1).join('-');\n\n      if (first && rest === 'h') {\n        acc.flipX = true;\n        return acc;\n      }\n\n      if (first && rest === 'v') {\n        acc.flipY = true;\n        return acc;\n      }\n\n      rest = parseFloat(rest);\n\n      if (isNaN(rest)) {\n        return acc;\n      }\n\n      switch (first) {\n        case 'grow':\n          acc.size = acc.size + rest;\n          break;\n        case 'shrink':\n          acc.size = acc.size - rest;\n          break;\n        case 'left':\n          acc.x = acc.x - rest;\n          break;\n        case 'right':\n          acc.x = acc.x + rest;\n          break;\n        case 'up':\n          acc.y = acc.y - rest;\n          break;\n        case 'down':\n          acc.y = acc.y + rest;\n          break;\n        case 'rotate':\n          acc.rotate = acc.rotate + rest;\n          break;\n      }\n\n      return acc;\n    }, transform);\n  }\n};\n\nvar transformParser = function transformParser(node) {\n  return parseTransformString(node.getAttribute('data-fa-transform'));\n};\n\nvar symbolParser = function symbolParser(node) {\n  var symbol = node.getAttribute('data-fa-symbol');\n\n  return symbol === null ? false : symbol === '' ? true : symbol;\n};\n\nvar attributesParser = function attributesParser(node) {\n  var extraAttributes = toArray(node.attributes).reduce(function (acc, attr) {\n    if (acc.name !== 'class' && acc.name !== 'style') {\n      acc[attr.name] = attr.value;\n    }\n    return acc;\n  }, {});\n\n  var title = node.getAttribute('title');\n\n  if (config$1.autoA11y) {\n    if (title) {\n      extraAttributes['aria-labelledby'] = config$1.replacementClass + '-title-' + nextUniqueId();\n    } else {\n      extraAttributes['aria-hidden'] = 'true';\n    }\n  }\n\n  return extraAttributes;\n};\n\nvar maskParser = function maskParser(node) {\n  var mask = node.getAttribute('data-fa-mask');\n\n  if (!mask) {\n    return emptyCanonicalIcon();\n  } else {\n    return getCanonicalIcon(mask.split(' ').map(function (i) {\n      return i.trim();\n    }));\n  }\n};\n\nfunction parseMeta(node) {\n  var _classParser = classParser(node),\n      iconName = _classParser.iconName,\n      prefix = _classParser.prefix,\n      extraClasses = _classParser.rest;\n\n  var extraStyles = styleParser(node);\n  var transform = transformParser(node);\n  var symbol = symbolParser(node);\n  var extraAttributes = attributesParser(node);\n  var mask = maskParser(node);\n\n  return {\n    iconName: iconName,\n    title: node.getAttribute('title'),\n    prefix: prefix,\n    transform: transform,\n    symbol: symbol,\n    mask: mask,\n    extra: {\n      classes: extraClasses,\n      styles: extraStyles,\n      attributes: extraAttributes\n    }\n  };\n}\n\nfunction MissingIcon(error) {\n  this.name = 'MissingIcon';\n  this.message = error || 'Icon unavailable';\n  this.stack = new Error().stack;\n}\n\nMissingIcon.prototype = Object.create(Error.prototype);\nMissingIcon.prototype.constructor = MissingIcon;\n\nvar FILL = { fill: 'currentColor' };\nvar ANIMATION_BASE = {\n  attributeType: 'XML',\n  repeatCount: 'indefinite',\n  dur: '2s'\n};\nvar RING = {\n  tag: 'path',\n  attributes: _extends({}, FILL, {\n    d: 'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'\n  })\n};\nvar OPACITY_ANIMATE = _extends({}, ANIMATION_BASE, {\n  attributeName: 'opacity'\n});\nvar DOT = {\n  tag: 'circle',\n  attributes: _extends({}, FILL, {\n    cx: '256',\n    cy: '364',\n    r: '28'\n  }),\n  children: [{ tag: 'animate', attributes: _extends({}, ANIMATION_BASE, { attributeName: 'r', values: '28;14;28;28;14;28;' }) }, { tag: 'animate', attributes: _extends({}, OPACITY_ANIMATE, { values: '1;0;1;1;0;1;' }) }]\n};\nvar QUESTION = {\n  tag: 'path',\n  attributes: _extends({}, FILL, {\n    opacity: '1',\n    d: 'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'\n  }),\n  children: [{ tag: 'animate', attributes: _extends({}, OPACITY_ANIMATE, { values: '1;0;0;0;0;1;' }) }]\n};\nvar EXCLAMATION = {\n  tag: 'path',\n  attributes: _extends({}, FILL, {\n    opacity: '0',\n    d: 'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'\n  }),\n  children: [{ tag: 'animate', attributes: _extends({}, OPACITY_ANIMATE, { values: '0;0;1;1;0;0;' }) }]\n};\n\nvar missing = { tag: 'g', children: [RING, DOT, QUESTION, EXCLAMATION] };\n\nvar styles = namespace.styles;\n\nvar LAYERS_TEXT_CLASSNAME = 'fa-layers-text';\nvar FONT_FAMILY_PATTERN = /Font Awesome 5 (Solid|Regular|Light|Brands)/;\nvar STYLE_TO_PREFIX = {\n  'Solid': 'fas',\n  'Regular': 'far',\n  'Light': 'fal',\n  'Brands': 'fab'\n};\n\nfunction findIcon(iconName, prefix) {\n  var val = {\n    found: false,\n    width: 512,\n    height: 512,\n    icon: missing\n  };\n\n  if (iconName && prefix && styles[prefix] && styles[prefix][iconName]) {\n    var icon = styles[prefix][iconName];\n    var width = icon[0];\n    var height = icon[1];\n    var vectorData = icon.slice(4);\n\n    val = {\n      found: true,\n      width: width,\n      height: height,\n      icon: { tag: 'path', attributes: { fill: 'currentColor', d: vectorData[0] } }\n    };\n  } else if (iconName && prefix && !config$1.showMissingIcons) {\n    throw new MissingIcon('Icon is missing for prefix ' + prefix + ' with icon name ' + iconName);\n  }\n\n  return val;\n}\n\nfunction generateSvgReplacementMutation(node, nodeMeta) {\n  var iconName = nodeMeta.iconName,\n      title = nodeMeta.title,\n      prefix = nodeMeta.prefix,\n      transform = nodeMeta.transform,\n      symbol = nodeMeta.symbol,\n      mask = nodeMeta.mask,\n      extra = nodeMeta.extra;\n\n  return [node, makeInlineSvgAbstract({\n    icons: {\n      main: findIcon(iconName, prefix),\n      mask: findIcon(mask.iconName, mask.prefix)\n    },\n    prefix: prefix,\n    iconName: iconName,\n    transform: transform,\n    symbol: symbol,\n    mask: mask,\n    title: title,\n    extra: extra,\n    watchable: true\n  })];\n}\n\nfunction generateLayersText(node, nodeMeta) {\n  var title = nodeMeta.title,\n      transform = nodeMeta.transform,\n      extra = nodeMeta.extra;\n\n  var width = null;\n  var height = null;\n\n  if (IS_IE) {\n    var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);\n    var boundingClientRect = node.getBoundingClientRect();\n    width = boundingClientRect.width / computedFontSize;\n    height = boundingClientRect.height / computedFontSize;\n  }\n\n  if (config$1.autoA11y && !title) {\n    extra.attributes['aria-hidden'] = 'true';\n  }\n\n  return [node, makeLayersTextAbstract({\n    content: node.innerHTML,\n    width: width,\n    height: height,\n    transform: transform,\n    title: title,\n    extra: extra,\n    watchable: true\n  })];\n}\n\nfunction generateMutation(node) {\n  var nodeMeta = parseMeta(node);\n\n  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {\n    return generateLayersText(node, nodeMeta);\n  } else {\n    return generateSvgReplacementMutation(node, nodeMeta);\n  }\n}\n\nfunction remove(node) {\n  if (typeof node.remove === 'function') {\n    node.remove();\n  } else if (node && node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\n\nfunction searchPseudoElements(root) {\n  if (!IS_DOM) return;\n\n  var end = perf.begin('searchPseudoElements');\n\n  disableObservation(function () {\n    toArray(root.querySelectorAll('*')).forEach(function (node) {\n      [':before', ':after'].forEach(function (pos) {\n        var styles = WINDOW.getComputedStyle(node, pos);\n        var fontFamily = styles.getPropertyValue('font-family').match(FONT_FAMILY_PATTERN);\n        var children = toArray(node.children);\n        var pseudoElement = children.filter(function (c) {\n          return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === pos;\n        })[0];\n\n        if (pseudoElement) {\n          if (pseudoElement.nextSibling && pseudoElement.nextSibling.textContent.indexOf(DATA_FA_PSEUDO_ELEMENT) > -1) {\n            remove(pseudoElement.nextSibling);\n          }\n          remove(pseudoElement);\n          pseudoElement = null;\n        }\n\n        if (fontFamily && !pseudoElement) {\n          var content = styles.getPropertyValue('content');\n          var i = DOCUMENT.createElement('i');\n          i.setAttribute('class', '' + STYLE_TO_PREFIX[fontFamily[1]]);\n          i.setAttribute(DATA_FA_PSEUDO_ELEMENT, pos);\n          i.innerText = content.length === 3 ? content.substr(1, 1) : content;\n          if (pos === ':before') {\n            node.insertBefore(i, node.firstChild);\n          } else {\n            node.appendChild(i);\n          }\n        }\n      });\n    });\n  });\n\n  end();\n}\n\nfunction onTree(root) {\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!IS_DOM) return;\n\n  var htmlClassList = DOCUMENT.documentElement.classList;\n  var hclAdd = function hclAdd(suffix) {\n    return htmlClassList.add(HTML_CLASS_I2SVG_BASE_CLASS + '-' + suffix);\n  };\n  var hclRemove = function hclRemove(suffix) {\n    return htmlClassList.remove(HTML_CLASS_I2SVG_BASE_CLASS + '-' + suffix);\n  };\n  var prefixes = Object.keys(styles);\n  var prefixesDomQuery = ['.' + LAYERS_TEXT_CLASSNAME + ':not([' + DATA_FA_I2SVG + '])'].concat(prefixes.map(function (p) {\n    return '.' + p + ':not([' + DATA_FA_I2SVG + '])';\n  })).join(', ');\n\n  if (prefixesDomQuery.length === 0) {\n    return;\n  }\n\n  var candidates = toArray(root.querySelectorAll(prefixesDomQuery));\n\n  if (candidates.length > 0) {\n    hclAdd('pending');\n    hclRemove('complete');\n  } else {\n    return;\n  }\n\n  var mark = perf.begin('onTree');\n\n  var mutations = candidates.reduce(function (acc, node) {\n    try {\n      var mutation = generateMutation(node);\n\n      if (mutation) {\n        acc.push(mutation);\n      }\n    } catch (e) {\n      if (!PRODUCTION) {\n        if (e instanceof MissingIcon) {\n          console.error(e);\n        }\n      }\n    }\n\n    return acc;\n  }, []);\n\n  mark();\n\n  perform(mutations, function () {\n    hclAdd('active');\n    hclAdd('complete');\n    hclRemove('pending');\n\n    if (typeof callback === 'function') callback();\n  });\n}\n\nfunction onNode(node) {\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  var mutation = generateMutation(node);\n\n  if (mutation) {\n    perform([mutation], callback);\n  }\n}\n\nvar baseStyles = \"svg:not(:root).svg-inline--fa {\\n  overflow: visible; }\\n\\n.svg-inline--fa {\\n  display: inline-block;\\n  font-size: inherit;\\n  height: 1em;\\n  overflow: visible;\\n  vertical-align: -.125em; }\\n  .svg-inline--fa.fa-lg {\\n    vertical-align: -.225em; }\\n  .svg-inline--fa.fa-w-1 {\\n    width: 0.0625em; }\\n  .svg-inline--fa.fa-w-2 {\\n    width: 0.125em; }\\n  .svg-inline--fa.fa-w-3 {\\n    width: 0.1875em; }\\n  .svg-inline--fa.fa-w-4 {\\n    width: 0.25em; }\\n  .svg-inline--fa.fa-w-5 {\\n    width: 0.3125em; }\\n  .svg-inline--fa.fa-w-6 {\\n    width: 0.375em; }\\n  .svg-inline--fa.fa-w-7 {\\n    width: 0.4375em; }\\n  .svg-inline--fa.fa-w-8 {\\n    width: 0.5em; }\\n  .svg-inline--fa.fa-w-9 {\\n    width: 0.5625em; }\\n  .svg-inline--fa.fa-w-10 {\\n    width: 0.625em; }\\n  .svg-inline--fa.fa-w-11 {\\n    width: 0.6875em; }\\n  .svg-inline--fa.fa-w-12 {\\n    width: 0.75em; }\\n  .svg-inline--fa.fa-w-13 {\\n    width: 0.8125em; }\\n  .svg-inline--fa.fa-w-14 {\\n    width: 0.875em; }\\n  .svg-inline--fa.fa-w-15 {\\n    width: 0.9375em; }\\n  .svg-inline--fa.fa-w-16 {\\n    width: 1em; }\\n  .svg-inline--fa.fa-w-17 {\\n    width: 1.0625em; }\\n  .svg-inline--fa.fa-w-18 {\\n    width: 1.125em; }\\n  .svg-inline--fa.fa-w-19 {\\n    width: 1.1875em; }\\n  .svg-inline--fa.fa-w-20 {\\n    width: 1.25em; }\\n  .svg-inline--fa.fa-pull-left {\\n    margin-right: .3em;\\n    width: auto; }\\n  .svg-inline--fa.fa-pull-right {\\n    margin-left: .3em;\\n    width: auto; }\\n  .svg-inline--fa.fa-border {\\n    height: 1.5em; }\\n  .svg-inline--fa.fa-li {\\n    width: 2em; }\\n  .svg-inline--fa.fa-fw {\\n    width: 1.25em; }\\n\\n.fa-layers svg.svg-inline--fa {\\n  bottom: 0;\\n  left: 0;\\n  margin: auto;\\n  position: absolute;\\n  right: 0;\\n  top: 0; }\\n\\n.fa-layers {\\n  display: inline-block;\\n  height: 1em;\\n  position: relative;\\n  text-align: center;\\n  vertical-align: -.125em;\\n  width: 1em; }\\n  .fa-layers svg.svg-inline--fa {\\n    -webkit-transform-origin: center center;\\n            transform-origin: center center; }\\n\\n.fa-layers-text, .fa-layers-counter {\\n  display: inline-block;\\n  position: absolute;\\n  text-align: center; }\\n\\n.fa-layers-text {\\n  left: 50%;\\n  top: 50%;\\n  -webkit-transform: translate(-50%, -50%);\\n          transform: translate(-50%, -50%);\\n  -webkit-transform-origin: center center;\\n          transform-origin: center center; }\\n\\n.fa-layers-counter {\\n  background-color: #ff253a;\\n  border-radius: 1em;\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box;\\n  color: #fff;\\n  height: 1.5em;\\n  line-height: 1;\\n  max-width: 5em;\\n  min-width: 1.5em;\\n  overflow: hidden;\\n  padding: .25em;\\n  right: 0;\\n  text-overflow: ellipsis;\\n  top: 0;\\n  -webkit-transform: scale(0.25);\\n          transform: scale(0.25);\\n  -webkit-transform-origin: top right;\\n          transform-origin: top right; }\\n\\n.fa-layers-bottom-right {\\n  bottom: 0;\\n  right: 0;\\n  top: auto;\\n  -webkit-transform: scale(0.25);\\n          transform: scale(0.25);\\n  -webkit-transform-origin: bottom right;\\n          transform-origin: bottom right; }\\n\\n.fa-layers-bottom-left {\\n  bottom: 0;\\n  left: 0;\\n  right: auto;\\n  top: auto;\\n  -webkit-transform: scale(0.25);\\n          transform: scale(0.25);\\n  -webkit-transform-origin: bottom left;\\n          transform-origin: bottom left; }\\n\\n.fa-layers-top-right {\\n  right: 0;\\n  top: 0;\\n  -webkit-transform: scale(0.25);\\n          transform: scale(0.25);\\n  -webkit-transform-origin: top right;\\n          transform-origin: top right; }\\n\\n.fa-layers-top-left {\\n  left: 0;\\n  right: auto;\\n  top: 0;\\n  -webkit-transform: scale(0.25);\\n          transform: scale(0.25);\\n  -webkit-transform-origin: top left;\\n          transform-origin: top left; }\\n\\n.fa-lg {\\n  font-size: 1.33333em;\\n  line-height: 0.75em;\\n  vertical-align: -.0667em; }\\n\\n.fa-xs {\\n  font-size: .75em; }\\n\\n.fa-sm {\\n  font-size: .875em; }\\n\\n.fa-1x {\\n  font-size: 1em; }\\n\\n.fa-2x {\\n  font-size: 2em; }\\n\\n.fa-3x {\\n  font-size: 3em; }\\n\\n.fa-4x {\\n  font-size: 4em; }\\n\\n.fa-5x {\\n  font-size: 5em; }\\n\\n.fa-6x {\\n  font-size: 6em; }\\n\\n.fa-7x {\\n  font-size: 7em; }\\n\\n.fa-8x {\\n  font-size: 8em; }\\n\\n.fa-9x {\\n  font-size: 9em; }\\n\\n.fa-10x {\\n  font-size: 10em; }\\n\\n.fa-fw {\\n  text-align: center;\\n  width: 1.25em; }\\n\\n.fa-ul {\\n  list-style-type: none;\\n  margin-left: 2.5em;\\n  padding-left: 0; }\\n  .fa-ul > li {\\n    position: relative; }\\n\\n.fa-li {\\n  left: -2em;\\n  position: absolute;\\n  text-align: center;\\n  width: 2em;\\n  line-height: inherit; }\\n\\n.fa-border {\\n  border: solid 0.08em #eee;\\n  border-radius: .1em;\\n  padding: .2em .25em .15em; }\\n\\n.fa-pull-left {\\n  float: left; }\\n\\n.fa-pull-right {\\n  float: right; }\\n\\n.fa.fa-pull-left,\\n.fas.fa-pull-left,\\n.far.fa-pull-left,\\n.fal.fa-pull-left,\\n.fab.fa-pull-left {\\n  margin-right: .3em; }\\n\\n.fa.fa-pull-right,\\n.fas.fa-pull-right,\\n.far.fa-pull-right,\\n.fal.fa-pull-right,\\n.fab.fa-pull-right {\\n  margin-left: .3em; }\\n\\n.fa-spin {\\n  -webkit-animation: fa-spin 2s infinite linear;\\n          animation: fa-spin 2s infinite linear; }\\n\\n.fa-pulse {\\n  -webkit-animation: fa-spin 1s infinite steps(8);\\n          animation: fa-spin 1s infinite steps(8); }\\n\\n@-webkit-keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg); }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg); } }\\n\\n@keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n            transform: rotate(0deg); }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n            transform: rotate(360deg); } }\\n\\n.fa-rotate-90 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\\\";\\n  -webkit-transform: rotate(90deg);\\n          transform: rotate(90deg); }\\n\\n.fa-rotate-180 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\\\";\\n  -webkit-transform: rotate(180deg);\\n          transform: rotate(180deg); }\\n\\n.fa-rotate-270 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\\\";\\n  -webkit-transform: rotate(270deg);\\n          transform: rotate(270deg); }\\n\\n.fa-flip-horizontal {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\\\";\\n  -webkit-transform: scale(-1, 1);\\n          transform: scale(-1, 1); }\\n\\n.fa-flip-vertical {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\\\";\\n  -webkit-transform: scale(1, -1);\\n          transform: scale(1, -1); }\\n\\n.fa-flip-horizontal.fa-flip-vertical {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\\\";\\n  -webkit-transform: scale(-1, -1);\\n          transform: scale(-1, -1); }\\n\\n:root .fa-rotate-90,\\n:root .fa-rotate-180,\\n:root .fa-rotate-270,\\n:root .fa-flip-horizontal,\\n:root .fa-flip-vertical {\\n  -webkit-filter: none;\\n          filter: none; }\\n\\n.fa-stack {\\n  display: inline-block;\\n  height: 2em;\\n  position: relative;\\n  width: 2em; }\\n\\n.fa-stack-1x,\\n.fa-stack-2x {\\n  bottom: 0;\\n  left: 0;\\n  margin: auto;\\n  position: absolute;\\n  right: 0;\\n  top: 0; }\\n\\n.svg-inline--fa.fa-stack-1x {\\n  height: 1em;\\n  width: 1em; }\\n\\n.svg-inline--fa.fa-stack-2x {\\n  height: 2em;\\n  width: 2em; }\\n\\n.fa-inverse {\\n  color: #fff; }\\n\\n.sr-only {\\n  border: 0;\\n  clip: rect(0, 0, 0, 0);\\n  height: 1px;\\n  margin: -1px;\\n  overflow: hidden;\\n  padding: 0;\\n  position: absolute;\\n  width: 1px; }\\n\\n.sr-only-focusable:active, .sr-only-focusable:focus {\\n  clip: auto;\\n  height: auto;\\n  margin: 0;\\n  overflow: visible;\\n  position: static;\\n  width: auto; }\\n\";\n\nvar css = function css() {\n  var dfp = DEFAULT_FAMILY_PREFIX;\n  var drc = DEFAULT_REPLACEMENT_CLASS;\n  var fp = config$1.familyPrefix;\n  var rc = config$1.replacementClass;\n  var s = baseStyles;\n\n  if (fp !== dfp || rc !== drc) {\n    var dPatt = new RegExp('\\\\.' + dfp + '\\\\-', 'g');\n    var rPatt = new RegExp('\\\\.' + drc, 'g');\n\n    s = s.replace(dPatt, '.' + fp + '-').replace(rPatt, '.' + rc);\n  }\n\n  return s;\n};\n\nfunction define(prefix, icons) {\n  var normalized = Object.keys(icons).reduce(function (acc, iconName) {\n    var icon = icons[iconName];\n    var expanded = !!icon.icon;\n\n    if (expanded) {\n      acc[icon.iconName] = icon.icon;\n    } else {\n      acc[iconName] = icon;\n    }\n    return acc;\n  }, {});\n\n  if (typeof namespace.hooks.addPack === 'function') {\n    namespace.hooks.addPack(prefix, normalized);\n  } else {\n    namespace.styles[prefix] = _extends({}, namespace.styles[prefix] || {}, normalized);\n  }\n\n  /**\n   * Font Awesome 4 used the prefix of `fa` for all icons. With the introduction\n   * of new styles we needed to differentiate between them. Prefix `fa` is now an alias\n   * for `fas` so we'll easy the upgrade process for our users by automatically defining\n   * this as well.\n   */\n  if (prefix === 'fas') {\n    define('fa', icons);\n  }\n}\n\nvar Library = function () {\n  function Library() {\n    classCallCheck(this, Library);\n\n    this.definitions = {};\n  }\n\n  createClass(Library, [{\n    key: 'add',\n    value: function add() {\n      var _this = this;\n\n      for (var _len = arguments.length, definitions = Array(_len), _key = 0; _key < _len; _key++) {\n        definitions[_key] = arguments[_key];\n      }\n\n      var additions = definitions.reduce(this._pullDefinitions, {});\n\n      Object.keys(additions).forEach(function (key) {\n        _this.definitions[key] = _extends({}, _this.definitions[key] || {}, additions[key]);\n        define(key, additions[key]);\n      });\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.definitions = {};\n    }\n  }, {\n    key: '_pullDefinitions',\n    value: function _pullDefinitions(additions, definition) {\n      var normalized = definition.prefix && definition.iconName && definition.icon ? { 0: definition } : definition;\n\n      Object.keys(normalized).map(function (key) {\n        var _normalized$key = normalized[key],\n            prefix = _normalized$key.prefix,\n            iconName = _normalized$key.iconName,\n            icon = _normalized$key.icon;\n\n        if (!additions[prefix]) additions[prefix] = {};\n\n        additions[prefix][iconName] = icon;\n      });\n\n      return additions;\n    }\n  }]);\n  return Library;\n}();\n\nfunction prepIcon(icon) {\n  var width = icon[0];\n  var height = icon[1];\n  var vectorData = icon.slice(4);\n\n  return {\n    found: true,\n    width: width,\n    height: height,\n    icon: { tag: 'path', attributes: { fill: 'currentColor', d: vectorData[0] } }\n  };\n}\n\nvar _cssInserted = false;\n\nfunction ensureCss() {\n  if (!config$1.autoAddCss) {\n    return;\n  }\n\n  if (!_cssInserted) {\n    insertCss(css());\n  }\n\n  _cssInserted = true;\n}\n\nfunction apiObject(val, abstractCreator) {\n  Object.defineProperty(val, 'abstract', {\n    get: abstractCreator\n  });\n\n  Object.defineProperty(val, 'html', {\n    get: function get() {\n      return val.abstract.map(function (a) {\n        return toHtml(a);\n      });\n    }\n  });\n\n  Object.defineProperty(val, 'node', {\n    get: function get() {\n      if (!IS_DOM) return;\n\n      var container = DOCUMENT.createElement('div');\n      container.innerHTML = val.html;\n      return container.children;\n    }\n  });\n\n  return val;\n}\n\nfunction findIconDefinition(params) {\n  var _params$prefix = params.prefix,\n      prefix = _params$prefix === undefined ? 'fa' : _params$prefix,\n      iconName = params.iconName;\n\n  if (!iconName) return;\n\n  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);\n}\n\nfunction resolveIcons(next) {\n  return function (maybeIconDefinition) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});\n\n    var mask = params.mask;\n\n    if (mask) {\n      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});\n    }\n\n    return next(iconDefinition, _extends({}, params, { mask: mask }));\n  };\n}\n\nvar library = new Library();\n\nvar noAuto = function noAuto() {\n  auto(false);\n  disconnect();\n};\n\nvar dom = {\n  i2svg: function i2svg() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (IS_DOM) {\n      ensureCss();\n\n      var _params$node = params.node,\n          node = _params$node === undefined ? DOCUMENT : _params$node,\n          _params$callback = params.callback,\n          callback = _params$callback === undefined ? function () {} : _params$callback;\n\n      if (config$1.searchPseudoElements) {\n        searchPseudoElements(node);\n      }\n\n      onTree(node, callback);\n    }\n  },\n\n  css: css,\n\n  insertCss: function insertCss$$1() {\n    insertCss(css());\n  }\n};\n\nvar parse = {\n  transform: function transform(transformString) {\n    return parseTransformString(transformString);\n  }\n};\n\nvar icon = resolveIcons(function (iconDefinition) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _params$transform = params.transform,\n      transform = _params$transform === undefined ? meaninglessTransform : _params$transform,\n      _params$symbol = params.symbol,\n      symbol = _params$symbol === undefined ? false : _params$symbol,\n      _params$mask = params.mask,\n      mask = _params$mask === undefined ? null : _params$mask,\n      _params$title = params.title,\n      title = _params$title === undefined ? null : _params$title,\n      _params$classes = params.classes,\n      classes = _params$classes === undefined ? [] : _params$classes,\n      _params$attributes = params.attributes,\n      attributes = _params$attributes === undefined ? {} : _params$attributes,\n      _params$styles = params.styles,\n      styles = _params$styles === undefined ? {} : _params$styles;\n\n  if (!iconDefinition) return;\n\n  var prefix = iconDefinition.prefix,\n      iconName = iconDefinition.iconName,\n      icon = iconDefinition.icon;\n\n  return apiObject(_extends({ type: 'icon' }, iconDefinition), function () {\n    ensureCss();\n\n    if (config$1.autoA11y) {\n      if (title) {\n        attributes['aria-labelledby'] = config$1.replacementClass + '-title-' + nextUniqueId();\n      } else {\n        attributes['aria-hidden'] = 'true';\n      }\n    }\n\n    return makeInlineSvgAbstract({\n      icons: {\n        main: prepIcon(icon),\n        mask: mask ? prepIcon(mask.icon) : { found: false, width: null, height: null, icon: {} }\n      },\n      prefix: prefix,\n      iconName: iconName,\n      transform: _extends({}, meaninglessTransform, transform),\n      symbol: symbol,\n      title: title,\n      extra: {\n        attributes: attributes,\n        styles: styles,\n        classes: classes\n      }\n    });\n  });\n});\n\nvar text = function text(content) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _params$transform2 = params.transform,\n      transform = _params$transform2 === undefined ? meaninglessTransform : _params$transform2,\n      _params$title2 = params.title,\n      title = _params$title2 === undefined ? null : _params$title2,\n      _params$classes2 = params.classes,\n      classes = _params$classes2 === undefined ? [] : _params$classes2,\n      _params$attributes2 = params.attributes,\n      attributes = _params$attributes2 === undefined ? {} : _params$attributes2,\n      _params$styles2 = params.styles,\n      styles = _params$styles2 === undefined ? {} : _params$styles2;\n\n  return apiObject({ type: 'text', content: content }, function () {\n    ensureCss();\n\n    return makeLayersTextAbstract({\n      content: content,\n      transform: _extends({}, meaninglessTransform, transform),\n      title: title,\n      extra: {\n        attributes: attributes,\n        styles: styles,\n        classes: [config$1.familyPrefix + '-layers-text'].concat(toConsumableArray(classes))\n      }\n    });\n  });\n};\n\nvar layer = function layer(assembler) {\n  return apiObject({ type: 'layer' }, function () {\n    ensureCss();\n\n    var children = [];\n\n    assembler(function (args) {\n      Array.isArray(args) ? args.map(function (a) {\n        children = children.concat(a.abstract);\n      }) : children = children.concat(args.abstract);\n    });\n\n    return [{\n      tag: 'span',\n      attributes: { class: config$1.familyPrefix + '-layers' },\n      children: children\n    }];\n  });\n};\n\nvar api$1 = {\n  noAuto: noAuto,\n  dom: dom,\n  library: library,\n  parse: parse,\n  findIconDefinition: findIconDefinition,\n  icon: icon,\n  text: text,\n  layer: layer\n};\n\nvar autoReplace = function autoReplace() {\n  if (IS_DOM && config$1.autoReplaceSvg) api$1.dom.i2svg({ node: DOCUMENT });\n};\n\nfunction bootstrap() {\n  if (IS_BROWSER) {\n    if (!WINDOW.FontAwesome) {\n      WINDOW.FontAwesome = api$1;\n    }\n\n    domready(function () {\n      if (Object.keys(namespace.styles).length > 0) {\n        autoReplace();\n      }\n\n      if (config$1.observeMutations && typeof MutationObserver === 'function') {\n        observe({\n          treeCallback: onTree,\n          nodeCallback: onNode,\n          pseudoElementsCallback: searchPseudoElements\n        });\n      }\n    });\n  }\n\n  namespace.hooks = _extends({}, namespace.hooks, {\n\n    addPack: function addPack(prefix, icons) {\n      namespace.styles[prefix] = _extends({}, namespace.styles[prefix] || {}, icons);\n\n      build();\n      autoReplace();\n    },\n\n    addShims: function addShims(shims) {\n      var _namespace$shims;\n\n      (_namespace$shims = namespace.shims).push.apply(_namespace$shims, toConsumableArray(shims));\n\n      build();\n      autoReplace();\n    }\n  });\n}\n\nObject.defineProperty(api$1, 'config', {\n  get: function get() {\n    return config$1;\n  },\n\n  set: function set(newConfig) {\n    update(newConfig);\n  }\n});\n\nif (IS_DOM) bunker(bootstrap);\n\nvar config = api$1.config;\n\nexports.config = config;\nexports.icon = icon;\nexports.noAuto = noAuto;\nexports.layer = layer;\nexports.text = text;\nexports.library = library;\nexports.dom = dom;\nexports.parse = parse;\nexports.findIconDefinition = findIconDefinition;\nexports.default = api$1;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lL2luZGV4LmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUvaW5kZXguZXMuanM/NGQ3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZvbnQgQXdlc29tZSBGcmVlIDUuMC4xMyBieSBAZm9udGF3ZXNvbWUgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbVxuICogTGljZW5zZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2xpY2Vuc2UgKEljb25zOiBDQyBCWSA0LjAsIEZvbnRzOiBTSUwgT0ZMIDEuMSwgQ29kZTogTUlUIExpY2Vuc2UpXG4gKi9cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgX1dJTkRPVyA9IHt9O1xudmFyIF9ET0NVTUVOVCA9IHt9O1xudmFyIF9NVVRBVElPTl9PQlNFUlZFUiQxID0gbnVsbDtcbnZhciBfUEVSRk9STUFOQ0UgPSB7IG1hcms6IG5vb3AsIG1lYXN1cmU6IG5vb3AgfTtcblxudHJ5IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBfV0lORE9XID0gd2luZG93O1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgX0RPQ1VNRU5UID0gZG9jdW1lbnQ7XG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIF9NVVRBVElPTl9PQlNFUlZFUiQxID0gTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcpIF9QRVJGT1JNQU5DRSA9IHBlcmZvcm1hbmNlO1xufSBjYXRjaCAoZSkge31cblxudmFyIF9yZWYgPSBfV0lORE9XLm5hdmlnYXRvciB8fCB7fTtcbnZhciBfcmVmJHVzZXJBZ2VudCA9IF9yZWYudXNlckFnZW50O1xudmFyIHVzZXJBZ2VudCA9IF9yZWYkdXNlckFnZW50ID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkdXNlckFnZW50O1xuXG52YXIgV0lORE9XID0gX1dJTkRPVztcbnZhciBET0NVTUVOVCA9IF9ET0NVTUVOVDtcbnZhciBNVVRBVElPTl9PQlNFUlZFUiA9IF9NVVRBVElPTl9PQlNFUlZFUiQxO1xudmFyIFBFUkZPUk1BTkNFID0gX1BFUkZPUk1BTkNFO1xudmFyIElTX0JST1dTRVIgPSAhIVdJTkRPVy5kb2N1bWVudDtcbnZhciBJU19ET00gPSAhIURPQ1VNRU5ULmRvY3VtZW50RWxlbWVudCAmJiAhIURPQ1VNRU5ULmhlYWQgJiYgdHlwZW9mIERPQ1VNRU5ULmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbic7XG52YXIgSVNfSUUgPSB+dXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSB8fCB+dXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cbnZhciBOQU1FU1BBQ0VfSURFTlRJRklFUiA9ICdfX19GT05UX0FXRVNPTUVfX18nO1xudmFyIFVOSVRTX0lOX0dSSUQgPSAxNjtcbnZhciBERUZBVUxUX0ZBTUlMWV9QUkVGSVggPSAnZmEnO1xudmFyIERFRkFVTFRfUkVQTEFDRU1FTlRfQ0xBU1MgPSAnc3ZnLWlubGluZS0tZmEnO1xudmFyIERBVEFfRkFfSTJTVkcgPSAnZGF0YS1mYS1pMnN2Zyc7XG52YXIgREFUQV9GQV9QU0VVRE9fRUxFTUVOVCA9ICdkYXRhLWZhLXBzZXVkby1lbGVtZW50JztcbnZhciBIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MgPSAnZm9udGF3ZXNvbWUtaTJzdmcnO1xuXG52YXIgUFJPRFVDVElPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSgpO1xuXG52YXIgb25lVG9UZW4gPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdO1xudmFyIG9uZVRvVHdlbnR5ID0gb25lVG9UZW4uY29uY2F0KFsxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMF0pO1xuXG52YXIgQVRUUklCVVRFU19XQVRDSEVEX0ZPUl9NVVRBVElPTiA9IFsnY2xhc3MnLCAnZGF0YS1wcmVmaXgnLCAnZGF0YS1pY29uJywgJ2RhdGEtZmEtdHJhbnNmb3JtJywgJ2RhdGEtZmEtbWFzayddO1xuXG52YXIgUkVTRVJWRURfQ0xBU1NFUyA9IFsneHMnLCAnc20nLCAnbGcnLCAnZncnLCAndWwnLCAnbGknLCAnYm9yZGVyJywgJ3B1bGwtbGVmdCcsICdwdWxsLXJpZ2h0JywgJ3NwaW4nLCAncHVsc2UnLCAncm90YXRlLTkwJywgJ3JvdGF0ZS0xODAnLCAncm90YXRlLTI3MCcsICdmbGlwLWhvcml6b250YWwnLCAnZmxpcC12ZXJ0aWNhbCcsICdzdGFjaycsICdzdGFjay0xeCcsICdzdGFjay0yeCcsICdpbnZlcnNlJywgJ2xheWVycycsICdsYXllcnMtdGV4dCcsICdsYXllcnMtY291bnRlciddLmNvbmNhdChvbmVUb1Rlbi5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAneCc7XG59KSkuY29uY2F0KG9uZVRvVHdlbnR5Lm1hcChmdW5jdGlvbiAobikge1xuICByZXR1cm4gJ3ctJyArIG47XG59KSk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG52YXIgaW5pdGlhbCA9IFdJTkRPVy5Gb250QXdlc29tZUNvbmZpZyB8fCB7fTtcbnZhciBpbml0aWFsS2V5cyA9IE9iamVjdC5rZXlzKGluaXRpYWwpO1xuXG52YXIgX2RlZmF1bHQgPSBfZXh0ZW5kcyh7XG4gIGZhbWlseVByZWZpeDogREVGQVVMVF9GQU1JTFlfUFJFRklYLFxuICByZXBsYWNlbWVudENsYXNzOiBERUZBVUxUX1JFUExBQ0VNRU5UX0NMQVNTLFxuICBhdXRvUmVwbGFjZVN2ZzogdHJ1ZSxcbiAgYXV0b0FkZENzczogdHJ1ZSxcbiAgYXV0b0ExMXk6IHRydWUsXG4gIHNlYXJjaFBzZXVkb0VsZW1lbnRzOiBmYWxzZSxcbiAgb2JzZXJ2ZU11dGF0aW9uczogdHJ1ZSxcbiAga2VlcE9yaWdpbmFsU291cmNlOiB0cnVlLFxuICBtZWFzdXJlUGVyZm9ybWFuY2U6IGZhbHNlLFxuICBzaG93TWlzc2luZ0ljb25zOiB0cnVlXG59LCBpbml0aWFsKTtcblxuaWYgKCFfZGVmYXVsdC5hdXRvUmVwbGFjZVN2ZykgX2RlZmF1bHQub2JzZXJ2ZU11dGF0aW9ucyA9IGZhbHNlO1xuXG52YXIgY29uZmlnJDEgPSBfZXh0ZW5kcyh7fSwgX2RlZmF1bHQpO1xuXG5XSU5ET1cuRm9udEF3ZXNvbWVDb25maWcgPSBjb25maWckMTtcblxuZnVuY3Rpb24gdXBkYXRlKG5ld0NvbmZpZykge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkYXNOZXdEZWZhdWx0ID0gcGFyYW1zLmFzTmV3RGVmYXVsdCxcbiAgICAgIGFzTmV3RGVmYXVsdCA9IF9wYXJhbXMkYXNOZXdEZWZhdWx0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wYXJhbXMkYXNOZXdEZWZhdWx0O1xuXG4gIHZhciB2YWxpZEtleXMgPSBPYmplY3Qua2V5cyhjb25maWckMSk7XG4gIHZhciBvayA9IGFzTmV3RGVmYXVsdCA/IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIH52YWxpZEtleXMuaW5kZXhPZihrKSAmJiAhfmluaXRpYWxLZXlzLmluZGV4T2Yoayk7XG4gIH0gOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiB+dmFsaWRLZXlzLmluZGV4T2Yoayk7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMobmV3Q29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdLZXkpIHtcbiAgICBpZiAob2soY29uZmlnS2V5KSkgY29uZmlnJDFbY29uZmlnS2V5XSA9IG5ld0NvbmZpZ1tjb25maWdLZXldO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXV0byh2YWx1ZSkge1xuICB1cGRhdGUoe1xuICAgIGF1dG9SZXBsYWNlU3ZnOiB2YWx1ZSxcbiAgICBvYnNlcnZlTXV0YXRpb25zOiB2YWx1ZVxuICB9KTtcbn1cblxudmFyIHcgPSBXSU5ET1cgfHwge307XG5cbmlmICghd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0pIHdbTkFNRVNQQUNFX0lERU5USUZJRVJdID0ge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdLnN0eWxlcykgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc3R5bGVzID0ge307XG5pZiAoIXdbTkFNRVNQQUNFX0lERU5USUZJRVJdLmhvb2tzKSB3W05BTUVTUEFDRV9JREVOVElGSUVSXS5ob29rcyA9IHt9O1xuaWYgKCF3W05BTUVTUEFDRV9JREVOVElGSUVSXS5zaGltcykgd1tOQU1FU1BBQ0VfSURFTlRJRklFUl0uc2hpbXMgPSBbXTtcblxudmFyIG5hbWVzcGFjZSA9IHdbTkFNRVNQQUNFX0lERU5USUZJRVJdO1xuXG52YXIgZnVuY3Rpb25zID0gW107XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgRE9DVU1FTlQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGxpc3RlbmVyKTtcbiAgbG9hZGVkID0gMTtcbiAgZnVuY3Rpb25zLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSk7XG59O1xuXG52YXIgbG9hZGVkID0gZmFsc2U7XG5cbmlmIChJU19ET00pIHtcbiAgbG9hZGVkID0gKERPQ1VNRU5ULmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChET0NVTUVOVC5yZWFkeVN0YXRlKTtcblxuICBpZiAoIWxvYWRlZCkgRE9DVU1FTlQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGxpc3RlbmVyKTtcbn1cblxudmFyIGRvbXJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghSVNfRE9NKSByZXR1cm47XG4gIGxvYWRlZCA/IHNldFRpbWVvdXQoZm4sIDApIDogZnVuY3Rpb25zLnB1c2goZm4pO1xufTtcblxudmFyIGQgPSBVTklUU19JTl9HUklEO1xuXG52YXIgbWVhbmluZ2xlc3NUcmFuc2Zvcm0gPSB7XG4gIHNpemU6IDE2LFxuICB4OiAwLFxuICB5OiAwLFxuICByb3RhdGU6IDAsXG4gIGZsaXBYOiBmYWxzZSxcbiAgZmxpcFk6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkKG5hbWUpIHtcbiAgcmV0dXJuIH5SRVNFUlZFRF9DTEFTU0VTLmluZGV4T2YobmFtZSk7XG59XG5cbmZ1bmN0aW9uIGJ1bmtlcihmbikge1xuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIVBST0RVQ1RJT04pIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydENzcyhjc3MpIHtcbiAgaWYgKCFjc3MgfHwgIUlTX0RPTSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5pbm5lckhUTUwgPSBjc3M7XG5cbiAgdmFyIGhlYWRDaGlsZHJlbiA9IERPQ1VNRU5ULmhlYWQuY2hpbGROb2RlcztcbiAgdmFyIGJlZm9yZUNoaWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gaGVhZENoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgdmFyIGNoaWxkID0gaGVhZENoaWxkcmVuW2ldO1xuICAgIHZhciB0YWdOYW1lID0gKGNoaWxkLnRhZ05hbWUgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKFsnU1RZTEUnLCAnTElOSyddLmluZGV4T2YodGFnTmFtZSkgPiAtMSkge1xuICAgICAgYmVmb3JlQ2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gIH1cblxuICBET0NVTUVOVC5oZWFkLmluc2VydEJlZm9yZShzdHlsZSwgYmVmb3JlQ2hpbGQpO1xuXG4gIHJldHVybiBjc3M7XG59XG5cbnZhciBfdW5pcXVlSWQgPSAwO1xuXG5mdW5jdGlvbiBuZXh0VW5pcXVlSWQoKSB7XG4gIF91bmlxdWVJZCsrO1xuXG4gIHJldHVybiBfdW5pcXVlSWQ7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAob2JqIHx8IFtdKS5sZW5ndGggPj4+IDA7IGktLTspIHtcbiAgICBhcnJheVtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gY2xhc3NBcnJheShub2RlKSB7XG4gIGlmIChub2RlLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiB0b0FycmF5KG5vZGUuY2xhc3NMaXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgnICcpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SWNvbk5hbWUoZmFtaWx5UHJlZml4LCBjbHMpIHtcbiAgdmFyIHBhcnRzID0gY2xzLnNwbGl0KCctJyk7XG4gIHZhciBwcmVmaXggPSBwYXJ0c1swXTtcbiAgdmFyIGljb25OYW1lID0gcGFydHMuc2xpY2UoMSkuam9pbignLScpO1xuXG4gIGlmIChwcmVmaXggPT09IGZhbWlseVByZWZpeCAmJiBpY29uTmFtZSAhPT0gJycgJiYgIWlzUmVzZXJ2ZWQoaWNvbk5hbWUpKSB7XG4gICAgcmV0dXJuIGljb25OYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGh0bWxFc2NhcGUoc3RyKSB7XG4gIHJldHVybiAoJycgKyBzdHIpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoLycvZywgJyYjMzk7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuZnVuY3Rpb24gam9pbkF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gYWNjICsgKGF0dHJpYnV0ZU5hbWUgKyAnPVwiJyArIGh0bWxFc2NhcGUoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSkgKyAnXCIgJyk7XG4gIH0sICcnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGpvaW5TdHlsZXMoc3R5bGVzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZXMgfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzdHlsZU5hbWUpIHtcbiAgICByZXR1cm4gYWNjICsgKHN0eWxlTmFtZSArICc6ICcgKyBzdHlsZXNbc3R5bGVOYW1lXSArICc7Jyk7XG4gIH0sICcnKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtSXNNZWFuaW5nZnVsKHRyYW5zZm9ybSkge1xuICByZXR1cm4gdHJhbnNmb3JtLnNpemUgIT09IG1lYW5pbmdsZXNzVHJhbnNmb3JtLnNpemUgfHwgdHJhbnNmb3JtLnggIT09IG1lYW5pbmdsZXNzVHJhbnNmb3JtLnggfHwgdHJhbnNmb3JtLnkgIT09IG1lYW5pbmdsZXNzVHJhbnNmb3JtLnkgfHwgdHJhbnNmb3JtLnJvdGF0ZSAhPT0gbWVhbmluZ2xlc3NUcmFuc2Zvcm0ucm90YXRlIHx8IHRyYW5zZm9ybS5mbGlwWCB8fCB0cmFuc2Zvcm0uZmxpcFk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUZvclN2ZyhfcmVmKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gX3JlZi5jb250YWluZXJXaWR0aCxcbiAgICAgIGljb25XaWR0aCA9IF9yZWYuaWNvbldpZHRoO1xuXG4gIHZhciBvdXRlciA9IHtcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIGNvbnRhaW5lcldpZHRoIC8gMiArICcgMjU2KSdcbiAgfTtcbiAgdmFyIGlubmVyVHJhbnNsYXRlID0gJ3RyYW5zbGF0ZSgnICsgdHJhbnNmb3JtLnggKiAzMiArICcsICcgKyB0cmFuc2Zvcm0ueSAqIDMyICsgJykgJztcbiAgdmFyIGlubmVyU2NhbGUgPSAnc2NhbGUoJyArIHRyYW5zZm9ybS5zaXplIC8gMTYgKiAodHJhbnNmb3JtLmZsaXBYID8gLTEgOiAxKSArICcsICcgKyB0cmFuc2Zvcm0uc2l6ZSAvIDE2ICogKHRyYW5zZm9ybS5mbGlwWSA/IC0xIDogMSkgKyAnKSAnO1xuICB2YXIgaW5uZXJSb3RhdGUgPSAncm90YXRlKCcgKyB0cmFuc2Zvcm0ucm90YXRlICsgJyAwIDApJztcbiAgdmFyIGlubmVyID0ge1xuICAgIHRyYW5zZm9ybTogaW5uZXJUcmFuc2xhdGUgKyAnICcgKyBpbm5lclNjYWxlICsgJyAnICsgaW5uZXJSb3RhdGVcbiAgfTtcbiAgdmFyIHBhdGggPSB7XG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBpY29uV2lkdGggLyAyICogLTEgKyAnIC0yNTYpJ1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyOiBvdXRlcixcbiAgICBpbm5lcjogaW5uZXIsXG4gICAgcGF0aDogcGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Gb3JDc3MoX3JlZjIpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IF9yZWYyLnRyYW5zZm9ybSxcbiAgICAgIF9yZWYyJHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICB3aWR0aCA9IF9yZWYyJHdpZHRoID09PSB1bmRlZmluZWQgPyBVTklUU19JTl9HUklEIDogX3JlZjIkd2lkdGgsXG4gICAgICBfcmVmMiRoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcmVmMiRoZWlnaHQgPT09IHVuZGVmaW5lZCA/IFVOSVRTX0lOX0dSSUQgOiBfcmVmMiRoZWlnaHQsXG4gICAgICBfcmVmMiRzdGFydENlbnRlcmVkID0gX3JlZjIuc3RhcnRDZW50ZXJlZCxcbiAgICAgIHN0YXJ0Q2VudGVyZWQgPSBfcmVmMiRzdGFydENlbnRlcmVkID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYyJHN0YXJ0Q2VudGVyZWQ7XG5cbiAgdmFyIHZhbCA9ICcnO1xuXG4gIGlmIChzdGFydENlbnRlcmVkICYmIElTX0lFKSB7XG4gICAgdmFsICs9ICd0cmFuc2xhdGUoJyArICh0cmFuc2Zvcm0ueCAvIGQgLSB3aWR0aCAvIDIpICsgJ2VtLCAnICsgKHRyYW5zZm9ybS55IC8gZCAtIGhlaWdodCAvIDIpICsgJ2VtKSAnO1xuICB9IGVsc2UgaWYgKHN0YXJ0Q2VudGVyZWQpIHtcbiAgICB2YWwgKz0gJ3RyYW5zbGF0ZShjYWxjKC01MCUgKyAnICsgdHJhbnNmb3JtLnggLyBkICsgJ2VtKSwgY2FsYygtNTAlICsgJyArIHRyYW5zZm9ybS55IC8gZCArICdlbSkpICc7XG4gIH0gZWxzZSB7XG4gICAgdmFsICs9ICd0cmFuc2xhdGUoJyArIHRyYW5zZm9ybS54IC8gZCArICdlbSwgJyArIHRyYW5zZm9ybS55IC8gZCArICdlbSkgJztcbiAgfVxuXG4gIHZhbCArPSAnc2NhbGUoJyArIHRyYW5zZm9ybS5zaXplIC8gZCAqICh0cmFuc2Zvcm0uZmxpcFggPyAtMSA6IDEpICsgJywgJyArIHRyYW5zZm9ybS5zaXplIC8gZCAqICh0cmFuc2Zvcm0uZmxpcFkgPyAtMSA6IDEpICsgJykgJztcbiAgdmFsICs9ICdyb3RhdGUoJyArIHRyYW5zZm9ybS5yb3RhdGUgKyAnZGVnKSAnO1xuXG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBBTExfU1BBQ0UgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnXG59O1xuXG52YXIgbWFrZUljb25NYXNraW5nID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgbWFzayA9IF9yZWYubWFzayxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtO1xuICB2YXIgbWFpbldpZHRoID0gbWFpbi53aWR0aCxcbiAgICAgIG1haW5QYXRoID0gbWFpbi5pY29uO1xuICB2YXIgbWFza1dpZHRoID0gbWFzay53aWR0aCxcbiAgICAgIG1hc2tQYXRoID0gbWFzay5pY29uO1xuXG5cbiAgdmFyIHRyYW5zID0gdHJhbnNmb3JtRm9yU3ZnKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sIGNvbnRhaW5lcldpZHRoOiBtYXNrV2lkdGgsIGljb25XaWR0aDogbWFpbldpZHRoIH0pO1xuXG4gIHZhciBtYXNrUmVjdCA9IHtcbiAgICB0YWc6ICdyZWN0JyxcbiAgICBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgQUxMX1NQQUNFLCB7XG4gICAgICBmaWxsOiAnd2hpdGUnXG4gICAgfSlcbiAgfTtcbiAgdmFyIG1hc2tJbm5lckdyb3VwID0ge1xuICAgIHRhZzogJ2cnLFxuICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCB0cmFucy5pbm5lciksXG4gICAgY2hpbGRyZW46IFt7IHRhZzogJ3BhdGgnLCBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgbWFpblBhdGguYXR0cmlidXRlcywgdHJhbnMucGF0aCwgeyBmaWxsOiAnYmxhY2snIH0pIH1dXG4gIH07XG4gIHZhciBtYXNrT3V0ZXJHcm91cCA9IHtcbiAgICB0YWc6ICdnJyxcbiAgICBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgdHJhbnMub3V0ZXIpLFxuICAgIGNoaWxkcmVuOiBbbWFza0lubmVyR3JvdXBdXG4gIH07XG4gIHZhciBtYXNrSWQgPSAnbWFzay0nICsgbmV4dFVuaXF1ZUlkKCk7XG4gIHZhciBjbGlwSWQgPSAnY2xpcC0nICsgbmV4dFVuaXF1ZUlkKCk7XG4gIHZhciBtYXNrVGFnID0ge1xuICAgIHRhZzogJ21hc2snLFxuICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCBBTExfU1BBQ0UsIHtcbiAgICAgIGlkOiBtYXNrSWQsXG4gICAgICBtYXNrVW5pdHM6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICBtYXNrQ29udGVudFVuaXRzOiAndXNlclNwYWNlT25Vc2UnXG4gICAgfSksXG4gICAgY2hpbGRyZW46IFttYXNrUmVjdCwgbWFza091dGVyR3JvdXBdXG4gIH07XG4gIHZhciBkZWZzID0ge1xuICAgIHRhZzogJ2RlZnMnLFxuICAgIGNoaWxkcmVuOiBbeyB0YWc6ICdjbGlwUGF0aCcsIGF0dHJpYnV0ZXM6IHsgaWQ6IGNsaXBJZCB9LCBjaGlsZHJlbjogW21hc2tQYXRoXSB9LCBtYXNrVGFnXVxuICB9O1xuXG4gIGNoaWxkcmVuLnB1c2goZGVmcywgeyB0YWc6ICdyZWN0JywgYXR0cmlidXRlczogX2V4dGVuZHMoeyBmaWxsOiAnY3VycmVudENvbG9yJywgJ2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwSWQgKyAnKScsIG1hc2s6ICd1cmwoIycgKyBtYXNrSWQgKyAnKScgfSwgQUxMX1NQQUNFKSB9KTtcblxuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gIH07XG59O1xuXG52YXIgbWFrZUljb25TdGFuZGFyZCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzLFxuICAgICAgbWFpbiA9IF9yZWYubWFpbixcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgc3R5bGVzID0gX3JlZi5zdHlsZXM7XG5cbiAgdmFyIHN0eWxlU3RyaW5nID0gam9pblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmIChzdHlsZVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlc1snc3R5bGUnXSA9IHN0eWxlU3RyaW5nO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybUlzTWVhbmluZ2Z1bCh0cmFuc2Zvcm0pKSB7XG4gICAgdmFyIHRyYW5zID0gdHJhbnNmb3JtRm9yU3ZnKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sIGNvbnRhaW5lcldpZHRoOiBtYWluLndpZHRoLCBpY29uV2lkdGg6IG1haW4ud2lkdGggfSk7XG4gICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICB0YWc6ICdnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCB0cmFucy5vdXRlciksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnOiAnZycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCB0cmFucy5pbm5lciksXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRhZzogbWFpbi5pY29uLnRhZyxcbiAgICAgICAgICBjaGlsZHJlbjogbWFpbi5pY29uLmNoaWxkcmVuLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCBtYWluLmljb24uYXR0cmlidXRlcywgdHJhbnMucGF0aClcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4ucHVzaChtYWluLmljb24pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICB9O1xufTtcblxudmFyIGFzSWNvbiA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBtYWluID0gX3JlZi5tYWluLFxuICAgICAgbWFzayA9IF9yZWYubWFzayxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzdHlsZXMgPSBfcmVmLnN0eWxlcyxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtO1xuXG4gIGlmICh0cmFuc2Zvcm1Jc01lYW5pbmdmdWwodHJhbnNmb3JtKSAmJiBtYWluLmZvdW5kICYmICFtYXNrLmZvdW5kKSB7XG4gICAgdmFyIHdpZHRoID0gbWFpbi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gbWFpbi5oZWlnaHQ7XG5cbiAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgeDogd2lkdGggLyBoZWlnaHQgLyAyLFxuICAgICAgeTogMC41XG4gICAgfTtcbiAgICBhdHRyaWJ1dGVzWydzdHlsZSddID0gam9pblN0eWxlcyhfZXh0ZW5kcyh7fSwgc3R5bGVzLCB7XG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IG9mZnNldC54ICsgdHJhbnNmb3JtLnggLyAxNiArICdlbSAnICsgKG9mZnNldC55ICsgdHJhbnNmb3JtLnkgLyAxNikgKyAnZW0nXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIFt7XG4gICAgdGFnOiAnc3ZnJyxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9XTtcbn07XG5cbnZhciBhc1N5bWJvbCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcmVmaXggPSBfcmVmLnByZWZpeCxcbiAgICAgIGljb25OYW1lID0gX3JlZi5pY29uTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmLmF0dHJpYnV0ZXMsXG4gICAgICBzeW1ib2wgPSBfcmVmLnN5bWJvbDtcblxuICB2YXIgaWQgPSBzeW1ib2wgPT09IHRydWUgPyBwcmVmaXggKyAnLScgKyBjb25maWckMS5mYW1pbHlQcmVmaXggKyAnLScgKyBpY29uTmFtZSA6IHN5bWJvbDtcblxuICByZXR1cm4gW3tcbiAgICB0YWc6ICdzdmcnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHN0eWxlOiAnZGlzcGxheTogbm9uZTsnXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgIHRhZzogJ3N5bWJvbCcsXG4gICAgICBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgeyBpZDogaWQgfSksXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9XVxuICB9XTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VJbmxpbmVTdmdBYnN0cmFjdChwYXJhbXMpIHtcbiAgdmFyIF9wYXJhbXMkaWNvbnMgPSBwYXJhbXMuaWNvbnMsXG4gICAgICBtYWluID0gX3BhcmFtcyRpY29ucy5tYWluLFxuICAgICAgbWFzayA9IF9wYXJhbXMkaWNvbnMubWFzayxcbiAgICAgIHByZWZpeCA9IHBhcmFtcy5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IHBhcmFtcy5pY29uTmFtZSxcbiAgICAgIHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICBzeW1ib2wgPSBwYXJhbXMuc3ltYm9sLFxuICAgICAgdGl0bGUgPSBwYXJhbXMudGl0bGUsXG4gICAgICBleHRyYSA9IHBhcmFtcy5leHRyYSxcbiAgICAgIF9wYXJhbXMkd2F0Y2hhYmxlID0gcGFyYW1zLndhdGNoYWJsZSxcbiAgICAgIHdhdGNoYWJsZSA9IF9wYXJhbXMkd2F0Y2hhYmxlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wYXJhbXMkd2F0Y2hhYmxlO1xuXG4gIHZhciBfcmVmID0gbWFzay5mb3VuZCA/IG1hc2sgOiBtYWluLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgdmFyIHdpZHRoQ2xhc3MgPSAnZmEtdy0nICsgTWF0aC5jZWlsKHdpZHRoIC8gaGVpZ2h0ICogMTYpO1xuICB2YXIgYXR0ckNsYXNzID0gW2NvbmZpZyQxLnJlcGxhY2VtZW50Q2xhc3MsIGljb25OYW1lID8gY29uZmlnJDEuZmFtaWx5UHJlZml4ICsgJy0nICsgaWNvbk5hbWUgOiAnJywgd2lkdGhDbGFzc10uY29uY2F0KGV4dHJhLmNsYXNzZXMpLmpvaW4oJyAnKTtcblxuICB2YXIgY29udGVudCA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYXR0cmlidXRlczogX2V4dGVuZHMoe30sIGV4dHJhLmF0dHJpYnV0ZXMsIHtcbiAgICAgICdkYXRhLXByZWZpeCc6IHByZWZpeCxcbiAgICAgICdkYXRhLWljb24nOiBpY29uTmFtZSxcbiAgICAgICdjbGFzcyc6IGF0dHJDbGFzcyxcbiAgICAgICdyb2xlJzogJ2ltZycsXG4gICAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgJ3ZpZXdCb3gnOiAnMCAwICcgKyB3aWR0aCArICcgJyArIGhlaWdodFxuICAgIH0pXG4gIH07XG5cbiAgaWYgKHdhdGNoYWJsZSkge1xuICAgIGNvbnRlbnQuYXR0cmlidXRlc1tEQVRBX0ZBX0kyU1ZHXSA9ICcnO1xuICB9XG5cbiAgaWYgKHRpdGxlKSBjb250ZW50LmNoaWxkcmVuLnB1c2goeyB0YWc6ICd0aXRsZScsIGF0dHJpYnV0ZXM6IHsgaWQ6IGNvbnRlbnQuYXR0cmlidXRlc1snYXJpYS1sYWJlbGxlZGJ5J10gfHwgJ3RpdGxlLScgKyBuZXh0VW5pcXVlSWQoKSB9LCBjaGlsZHJlbjogW3RpdGxlXSB9KTtcblxuICB2YXIgYXJncyA9IF9leHRlbmRzKHt9LCBjb250ZW50LCB7XG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgaWNvbk5hbWU6IGljb25OYW1lLFxuICAgIG1haW46IG1haW4sXG4gICAgbWFzazogbWFzayxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICBzdHlsZXM6IGV4dHJhLnN0eWxlc1xuICB9KTtcblxuICB2YXIgX3JlZjIgPSBtYXNrLmZvdW5kICYmIG1haW4uZm91bmQgPyBtYWtlSWNvbk1hc2tpbmcoYXJncykgOiBtYWtlSWNvblN0YW5kYXJkKGFyZ3MpLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfcmVmMi5hdHRyaWJ1dGVzO1xuXG4gIGFyZ3MuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgYXJncy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICBpZiAoc3ltYm9sKSB7XG4gICAgcmV0dXJuIGFzU3ltYm9sKGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc0ljb24oYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUxheWVyc1RleHRBYnN0cmFjdChwYXJhbXMpIHtcbiAgdmFyIGNvbnRlbnQgPSBwYXJhbXMuY29udGVudCxcbiAgICAgIHdpZHRoID0gcGFyYW1zLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCxcbiAgICAgIHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIGV4dHJhID0gcGFyYW1zLmV4dHJhLFxuICAgICAgX3BhcmFtcyR3YXRjaGFibGUyID0gcGFyYW1zLndhdGNoYWJsZSxcbiAgICAgIHdhdGNoYWJsZSA9IF9wYXJhbXMkd2F0Y2hhYmxlMiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcGFyYW1zJHdhdGNoYWJsZTI7XG5cblxuICB2YXIgYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBleHRyYS5hdHRyaWJ1dGVzLCB0aXRsZSA/IHsgJ3RpdGxlJzogdGl0bGUgfSA6IHt9LCB7XG4gICAgJ2NsYXNzJzogZXh0cmEuY2xhc3Nlcy5qb2luKCcgJylcbiAgfSk7XG5cbiAgaWYgKHdhdGNoYWJsZSkge1xuICAgIGF0dHJpYnV0ZXNbREFUQV9GQV9JMlNWR10gPSAnJztcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZXh0cmEuc3R5bGVzKTtcblxuICBpZiAodHJhbnNmb3JtSXNNZWFuaW5nZnVsKHRyYW5zZm9ybSkpIHtcbiAgICBzdHlsZXNbJ3RyYW5zZm9ybSddID0gdHJhbnNmb3JtRm9yQ3NzKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sIHN0YXJ0Q2VudGVyZWQ6IHRydWUsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgc3R5bGVzWyctd2Via2l0LXRyYW5zZm9ybSddID0gc3R5bGVzWyd0cmFuc2Zvcm0nXTtcbiAgfVxuXG4gIHZhciBzdHlsZVN0cmluZyA9IGpvaW5TdHlsZXMoc3R5bGVzKTtcblxuICBpZiAoc3R5bGVTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGF0dHJpYnV0ZXNbJ3N0eWxlJ10gPSBzdHlsZVN0cmluZztcbiAgfVxuXG4gIHZhciB2YWwgPSBbXTtcblxuICB2YWwucHVzaCh7XG4gICAgdGFnOiAnc3BhbicsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbjogW2NvbnRlbnRdXG4gIH0pO1xuXG4gIGlmICh0aXRsZSkge1xuICAgIHZhbC5wdXNoKHsgdGFnOiAnc3BhbicsIGF0dHJpYnV0ZXM6IHsgY2xhc3M6ICdzci1vbmx5JyB9LCBjaGlsZHJlbjogW3RpdGxlXSB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbnZhciBub29wJDIgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgcCA9IGNvbmZpZyQxLm1lYXN1cmVQZXJmb3JtYW5jZSAmJiBQRVJGT1JNQU5DRSAmJiBQRVJGT1JNQU5DRS5tYXJrICYmIFBFUkZPUk1BTkNFLm1lYXN1cmUgPyBQRVJGT1JNQU5DRSA6IHsgbWFyazogbm9vcCQyLCBtZWFzdXJlOiBub29wJDIgfTtcbnZhciBwcmVhbWJsZSA9ICdGQSBcIjUuMC4xM1wiJztcblxudmFyIGJlZ2luID0gZnVuY3Rpb24gYmVnaW4obmFtZSkge1xuICBwLm1hcmsocHJlYW1ibGUgKyAnICcgKyBuYW1lICsgJyBiZWdpbnMnKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW5kKG5hbWUpO1xuICB9O1xufTtcblxudmFyIGVuZCA9IGZ1bmN0aW9uIGVuZChuYW1lKSB7XG4gIHAubWFyayhwcmVhbWJsZSArICcgJyArIG5hbWUgKyAnIGVuZHMnKTtcbiAgcC5tZWFzdXJlKHByZWFtYmxlICsgJyAnICsgbmFtZSwgcHJlYW1ibGUgKyAnICcgKyBuYW1lICsgJyBiZWdpbnMnLCBwcmVhbWJsZSArICcgJyArIG5hbWUgKyAnIGVuZHMnKTtcbn07XG5cbnZhciBwZXJmID0geyBiZWdpbjogYmVnaW4sIGVuZDogZW5kIH07XG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gYmluZCBhIGZ1bmN0aW9uIGtub3duIHRvIGhhdmUgNCBhcmd1bWVudHNcbiAqIHRvIGEgZ2l2ZW4gY29udGV4dC5cbiAqL1xudmFyIGJpbmRJbnRlcm5hbDQgPSBmdW5jdGlvbiBiaW5kSW50ZXJuYWw0IChmdW5jLCB0aGlzQ29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNDb250ZXh0LCBhLCBiLCBjLCBkKTtcbiAgfTtcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbi8qKlxuICogIyBSZWR1Y2VcbiAqXG4gKiBBIGZhc3Qgb2JqZWN0IGAucmVkdWNlKClgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICBzdWJqZWN0ICAgICAgVGhlIG9iamVjdCB0byByZWR1Y2Ugb3Zlci5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICAgICAgICAgVGhlIHJlZHVjZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHttaXhlZH0gICAgaW5pdGlhbFZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgcmVkdWNlciwgZGVmYXVsdHMgdG8gc3ViamVjdFswXS5cbiAqIEBwYXJhbSAge09iamVjdH0gICB0aGlzQ29udGV4dCAgVGhlIGNvbnRleHQgZm9yIHRoZSByZWR1Y2VyLlxuICogQHJldHVybiB7bWl4ZWR9ICAgICAgICAgICAgICAgICBUaGUgZmluYWwgcmVzdWx0LlxuICovXG52YXIgcmVkdWNlID0gZnVuY3Rpb24gZmFzdFJlZHVjZU9iamVjdCAoc3ViamVjdCwgZm4sIGluaXRpYWxWYWx1ZSwgdGhpc0NvbnRleHQpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdWJqZWN0KSxcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgaXRlcmF0b3IgPSB0aGlzQ29udGV4dCAhPT0gdW5kZWZpbmVkID8gYmluZEludGVybmFsNChmbiwgdGhpc0NvbnRleHQpIDogZm4sXG4gICAgICBpLCBrZXksIHJlc3VsdDtcblxuICBpZiAoaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBpID0gMTtcbiAgICByZXN1bHQgPSBzdWJqZWN0W2tleXNbMF1dO1xuICB9XG4gIGVsc2Uge1xuICAgIGkgPSAwO1xuICAgIHJlc3VsdCA9IGluaXRpYWxWYWx1ZTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgc3ViamVjdFtrZXldLCBrZXksIHN1YmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBzdHlsZXMkMiA9IG5hbWVzcGFjZS5zdHlsZXM7XG52YXIgc2hpbXMgPSBuYW1lc3BhY2Uuc2hpbXM7XG5cblxudmFyIF9ieVVuaWNvZGUgPSB7fTtcbnZhciBfYnlMaWdhdHVyZSA9IHt9O1xudmFyIF9ieU9sZE5hbWUgPSB7fTtcblxudmFyIGJ1aWxkID0gZnVuY3Rpb24gYnVpbGQoKSB7XG4gIHZhciBsb29rdXAgPSBmdW5jdGlvbiBsb29rdXAocmVkdWNlcikge1xuICAgIHJldHVybiByZWR1Y2Uoc3R5bGVzJDIsIGZ1bmN0aW9uIChvLCBzdHlsZSwgcHJlZml4KSB7XG4gICAgICBvW3ByZWZpeF0gPSByZWR1Y2Uoc3R5bGUsIHJlZHVjZXIsIHt9KTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICBfYnlVbmljb2RlID0gbG9va3VwKGZ1bmN0aW9uIChhY2MsIGljb24sIGljb25OYW1lKSB7XG4gICAgYWNjW2ljb25bM11dID0gaWNvbk5hbWU7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9KTtcblxuICBfYnlMaWdhdHVyZSA9IGxvb2t1cChmdW5jdGlvbiAoYWNjLCBpY29uLCBpY29uTmFtZSkge1xuICAgIHZhciBsaWdhdHVyZXMgPSBpY29uWzJdO1xuXG4gICAgYWNjW2ljb25OYW1lXSA9IGljb25OYW1lO1xuXG4gICAgbGlnYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGxpZ2F0dXJlKSB7XG4gICAgICBhY2NbbGlnYXR1cmVdID0gaWNvbk5hbWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9KTtcblxuICB2YXIgaGFzUmVndWxhciA9ICdmYXInIGluIHN0eWxlcyQyO1xuXG4gIF9ieU9sZE5hbWUgPSByZWR1Y2Uoc2hpbXMsIGZ1bmN0aW9uIChhY2MsIHNoaW0pIHtcbiAgICB2YXIgb2xkTmFtZSA9IHNoaW1bMF07XG4gICAgdmFyIHByZWZpeCA9IHNoaW1bMV07XG4gICAgdmFyIGljb25OYW1lID0gc2hpbVsyXTtcblxuICAgIGlmIChwcmVmaXggPT09ICdmYXInICYmICFoYXNSZWd1bGFyKSB7XG4gICAgICBwcmVmaXggPSAnZmFzJztcbiAgICB9XG5cbiAgICBhY2Nbb2xkTmFtZV0gPSB7IHByZWZpeDogcHJlZml4LCBpY29uTmFtZTogaWNvbk5hbWUgfTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5cbmJ1aWxkKCk7XG5cbmZ1bmN0aW9uIGJ5VW5pY29kZShwcmVmaXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIF9ieVVuaWNvZGVbcHJlZml4XVt1bmljb2RlXTtcbn1cblxuZnVuY3Rpb24gYnlMaWdhdHVyZShwcmVmaXgsIGxpZ2F0dXJlKSB7XG4gIHJldHVybiBfYnlMaWdhdHVyZVtwcmVmaXhdW2xpZ2F0dXJlXTtcbn1cblxuZnVuY3Rpb24gYnlPbGROYW1lKG5hbWUpIHtcbiAgcmV0dXJuIF9ieU9sZE5hbWVbbmFtZV0gfHwgeyBwcmVmaXg6IG51bGwsIGljb25OYW1lOiBudWxsIH07XG59XG5cbnZhciBzdHlsZXMkMSA9IG5hbWVzcGFjZS5zdHlsZXM7XG5cblxudmFyIGVtcHR5Q2Fub25pY2FsSWNvbiA9IGZ1bmN0aW9uIGVtcHR5Q2Fub25pY2FsSWNvbigpIHtcbiAgcmV0dXJuIHsgcHJlZml4OiBudWxsLCBpY29uTmFtZTogbnVsbCwgcmVzdDogW10gfTtcbn07XG5cbmZ1bmN0aW9uIGdldENhbm9uaWNhbEljb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNscykge1xuICAgIHZhciBpY29uTmFtZSA9IGdldEljb25OYW1lKGNvbmZpZyQxLmZhbWlseVByZWZpeCwgY2xzKTtcblxuICAgIGlmIChzdHlsZXMkMVtjbHNdKSB7XG4gICAgICBhY2MucHJlZml4ID0gY2xzO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUpIHtcbiAgICAgIHZhciBzaGltID0gYWNjLnByZWZpeCA9PT0gJ2ZhJyA/IGJ5T2xkTmFtZShpY29uTmFtZSkgOiB7fTtcblxuICAgICAgYWNjLmljb25OYW1lID0gc2hpbS5pY29uTmFtZSB8fCBpY29uTmFtZTtcbiAgICAgIGFjYy5wcmVmaXggPSBzaGltLnByZWZpeCB8fCBhY2MucHJlZml4O1xuICAgIH0gZWxzZSBpZiAoY2xzICE9PSBjb25maWckMS5yZXBsYWNlbWVudENsYXNzICYmIGNscy5pbmRleE9mKCdmYS13LScpICE9PSAwKSB7XG4gICAgICBhY2MucmVzdC5wdXNoKGNscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwgZW1wdHlDYW5vbmljYWxJY29uKCkpO1xufVxuXG5mdW5jdGlvbiBpY29uRnJvbU1hcHBpbmcobWFwcGluZywgcHJlZml4LCBpY29uTmFtZSkge1xuICBpZiAobWFwcGluZyAmJiBtYXBwaW5nW3ByZWZpeF0gJiYgbWFwcGluZ1twcmVmaXhdW2ljb25OYW1lXSkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgIGljb246IG1hcHBpbmdbcHJlZml4XVtpY29uTmFtZV1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvSHRtbChhYnN0cmFjdE5vZGVzKSB7XG4gIHZhciB0YWcgPSBhYnN0cmFjdE5vZGVzLnRhZyxcbiAgICAgIF9hYnN0cmFjdE5vZGVzJGF0dHJpYiA9IGFic3RyYWN0Tm9kZXMuYXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfYWJzdHJhY3ROb2RlcyRhdHRyaWIgPT09IHVuZGVmaW5lZCA/IHt9IDogX2Fic3RyYWN0Tm9kZXMkYXR0cmliLFxuICAgICAgX2Fic3RyYWN0Tm9kZXMkY2hpbGRyID0gYWJzdHJhY3ROb2Rlcy5jaGlsZHJlbixcbiAgICAgIGNoaWxkcmVuID0gX2Fic3RyYWN0Tm9kZXMkY2hpbGRyID09PSB1bmRlZmluZWQgPyBbXSA6IF9hYnN0cmFjdE5vZGVzJGNoaWxkcjtcblxuXG4gIGlmICh0eXBlb2YgYWJzdHJhY3ROb2RlcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaHRtbEVzY2FwZShhYnN0cmFjdE5vZGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJzwnICsgdGFnICsgJyAnICsgam9pbkF0dHJpYnV0ZXMoYXR0cmlidXRlcykgKyAnPicgKyBjaGlsZHJlbi5tYXAodG9IdG1sKS5qb2luKCcnKSArICc8LycgKyB0YWcgKyAnPic7XG4gIH1cbn1cblxudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuZnVuY3Rpb24gaXNXYXRjaGVkKG5vZGUpIHtcbiAgdmFyIGkyc3ZnID0gbm9kZS5nZXRBdHRyaWJ1dGUgPyBub2RlLmdldEF0dHJpYnV0ZShEQVRBX0ZBX0kyU1ZHKSA6IG51bGw7XG5cbiAgcmV0dXJuIHR5cGVvZiBpMnN2ZyA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGdldE11dGF0b3IoKSB7XG4gIGlmIChjb25maWckMS5hdXRvUmVwbGFjZVN2ZyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBtdXRhdG9ycy5yZXBsYWNlO1xuICB9XG5cbiAgdmFyIG11dGF0b3IgPSBtdXRhdG9yc1tjb25maWckMS5hdXRvUmVwbGFjZVN2Z107XG5cbiAgcmV0dXJuIG11dGF0b3IgfHwgbXV0YXRvcnMucmVwbGFjZTtcbn1cblxudmFyIG11dGF0b3JzID0ge1xuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG11dGF0aW9uKSB7XG4gICAgdmFyIG5vZGUgPSBtdXRhdGlvblswXTtcbiAgICB2YXIgYWJzdHJhY3QgPSBtdXRhdGlvblsxXTtcbiAgICB2YXIgbmV3T3V0ZXJIVE1MID0gYWJzdHJhY3QubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gdG9IdG1sKGEpO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLm91dGVySFRNTCkge1xuICAgICAgbm9kZS5vdXRlckhUTUwgPSBuZXdPdXRlckhUTUwgKyAoY29uZmlnJDEua2VlcE9yaWdpbmFsU291cmNlICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJyA/ICc8IS0tICcgKyBub2RlLm91dGVySFRNTCArICcgLS0+JyA6ICcnKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIG5ld05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIG5vZGUpO1xuICAgICAgbmV3Tm9kZS5vdXRlckhUTUwgPSBuZXdPdXRlckhUTUw7XG4gICAgfVxuICB9LFxuICBuZXN0OiBmdW5jdGlvbiBuZXN0KG11dGF0aW9uKSB7XG4gICAgdmFyIG5vZGUgPSBtdXRhdGlvblswXTtcbiAgICB2YXIgYWJzdHJhY3QgPSBtdXRhdGlvblsxXTtcblxuICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIHJlcGxhY2VkIG5vZGUgd2UgZG8gbm90IHdhbnQgdG8gY29udGludWUgbmVzdGluZyB3aXRoaW4gaXQuXG4gICAgLy8gU2hvcnQtY2lyY3VpdCB0byB0aGUgc3RhbmRhcmQgcmVwbGFjZW1lbnRcbiAgICBpZiAofmNsYXNzQXJyYXkobm9kZSkuaW5kZXhPZihjb25maWckMS5yZXBsYWNlbWVudENsYXNzKSkge1xuICAgICAgcmV0dXJuIG11dGF0b3JzLnJlcGxhY2UobXV0YXRpb24pO1xuICAgIH1cblxuICAgIHZhciBmb3JTdmcgPSBuZXcgUmVnRXhwKGNvbmZpZyQxLmZhbWlseVByZWZpeCArICctLionKTtcblxuICAgIGRlbGV0ZSBhYnN0cmFjdFswXS5hdHRyaWJ1dGVzLnN0eWxlO1xuXG4gICAgdmFyIHNwbGl0Q2xhc3NlcyA9IGFic3RyYWN0WzBdLmF0dHJpYnV0ZXMuY2xhc3Muc3BsaXQoJyAnKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2xzKSB7XG4gICAgICBpZiAoY2xzID09PSBjb25maWckMS5yZXBsYWNlbWVudENsYXNzIHx8IGNscy5tYXRjaChmb3JTdmcpKSB7XG4gICAgICAgIGFjYy50b1N2Zy5wdXNoKGNscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2MudG9Ob2RlLnB1c2goY2xzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7IHRvTm9kZTogW10sIHRvU3ZnOiBbXSB9KTtcblxuICAgIGFic3RyYWN0WzBdLmF0dHJpYnV0ZXMuY2xhc3MgPSBzcGxpdENsYXNzZXMudG9Tdmcuam9pbignICcpO1xuXG4gICAgdmFyIG5ld0lubmVySFRNTCA9IGFic3RyYWN0Lm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIHRvSHRtbChhKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzcGxpdENsYXNzZXMudG9Ob2RlLmpvaW4oJyAnKSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoREFUQV9GQV9JMlNWRywgJycpO1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbmV3SW5uZXJIVE1MO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwZXJmb3JtKG11dGF0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxiYWNrRnVuY3Rpb24gPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG5vb3AkMTtcblxuICBpZiAobXV0YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNhbGxiYWNrRnVuY3Rpb24oKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZnJhbWUgPSBXSU5ET1cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChvcCkge1xuICAgICAgcmV0dXJuIG9wKCk7XG4gICAgfTtcblxuICAgIGZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtdXRhdG9yID0gZ2V0TXV0YXRvcigpO1xuICAgICAgdmFyIG1hcmsgPSBwZXJmLmJlZ2luKCdtdXRhdGUnKTtcblxuICAgICAgbXV0YXRpb25zLm1hcChtdXRhdG9yKTtcblxuICAgICAgbWFyaygpO1xuXG4gICAgICBjYWxsYmFja0Z1bmN0aW9uKCk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGRpc2FibGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRpc2FibGVPYnNlcnZhdGlvbihvcGVyYXRpb24pIHtcbiAgZGlzYWJsZWQgPSB0cnVlO1xuICBvcGVyYXRpb24oKTtcbiAgZGlzYWJsZWQgPSBmYWxzZTtcbn1cblxudmFyIG1vID0gbnVsbDtcblxuZnVuY3Rpb24gb2JzZXJ2ZShvcHRpb25zKSB7XG4gIGlmICghTVVUQVRJT05fT0JTRVJWRVIpIHJldHVybjtcblxuICB2YXIgdHJlZUNhbGxiYWNrID0gb3B0aW9ucy50cmVlQ2FsbGJhY2ssXG4gICAgICBub2RlQ2FsbGJhY2sgPSBvcHRpb25zLm5vZGVDYWxsYmFjayxcbiAgICAgIHBzZXVkb0VsZW1lbnRzQ2FsbGJhY2sgPSBvcHRpb25zLnBzZXVkb0VsZW1lbnRzQ2FsbGJhY2s7XG5cblxuICBtbyA9IG5ldyBNVVRBVElPTl9PQlNFUlZFUihmdW5jdGlvbiAob2JqZWN0cykge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgdG9BcnJheShvYmplY3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChtdXRhdGlvblJlY29yZCkge1xuICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnICYmIG11dGF0aW9uUmVjb3JkLmFkZGVkTm9kZXMubGVuZ3RoID4gMCAmJiAhaXNXYXRjaGVkKG11dGF0aW9uUmVjb3JkLmFkZGVkTm9kZXNbMF0pKSB7XG4gICAgICAgIGlmIChjb25maWckMS5zZWFyY2hQc2V1ZG9FbGVtZW50cykge1xuICAgICAgICAgIHBzZXVkb0VsZW1lbnRzQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyZWVDYWxsYmFjayhtdXRhdGlvblJlY29yZC50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uUmVjb3JkLnRhcmdldC5wYXJlbnROb2RlICYmIGNvbmZpZyQxLnNlYXJjaFBzZXVkb0VsZW1lbnRzKSB7XG4gICAgICAgIHBzZXVkb0VsZW1lbnRzQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXV0YXRpb25SZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIGlzV2F0Y2hlZChtdXRhdGlvblJlY29yZC50YXJnZXQpICYmIH5BVFRSSUJVVEVTX1dBVENIRURfRk9SX01VVEFUSU9OLmluZGV4T2YobXV0YXRpb25SZWNvcmQuYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uUmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICB2YXIgX2dldENhbm9uaWNhbEljb24gPSBnZXRDYW5vbmljYWxJY29uKGNsYXNzQXJyYXkobXV0YXRpb25SZWNvcmQudGFyZ2V0KSksXG4gICAgICAgICAgICAgIHByZWZpeCA9IF9nZXRDYW5vbmljYWxJY29uLnByZWZpeCxcbiAgICAgICAgICAgICAgaWNvbk5hbWUgPSBfZ2V0Q2Fub25pY2FsSWNvbi5pY29uTmFtZTtcblxuICAgICAgICAgIGlmIChwcmVmaXgpIG11dGF0aW9uUmVjb3JkLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHJlZml4JywgcHJlZml4KTtcbiAgICAgICAgICBpZiAoaWNvbk5hbWUpIG11dGF0aW9uUmVjb3JkLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWNvbicsIGljb25OYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlQ2FsbGJhY2sobXV0YXRpb25SZWNvcmQudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuXG4gIG1vLm9ic2VydmUoRE9DVU1FTlQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXSwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSwgYXR0cmlidXRlczogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSwgc3VidHJlZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgaWYgKCFtbykgcmV0dXJuO1xuXG4gIG1vLmRpc2Nvbm5lY3QoKTtcbn1cblxudmFyIHN0eWxlUGFyc2VyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgdmFyIHZhbCA9IFtdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhbCA9IHN0eWxlLnNwbGl0KCc7JykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHN0eWxlKSB7XG4gICAgICB2YXIgc3R5bGVzID0gc3R5bGUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBwcm9wID0gc3R5bGVzWzBdO1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVzLnNsaWNlKDEpO1xuXG4gICAgICBpZiAocHJvcCAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjY1twcm9wXSA9IHZhbHVlLmpvaW4oJzonKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmZ1bmN0aW9uIHRvSGV4KHVuaWNvZGUpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pY29kZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBoZXggPSB1bmljb2RlLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpO1xuICAgIHJlc3VsdCArPSAoJzAwMCcgKyBoZXgpLnNsaWNlKC00KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBjbGFzc1BhcnNlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBleGlzdGluZ1ByZWZpeCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXByZWZpeCcpO1xuICB2YXIgZXhpc3RpbmdJY29uTmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWljb24nKTtcbiAgdmFyIGlubmVyVGV4dCA9IG5vZGUuaW5uZXJUZXh0ICE9PSB1bmRlZmluZWQgPyBub2RlLmlubmVyVGV4dC50cmltKCkgOiAnJztcblxuICB2YXIgdmFsID0gZ2V0Q2Fub25pY2FsSWNvbihjbGFzc0FycmF5KG5vZGUpKTtcblxuICBpZiAoZXhpc3RpbmdQcmVmaXggJiYgZXhpc3RpbmdJY29uTmFtZSkge1xuICAgIHZhbC5wcmVmaXggPSBleGlzdGluZ1ByZWZpeDtcbiAgICB2YWwuaWNvbk5hbWUgPSBleGlzdGluZ0ljb25OYW1lO1xuICB9XG5cbiAgaWYgKHZhbC5wcmVmaXggJiYgaW5uZXJUZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICB2YWwuaWNvbk5hbWUgPSBieUxpZ2F0dXJlKHZhbC5wcmVmaXgsIG5vZGUuaW5uZXJUZXh0KTtcbiAgfSBlbHNlIGlmICh2YWwucHJlZml4ICYmIGlubmVyVGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB2YWwuaWNvbk5hbWUgPSBieVVuaWNvZGUodmFsLnByZWZpeCwgdG9IZXgobm9kZS5pbm5lclRleHQpKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG52YXIgcGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICBzaXplOiAxNixcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgZmxpcFg6IGZhbHNlLFxuICAgIGZsaXBZOiBmYWxzZSxcbiAgICByb3RhdGU6IDBcbiAgfTtcblxuICBpZiAoIXRyYW5zZm9ybVN0cmluZykge1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG4pIHtcbiAgICAgIHZhciBwYXJ0cyA9IG4udG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgdmFyIGZpcnN0ID0gcGFydHNbMF07XG4gICAgICB2YXIgcmVzdCA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJy0nKTtcblxuICAgICAgaWYgKGZpcnN0ICYmIHJlc3QgPT09ICdoJykge1xuICAgICAgICBhY2MuZmxpcFggPSB0cnVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3QgJiYgcmVzdCA9PT0gJ3YnKSB7XG4gICAgICAgIGFjYy5mbGlwWSA9IHRydWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG5cbiAgICAgIHJlc3QgPSBwYXJzZUZsb2F0KHJlc3QpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlICdncm93JzpcbiAgICAgICAgICBhY2Muc2l6ZSA9IGFjYy5zaXplICsgcmVzdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hyaW5rJzpcbiAgICAgICAgICBhY2Muc2l6ZSA9IGFjYy5zaXplIC0gcmVzdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYWNjLnggPSBhY2MueCAtIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBhY2MueCA9IGFjYy54ICsgcmVzdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndXAnOlxuICAgICAgICAgIGFjYy55ID0gYWNjLnkgLSByZXN0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgICBhY2MueSA9IGFjYy55ICsgcmVzdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICBhY2Mucm90YXRlID0gYWNjLnJvdGF0ZSArIHJlc3Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdHJhbnNmb3JtKTtcbiAgfVxufTtcblxudmFyIHRyYW5zZm9ybVBhcnNlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBwYXJzZVRyYW5zZm9ybVN0cmluZyhub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1mYS10cmFuc2Zvcm0nKSk7XG59O1xuXG52YXIgc3ltYm9sUGFyc2VyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHN5bWJvbCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLXN5bWJvbCcpO1xuXG4gIHJldHVybiBzeW1ib2wgPT09IG51bGwgPyBmYWxzZSA6IHN5bWJvbCA9PT0gJycgPyB0cnVlIDogc3ltYm9sO1xufTtcblxudmFyIGF0dHJpYnV0ZXNQYXJzZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVzID0gdG9BcnJheShub2RlLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgaWYgKGFjYy5uYW1lICE9PSAnY2xhc3MnICYmIGFjYy5uYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICBhY2NbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICB2YXIgdGl0bGUgPSBub2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcblxuICBpZiAoY29uZmlnJDEuYXV0b0ExMXkpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGV4dHJhQXR0cmlidXRlc1snYXJpYS1sYWJlbGxlZGJ5J10gPSBjb25maWckMS5yZXBsYWNlbWVudENsYXNzICsgJy10aXRsZS0nICsgbmV4dFVuaXF1ZUlkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dHJhQXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXh0cmFBdHRyaWJ1dGVzO1xufTtcblxudmFyIG1hc2tQYXJzZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgbWFzayA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWZhLW1hc2snKTtcblxuICBpZiAoIW1hc2spIHtcbiAgICByZXR1cm4gZW1wdHlDYW5vbmljYWxJY29uKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldENhbm9uaWNhbEljb24obWFzay5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGkudHJpbSgpO1xuICAgIH0pKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VNZXRhKG5vZGUpIHtcbiAgdmFyIF9jbGFzc1BhcnNlciA9IGNsYXNzUGFyc2VyKG5vZGUpLFxuICAgICAgaWNvbk5hbWUgPSBfY2xhc3NQYXJzZXIuaWNvbk5hbWUsXG4gICAgICBwcmVmaXggPSBfY2xhc3NQYXJzZXIucHJlZml4LFxuICAgICAgZXh0cmFDbGFzc2VzID0gX2NsYXNzUGFyc2VyLnJlc3Q7XG5cbiAgdmFyIGV4dHJhU3R5bGVzID0gc3R5bGVQYXJzZXIobm9kZSk7XG4gIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1QYXJzZXIobm9kZSk7XG4gIHZhciBzeW1ib2wgPSBzeW1ib2xQYXJzZXIobm9kZSk7XG4gIHZhciBleHRyYUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzUGFyc2VyKG5vZGUpO1xuICB2YXIgbWFzayA9IG1hc2tQYXJzZXIobm9kZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpY29uTmFtZTogaWNvbk5hbWUsXG4gICAgdGl0bGU6IG5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpLFxuICAgIHByZWZpeDogcHJlZml4LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIHN5bWJvbDogc3ltYm9sLFxuICAgIG1hc2s6IG1hc2ssXG4gICAgZXh0cmE6IHtcbiAgICAgIGNsYXNzZXM6IGV4dHJhQ2xhc3NlcyxcbiAgICAgIHN0eWxlczogZXh0cmFTdHlsZXMsXG4gICAgICBhdHRyaWJ1dGVzOiBleHRyYUF0dHJpYnV0ZXNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIE1pc3NpbmdJY29uKGVycm9yKSB7XG4gIHRoaXMubmFtZSA9ICdNaXNzaW5nSWNvbic7XG4gIHRoaXMubWVzc2FnZSA9IGVycm9yIHx8ICdJY29uIHVuYXZhaWxhYmxlJztcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xufVxuXG5NaXNzaW5nSWNvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5NaXNzaW5nSWNvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaXNzaW5nSWNvbjtcblxudmFyIEZJTEwgPSB7IGZpbGw6ICdjdXJyZW50Q29sb3InIH07XG52YXIgQU5JTUFUSU9OX0JBU0UgPSB7XG4gIGF0dHJpYnV0ZVR5cGU6ICdYTUwnLFxuICByZXBlYXRDb3VudDogJ2luZGVmaW5pdGUnLFxuICBkdXI6ICcycydcbn07XG52YXIgUklORyA9IHtcbiAgdGFnOiAncGF0aCcsXG4gIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCBGSUxMLCB7XG4gICAgZDogJ00xNTYuNSw0NDcuN2wtMTIuNiwyOS41Yy0xOC43LTkuNS0zNS45LTIxLjItNTEuNS0zNC45bDIyLjctMjIuN0MxMjcuNiw0MzAuNSwxNDEuNSw0NDAsMTU2LjUsNDQ3Ljd6IE00MC42LDI3Mkg4LjUgYzEuNCwyMS4yLDUuNCw0MS43LDExLjcsNjEuMUw1MCwzMjEuMkM0NS4xLDMwNS41LDQxLjgsMjg5LDQwLjYsMjcyeiBNNDAuNiwyNDBjMS40LTE4LjgsNS4yLTM3LDExLjEtNTQuMWwtMjkuNS0xMi42IEMxNC43LDE5NC4zLDEwLDIxNi43LDguNSwyNDBINDAuNnogTTY0LjMsMTU2LjVjNy44LTE0LjksMTcuMi0yOC44LDI4LjEtNDEuNUw2OS43LDkyLjNjLTEzLjcsMTUuNi0yNS41LDMyLjgtMzQuOSw1MS41IEw2NC4zLDE1Ni41eiBNMzk3LDQxOS42Yy0xMy45LDEyLTI5LjQsMjIuMy00Ni4xLDMwLjRsMTEuOSwyOS44YzIwLjctOS45LDM5LjgtMjIuNiw1Ni45LTM3LjZMMzk3LDQxOS42eiBNMTE1LDkyLjQgYzEzLjktMTIsMjkuNC0yMi4zLDQ2LjEtMzAuNGwtMTEuOS0yOS44Yy0yMC43LDkuOS0zOS44LDIyLjYtNTYuOCwzNy42TDExNSw5Mi40eiBNNDQ3LjcsMzU1LjVjLTcuOCwxNC45LTE3LjIsMjguOC0yOC4xLDQxLjUgbDIyLjcsMjIuN2MxMy43LTE1LjYsMjUuNS0zMi45LDM0LjktNTEuNUw0NDcuNywzNTUuNXogTTQ3MS40LDI3MmMtMS40LDE4LjgtNS4yLDM3LTExLjEsNTQuMWwyOS41LDEyLjYgYzcuNS0yMS4xLDEyLjItNDMuNSwxMy42LTY2LjhINDcxLjR6IE0zMjEuMiw0NjJjLTE1LjcsNS0zMi4yLDguMi00OS4yLDkuNHYzMi4xYzIxLjItMS40LDQxLjctNS40LDYxLjEtMTEuN0wzMjEuMiw0NjJ6IE0yNDAsNDcxLjRjLTE4LjgtMS40LTM3LTUuMi01NC4xLTExLjFsLTEyLjYsMjkuNWMyMS4xLDcuNSw0My41LDEyLjIsNjYuOCwxMy42VjQ3MS40eiBNNDYyLDE5MC44YzUsMTUuNyw4LjIsMzIuMiw5LjQsNDkuMmgzMi4xIGMtMS40LTIxLjItNS40LTQxLjctMTEuNy02MS4xTDQ2MiwxOTAuOHogTTkyLjQsMzk3Yy0xMi0xMy45LTIyLjMtMjkuNC0zMC40LTQ2LjFsLTI5LjgsMTEuOWM5LjksMjAuNywyMi42LDM5LjgsMzcuNiw1Ni45IEw5Mi40LDM5N3ogTTI3Miw0MC42YzE4LjgsMS40LDM2LjksNS4yLDU0LjEsMTEuMWwxMi42LTI5LjVDMzE3LjcsMTQuNywyOTUuMywxMCwyNzIsOC41VjQwLjZ6IE0xOTAuOCw1MCBjMTUuNy01LDMyLjItOC4yLDQ5LjItOS40VjguNWMtMjEuMiwxLjQtNDEuNyw1LjQtNjEuMSwxMS43TDE5MC44LDUweiBNNDQyLjMsOTIuM0w0MTkuNiwxMTVjMTIsMTMuOSwyMi4zLDI5LjQsMzAuNSw0Ni4xIGwyOS44LTExLjlDNDcwLDEyOC41LDQ1Ny4zLDEwOS40LDQ0Mi4zLDkyLjN6IE0zOTcsOTIuNGwyMi43LTIyLjdjLTE1LjYtMTMuNy0zMi44LTI1LjUtNTEuNS0zNC45bC0xMi42LDI5LjUgQzM3MC40LDcyLjEsMzg0LjQsODEuNSwzOTcsOTIuNHonXG4gIH0pXG59O1xudmFyIE9QQUNJVFlfQU5JTUFURSA9IF9leHRlbmRzKHt9LCBBTklNQVRJT05fQkFTRSwge1xuICBhdHRyaWJ1dGVOYW1lOiAnb3BhY2l0eSdcbn0pO1xudmFyIERPVCA9IHtcbiAgdGFnOiAnY2lyY2xlJyxcbiAgYXR0cmlidXRlczogX2V4dGVuZHMoe30sIEZJTEwsIHtcbiAgICBjeDogJzI1NicsXG4gICAgY3k6ICczNjQnLFxuICAgIHI6ICcyOCdcbiAgfSksXG4gIGNoaWxkcmVuOiBbeyB0YWc6ICdhbmltYXRlJywgYXR0cmlidXRlczogX2V4dGVuZHMoe30sIEFOSU1BVElPTl9CQVNFLCB7IGF0dHJpYnV0ZU5hbWU6ICdyJywgdmFsdWVzOiAnMjg7MTQ7Mjg7Mjg7MTQ7Mjg7JyB9KSB9LCB7IHRhZzogJ2FuaW1hdGUnLCBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgT1BBQ0lUWV9BTklNQVRFLCB7IHZhbHVlczogJzE7MDsxOzE7MDsxOycgfSkgfV1cbn07XG52YXIgUVVFU1RJT04gPSB7XG4gIHRhZzogJ3BhdGgnLFxuICBhdHRyaWJ1dGVzOiBfZXh0ZW5kcyh7fSwgRklMTCwge1xuICAgIG9wYWNpdHk6ICcxJyxcbiAgICBkOiAnTTI2My43LDMxMmgtMTZjLTYuNiwwLTEyLTUuNC0xMi0xMmMwLTcxLDc3LjQtNjMuOSw3Ny40LTEwNy44YzAtMjAtMTcuOC00MC4yLTU3LjQtNDAuMmMtMjkuMSwwLTQ0LjMsOS42LTU5LjIsMjguNyBjLTMuOSw1LTExLjEsNi0xNi4yLDIuNGwtMTMuMS05LjJjLTUuNi0zLjktNi45LTExLjgtMi42LTE3LjJjMjEuMi0yNy4yLDQ2LjQtNDQuNyw5MS4yLTQ0LjdjNTIuMywwLDk3LjQsMjkuOCw5Ny40LDgwLjIgYzAsNjcuNi03Ny40LDYzLjUtNzcuNCwxMDcuOEMyNzUuNywzMDYuNiwyNzAuMywzMTIsMjYzLjcsMzEyeidcbiAgfSksXG4gIGNoaWxkcmVuOiBbeyB0YWc6ICdhbmltYXRlJywgYXR0cmlidXRlczogX2V4dGVuZHMoe30sIE9QQUNJVFlfQU5JTUFURSwgeyB2YWx1ZXM6ICcxOzA7MDswOzA7MTsnIH0pIH1dXG59O1xudmFyIEVYQ0xBTUFUSU9OID0ge1xuICB0YWc6ICdwYXRoJyxcbiAgYXR0cmlidXRlczogX2V4dGVuZHMoe30sIEZJTEwsIHtcbiAgICBvcGFjaXR5OiAnMCcsXG4gICAgZDogJ00yMzIuNSwxMzQuNWw3LDE2OGMwLjMsNi40LDUuNiwxMS41LDEyLDExLjVoOWM2LjQsMCwxMS43LTUuMSwxMi0xMS41bDctMTY4YzAuMy02LjgtNS4yLTEyLjUtMTItMTIuNWgtMjMgQzIzNy43LDEyMiwyMzIuMiwxMjcuNywyMzIuNSwxMzQuNXonXG4gIH0pLFxuICBjaGlsZHJlbjogW3sgdGFnOiAnYW5pbWF0ZScsIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHt9LCBPUEFDSVRZX0FOSU1BVEUsIHsgdmFsdWVzOiAnMDswOzE7MTswOzA7JyB9KSB9XVxufTtcblxudmFyIG1pc3NpbmcgPSB7IHRhZzogJ2cnLCBjaGlsZHJlbjogW1JJTkcsIERPVCwgUVVFU1RJT04sIEVYQ0xBTUFUSU9OXSB9O1xuXG52YXIgc3R5bGVzID0gbmFtZXNwYWNlLnN0eWxlcztcblxudmFyIExBWUVSU19URVhUX0NMQVNTTkFNRSA9ICdmYS1sYXllcnMtdGV4dCc7XG52YXIgRk9OVF9GQU1JTFlfUEFUVEVSTiA9IC9Gb250IEF3ZXNvbWUgNSAoU29saWR8UmVndWxhcnxMaWdodHxCcmFuZHMpLztcbnZhciBTVFlMRV9UT19QUkVGSVggPSB7XG4gICdTb2xpZCc6ICdmYXMnLFxuICAnUmVndWxhcic6ICdmYXInLFxuICAnTGlnaHQnOiAnZmFsJyxcbiAgJ0JyYW5kcyc6ICdmYWInXG59O1xuXG5mdW5jdGlvbiBmaW5kSWNvbihpY29uTmFtZSwgcHJlZml4KSB7XG4gIHZhciB2YWwgPSB7XG4gICAgZm91bmQ6IGZhbHNlLFxuICAgIHdpZHRoOiA1MTIsXG4gICAgaGVpZ2h0OiA1MTIsXG4gICAgaWNvbjogbWlzc2luZ1xuICB9O1xuXG4gIGlmIChpY29uTmFtZSAmJiBwcmVmaXggJiYgc3R5bGVzW3ByZWZpeF0gJiYgc3R5bGVzW3ByZWZpeF1baWNvbk5hbWVdKSB7XG4gICAgdmFyIGljb24gPSBzdHlsZXNbcHJlZml4XVtpY29uTmFtZV07XG4gICAgdmFyIHdpZHRoID0gaWNvblswXTtcbiAgICB2YXIgaGVpZ2h0ID0gaWNvblsxXTtcbiAgICB2YXIgdmVjdG9yRGF0YSA9IGljb24uc2xpY2UoNCk7XG5cbiAgICB2YWwgPSB7XG4gICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgaWNvbjogeyB0YWc6ICdwYXRoJywgYXR0cmlidXRlczogeyBmaWxsOiAnY3VycmVudENvbG9yJywgZDogdmVjdG9yRGF0YVswXSB9IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKGljb25OYW1lICYmIHByZWZpeCAmJiAhY29uZmlnJDEuc2hvd01pc3NpbmdJY29ucykge1xuICAgIHRocm93IG5ldyBNaXNzaW5nSWNvbignSWNvbiBpcyBtaXNzaW5nIGZvciBwcmVmaXggJyArIHByZWZpeCArICcgd2l0aCBpY29uIG5hbWUgJyArIGljb25OYW1lKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3ZnUmVwbGFjZW1lbnRNdXRhdGlvbihub2RlLCBub2RlTWV0YSkge1xuICB2YXIgaWNvbk5hbWUgPSBub2RlTWV0YS5pY29uTmFtZSxcbiAgICAgIHRpdGxlID0gbm9kZU1ldGEudGl0bGUsXG4gICAgICBwcmVmaXggPSBub2RlTWV0YS5wcmVmaXgsXG4gICAgICB0cmFuc2Zvcm0gPSBub2RlTWV0YS50cmFuc2Zvcm0sXG4gICAgICBzeW1ib2wgPSBub2RlTWV0YS5zeW1ib2wsXG4gICAgICBtYXNrID0gbm9kZU1ldGEubWFzayxcbiAgICAgIGV4dHJhID0gbm9kZU1ldGEuZXh0cmE7XG5cblxuICByZXR1cm4gW25vZGUsIG1ha2VJbmxpbmVTdmdBYnN0cmFjdCh7XG4gICAgaWNvbnM6IHtcbiAgICAgIG1haW46IGZpbmRJY29uKGljb25OYW1lLCBwcmVmaXgpLFxuICAgICAgbWFzazogZmluZEljb24obWFzay5pY29uTmFtZSwgbWFzay5wcmVmaXgpXG4gICAgfSxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBpY29uTmFtZTogaWNvbk5hbWUsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgbWFzazogbWFzayxcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgZXh0cmE6IGV4dHJhLFxuICAgIHdhdGNoYWJsZTogdHJ1ZVxuICB9KV07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTGF5ZXJzVGV4dChub2RlLCBub2RlTWV0YSkge1xuICB2YXIgdGl0bGUgPSBub2RlTWV0YS50aXRsZSxcbiAgICAgIHRyYW5zZm9ybSA9IG5vZGVNZXRhLnRyYW5zZm9ybSxcbiAgICAgIGV4dHJhID0gbm9kZU1ldGEuZXh0cmE7XG5cblxuICB2YXIgd2lkdGggPSBudWxsO1xuICB2YXIgaGVpZ2h0ID0gbnVsbDtcblxuICBpZiAoSVNfSUUpIHtcbiAgICB2YXIgY29tcHV0ZWRGb250U2l6ZSA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUobm9kZSkuZm9udFNpemUsIDEwKTtcbiAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB3aWR0aCA9IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCAvIGNvbXB1dGVkRm9udFNpemU7XG4gICAgaGVpZ2h0ID0gYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAvIGNvbXB1dGVkRm9udFNpemU7XG4gIH1cblxuICBpZiAoY29uZmlnJDEuYXV0b0ExMXkgJiYgIXRpdGxlKSB7XG4gICAgZXh0cmEuYXR0cmlidXRlc1snYXJpYS1oaWRkZW4nXSA9ICd0cnVlJztcbiAgfVxuXG4gIHJldHVybiBbbm9kZSwgbWFrZUxheWVyc1RleHRBYnN0cmFjdCh7XG4gICAgY29udGVudDogbm9kZS5pbm5lckhUTUwsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIHRpdGxlOiB0aXRsZSxcbiAgICBleHRyYTogZXh0cmEsXG4gICAgd2F0Y2hhYmxlOiB0cnVlXG4gIH0pXTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNdXRhdGlvbihub2RlKSB7XG4gIHZhciBub2RlTWV0YSA9IHBhcnNlTWV0YShub2RlKTtcblxuICBpZiAofm5vZGVNZXRhLmV4dHJhLmNsYXNzZXMuaW5kZXhPZihMQVlFUlNfVEVYVF9DTEFTU05BTUUpKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlTGF5ZXJzVGV4dChub2RlLCBub2RlTWV0YSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlU3ZnUmVwbGFjZW1lbnRNdXRhdGlvbihub2RlLCBub2RlTWV0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSBpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VhcmNoUHNldWRvRWxlbWVudHMocm9vdCkge1xuICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuXG4gIHZhciBlbmQgPSBwZXJmLmJlZ2luKCdzZWFyY2hQc2V1ZG9FbGVtZW50cycpO1xuXG4gIGRpc2FibGVPYnNlcnZhdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgdG9BcnJheShyb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgWyc6YmVmb3JlJywgJzphZnRlciddLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgc3R5bGVzID0gV0lORE9XLmdldENvbXB1dGVkU3R5bGUobm9kZSwgcG9zKTtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1mYW1pbHknKS5tYXRjaChGT05UX0ZBTUlMWV9QQVRURVJOKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdG9BcnJheShub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIHBzZXVkb0VsZW1lbnQgPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5nZXRBdHRyaWJ1dGUoREFUQV9GQV9QU0VVRE9fRUxFTUVOVCkgPT09IHBvcztcbiAgICAgICAgfSlbMF07XG5cbiAgICAgICAgaWYgKHBzZXVkb0VsZW1lbnQpIHtcbiAgICAgICAgICBpZiAocHNldWRvRWxlbWVudC5uZXh0U2libGluZyAmJiBwc2V1ZG9FbGVtZW50Lm5leHRTaWJsaW5nLnRleHRDb250ZW50LmluZGV4T2YoREFUQV9GQV9QU0VVRE9fRUxFTUVOVCkgPiAtMSkge1xuICAgICAgICAgICAgcmVtb3ZlKHBzZXVkb0VsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmUocHNldWRvRWxlbWVudCk7XG4gICAgICAgICAgcHNldWRvRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udEZhbWlseSAmJiAhcHNldWRvRWxlbWVudCkge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKTtcbiAgICAgICAgICB2YXIgaSA9IERPQ1VNRU5ULmNyZWF0ZUVsZW1lbnQoJ2knKTtcbiAgICAgICAgICBpLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnJyArIFNUWUxFX1RPX1BSRUZJWFtmb250RmFtaWx5WzFdXSk7XG4gICAgICAgICAgaS5zZXRBdHRyaWJ1dGUoREFUQV9GQV9QU0VVRE9fRUxFTUVOVCwgcG9zKTtcbiAgICAgICAgICBpLmlubmVyVGV4dCA9IGNvbnRlbnQubGVuZ3RoID09PSAzID8gY29udGVudC5zdWJzdHIoMSwgMSkgOiBjb250ZW50O1xuICAgICAgICAgIGlmIChwb3MgPT09ICc6YmVmb3JlJykge1xuICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoaSwgbm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBlbmQoKTtcbn1cblxuZnVuY3Rpb24gb25UcmVlKHJvb3QpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gIGlmICghSVNfRE9NKSByZXR1cm47XG5cbiAgdmFyIGh0bWxDbGFzc0xpc3QgPSBET0NVTUVOVC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0O1xuICB2YXIgaGNsQWRkID0gZnVuY3Rpb24gaGNsQWRkKHN1ZmZpeCkge1xuICAgIHJldHVybiBodG1sQ2xhc3NMaXN0LmFkZChIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MgKyAnLScgKyBzdWZmaXgpO1xuICB9O1xuICB2YXIgaGNsUmVtb3ZlID0gZnVuY3Rpb24gaGNsUmVtb3ZlKHN1ZmZpeCkge1xuICAgIHJldHVybiBodG1sQ2xhc3NMaXN0LnJlbW92ZShIVE1MX0NMQVNTX0kyU1ZHX0JBU0VfQ0xBU1MgKyAnLScgKyBzdWZmaXgpO1xuICB9O1xuICB2YXIgcHJlZml4ZXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpO1xuICB2YXIgcHJlZml4ZXNEb21RdWVyeSA9IFsnLicgKyBMQVlFUlNfVEVYVF9DTEFTU05BTUUgKyAnOm5vdChbJyArIERBVEFfRkFfSTJTVkcgKyAnXSknXS5jb25jYXQocHJlZml4ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICcuJyArIHAgKyAnOm5vdChbJyArIERBVEFfRkFfSTJTVkcgKyAnXSknO1xuICB9KSkuam9pbignLCAnKTtcblxuICBpZiAocHJlZml4ZXNEb21RdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlcyA9IHRvQXJyYXkocm9vdC5xdWVyeVNlbGVjdG9yQWxsKHByZWZpeGVzRG9tUXVlcnkpKTtcblxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgaGNsQWRkKCdwZW5kaW5nJyk7XG4gICAgaGNsUmVtb3ZlKCdjb21wbGV0ZScpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrID0gcGVyZi5iZWdpbignb25UcmVlJyk7XG5cbiAgdmFyIG11dGF0aW9ucyA9IGNhbmRpZGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG11dGF0aW9uID0gZ2VuZXJhdGVNdXRhdGlvbihub2RlKTtcblxuICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgIGFjYy5wdXNoKG11dGF0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIVBST0RVQ1RJT04pIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNaXNzaW5nSWNvbikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG5cbiAgbWFyaygpO1xuXG4gIHBlcmZvcm0obXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgaGNsQWRkKCdhY3RpdmUnKTtcbiAgICBoY2xBZGQoJ2NvbXBsZXRlJyk7XG4gICAgaGNsUmVtb3ZlKCdwZW5kaW5nJyk7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25Ob2RlKG5vZGUpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gIHZhciBtdXRhdGlvbiA9IGdlbmVyYXRlTXV0YXRpb24obm9kZSk7XG5cbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgcGVyZm9ybShbbXV0YXRpb25dLCBjYWxsYmFjayk7XG4gIH1cbn1cblxudmFyIGJhc2VTdHlsZXMgPSBcInN2Zzpub3QoOnJvb3QpLnN2Zy1pbmxpbmUtLWZhIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XFxuXFxuLnN2Zy1pbmxpbmUtLWZhIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGhlaWdodDogMWVtO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogLS4xMjVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLWxnIHtcXG4gICAgdmVydGljYWwtYWxpZ246IC0uMjI1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTEge1xcbiAgICB3aWR0aDogMC4wNjI1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTIge1xcbiAgICB3aWR0aDogMC4xMjVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctMyB7XFxuICAgIHdpZHRoOiAwLjE4NzVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctNCB7XFxuICAgIHdpZHRoOiAwLjI1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTUge1xcbiAgICB3aWR0aDogMC4zMTI1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTYge1xcbiAgICB3aWR0aDogMC4zNzVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctNyB7XFxuICAgIHdpZHRoOiAwLjQzNzVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctOCB7XFxuICAgIHdpZHRoOiAwLjVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctOSB7XFxuICAgIHdpZHRoOiAwLjU2MjVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTAge1xcbiAgICB3aWR0aDogMC42MjVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTEge1xcbiAgICB3aWR0aDogMC42ODc1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTEyIHtcXG4gICAgd2lkdGg6IDAuNzVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctMTMge1xcbiAgICB3aWR0aDogMC44MTI1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTE0IHtcXG4gICAgd2lkdGg6IDAuODc1ZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTE1IHtcXG4gICAgd2lkdGg6IDAuOTM3NWVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtdy0xNiB7XFxuICAgIHdpZHRoOiAxZW07IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS13LTE3IHtcXG4gICAgd2lkdGg6IDEuMDYyNWVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtdy0xOCB7XFxuICAgIHdpZHRoOiAxLjEyNWVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtdy0xOSB7XFxuICAgIHdpZHRoOiAxLjE4NzVlbTsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXctMjAge1xcbiAgICB3aWR0aDogMS4yNWVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtcHVsbC1sZWZ0IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAuM2VtO1xcbiAgICB3aWR0aDogYXV0bzsgfVxcbiAgLnN2Zy1pbmxpbmUtLWZhLmZhLXB1bGwtcmlnaHQge1xcbiAgICBtYXJnaW4tbGVmdDogLjNlbTtcXG4gICAgd2lkdGg6IGF1dG87IH1cXG4gIC5zdmctaW5saW5lLS1mYS5mYS1ib3JkZXIge1xcbiAgICBoZWlnaHQ6IDEuNWVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtbGkge1xcbiAgICB3aWR0aDogMmVtOyB9XFxuICAuc3ZnLWlubGluZS0tZmEuZmEtZncge1xcbiAgICB3aWR0aDogMS4yNWVtOyB9XFxuXFxuLmZhLWxheWVycyBzdmcuc3ZnLWlubGluZS0tZmEge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogYXV0bztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwOyB9XFxuXFxuLmZhLWxheWVycyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBoZWlnaHQ6IDFlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHZlcnRpY2FsLWFsaWduOiAtLjEyNWVtO1xcbiAgd2lkdGg6IDFlbTsgfVxcbiAgLmZhLWxheWVycyBzdmcuc3ZnLWlubGluZS0tZmEge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XFxuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjsgfVxcblxcbi5mYS1sYXllcnMtdGV4dCwgLmZhLWxheWVycy1jb3VudGVyIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi5mYS1sYXllcnMtdGV4dCB7XFxuICBsZWZ0OiA1MCU7XFxuICB0b3A6IDUwJTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyOyB9XFxuXFxuLmZhLWxheWVycy1jb3VudGVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjI1M2E7XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGhlaWdodDogMS41ZW07XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIG1heC13aWR0aDogNWVtO1xcbiAgbWluLXdpZHRoOiAxLjVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiAuMjVlbTtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB0b3A6IDA7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHRvcCByaWdodDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIHJpZ2h0OyB9XFxuXFxuLmZhLWxheWVycy1ib3R0b20tcmlnaHQge1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IGF1dG87XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSByaWdodDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0OyB9XFxuXFxuLmZhLWxheWVycy1ib3R0b20tbGVmdCB7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IGF1dG87XFxuICB0b3A6IGF1dG87XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4yNSk7XFxuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGJvdHRvbSBsZWZ0O1xcbiAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gbGVmdDsgfVxcblxcbi5mYS1sYXllcnMtdG9wLXJpZ2h0IHtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiB0b3AgcmlnaHQ7XFxuICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCByaWdodDsgfVxcblxcbi5mYS1sYXllcnMtdG9wLWxlZnQge1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiBhdXRvO1xcbiAgdG9wOiAwO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMjUpO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcXG4gICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IH1cXG5cXG4uZmEtbGcge1xcbiAgZm9udC1zaXplOiAxLjMzMzMzZW07XFxuICBsaW5lLWhlaWdodDogMC43NWVtO1xcbiAgdmVydGljYWwtYWxpZ246IC0uMDY2N2VtOyB9XFxuXFxuLmZhLXhzIHtcXG4gIGZvbnQtc2l6ZTogLjc1ZW07IH1cXG5cXG4uZmEtc20ge1xcbiAgZm9udC1zaXplOiAuODc1ZW07IH1cXG5cXG4uZmEtMXgge1xcbiAgZm9udC1zaXplOiAxZW07IH1cXG5cXG4uZmEtMngge1xcbiAgZm9udC1zaXplOiAyZW07IH1cXG5cXG4uZmEtM3gge1xcbiAgZm9udC1zaXplOiAzZW07IH1cXG5cXG4uZmEtNHgge1xcbiAgZm9udC1zaXplOiA0ZW07IH1cXG5cXG4uZmEtNXgge1xcbiAgZm9udC1zaXplOiA1ZW07IH1cXG5cXG4uZmEtNngge1xcbiAgZm9udC1zaXplOiA2ZW07IH1cXG5cXG4uZmEtN3gge1xcbiAgZm9udC1zaXplOiA3ZW07IH1cXG5cXG4uZmEtOHgge1xcbiAgZm9udC1zaXplOiA4ZW07IH1cXG5cXG4uZmEtOXgge1xcbiAgZm9udC1zaXplOiA5ZW07IH1cXG5cXG4uZmEtMTB4IHtcXG4gIGZvbnQtc2l6ZTogMTBlbTsgfVxcblxcbi5mYS1mdyB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aWR0aDogMS4yNWVtOyB9XFxuXFxuLmZhLXVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXG4gIG1hcmdpbi1sZWZ0OiAyLjVlbTtcXG4gIHBhZGRpbmctbGVmdDogMDsgfVxcbiAgLmZhLXVsID4gbGkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG5cXG4uZmEtbGkge1xcbiAgbGVmdDogLTJlbTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHdpZHRoOiAyZW07XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbi5mYS1ib3JkZXIge1xcbiAgYm9yZGVyOiBzb2xpZCAwLjA4ZW0gI2VlZTtcXG4gIGJvcmRlci1yYWRpdXM6IC4xZW07XFxuICBwYWRkaW5nOiAuMmVtIC4yNWVtIC4xNWVtOyB9XFxuXFxuLmZhLXB1bGwtbGVmdCB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi5mYS1wdWxsLXJpZ2h0IHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi5mYS5mYS1wdWxsLWxlZnQsXFxuLmZhcy5mYS1wdWxsLWxlZnQsXFxuLmZhci5mYS1wdWxsLWxlZnQsXFxuLmZhbC5mYS1wdWxsLWxlZnQsXFxuLmZhYi5mYS1wdWxsLWxlZnQge1xcbiAgbWFyZ2luLXJpZ2h0OiAuM2VtOyB9XFxuXFxuLmZhLmZhLXB1bGwtcmlnaHQsXFxuLmZhcy5mYS1wdWxsLXJpZ2h0LFxcbi5mYXIuZmEtcHVsbC1yaWdodCxcXG4uZmFsLmZhLXB1bGwtcmlnaHQsXFxuLmZhYi5mYS1wdWxsLXJpZ2h0IHtcXG4gIG1hcmdpbi1sZWZ0OiAuM2VtOyB9XFxuXFxuLmZhLXNwaW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyOyB9XFxuXFxuLmZhLXB1bHNlIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBmYS1zcGluIDFzIGluZmluaXRlIHN0ZXBzKDgpO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7IH1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZmEtc3BpbiB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XFxuXFxuQGtleWZyYW1lcyBmYS1zcGluIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH1cXG5cXG4uZmEtcm90YXRlLTkwIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0xKVxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOyB9XFxuXFxuLmZhLXJvdGF0ZS0xODAge1xcbiAgLW1zLWZpbHRlcjogXFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5CYXNpY0ltYWdlKHJvdGF0aW9uPTIpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTsgfVxcblxcbi5mYS1yb3RhdGUtMjcwIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0zKVxcXCI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7IH1cXG5cXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0wLCBtaXJyb3I9MSlcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKC0xLCAxKTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7IH1cXG5cXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtbXMtZmlsdGVyOiBcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJhc2ljSW1hZ2Uocm90YXRpb249MiwgbWlycm9yPTEpXFxcIjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpOyB9XFxuXFxuLmZhLWZsaXAtaG9yaXpvbnRhbC5mYS1mbGlwLXZlcnRpY2FsIHtcXG4gIC1tcy1maWx0ZXI6IFxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQmFzaWNJbWFnZShyb3RhdGlvbj0yLCBtaXJyb3I9MSlcXFwiO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKC0xLCAtMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLTEsIC0xKTsgfVxcblxcbjpyb290IC5mYS1yb3RhdGUtOTAsXFxuOnJvb3QgLmZhLXJvdGF0ZS0xODAsXFxuOnJvb3QgLmZhLXJvdGF0ZS0yNzAsXFxuOnJvb3QgLmZhLWZsaXAtaG9yaXpvbnRhbCxcXG46cm9vdCAuZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtd2Via2l0LWZpbHRlcjogbm9uZTtcXG4gICAgICAgICAgZmlsdGVyOiBub25lOyB9XFxuXFxuLmZhLXN0YWNrIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGhlaWdodDogMmVtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDJlbTsgfVxcblxcbi5mYS1zdGFjay0xeCxcXG4uZmEtc3RhY2stMngge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogYXV0bztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwOyB9XFxuXFxuLnN2Zy1pbmxpbmUtLWZhLmZhLXN0YWNrLTF4IHtcXG4gIGhlaWdodDogMWVtO1xcbiAgd2lkdGg6IDFlbTsgfVxcblxcbi5zdmctaW5saW5lLS1mYS5mYS1zdGFjay0yeCB7XFxuICBoZWlnaHQ6IDJlbTtcXG4gIHdpZHRoOiAyZW07IH1cXG5cXG4uZmEtaW52ZXJzZSB7XFxuICBjb2xvcjogI2ZmZjsgfVxcblxcbi5zci1vbmx5IHtcXG4gIGJvcmRlcjogMDtcXG4gIGNsaXA6IHJlY3QoMCwgMCwgMCwgMCk7XFxuICBoZWlnaHQ6IDFweDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDFweDsgfVxcblxcbi5zci1vbmx5LWZvY3VzYWJsZTphY3RpdmUsIC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1cyB7XFxuICBjbGlwOiBhdXRvO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbWFyZ2luOiAwO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICBwb3NpdGlvbjogc3RhdGljO1xcbiAgd2lkdGg6IGF1dG87IH1cXG5cIjtcblxudmFyIGNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRmcCA9IERFRkFVTFRfRkFNSUxZX1BSRUZJWDtcbiAgdmFyIGRyYyA9IERFRkFVTFRfUkVQTEFDRU1FTlRfQ0xBU1M7XG4gIHZhciBmcCA9IGNvbmZpZyQxLmZhbWlseVByZWZpeDtcbiAgdmFyIHJjID0gY29uZmlnJDEucmVwbGFjZW1lbnRDbGFzcztcbiAgdmFyIHMgPSBiYXNlU3R5bGVzO1xuXG4gIGlmIChmcCAhPT0gZGZwIHx8IHJjICE9PSBkcmMpIHtcbiAgICB2YXIgZFBhdHQgPSBuZXcgUmVnRXhwKCdcXFxcLicgKyBkZnAgKyAnXFxcXC0nLCAnZycpO1xuICAgIHZhciByUGF0dCA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGRyYywgJ2cnKTtcblxuICAgIHMgPSBzLnJlcGxhY2UoZFBhdHQsICcuJyArIGZwICsgJy0nKS5yZXBsYWNlKHJQYXR0LCAnLicgKyByYyk7XG4gIH1cblxuICByZXR1cm4gcztcbn07XG5cbmZ1bmN0aW9uIGRlZmluZShwcmVmaXgsIGljb25zKSB7XG4gIHZhciBub3JtYWxpemVkID0gT2JqZWN0LmtleXMoaWNvbnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpY29uTmFtZSkge1xuICAgIHZhciBpY29uID0gaWNvbnNbaWNvbk5hbWVdO1xuICAgIHZhciBleHBhbmRlZCA9ICEhaWNvbi5pY29uO1xuXG4gICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICBhY2NbaWNvbi5pY29uTmFtZV0gPSBpY29uLmljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1tpY29uTmFtZV0gPSBpY29uO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbiAgaWYgKHR5cGVvZiBuYW1lc3BhY2UuaG9va3MuYWRkUGFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWVzcGFjZS5ob29rcy5hZGRQYWNrKHByZWZpeCwgbm9ybWFsaXplZCk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZXNwYWNlLnN0eWxlc1twcmVmaXhdID0gX2V4dGVuZHMoe30sIG5hbWVzcGFjZS5zdHlsZXNbcHJlZml4XSB8fCB7fSwgbm9ybWFsaXplZCk7XG4gIH1cblxuICAvKipcbiAgICogRm9udCBBd2Vzb21lIDQgdXNlZCB0aGUgcHJlZml4IG9mIGBmYWAgZm9yIGFsbCBpY29ucy4gV2l0aCB0aGUgaW50cm9kdWN0aW9uXG4gICAqIG9mIG5ldyBzdHlsZXMgd2UgbmVlZGVkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGVtLiBQcmVmaXggYGZhYCBpcyBub3cgYW4gYWxpYXNcbiAgICogZm9yIGBmYXNgIHNvIHdlJ2xsIGVhc3kgdGhlIHVwZ3JhZGUgcHJvY2VzcyBmb3Igb3VyIHVzZXJzIGJ5IGF1dG9tYXRpY2FsbHkgZGVmaW5pbmdcbiAgICogdGhpcyBhcyB3ZWxsLlxuICAgKi9cbiAgaWYgKHByZWZpeCA9PT0gJ2ZhcycpIHtcbiAgICBkZWZpbmUoJ2ZhJywgaWNvbnMpO1xuICB9XG59XG5cbnZhciBMaWJyYXJ5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaWJyYXJ5KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExpYnJhcnkpO1xuXG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTGlicmFyeSwgW3tcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZGVmaW5pdGlvbnMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgZGVmaW5pdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGRpdGlvbnMgPSBkZWZpbml0aW9ucy5yZWR1Y2UodGhpcy5fcHVsbERlZmluaXRpb25zLCB7fSk7XG5cbiAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF90aGlzLmRlZmluaXRpb25zW2tleV0gPSBfZXh0ZW5kcyh7fSwgX3RoaXMuZGVmaW5pdGlvbnNba2V5XSB8fCB7fSwgYWRkaXRpb25zW2tleV0pO1xuICAgICAgICBkZWZpbmUoa2V5LCBhZGRpdGlvbnNba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19wdWxsRGVmaW5pdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVsbERlZmluaXRpb25zKGFkZGl0aW9ucywgZGVmaW5pdGlvbikge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBkZWZpbml0aW9uLnByZWZpeCAmJiBkZWZpbml0aW9uLmljb25OYW1lICYmIGRlZmluaXRpb24uaWNvbiA/IHsgMDogZGVmaW5pdGlvbiB9IDogZGVmaW5pdGlvbjtcblxuICAgICAgT2JqZWN0LmtleXMobm9ybWFsaXplZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9ub3JtYWxpemVkJGtleSA9IG5vcm1hbGl6ZWRba2V5XSxcbiAgICAgICAgICAgIHByZWZpeCA9IF9ub3JtYWxpemVkJGtleS5wcmVmaXgsXG4gICAgICAgICAgICBpY29uTmFtZSA9IF9ub3JtYWxpemVkJGtleS5pY29uTmFtZSxcbiAgICAgICAgICAgIGljb24gPSBfbm9ybWFsaXplZCRrZXkuaWNvbjtcblxuXG4gICAgICAgIGlmICghYWRkaXRpb25zW3ByZWZpeF0pIGFkZGl0aW9uc1twcmVmaXhdID0ge307XG5cbiAgICAgICAgYWRkaXRpb25zW3ByZWZpeF1baWNvbk5hbWVdID0gaWNvbjtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYWRkaXRpb25zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGlicmFyeTtcbn0oKTtcblxuZnVuY3Rpb24gcHJlcEljb24oaWNvbikge1xuICB2YXIgd2lkdGggPSBpY29uWzBdO1xuICB2YXIgaGVpZ2h0ID0gaWNvblsxXTtcbiAgdmFyIHZlY3RvckRhdGEgPSBpY29uLnNsaWNlKDQpO1xuXG4gIHJldHVybiB7XG4gICAgZm91bmQ6IHRydWUsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGljb246IHsgdGFnOiAncGF0aCcsIGF0dHJpYnV0ZXM6IHsgZmlsbDogJ2N1cnJlbnRDb2xvcicsIGQ6IHZlY3RvckRhdGFbMF0gfSB9XG4gIH07XG59XG5cbnZhciBfY3NzSW5zZXJ0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5zdXJlQ3NzKCkge1xuICBpZiAoIWNvbmZpZyQxLmF1dG9BZGRDc3MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIV9jc3NJbnNlcnRlZCkge1xuICAgIGluc2VydENzcyhjc3MoKSk7XG4gIH1cblxuICBfY3NzSW5zZXJ0ZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBhcGlPYmplY3QodmFsLCBhYnN0cmFjdENyZWF0b3IpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ2Fic3RyYWN0Jywge1xuICAgIGdldDogYWJzdHJhY3RDcmVhdG9yXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWwsICdodG1sJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbC5hYnN0cmFjdC5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRvSHRtbChhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbCwgJ25vZGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlTX0RPTSkgcmV0dXJuO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gRE9DVU1FTlQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdmFsLmh0bWw7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZmluZEljb25EZWZpbml0aW9uKHBhcmFtcykge1xuICB2YXIgX3BhcmFtcyRwcmVmaXggPSBwYXJhbXMucHJlZml4LFxuICAgICAgcHJlZml4ID0gX3BhcmFtcyRwcmVmaXggPT09IHVuZGVmaW5lZCA/ICdmYScgOiBfcGFyYW1zJHByZWZpeCxcbiAgICAgIGljb25OYW1lID0gcGFyYW1zLmljb25OYW1lO1xuXG5cbiAgaWYgKCFpY29uTmFtZSkgcmV0dXJuO1xuXG4gIHJldHVybiBpY29uRnJvbU1hcHBpbmcobGlicmFyeS5kZWZpbml0aW9ucywgcHJlZml4LCBpY29uTmFtZSkgfHwgaWNvbkZyb21NYXBwaW5nKG5hbWVzcGFjZS5zdHlsZXMsIHByZWZpeCwgaWNvbk5hbWUpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSWNvbnMobmV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1heWJlSWNvbkRlZmluaXRpb24pIHtcbiAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBpY29uRGVmaW5pdGlvbiA9IChtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KS5pY29uID8gbWF5YmVJY29uRGVmaW5pdGlvbiA6IGZpbmRJY29uRGVmaW5pdGlvbihtYXliZUljb25EZWZpbml0aW9uIHx8IHt9KTtcblxuICAgIHZhciBtYXNrID0gcGFyYW1zLm1hc2s7XG5cblxuICAgIGlmIChtYXNrKSB7XG4gICAgICBtYXNrID0gKG1hc2sgfHwge30pLmljb24gPyBtYXNrIDogZmluZEljb25EZWZpbml0aW9uKG1hc2sgfHwge30pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0KGljb25EZWZpbml0aW9uLCBfZXh0ZW5kcyh7fSwgcGFyYW1zLCB7IG1hc2s6IG1hc2sgfSkpO1xuICB9O1xufVxuXG52YXIgbGlicmFyeSA9IG5ldyBMaWJyYXJ5KCk7XG5cbnZhciBub0F1dG8gPSBmdW5jdGlvbiBub0F1dG8oKSB7XG4gIGF1dG8oZmFsc2UpO1xuICBkaXNjb25uZWN0KCk7XG59O1xuXG52YXIgZG9tID0ge1xuICBpMnN2ZzogZnVuY3Rpb24gaTJzdmcoKSB7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoSVNfRE9NKSB7XG4gICAgICBlbnN1cmVDc3MoKTtcblxuICAgICAgdmFyIF9wYXJhbXMkbm9kZSA9IHBhcmFtcy5ub2RlLFxuICAgICAgICAgIG5vZGUgPSBfcGFyYW1zJG5vZGUgPT09IHVuZGVmaW5lZCA/IERPQ1VNRU5UIDogX3BhcmFtcyRub2RlLFxuICAgICAgICAgIF9wYXJhbXMkY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2ssXG4gICAgICAgICAgY2FsbGJhY2sgPSBfcGFyYW1zJGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7fSA6IF9wYXJhbXMkY2FsbGJhY2s7XG5cblxuICAgICAgaWYgKGNvbmZpZyQxLnNlYXJjaFBzZXVkb0VsZW1lbnRzKSB7XG4gICAgICAgIHNlYXJjaFBzZXVkb0VsZW1lbnRzKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBvblRyZWUobm9kZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBjc3M6IGNzcyxcblxuICBpbnNlcnRDc3M6IGZ1bmN0aW9uIGluc2VydENzcyQkMSgpIHtcbiAgICBpbnNlcnRDc3MoY3NzKCkpO1xuICB9XG59O1xuXG52YXIgcGFyc2UgPSB7XG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybVN0cmluZykge1xuICAgIHJldHVybiBwYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1TdHJpbmcpO1xuICB9XG59O1xuXG52YXIgaWNvbiA9IHJlc29sdmVJY29ucyhmdW5jdGlvbiAoaWNvbkRlZmluaXRpb24pIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfcGFyYW1zJHRyYW5zZm9ybSA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcGFyYW1zJHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID8gbWVhbmluZ2xlc3NUcmFuc2Zvcm0gOiBfcGFyYW1zJHRyYW5zZm9ybSxcbiAgICAgIF9wYXJhbXMkc3ltYm9sID0gcGFyYW1zLnN5bWJvbCxcbiAgICAgIHN5bWJvbCA9IF9wYXJhbXMkc3ltYm9sID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wYXJhbXMkc3ltYm9sLFxuICAgICAgX3BhcmFtcyRtYXNrID0gcGFyYW1zLm1hc2ssXG4gICAgICBtYXNrID0gX3BhcmFtcyRtYXNrID09PSB1bmRlZmluZWQgPyBudWxsIDogX3BhcmFtcyRtYXNrLFxuICAgICAgX3BhcmFtcyR0aXRsZSA9IHBhcmFtcy50aXRsZSxcbiAgICAgIHRpdGxlID0gX3BhcmFtcyR0aXRsZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IF9wYXJhbXMkdGl0bGUsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcyxcbiAgICAgIGNsYXNzZXMgPSBfcGFyYW1zJGNsYXNzZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3BhcmFtcyRjbGFzc2VzLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzID0gcGFyYW1zLmF0dHJpYnV0ZXMsXG4gICAgICBhdHRyaWJ1dGVzID0gX3BhcmFtcyRhdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgPyB7fSA6IF9wYXJhbXMkYXR0cmlidXRlcyxcbiAgICAgIF9wYXJhbXMkc3R5bGVzID0gcGFyYW1zLnN0eWxlcyxcbiAgICAgIHN0eWxlcyA9IF9wYXJhbXMkc3R5bGVzID09PSB1bmRlZmluZWQgPyB7fSA6IF9wYXJhbXMkc3R5bGVzO1xuXG5cbiAgaWYgKCFpY29uRGVmaW5pdGlvbikgcmV0dXJuO1xuXG4gIHZhciBwcmVmaXggPSBpY29uRGVmaW5pdGlvbi5wcmVmaXgsXG4gICAgICBpY29uTmFtZSA9IGljb25EZWZpbml0aW9uLmljb25OYW1lLFxuICAgICAgaWNvbiA9IGljb25EZWZpbml0aW9uLmljb247XG5cblxuICByZXR1cm4gYXBpT2JqZWN0KF9leHRlbmRzKHsgdHlwZTogJ2ljb24nIH0sIGljb25EZWZpbml0aW9uKSwgZnVuY3Rpb24gKCkge1xuICAgIGVuc3VyZUNzcygpO1xuXG4gICAgaWYgKGNvbmZpZyQxLmF1dG9BMTF5KSB7XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgYXR0cmlidXRlc1snYXJpYS1sYWJlbGxlZGJ5J10gPSBjb25maWckMS5yZXBsYWNlbWVudENsYXNzICsgJy10aXRsZS0nICsgbmV4dFVuaXF1ZUlkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzWydhcmlhLWhpZGRlbiddID0gJ3RydWUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlSW5saW5lU3ZnQWJzdHJhY3Qoe1xuICAgICAgaWNvbnM6IHtcbiAgICAgICAgbWFpbjogcHJlcEljb24oaWNvbiksXG4gICAgICAgIG1hc2s6IG1hc2sgPyBwcmVwSWNvbihtYXNrLmljb24pIDogeyBmb3VuZDogZmFsc2UsIHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsIGljb246IHt9IH1cbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIGljb25OYW1lOiBpY29uTmFtZSxcbiAgICAgIHRyYW5zZm9ybTogX2V4dGVuZHMoe30sIG1lYW5pbmdsZXNzVHJhbnNmb3JtLCB0cmFuc2Zvcm0pLFxuICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBleHRyYToge1xuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgY2xhc3NlczogY2xhc3Nlc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG52YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQoY29udGVudCkge1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIF9wYXJhbXMkdHJhbnNmb3JtMiA9IHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcGFyYW1zJHRyYW5zZm9ybTIgPT09IHVuZGVmaW5lZCA/IG1lYW5pbmdsZXNzVHJhbnNmb3JtIDogX3BhcmFtcyR0cmFuc2Zvcm0yLFxuICAgICAgX3BhcmFtcyR0aXRsZTIgPSBwYXJhbXMudGl0bGUsXG4gICAgICB0aXRsZSA9IF9wYXJhbXMkdGl0bGUyID09PSB1bmRlZmluZWQgPyBudWxsIDogX3BhcmFtcyR0aXRsZTIsXG4gICAgICBfcGFyYW1zJGNsYXNzZXMyID0gcGFyYW1zLmNsYXNzZXMsXG4gICAgICBjbGFzc2VzID0gX3BhcmFtcyRjbGFzc2VzMiA9PT0gdW5kZWZpbmVkID8gW10gOiBfcGFyYW1zJGNsYXNzZXMyLFxuICAgICAgX3BhcmFtcyRhdHRyaWJ1dGVzMiA9IHBhcmFtcy5hdHRyaWJ1dGVzLFxuICAgICAgYXR0cmlidXRlcyA9IF9wYXJhbXMkYXR0cmlidXRlczIgPT09IHVuZGVmaW5lZCA/IHt9IDogX3BhcmFtcyRhdHRyaWJ1dGVzMixcbiAgICAgIF9wYXJhbXMkc3R5bGVzMiA9IHBhcmFtcy5zdHlsZXMsXG4gICAgICBzdHlsZXMgPSBfcGFyYW1zJHN0eWxlczIgPT09IHVuZGVmaW5lZCA/IHt9IDogX3BhcmFtcyRzdHlsZXMyO1xuXG5cbiAgcmV0dXJuIGFwaU9iamVjdCh7IHR5cGU6ICd0ZXh0JywgY29udGVudDogY29udGVudCB9LCBmdW5jdGlvbiAoKSB7XG4gICAgZW5zdXJlQ3NzKCk7XG5cbiAgICByZXR1cm4gbWFrZUxheWVyc1RleHRBYnN0cmFjdCh7XG4gICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgdHJhbnNmb3JtOiBfZXh0ZW5kcyh7fSwgbWVhbmluZ2xlc3NUcmFuc2Zvcm0sIHRyYW5zZm9ybSksXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBleHRyYToge1xuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgY2xhc3NlczogW2NvbmZpZyQxLmZhbWlseVByZWZpeCArICctbGF5ZXJzLXRleHQnXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY2xhc3NlcykpXG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIGxheWVyID0gZnVuY3Rpb24gbGF5ZXIoYXNzZW1ibGVyKSB7XG4gIHJldHVybiBhcGlPYmplY3QoeyB0eXBlOiAnbGF5ZXInIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBlbnN1cmVDc3MoKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgYXNzZW1ibGVyKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoYS5hYnN0cmFjdCk7XG4gICAgICB9KSA6IGNoaWxkcmVuID0gY2hpbGRyZW4uY29uY2F0KGFyZ3MuYWJzdHJhY3QpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFt7XG4gICAgICB0YWc6ICdzcGFuJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IGNvbmZpZyQxLmZhbWlseVByZWZpeCArICctbGF5ZXJzJyB9LFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfV07XG4gIH0pO1xufTtcblxudmFyIGFwaSQxID0ge1xuICBub0F1dG86IG5vQXV0byxcbiAgZG9tOiBkb20sXG4gIGxpYnJhcnk6IGxpYnJhcnksXG4gIHBhcnNlOiBwYXJzZSxcbiAgZmluZEljb25EZWZpbml0aW9uOiBmaW5kSWNvbkRlZmluaXRpb24sXG4gIGljb246IGljb24sXG4gIHRleHQ6IHRleHQsXG4gIGxheWVyOiBsYXllclxufTtcblxudmFyIGF1dG9SZXBsYWNlID0gZnVuY3Rpb24gYXV0b1JlcGxhY2UoKSB7XG4gIGlmIChJU19ET00gJiYgY29uZmlnJDEuYXV0b1JlcGxhY2VTdmcpIGFwaSQxLmRvbS5pMnN2Zyh7IG5vZGU6IERPQ1VNRU5UIH0pO1xufTtcblxuZnVuY3Rpb24gYm9vdHN0cmFwKCkge1xuICBpZiAoSVNfQlJPV1NFUikge1xuICAgIGlmICghV0lORE9XLkZvbnRBd2Vzb21lKSB7XG4gICAgICBXSU5ET1cuRm9udEF3ZXNvbWUgPSBhcGkkMTtcbiAgICB9XG5cbiAgICBkb21yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmFtZXNwYWNlLnN0eWxlcykubGVuZ3RoID4gMCkge1xuICAgICAgICBhdXRvUmVwbGFjZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnJDEub2JzZXJ2ZU11dGF0aW9ucyAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZlKHtcbiAgICAgICAgICB0cmVlQ2FsbGJhY2s6IG9uVHJlZSxcbiAgICAgICAgICBub2RlQ2FsbGJhY2s6IG9uTm9kZSxcbiAgICAgICAgICBwc2V1ZG9FbGVtZW50c0NhbGxiYWNrOiBzZWFyY2hQc2V1ZG9FbGVtZW50c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5hbWVzcGFjZS5ob29rcyA9IF9leHRlbmRzKHt9LCBuYW1lc3BhY2UuaG9va3MsIHtcblxuICAgIGFkZFBhY2s6IGZ1bmN0aW9uIGFkZFBhY2socHJlZml4LCBpY29ucykge1xuICAgICAgbmFtZXNwYWNlLnN0eWxlc1twcmVmaXhdID0gX2V4dGVuZHMoe30sIG5hbWVzcGFjZS5zdHlsZXNbcHJlZml4XSB8fCB7fSwgaWNvbnMpO1xuXG4gICAgICBidWlsZCgpO1xuICAgICAgYXV0b1JlcGxhY2UoKTtcbiAgICB9LFxuXG4gICAgYWRkU2hpbXM6IGZ1bmN0aW9uIGFkZFNoaW1zKHNoaW1zKSB7XG4gICAgICB2YXIgX25hbWVzcGFjZSRzaGltcztcblxuICAgICAgKF9uYW1lc3BhY2Ukc2hpbXMgPSBuYW1lc3BhY2Uuc2hpbXMpLnB1c2guYXBwbHkoX25hbWVzcGFjZSRzaGltcywgdG9Db25zdW1hYmxlQXJyYXkoc2hpbXMpKTtcblxuICAgICAgYnVpbGQoKTtcbiAgICAgIGF1dG9SZXBsYWNlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaSQxLCAnY29uZmlnJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY29uZmlnJDE7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiBzZXQobmV3Q29uZmlnKSB7XG4gICAgdXBkYXRlKG5ld0NvbmZpZyk7XG4gIH1cbn0pO1xuXG5pZiAoSVNfRE9NKSBidW5rZXIoYm9vdHN0cmFwKTtcblxudmFyIGNvbmZpZyA9IGFwaSQxLmNvbmZpZztcblxuZXhwb3J0IHsgY29uZmlnLCBpY29uLCBub0F1dG8sIGxheWVyLCB0ZXh0LCBsaWJyYXJ5LCBkb20sIHBhcnNlLCBmaW5kSWNvbkRlZmluaXRpb24gfTtcbmV4cG9ydCBkZWZhdWx0IGFwaSQxO1xuIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSEE7QUFIQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUxBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBV0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUZBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoREE7QUFDQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBUEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBVkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFKQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fortawesome/fontawesome/index.es.js\n");

/***/ }),

/***/ "./node_modules/@fortawesome/react-fontawesome/index.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fortawesome/react-fontawesome/index.es.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _fontawesome = __webpack_require__(/*! @fortawesome/fontawesome */ \"./node_modules/@fortawesome/fontawesome/index.es.js\");\n\nvar _fontawesome2 = _interopRequireDefault(_fontawesome);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n  return module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar humps = createCommonjsModule(function (module) {\n  // =========\n  // = humps =\n  // =========\n  // Underscore-to-camelCase converter (and vice versa)\n  // for strings and object keys\n\n  // humps is copyright © 2012+ Dom Christie\n  // Released under the MIT license.\n\n\n  (function (global) {\n\n    var _processKeys = function _processKeys(convert, obj, options) {\n      if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {\n        return obj;\n      }\n\n      var output,\n          i = 0,\n          l = 0;\n\n      if (_isArray(obj)) {\n        output = [];\n        for (l = obj.length; i < l; i++) {\n          output.push(_processKeys(convert, obj[i], options));\n        }\n      } else {\n        output = {};\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            output[convert(key, options)] = _processKeys(convert, obj[key], options);\n          }\n        }\n      }\n      return output;\n    };\n\n    // String conversion methods\n\n    var separateWords = function separateWords(string, options) {\n      options = options || {};\n      var separator = options.separator || '_';\n      var split = options.split || /(?=[A-Z])/;\n\n      return string.split(split).join(separator);\n    };\n\n    var camelize = function camelize(string) {\n      if (_isNumerical(string)) {\n        return string;\n      }\n      string = string.replace(/[\\-_\\s]+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n      // Ensure 1st char is always lowercase\n      return string.substr(0, 1).toLowerCase() + string.substr(1);\n    };\n\n    var pascalize = function pascalize(string) {\n      var camelized = camelize(string);\n      // Ensure 1st char is always uppercase\n      return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);\n    };\n\n    var decamelize = function decamelize(string, options) {\n      return separateWords(string, options).toLowerCase();\n    };\n\n    // Utilities\n    // Taken from Underscore.js\n\n    var toString = Object.prototype.toString;\n\n    var _isFunction = function _isFunction(obj) {\n      return typeof obj === 'function';\n    };\n    var _isObject = function _isObject(obj) {\n      return obj === Object(obj);\n    };\n    var _isArray = function _isArray(obj) {\n      return toString.call(obj) == '[object Array]';\n    };\n    var _isDate = function _isDate(obj) {\n      return toString.call(obj) == '[object Date]';\n    };\n    var _isRegExp = function _isRegExp(obj) {\n      return toString.call(obj) == '[object RegExp]';\n    };\n    var _isBoolean = function _isBoolean(obj) {\n      return toString.call(obj) == '[object Boolean]';\n    };\n\n    // Performant way to determine if obj coerces to a number\n    var _isNumerical = function _isNumerical(obj) {\n      obj = obj - 0;\n      return obj === obj;\n    };\n\n    // Sets up function which handles processing keys\n    // allowing the convert function to be modified by a callback\n    var _processor = function _processor(convert, options) {\n      var callback = options && 'process' in options ? options.process : options;\n\n      if (typeof callback !== 'function') {\n        return convert;\n      }\n\n      return function (string, options) {\n        return callback(string, convert, options);\n      };\n    };\n\n    var humps = {\n      camelize: camelize,\n      decamelize: decamelize,\n      pascalize: pascalize,\n      depascalize: decamelize,\n      camelizeKeys: function camelizeKeys(object, options) {\n        return _processKeys(_processor(camelize, options), object);\n      },\n      decamelizeKeys: function decamelizeKeys(object, options) {\n        return _processKeys(_processor(decamelize, options), object, options);\n      },\n      pascalizeKeys: function pascalizeKeys(object, options) {\n        return _processKeys(_processor(pascalize, options), object);\n      },\n      depascalizeKeys: function depascalizeKeys() {\n        return this.decamelizeKeys.apply(this, arguments);\n      }\n    };\n\n    if (false) {} else if ('object' !== 'undefined' && module.exports) {\n      module.exports = humps;\n    } else {\n      global.humps = humps;\n    }\n  })(commonjsGlobal);\n});\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n};\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function wrap(fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function _await(value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction capitalize(val) {\n  return val.charAt(0).toUpperCase() + val.slice(1);\n}\n\nfunction styleToObject(style) {\n  return style.split(';').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s;\n  }).reduce(function (acc, pair) {\n    var i = pair.indexOf(':');\n    var prop = humps.camelize(pair.slice(0, i));\n    var value = pair.slice(i + 1).trim();\n\n    prop.startsWith('webkit') ? acc[capitalize(prop)] = value : acc[prop] = value;\n\n    return acc;\n  }, {});\n}\n\nfunction convert(createElement, element) {\n  var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var children = (element.children || []).map(convert.bind(null, createElement));\n\n  var mixins = Object.keys(element.attributes || {}).reduce(function (acc, key) {\n    var val = element.attributes[key];\n\n    switch (key) {\n      case 'class':\n        acc.attrs['className'] = val;\n        delete element.attributes['class'];\n        break;\n      case 'style':\n        acc.attrs['style'] = styleToObject(val);\n        break;\n      default:\n        if (key.indexOf('aria-') === 0 || key.indexOf('data-') === 0) {\n          acc.attrs[key.toLowerCase()] = val;\n        } else {\n          acc.attrs[humps.camelize(key)] = val;\n        }\n    }\n\n    return acc;\n  }, { attrs: {} });\n\n  var _extraProps$style = extraProps.style,\n      existingStyle = _extraProps$style === undefined ? {} : _extraProps$style,\n      remaining = objectWithoutProperties(extraProps, ['style']);\n\n  mixins.attrs['style'] = _extends({}, mixins.attrs['style'], existingStyle);\n\n  return createElement.apply(undefined, [element.tag, _extends({}, mixins.attrs, remaining)].concat(toConsumableArray(children)));\n}\n\nvar PRODUCTION = false;\n\ntry {\n  PRODUCTION = \"development\" === 'production';\n} catch (e) {}\n\nvar log = function log() {\n  if (!PRODUCTION && console && typeof console.error === 'function') {\n    var _console;\n\n    (_console = console).error.apply(_console, arguments);\n  }\n};\n\nfunction objectWithKey(key, value) {\n  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? defineProperty({}, key, value) : {};\n}\n\nfunction classList(props) {\n  var _classes;\n\n  var classes = (_classes = {\n    'fa-spin': props.spin,\n    'fa-pulse': props.pulse,\n    'fa-fw': props.fixedWidth,\n    'fa-border': props.border,\n    'fa-li': props.listItem,\n    'fa-flip-horizontal': props.flip === 'horizontal' || props.flip === 'both',\n    'fa-flip-vertical': props.flip === 'vertical' || props.flip === 'both'\n  }, defineProperty(_classes, 'fa-' + props.size, props.size !== null), defineProperty(_classes, 'fa-rotate-' + props.rotation, props.rotation !== null), defineProperty(_classes, 'fa-pull-' + props.pull, props.pull !== null), _classes);\n\n  return Object.keys(classes).map(function (key) {\n    return classes[key] ? key : null;\n  }).filter(function (key) {\n    return key;\n  });\n}\n\nfunction normalizeIconArgs(icon) {\n  if (icon === null) {\n    return null;\n  }\n\n  if ((typeof icon === 'undefined' ? 'undefined' : _typeof(icon)) === 'object' && icon.prefix && icon.iconName) {\n    return icon;\n  }\n\n  if (Array.isArray(icon) && icon.length === 2) {\n    return { prefix: icon[0], iconName: icon[1] };\n  }\n\n  if (typeof icon === 'string') {\n    return { prefix: 'fas', iconName: icon };\n  }\n}\n\nfunction FontAwesomeIcon$1(props) {\n  var iconArgs = props.icon,\n      maskArgs = props.mask,\n      symbol = props.symbol,\n      className = props.className;\n\n  var icon = normalizeIconArgs(iconArgs);\n  var classes = objectWithKey('classes', [].concat(toConsumableArray(classList(props)), toConsumableArray(className.split(' '))));\n  var transform = objectWithKey('transform', typeof props.transform === 'string' ? _fontawesome2.default.parse.transform(props.transform) : props.transform);\n  var mask = objectWithKey('mask', normalizeIconArgs(maskArgs));\n\n  var renderedIcon = _fontawesome2.default.icon(icon, _extends({}, classes, transform, mask, {\n    symbol: symbol\n  }));\n\n  if (!renderedIcon) {\n    log('Could not find icon', icon);\n    return null;\n  }\n\n  var abstract = renderedIcon.abstract;\n\n  var convertCurry = convert.bind(null, _react2.default.createElement);\n  var extraProps = {};\n\n  Object.keys(props).forEach(function (key) {\n    if (!FontAwesomeIcon$1.defaultProps.hasOwnProperty(key)) extraProps[key] = props[key];\n  });\n\n  return convertCurry(abstract[0], extraProps);\n}\n\nFontAwesomeIcon$1.propTypes = {\n  border: _propTypes2.default.bool,\n\n  className: _propTypes2.default.string,\n\n  mask: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array, _propTypes2.default.string]),\n\n  fixedWidth: _propTypes2.default.bool,\n\n  flip: _propTypes2.default.oneOf(['horizontal', 'vertical', 'both']),\n\n  icon: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array, _propTypes2.default.string]),\n\n  listItem: _propTypes2.default.bool,\n\n  pull: _propTypes2.default.oneOf(['right', 'left']),\n\n  pulse: _propTypes2.default.bool,\n\n  name: _propTypes2.default.string,\n\n  rotation: _propTypes2.default.oneOf([90, 180, 270]),\n\n  size: _propTypes2.default.oneOf(['lg', 'xs', 'sm', '1x', '2x', '3x', '4x', '5x', '6x', '7x', '8x', '9x', '10x']),\n\n  spin: _propTypes2.default.bool,\n\n  symbol: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),\n\n  transform: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])\n};\n\nFontAwesomeIcon$1.defaultProps = {\n  border: false,\n  className: '',\n  mask: null,\n  fixedWidth: false,\n  flip: null,\n  icon: null,\n  listItem: false,\n  pull: null,\n  pulse: false,\n  name: '',\n  rotation: null,\n  size: null,\n  spin: false,\n  symbol: false,\n  transform: null\n};\n\n_fontawesome2.default.noAuto();\n\nexports.default = FontAwesomeIcon$1;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcnRhd2Vzb21lL3JlYWN0LWZvbnRhd2Vzb21lL2luZGV4LmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvcmVhY3QtZm9udGF3ZXNvbWUvaW5kZXguZXMuanM/MDZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZm9udGF3ZXNvbWUgZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaHVtcHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vLyA9PT09PT09PT1cbi8vID0gaHVtcHMgPVxuLy8gPT09PT09PT09XG4vLyBVbmRlcnNjb3JlLXRvLWNhbWVsQ2FzZSBjb252ZXJ0ZXIgKGFuZCB2aWNlIHZlcnNhKVxuLy8gZm9yIHN0cmluZ3MgYW5kIG9iamVjdCBrZXlzXG5cbi8vIGh1bXBzIGlzIGNvcHlyaWdodCDCqSAyMDEyKyBEb20gQ2hyaXN0aWVcbi8vIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgdmFyIF9wcm9jZXNzS2V5cyA9IGZ1bmN0aW9uKGNvbnZlcnQsIG9iaiwgb3B0aW9ucykge1xuICAgIGlmKCFfaXNPYmplY3Qob2JqKSB8fCBfaXNEYXRlKG9iaikgfHwgX2lzUmVnRXhwKG9iaikgfHwgX2lzQm9vbGVhbihvYmopIHx8IF9pc0Z1bmN0aW9uKG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSAwO1xuXG4gICAgaWYoX2lzQXJyYXkob2JqKSkge1xuICAgICAgb3V0cHV0ID0gW107XG4gICAgICBmb3IobD1vYmoubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICBvdXRwdXQucHVzaChfcHJvY2Vzc0tleXMoY29udmVydCwgb2JqW2ldLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3V0cHV0ID0ge307XG4gICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIG91dHB1dFtjb252ZXJ0KGtleSwgb3B0aW9ucyldID0gX3Byb2Nlc3NLZXlzKGNvbnZlcnQsIG9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIFN0cmluZyBjb252ZXJzaW9uIG1ldGhvZHNcblxuICB2YXIgc2VwYXJhdGVXb3JkcyA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciB8fCAnXyc7XG4gICAgdmFyIHNwbGl0ID0gb3B0aW9ucy5zcGxpdCB8fCAvKD89W0EtWl0pLztcblxuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc3BsaXQpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfTtcblxuICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBpZiAoX2lzTnVtZXJpY2FsKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9bXFwtX1xcc10rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hyKSB7XG4gICAgICByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgMXN0IGNoYXIgaXMgYWx3YXlzIGxvd2VyY2FzZVxuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyKDEpO1xuICB9O1xuXG4gIHZhciBwYXNjYWxpemUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgY2FtZWxpemVkID0gY2FtZWxpemUoc3RyaW5nKTtcbiAgICAvLyBFbnN1cmUgMXN0IGNoYXIgaXMgYWx3YXlzIHVwcGVyY2FzZVxuICAgIHJldHVybiBjYW1lbGl6ZWQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBjYW1lbGl6ZWQuc3Vic3RyKDEpO1xuICB9O1xuXG4gIHZhciBkZWNhbWVsaXplID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHNlcGFyYXRlV29yZHMoc3RyaW5nLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIC8vIFV0aWxpdGllc1xuICAvLyBUYWtlbiBmcm9tIFVuZGVyc2NvcmUuanNcblxuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIHZhciBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Yob2JqKSA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcbiAgdmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuICB2YXIgX2lzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG4gIHZhciBfaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG4gIH07XG4gIHZhciBfaXNSZWdFeHAgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFJlZ0V4cF0nO1xuICB9O1xuICB2YXIgX2lzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1hbnQgd2F5IHRvIGRldGVybWluZSBpZiBvYmogY29lcmNlcyB0byBhIG51bWJlclxuICB2YXIgX2lzTnVtZXJpY2FsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgb2JqID0gb2JqIC0gMDtcbiAgICByZXR1cm4gb2JqID09PSBvYmo7XG4gIH07XG5cbiAgLy8gU2V0cyB1cCBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIHByb2Nlc3Npbmcga2V5c1xuICAvLyBhbGxvd2luZyB0aGUgY29udmVydCBmdW5jdGlvbiB0byBiZSBtb2RpZmllZCBieSBhIGNhbGxiYWNrXG4gIHZhciBfcHJvY2Vzc29yID0gZnVuY3Rpb24oY29udmVydCwgb3B0aW9ucykge1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMgJiYgJ3Byb2Nlc3MnIGluIG9wdGlvbnMgPyBvcHRpb25zLnByb2Nlc3MgOiBvcHRpb25zO1xuXG4gICAgaWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNvbnZlcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHN0cmluZywgY29udmVydCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBodW1wcyA9IHtcbiAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgZGVjYW1lbGl6ZTogZGVjYW1lbGl6ZSxcbiAgICBwYXNjYWxpemU6IHBhc2NhbGl6ZSxcbiAgICBkZXBhc2NhbGl6ZTogZGVjYW1lbGl6ZSxcbiAgICBjYW1lbGl6ZUtleXM6IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9wcm9jZXNzS2V5cyhfcHJvY2Vzc29yKGNhbWVsaXplLCBvcHRpb25zKSwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGRlY2FtZWxpemVLZXlzOiBmdW5jdGlvbihvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfcHJvY2Vzc0tleXMoX3Byb2Nlc3NvcihkZWNhbWVsaXplLCBvcHRpb25zKSwgb2JqZWN0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIHBhc2NhbGl6ZUtleXM6IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9wcm9jZXNzS2V5cyhfcHJvY2Vzc29yKHBhc2NhbGl6ZSwgb3B0aW9ucyksIG9iamVjdCk7XG4gICAgfSxcbiAgICBkZXBhc2NhbGl6ZUtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2FtZWxpemVLZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2YgdW5kZWZpbmVkID09PSAnZnVuY3Rpb24nICYmIHVuZGVmaW5lZC5hbWQpIHtcbiAgICB1bmRlZmluZWQoaHVtcHMpO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaHVtcHM7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLmh1bXBzID0gaHVtcHM7XG4gIH1cblxufSkoY29tbW9uanNHbG9iYWwpO1xufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cbnZhciBhc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXdhaXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgIHZhciBmcm9udCwgYmFjaztcblxuICAgIGZ1bmN0aW9uIHNlbmQoa2V5LCBhcmcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFyZzogYXJnLFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRWYWx1ZSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZS52YWx1ZSkudGhlbihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIGFyZyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldHRsZShcInRocm93XCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZyb250ID0gZnJvbnQubmV4dDtcblxuICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2UgPSBzZW5kO1xuXG4gICAgaWYgKHR5cGVvZiBnZW4ucmV0dXJuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGFyZyk7XG4gIH07XG5cbiAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJ0aHJvd1wiLCBhcmcpO1xuICB9O1xuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJldHVyblwiLCBhcmcpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgd3JhcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jR2VuZXJhdG9yKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGF3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWwpIHtcbiAgcmV0dXJuIHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVUb09iamVjdChzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy50cmltKCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGFpcikge1xuICAgIHZhciBpID0gcGFpci5pbmRleE9mKCc6Jyk7XG4gICAgdmFyIHByb3AgPSBodW1wcy5jYW1lbGl6ZShwYWlyLnNsaWNlKDAsIGkpKTtcbiAgICB2YXIgdmFsdWUgPSBwYWlyLnNsaWNlKGkgKyAxKS50cmltKCk7XG5cbiAgICBwcm9wLnN0YXJ0c1dpdGgoJ3dlYmtpdCcpID8gYWNjW2NhcGl0YWxpemUocHJvcCldID0gdmFsdWUgOiBhY2NbcHJvcF0gPSB2YWx1ZTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY29udmVydChjcmVhdGVFbGVtZW50LCBlbGVtZW50KSB7XG4gIHZhciBleHRyYVByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICB2YXIgY2hpbGRyZW4gPSAoZWxlbWVudC5jaGlsZHJlbiB8fCBbXSkubWFwKGNvbnZlcnQuYmluZChudWxsLCBjcmVhdGVFbGVtZW50KSk7XG5cbiAgdmFyIG1peGlucyA9IE9iamVjdC5rZXlzKGVsZW1lbnQuYXR0cmlidXRlcyB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgIHZhciB2YWwgPSBlbGVtZW50LmF0dHJpYnV0ZXNba2V5XTtcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGFjYy5hdHRyc1snY2xhc3NOYW1lJ10gPSB2YWw7XG4gICAgICAgIGRlbGV0ZSBlbGVtZW50LmF0dHJpYnV0ZXNbJ2NsYXNzJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICBhY2MuYXR0cnNbJ3N0eWxlJ10gPSBzdHlsZVRvT2JqZWN0KHZhbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCdhcmlhLScpID09PSAwIHx8IGtleS5pbmRleE9mKCdkYXRhLScpID09PSAwKSB7XG4gICAgICAgICAgYWNjLmF0dHJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MuYXR0cnNbaHVtcHMuY2FtZWxpemUoa2V5KV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7IGF0dHJzOiB7fSB9KTtcblxuICB2YXIgX2V4dHJhUHJvcHMkc3R5bGUgPSBleHRyYVByb3BzLnN0eWxlLFxuICAgICAgZXhpc3RpbmdTdHlsZSA9IF9leHRyYVByb3BzJHN0eWxlID09PSB1bmRlZmluZWQgPyB7fSA6IF9leHRyYVByb3BzJHN0eWxlLFxuICAgICAgcmVtYWluaW5nID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZXh0cmFQcm9wcywgWydzdHlsZSddKTtcblxuXG4gIG1peGlucy5hdHRyc1snc3R5bGUnXSA9IF9leHRlbmRzKHt9LCBtaXhpbnMuYXR0cnNbJ3N0eWxlJ10sIGV4aXN0aW5nU3R5bGUpO1xuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHVuZGVmaW5lZCwgW2VsZW1lbnQudGFnLCBfZXh0ZW5kcyh7fSwgbWl4aW5zLmF0dHJzLCByZW1haW5pbmcpXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY2hpbGRyZW4pKSk7XG59XG5cbnZhciBQUk9EVUNUSU9OID0gZmFsc2U7XG5cbnRyeSB7XG4gIFBST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xufSBjYXRjaCAoZSkge31cblxudmFyIGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFQUk9EVUNUSU9OICYmIGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb2JqZWN0V2l0aEtleShrZXksIHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSA/IGRlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSA6IHt9O1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3QocHJvcHMpIHtcbiAgdmFyIF9jbGFzc2VzO1xuXG4gIHZhciBjbGFzc2VzID0gKF9jbGFzc2VzID0ge1xuICAgICdmYS1zcGluJzogcHJvcHMuc3BpbixcbiAgICAnZmEtcHVsc2UnOiBwcm9wcy5wdWxzZSxcbiAgICAnZmEtZncnOiBwcm9wcy5maXhlZFdpZHRoLFxuICAgICdmYS1ib3JkZXInOiBwcm9wcy5ib3JkZXIsXG4gICAgJ2ZhLWxpJzogcHJvcHMubGlzdEl0ZW0sXG4gICAgJ2ZhLWZsaXAtaG9yaXpvbnRhbCc6IHByb3BzLmZsaXAgPT09ICdob3Jpem9udGFsJyB8fCBwcm9wcy5mbGlwID09PSAnYm90aCcsXG4gICAgJ2ZhLWZsaXAtdmVydGljYWwnOiBwcm9wcy5mbGlwID09PSAndmVydGljYWwnIHx8IHByb3BzLmZsaXAgPT09ICdib3RoJ1xuICB9LCBkZWZpbmVQcm9wZXJ0eShfY2xhc3NlcywgJ2ZhLScgKyBwcm9wcy5zaXplLCBwcm9wcy5zaXplICE9PSBudWxsKSwgZGVmaW5lUHJvcGVydHkoX2NsYXNzZXMsICdmYS1yb3RhdGUtJyArIHByb3BzLnJvdGF0aW9uLCBwcm9wcy5yb3RhdGlvbiAhPT0gbnVsbCksIGRlZmluZVByb3BlcnR5KF9jbGFzc2VzLCAnZmEtcHVsbC0nICsgcHJvcHMucHVsbCwgcHJvcHMucHVsbCAhPT0gbnVsbCksIF9jbGFzc2VzKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMoY2xhc3NlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gY2xhc3Nlc1trZXldID8ga2V5IDogbnVsbDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSWNvbkFyZ3MoaWNvbikge1xuICBpZiAoaWNvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgaWNvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaWNvbikpID09PSAnb2JqZWN0JyAmJiBpY29uLnByZWZpeCAmJiBpY29uLmljb25OYW1lKSB7XG4gICAgcmV0dXJuIGljb247XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpY29uKSAmJiBpY29uLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiB7IHByZWZpeDogaWNvblswXSwgaWNvbk5hbWU6IGljb25bMV0gfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyBwcmVmaXg6ICdmYXMnLCBpY29uTmFtZTogaWNvbiB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIEZvbnRBd2Vzb21lSWNvbiQxKHByb3BzKSB7XG4gIHZhciBpY29uQXJncyA9IHByb3BzLmljb24sXG4gICAgICBtYXNrQXJncyA9IHByb3BzLm1hc2ssXG4gICAgICBzeW1ib2wgPSBwcm9wcy5zeW1ib2wsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG5cblxuICB2YXIgaWNvbiA9IG5vcm1hbGl6ZUljb25BcmdzKGljb25BcmdzKTtcbiAgdmFyIGNsYXNzZXMgPSBvYmplY3RXaXRoS2V5KCdjbGFzc2VzJywgW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KGNsYXNzTGlzdChwcm9wcykpLCB0b0NvbnN1bWFibGVBcnJheShjbGFzc05hbWUuc3BsaXQoJyAnKSkpKTtcbiAgdmFyIHRyYW5zZm9ybSA9IG9iamVjdFdpdGhLZXkoJ3RyYW5zZm9ybScsIHR5cGVvZiBwcm9wcy50cmFuc2Zvcm0gPT09ICdzdHJpbmcnID8gZm9udGF3ZXNvbWUucGFyc2UudHJhbnNmb3JtKHByb3BzLnRyYW5zZm9ybSkgOiBwcm9wcy50cmFuc2Zvcm0pO1xuICB2YXIgbWFzayA9IG9iamVjdFdpdGhLZXkoJ21hc2snLCBub3JtYWxpemVJY29uQXJncyhtYXNrQXJncykpO1xuXG4gIHZhciByZW5kZXJlZEljb24gPSBmb250YXdlc29tZS5pY29uKGljb24sIF9leHRlbmRzKHt9LCBjbGFzc2VzLCB0cmFuc2Zvcm0sIG1hc2ssIHtcbiAgICBzeW1ib2w6IHN5bWJvbFxuICB9KSk7XG5cbiAgaWYgKCFyZW5kZXJlZEljb24pIHtcbiAgICBsb2coJ0NvdWxkIG5vdCBmaW5kIGljb24nLCBpY29uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhYnN0cmFjdCA9IHJlbmRlcmVkSWNvbi5hYnN0cmFjdDtcblxuICB2YXIgY29udmVydEN1cnJ5ID0gY29udmVydC5iaW5kKG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQpO1xuICB2YXIgZXh0cmFQcm9wcyA9IHt9O1xuXG4gIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIUZvbnRBd2Vzb21lSWNvbiQxLmRlZmF1bHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBleHRyYVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICB9KTtcblxuICByZXR1cm4gY29udmVydEN1cnJ5KGFic3RyYWN0WzBdLCBleHRyYVByb3BzKTtcbn1cblxuRm9udEF3ZXNvbWVJY29uJDEucHJvcFR5cGVzID0ge1xuICBib3JkZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICBtYXNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICBmaXhlZFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICBmbGlwOiBQcm9wVHlwZXMub25lT2YoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJywgJ2JvdGgnXSksXG5cbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgbGlzdEl0ZW06IFByb3BUeXBlcy5ib29sLFxuXG4gIHB1bGw6IFByb3BUeXBlcy5vbmVPZihbJ3JpZ2h0JywgJ2xlZnQnXSksXG5cbiAgcHVsc2U6IFByb3BUeXBlcy5ib29sLFxuXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgcm90YXRpb246IFByb3BUeXBlcy5vbmVPZihbOTAsIDE4MCwgMjcwXSksXG5cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbGcnLCAneHMnLCAnc20nLCAnMXgnLCAnMngnLCAnM3gnLCAnNHgnLCAnNXgnLCAnNngnLCAnN3gnLCAnOHgnLCAnOXgnLCAnMTB4J10pLFxuXG4gIHNwaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIHN5bWJvbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICB0cmFuc2Zvcm06IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxufTtcblxuRm9udEF3ZXNvbWVJY29uJDEuZGVmYXVsdFByb3BzID0ge1xuICBib3JkZXI6IGZhbHNlLFxuICBjbGFzc05hbWU6ICcnLFxuICBtYXNrOiBudWxsLFxuICBmaXhlZFdpZHRoOiBmYWxzZSxcbiAgZmxpcDogbnVsbCxcbiAgaWNvbjogbnVsbCxcbiAgbGlzdEl0ZW06IGZhbHNlLFxuICBwdWxsOiBudWxsLFxuICBwdWxzZTogZmFsc2UsXG4gIG5hbWU6ICcnLFxuICByb3RhdGlvbjogbnVsbCxcbiAgc2l6ZTogbnVsbCxcbiAgc3BpbjogZmFsc2UsXG4gIHN5bWJvbDogZmFsc2UsXG4gIHRyYW5zZm9ybTogbnVsbFxufTtcblxuZm9udGF3ZXNvbWUubm9BdXRvKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvbnRBd2Vzb21lSWNvbiQxO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFDQTtBQWtCQSxpQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQWpCQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdCQTtBQUNBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fortawesome/react-fontawesome/index.es.js\n");

/***/ }),

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (\"function\" === 'function' && _typeof(__webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) === 'object' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcz8xYzQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/classnames/index.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/ExecutionEnvironment.js":
/*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzPzM1NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/ExecutionEnvironment.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelize.js":
/*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzPzczNGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelize.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/camelizeStyleName.js":
/*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(/*! ./camelize */ \"./node_modules/fbjs/lib/camelize.js\");\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzP2VmYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/camelizeStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/containsNode.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(/*! ./isTextNode */ \"./node_modules/fbjs/lib/isTextNode.js\");\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanM/NzMwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/containsNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcz8yY2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyFunction.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/emptyObject.js":
/*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (true) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzPzg5NjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/emptyObject.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/getActiveElement.js":
/*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\n\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcz9lMzVlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/getActiveElement.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenate.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanM/MWM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenate.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/hyphenateStyleName.js":
/*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(/*! ./hyphenate */ \"./node_modules/fbjs/lib/hyphenate.js\");\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanM/MGQwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/hyphenateStyleName.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/invariant.js":
/*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanM/NDY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/invariant.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isNode.js":
/*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanM/NDYxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIGRvYyA9IG9iamVjdCA/IG9iamVjdC5vd25lckRvY3VtZW50IHx8IG9iamVjdCA6IGRvY3VtZW50O1xuICB2YXIgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/isTextNode.js":
/*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(/*! ./isNode */ \"./node_modules/fbjs/lib/isNode.js\");\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcz9lYzE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/isTextNode.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/shallowEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanM/MmVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDsiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/shallowEqual.js\n");

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcz84MGMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fbjs/lib/warning.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz80YmE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar printWarning = function printWarning() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n\n  printWarning = function printWarning(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz82NzhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function printWarning() {};\n\nif (true) {\n  printWarning = function printWarning(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function (isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if (\"development\" !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (!manualPropTypeCallCache[cacheKey] &&\n          // Avoid spamming the console because they are often not actionable except for lib authors\n          manualPropTypeWarningCount < 3) {\n            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       true ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : undefined;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz84NWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBQ0E7QUFvQkE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQ0E7QUE0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n  var isValidElement = function isValidElement(object) {\n    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(isValidElement, throwOnDirectAccess);\n} else {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9mNDNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP2YzNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.4.1\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};if(true){(function(){'use strict';var invariant=__webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var warning=__webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");var ExecutionEnvironment=__webpack_require__(/*! fbjs/lib/ExecutionEnvironment */ \"./node_modules/fbjs/lib/ExecutionEnvironment.js\");var _assign=__webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");var emptyFunction=__webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");var checkPropTypes=__webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");var getActiveElement=__webpack_require__(/*! fbjs/lib/getActiveElement */ \"./node_modules/fbjs/lib/getActiveElement.js\");var shallowEqual=__webpack_require__(/*! fbjs/lib/shallowEqual */ \"./node_modules/fbjs/lib/shallowEqual.js\");var containsNode=__webpack_require__(/*! fbjs/lib/containsNode */ \"./node_modules/fbjs/lib/containsNode.js\");var emptyObject=__webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");var hyphenateStyleName=__webpack_require__(/*! fbjs/lib/hyphenateStyleName */ \"./node_modules/fbjs/lib/hyphenateStyleName.js\");var camelizeStyleName=__webpack_require__(/*! fbjs/lib/camelizeStyleName */ \"./node_modules/fbjs/lib/camelizeStyleName.js\");// Relying on the `invariant()` implementation lets us\n// have preserve the format and params in the www builds.\n!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;var invokeGuardedCallback=function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){this._hasCaughtError=false;this._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this._caughtError=error;this._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// untintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebookincubator/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\n!(typeof document!=='undefined')?invariant(false,'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'):void 0;var evt=document.createEvent('Event');// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error=void 0;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.\nvar evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}this._hasCaughtError=true;this._caughtError=error;}else{this._hasCaughtError=false;this._caughtError=null;}// Remove our event listeners\nwindow.removeEventListener('error',onError);};invokeGuardedCallback=invokeGuardedCallbackDev;}}var invokeGuardedCallback$1=invokeGuardedCallback;var ReactErrorUtils={// Used by Fiber to simulate a try-catch.\n_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.\n_rethrowError:null,_hasRethrowError:false,/**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){invokeGuardedCallback$1.apply(ReactErrorUtils,arguments);},/**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**\n * Injectable ordering of event plugins.\n */var eventPluginOrder=null;/**\n * Injectable mapping from names to event plugin modules.\n */var namesToPlugins={};/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.\nreturn;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n *//**\n * Ordered list of injected plugins.\n */var plugins=[];/**\n * Mapping from event name to dispatch config\n */var eventNameDispatchConfigs={};/**\n * Mapping from registration name to plugin module\n */var registrationNameModules={};/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.\neventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$1={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{!(getNodeFromInstance&&getInstanceFromNode)?warning(false,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.'):void 0;}}};var validateEventDispatches=void 0;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;!(instancesIsArr===listenersIsArr&&instancesLen===listenersLen)?warning(false,'EventPluginUtils: Invalid `event`.'):void 0;};}/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**\n * Standard/simple iteration through an event's collected dispatches.\n */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.\nexecuteDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n *//**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n *//**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n *//**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not\n// certain that x is an Array (x could be a string with concat method).\nif(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.\nreturn[current].concat(next);}return[current,next];}/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */var eventQueue=null;/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n *//**\n * Methods for injecting dependencies.\n */var injection={/**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */injectEventPluginOrder:injectEventPluginOrder,/**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */injectEventPluginsByName:injectEventPluginsByName};/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var listener=void 0;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n// live here; needs to be moved to a better place soon\nvar stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.\nreturn null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=null;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.\nvar possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}function runEventsInBatch(events,simulated){if(events!==null){eventQueue=accumulateInto(eventQueue,events);}// Set `eventQueue` to null before processing it so that we can tell if more\n// events get enqueued while processing.\nvar processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.\nReactErrorUtils.rethrowCaughtError();}function runExtractedEventsInBatch(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventsInBatch(events,false);}var EventPluginHub=Object.freeze({injection:injection,getListener:getListener,runEventsInBatch:runEventsInBatch,runExtractedEventsInBatch:runExtractedEventsInBatch});var IndeterminateComponent=0;// Before we know whether it is functional or class\nvar FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=10;var Mode=11;var ContextConsumer=12;var ContextProvider=13;var ForwardRef=14;var Profiler=15;var TimeoutComponent=16;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}while(!node[internalInstanceKey]){if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is\n// unmounted, potentially).\nreturn null;}}var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.\nreturn inst;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\ninvariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps});function getParent(inst){do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**\n * Return if A is an ancestor of B.\n *//**\n * Return the parent instance of the passed-in instance.\n */function getParentInstance(inst){return getParent(inst);}/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i=void 0;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n *//**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */function accumulateDirectionalDispatches(inst,phase,event){{!inst?warning(false,'Dispatching inst must not be null'):void 0;}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});// Do not uses the below two methods directly!\n// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\n// (It is the only module that is allowed to access these methods.)\nfunction unsafeCastStringToDOMTopLevelType(topLevelType){return topLevelType;}function unsafeCastDOMTopLevelTypeToString(topLevelType){return topLevelType;}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}/**\n * To identify top level events in ReactDOM, we use constants defined by this\n * module. This is the only module that uses the unsafe* methods to express\n * that the constants actually correspond to the browser event names. This lets\n * us save some bundle size by avoiding a top level type -> event name map.\n * The rest of ReactDOM code should import top level types from this file.\n */var TOP_ABORT=unsafeCastStringToDOMTopLevelType('abort');var TOP_ANIMATION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));var TOP_ANIMATION_ITERATION=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));var TOP_ANIMATION_START=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));var TOP_BLUR=unsafeCastStringToDOMTopLevelType('blur');var TOP_CAN_PLAY=unsafeCastStringToDOMTopLevelType('canplay');var TOP_CAN_PLAY_THROUGH=unsafeCastStringToDOMTopLevelType('canplaythrough');var TOP_CANCEL=unsafeCastStringToDOMTopLevelType('cancel');var TOP_CHANGE=unsafeCastStringToDOMTopLevelType('change');var TOP_CLICK=unsafeCastStringToDOMTopLevelType('click');var TOP_CLOSE=unsafeCastStringToDOMTopLevelType('close');var TOP_COMPOSITION_END=unsafeCastStringToDOMTopLevelType('compositionend');var TOP_COMPOSITION_START=unsafeCastStringToDOMTopLevelType('compositionstart');var TOP_COMPOSITION_UPDATE=unsafeCastStringToDOMTopLevelType('compositionupdate');var TOP_CONTEXT_MENU=unsafeCastStringToDOMTopLevelType('contextmenu');var TOP_COPY=unsafeCastStringToDOMTopLevelType('copy');var TOP_CUT=unsafeCastStringToDOMTopLevelType('cut');var TOP_DOUBLE_CLICK=unsafeCastStringToDOMTopLevelType('dblclick');var TOP_DRAG=unsafeCastStringToDOMTopLevelType('drag');var TOP_DRAG_END=unsafeCastStringToDOMTopLevelType('dragend');var TOP_DRAG_ENTER=unsafeCastStringToDOMTopLevelType('dragenter');var TOP_DRAG_EXIT=unsafeCastStringToDOMTopLevelType('dragexit');var TOP_DRAG_LEAVE=unsafeCastStringToDOMTopLevelType('dragleave');var TOP_DRAG_OVER=unsafeCastStringToDOMTopLevelType('dragover');var TOP_DRAG_START=unsafeCastStringToDOMTopLevelType('dragstart');var TOP_DROP=unsafeCastStringToDOMTopLevelType('drop');var TOP_DURATION_CHANGE=unsafeCastStringToDOMTopLevelType('durationchange');var TOP_EMPTIED=unsafeCastStringToDOMTopLevelType('emptied');var TOP_ENCRYPTED=unsafeCastStringToDOMTopLevelType('encrypted');var TOP_ENDED=unsafeCastStringToDOMTopLevelType('ended');var TOP_ERROR=unsafeCastStringToDOMTopLevelType('error');var TOP_FOCUS=unsafeCastStringToDOMTopLevelType('focus');var TOP_GOT_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('gotpointercapture');var TOP_INPUT=unsafeCastStringToDOMTopLevelType('input');var TOP_INVALID=unsafeCastStringToDOMTopLevelType('invalid');var TOP_KEY_DOWN=unsafeCastStringToDOMTopLevelType('keydown');var TOP_KEY_PRESS=unsafeCastStringToDOMTopLevelType('keypress');var TOP_KEY_UP=unsafeCastStringToDOMTopLevelType('keyup');var TOP_LOAD=unsafeCastStringToDOMTopLevelType('load');var TOP_LOAD_START=unsafeCastStringToDOMTopLevelType('loadstart');var TOP_LOADED_DATA=unsafeCastStringToDOMTopLevelType('loadeddata');var TOP_LOADED_METADATA=unsafeCastStringToDOMTopLevelType('loadedmetadata');var TOP_LOST_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('lostpointercapture');var TOP_MOUSE_DOWN=unsafeCastStringToDOMTopLevelType('mousedown');var TOP_MOUSE_MOVE=unsafeCastStringToDOMTopLevelType('mousemove');var TOP_MOUSE_OUT=unsafeCastStringToDOMTopLevelType('mouseout');var TOP_MOUSE_OVER=unsafeCastStringToDOMTopLevelType('mouseover');var TOP_MOUSE_UP=unsafeCastStringToDOMTopLevelType('mouseup');var TOP_PASTE=unsafeCastStringToDOMTopLevelType('paste');var TOP_PAUSE=unsafeCastStringToDOMTopLevelType('pause');var TOP_PLAY=unsafeCastStringToDOMTopLevelType('play');var TOP_PLAYING=unsafeCastStringToDOMTopLevelType('playing');var TOP_POINTER_CANCEL=unsafeCastStringToDOMTopLevelType('pointercancel');var TOP_POINTER_DOWN=unsafeCastStringToDOMTopLevelType('pointerdown');var TOP_POINTER_MOVE=unsafeCastStringToDOMTopLevelType('pointermove');var TOP_POINTER_OUT=unsafeCastStringToDOMTopLevelType('pointerout');var TOP_POINTER_OVER=unsafeCastStringToDOMTopLevelType('pointerover');var TOP_POINTER_UP=unsafeCastStringToDOMTopLevelType('pointerup');var TOP_PROGRESS=unsafeCastStringToDOMTopLevelType('progress');var TOP_RATE_CHANGE=unsafeCastStringToDOMTopLevelType('ratechange');var TOP_RESET=unsafeCastStringToDOMTopLevelType('reset');var TOP_SCROLL=unsafeCastStringToDOMTopLevelType('scroll');var TOP_SEEKED=unsafeCastStringToDOMTopLevelType('seeked');var TOP_SEEKING=unsafeCastStringToDOMTopLevelType('seeking');var TOP_SELECTION_CHANGE=unsafeCastStringToDOMTopLevelType('selectionchange');var TOP_STALLED=unsafeCastStringToDOMTopLevelType('stalled');var TOP_SUBMIT=unsafeCastStringToDOMTopLevelType('submit');var TOP_SUSPEND=unsafeCastStringToDOMTopLevelType('suspend');var TOP_TEXT_INPUT=unsafeCastStringToDOMTopLevelType('textInput');var TOP_TIME_UPDATE=unsafeCastStringToDOMTopLevelType('timeupdate');var TOP_TOGGLE=unsafeCastStringToDOMTopLevelType('toggle');var TOP_TOUCH_CANCEL=unsafeCastStringToDOMTopLevelType('touchcancel');var TOP_TOUCH_END=unsafeCastStringToDOMTopLevelType('touchend');var TOP_TOUCH_MOVE=unsafeCastStringToDOMTopLevelType('touchmove');var TOP_TOUCH_START=unsafeCastStringToDOMTopLevelType('touchstart');var TOP_TRANSITION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));var TOP_VOLUME_CHANGE=unsafeCastStringToDOMTopLevelType('volumechange');var TOP_WAITING=unsafeCastStringToDOMTopLevelType('waiting');var TOP_WHEEL=unsafeCastStringToDOMTopLevelType('wheel');// List of events that need to be individually attached to media elements.\n// Note that events in this list will *not* be listened to at the top level\n// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\nvar mediaEventTypes=[TOP_ABORT,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_VOLUME_CHANGE,TOP_WAITING];function getRawEventName(topLevelType){return unsafeCastDOMTopLevelTypeToString(topLevelType);}var contentKey=null;/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but\n// SVG <text> elements don't support innerText even when <div> does.\ncontentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start=void 0;var startValue=compositionState._startText;var startLength=startValue.length;var end=void 0;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here\ncurrentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings\ndelete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings\n}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */persist:function persist(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */isPersistent:emptyFunction.thatReturnsFalse,/**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**\n * Helper to reduce boilerplate when creating subclasses.\n */SyntheticEvent.extend=function(Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();function Class(){return Super.apply(this,arguments);}_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.extend=Super.extend;addEventPoolingTo(Class);return Class;};/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */{var isProxySupported=typeof Proxy==='function'&&// https://github.com/facebook/react/issues/12011\n!Object.isSealed(new Proxy({},{}));if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){!(didWarnForAddedNewProperty||target.isPersistent())?warning(false,\"This synthetic event is reused for performance reasons. If you're \"+\"seeing this, you're adding a new property in the synthetic event object. \"+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.'):void 0;didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;!warningCondition?warning(false,\"This synthetic event is reused for performance reasons. If you're seeing this, \"+\"you're %s `%s` on a released/nullified synthetic event. %s. \"+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result):void 0;}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var SyntheticCompositionEvent=SyntheticEvent$1.extend({data:null});/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */var SyntheticInputEvent=SyntheticEvent$1.extend({data:null});var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.\nvar eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:[TOP_COMPOSITION_END,TOP_KEY_PRESS,TOP_TEXT_INPUT,TOP_PASTE]},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_END,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_START,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_UPDATE,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]}};// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */function getCompositionEventType(topLevelType){switch(topLevelType){case TOP_COMPOSITION_START:return eventTypes.compositionStart;case TOP_COMPOSITION_END:return eventTypes.compositionEnd;case TOP_COMPOSITION_UPDATE:return eventTypes.compositionUpdate;}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType===TOP_KEY_DOWN&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case TOP_KEY_UP:// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case TOP_KEY_DOWN:// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case TOP_KEY_PRESS:case TOP_MOUSE_DOWN:case TOP_BLUR:// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType=void 0;var fallbackData=void 0;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case TOP_COMPOSITION_END:return getDataFromCustomEvent(nativeEvent);case TOP_KEY_PRESS:/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case TOP_TEXT_INPUT:// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to blacklist it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(topLevelType===TOP_COMPOSITION_END||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case TOP_PASTE:// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case TOP_KEY_PRESS:/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case TOP_COMPOSITION_END:return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars=void 0;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var composition=extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);var beforeInput=extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(composition===null){return beforeInput;}if(beforeInput===null){return composition;}return[composition,beforeInput];}};// Use to restore controlled state after a change event has fired.\nvar fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to\n// inject the implementation.\nfiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$2=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$2,enqueueStateRestore:enqueueStateRestore,needsStateRestore:needsStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar _batchedUpdates=function _batchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var _interactiveUpdates=function _interactiveUpdates(fn,a,b){return fn(a,b);};var _flushInteractiveUpdates=function _flushInteractiveUpdates(){};var isBatching=false;function batchedUpdates(fn,bookkeeping){if(isBatching){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(bookkeeping);}isBatching=true;try{return _batchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nisBatching=false;var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n_flushInteractiveUpdates();restoreStateIfNeeded();}}}function interactiveUpdates(fn,a,b){return _interactiveUpdates(fn,a,b);}var injection$3={injectRenderer:function injectRenderer(renderer){_batchedUpdates=renderer.batchedUpdates;_interactiveUpdates=renderer.interactiveUpdates;_flushInteractiveUpdates=renderer.flushInteractiveUpdates;}};/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol=typeof Symbol==='function'&&Symbol.for;var REACT_ELEMENT_TYPE=hasSymbol?Symbol.for('react.element'):0xeac7;var REACT_PORTAL_TYPE=hasSymbol?Symbol.for('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol.for('react.fragment'):0xeacb;var REACT_STRICT_MODE_TYPE=hasSymbol?Symbol.for('react.strict_mode'):0xeacc;var REACT_PROFILER_TYPE=hasSymbol?Symbol.for('react.profiler'):0xead2;var REACT_PROVIDER_TYPE=hasSymbol?Symbol.for('react.provider'):0xeacd;var REACT_CONTEXT_TYPE=hasSymbol?Symbol.for('react.context'):0xeace;var REACT_ASYNC_MODE_TYPE=hasSymbol?Symbol.for('react.async_mode'):0xeacf;var REACT_FORWARD_REF_TYPE=hasSymbol?Symbol.for('react.forward_ref'):0xead0;var REACT_TIMEOUT_TYPE=hasSymbol?Symbol.for('react.timeout'):0xead1;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}function getComponentName(fiber){var type=fiber.type;if(typeof type==='function'){return type.displayName||type.name;}if(typeof type==='string'){return type;}switch(type){case REACT_ASYNC_MODE_TYPE:return'AsyncMode';case REACT_CONTEXT_TYPE:return'Context.Consumer';case REACT_FRAGMENT_TYPE:return'ReactFragment';case REACT_PORTAL_TYPE:return'ReactPortal';case REACT_PROFILER_TYPE:return'Profiler('+fiber.pendingProps.id+')';case REACT_PROVIDER_TYPE:return'Context.Provider';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_TIMEOUT_TYPE:return'Timeout';}if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:var functionName=type.render.displayName||type.render.name||'';return functionName!==''?'ForwardRef('+functionName+')':'ForwardRef';}}return null;}function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:\nnode=node.return;}while(node);return info;}function getCurrentFiberOwnerName$1(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum$1(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum$1;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName$1,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum$1};// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\n['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull);}// attributeNamespace\n);// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull);}// attributeNamespace\n);// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull);}// attributeNamespace\n);// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull);}// attributeNamespace\n);var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null);}// attributeNamespace\n);// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink');});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace');});// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex=new PropertyInfoRecord('tabIndex',STRING,false,// mustUseProperty\n'tabindex',// attributeName\nnull);/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.\nif(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue=void 0;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){attributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\nattributeValue=''+value;}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=_assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getSafeValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var _controlled=isControlled(props);if(!node._wrapperState.controlled&&_controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!_controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getSafeValue(props.value);if(value!=null){if(props.type==='number'){if(value===0&&node.value===''||// eslint-disable-next-line\nnode.value!=value){node.value=''+value;}}else if(node.value!==''+value){node.value=''+value;}}if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getSafeValue(props.defaultValue));}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}function postMountWrapper(element,props,isHydrating){var node=element;if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var _initialValue=''+node._wrapperState.initialValue;var currentValue=node.value;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){// Do not re-assign the value property if there is no change. This\n// potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n// prematurely marking required inputs as invalid\nif(_initialValue!==currentValue){node.value=_initialValue;}}// value must be assigned before defaultValue. This fixes an issue where the\n// visually displayed value of date inputs disappears on mobile Safari and Chrome:\n// https://github.com/facebook/react/issues/7233\nnode.defaultValue=_initialValue;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\nvar group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||node.ownerDocument.activeElement!==node){if(value==null){node.defaultValue=''+node._wrapperState.initialValue;}else if(node.defaultValue!==''+value){node.defaultValue=''+value;}}}function getSafeValue(value){switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':case'number':case'object':case'string':case'undefined':return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:[TOP_BLUR,TOP_CHANGE,TOP_CLICK,TOP_FOCUS,TOP_INPUT,TOP_KEY_DOWN,TOP_KEY_UP,TOP_SELECTION_CHANGE]}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.\nenqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,event);}function runEventInBatch(event){runEventsInBatch(event,false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_CHANGE){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType===TOP_FOCUS){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType===TOP_BLUR){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType===TOP_SELECTION_CHANGE||topLevelType===TOP_KEY_UP||topLevelType===TOP_KEY_DOWN){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType===TOP_CLICK){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_INPUT||topLevelType===TOP_CHANGE){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc=void 0,handleEventFunc=void 0;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(topLevelType===TOP_BLUR){handleControlledInputBlur(targetNode);}}};/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];var SyntheticUIEvent=SyntheticEvent$1.extend({view:null,detail:null});/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var SyntheticMouseEvent=SyntheticUIEvent.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}});/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var SyntheticPointerEvent=SyntheticMouseEvent.extend({pointerId:null,width:null,height:null,pressure:null,tiltX:null,tiltY:null,pointerType:null,isPrimary:null});var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},mouseLeave:{registrationName:'onMouseLeave',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},pointerEnter:{registrationName:'onPointerEnter',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]},pointerLeave:{registrationName:'onPointerLeave',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var isOverEvent=topLevelType===TOP_MOUSE_OVER||topLevelType===TOP_POINTER_OVER;var isOutEvent=topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_POINTER_OUT;if(isOverEvent&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn null;}var win=void 0;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from=void 0;var to=void 0;if(isOutEvent){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn null;}var eventInterface=void 0,leaveEventType=void 0,enterEventType=void 0,eventTypePrefix=void 0;if(topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_MOUSE_OVER){eventInterface=SyntheticMouseEvent;leaveEventType=eventTypes$2.mouseLeave;enterEventType=eventTypes$2.mouseEnter;eventTypePrefix='mouse';}else if(topLevelType===TOP_POINTER_OUT||topLevelType===TOP_POINTER_OVER){eventInterface=SyntheticPointerEvent;leaveEventType=eventTypes$2.pointerLeave;enterEventType=eventTypes$2.pointerEnter;eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=eventInterface.getPooled(leaveEventType,from,nativeEvent,nativeEventTarget);leave.type=eventTypePrefix+'leave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=eventInterface.getPooled(enterEventType,to,nativeEvent,nativeEventTarget);enter.type=eventTypePrefix+'enter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n *//**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect=/*              */0;var PerformedWork=/*         */1;// You can change the rest (and add more).\nvar Placement=/*             */2;var Update=/*                */4;var PlacementAndUpdate=/*    */6;var Deletion=/*              */8;var ContentReset=/*          */16;var Callback=/*              */32;var DidCapture=/*            */64;var Ref=/*                   */128;var Snapshot=/*              */256;// Union of all host effects\nvar HostEffectMask=/*        */511;var Incomplete=/*            */512;var ShouldCapture=/*         */1024;var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nif((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node.return){node=node.return;if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;!instance._warnedAboutRefsInRender?warning(false,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component'):void 0;instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a.return;var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\ninvariant(false,'Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\n!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.\nvar node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.\n// eslint-disable-next-line no-unreachable\nreturn null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.\nvar node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.\n// eslint-disable-next-line no-unreachable\nreturn null;}function addEventBubbleListener(element,eventType,listener){element.addEventListener(eventType,listener,false);}function addEventCaptureListener(element,eventType,listener){element.addEventListener(eventType,listener,true);}/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var SyntheticAnimationEvent=SyntheticEvent$1.extend({animationName:null,elapsedTime:null,pseudoElement:null});/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var SyntheticClipboardEvent=SyntheticEvent$1.extend({clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var SyntheticFocusEvent=SyntheticUIEvent.extend({relatedTarget:null});/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode=void 0;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var SyntheticKeyboardEvent=SyntheticUIEvent.extend({key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var SyntheticDragEvent=SyntheticMouseEvent.extend({dataTransfer:null});/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var SyntheticTouchEvent=SyntheticUIEvent.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState});/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var SyntheticTransitionEvent=SyntheticEvent$1.extend({propertyName:null,elapsedTime:null,pseudoElement:null});/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var SyntheticWheelEvent=SyntheticMouseEvent.extend({deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:null});/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: [TOP_ABORT],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = new Map([\n *   [TOP_ABORT, { sameConfig }],\n * ]);\n */var interactiveEventTypeNames=[[TOP_BLUR,'blur'],[TOP_CANCEL,'cancel'],[TOP_CLICK,'click'],[TOP_CLOSE,'close'],[TOP_CONTEXT_MENU,'contextMenu'],[TOP_COPY,'copy'],[TOP_CUT,'cut'],[TOP_DOUBLE_CLICK,'doubleClick'],[TOP_DRAG_END,'dragEnd'],[TOP_DRAG_START,'dragStart'],[TOP_DROP,'drop'],[TOP_FOCUS,'focus'],[TOP_INPUT,'input'],[TOP_INVALID,'invalid'],[TOP_KEY_DOWN,'keyDown'],[TOP_KEY_PRESS,'keyPress'],[TOP_KEY_UP,'keyUp'],[TOP_MOUSE_DOWN,'mouseDown'],[TOP_MOUSE_UP,'mouseUp'],[TOP_PASTE,'paste'],[TOP_PAUSE,'pause'],[TOP_PLAY,'play'],[TOP_POINTER_CANCEL,'pointerCancel'],[TOP_POINTER_DOWN,'pointerDown'],[TOP_POINTER_UP,'pointerUp'],[TOP_RATE_CHANGE,'rateChange'],[TOP_RESET,'reset'],[TOP_SEEKED,'seeked'],[TOP_SUBMIT,'submit'],[TOP_TOUCH_CANCEL,'touchCancel'],[TOP_TOUCH_END,'touchEnd'],[TOP_TOUCH_START,'touchStart'],[TOP_VOLUME_CHANGE,'volumeChange']];var nonInteractiveEventTypeNames=[[TOP_ABORT,'abort'],[TOP_ANIMATION_END,'animationEnd'],[TOP_ANIMATION_ITERATION,'animationIteration'],[TOP_ANIMATION_START,'animationStart'],[TOP_CAN_PLAY,'canPlay'],[TOP_CAN_PLAY_THROUGH,'canPlayThrough'],[TOP_DRAG,'drag'],[TOP_DRAG_ENTER,'dragEnter'],[TOP_DRAG_EXIT,'dragExit'],[TOP_DRAG_LEAVE,'dragLeave'],[TOP_DRAG_OVER,'dragOver'],[TOP_DURATION_CHANGE,'durationChange'],[TOP_EMPTIED,'emptied'],[TOP_ENCRYPTED,'encrypted'],[TOP_ENDED,'ended'],[TOP_ERROR,'error'],[TOP_GOT_POINTER_CAPTURE,'gotPointerCapture'],[TOP_LOAD,'load'],[TOP_LOADED_DATA,'loadedData'],[TOP_LOADED_METADATA,'loadedMetadata'],[TOP_LOAD_START,'loadStart'],[TOP_LOST_POINTER_CAPTURE,'lostPointerCapture'],[TOP_MOUSE_MOVE,'mouseMove'],[TOP_MOUSE_OUT,'mouseOut'],[TOP_MOUSE_OVER,'mouseOver'],[TOP_PLAYING,'playing'],[TOP_POINTER_MOVE,'pointerMove'],[TOP_POINTER_OUT,'pointerOut'],[TOP_POINTER_OVER,'pointerOver'],[TOP_PROGRESS,'progress'],[TOP_SCROLL,'scroll'],[TOP_SEEKING,'seeking'],[TOP_STALLED,'stalled'],[TOP_SUSPEND,'suspend'],[TOP_TIME_UPDATE,'timeUpdate'],[TOP_TOGGLE,'toggle'],[TOP_TOUCH_MOVE,'touchMove'],[TOP_TRANSITION_END,'transitionEnd'],[TOP_WAITING,'waiting'],[TOP_WHEEL,'wheel']];var eventTypes$4={};var topLevelEventsToDispatchConfig={};function addEventTypeNameToConfig(_ref,isInteractive){var topEvent=_ref[0],event=_ref[1];var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent],isInteractive:isInteractive};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;}interactiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,true);});nonInteractiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,false);});// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes=[TOP_ABORT,TOP_CANCEL,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_CLOSE,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_INPUT,TOP_INVALID,TOP_LOAD,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_RESET,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUBMIT,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_TOGGLE,TOP_VOLUME_CHANGE,TOP_WAITING];var SimpleEventPlugin={eventTypes:eventTypes$4,isInteractiveTopLevelEventType:function isInteractiveTopLevelEventType(topLevelType){var config=topLevelEventsToDispatchConfig[topLevelType];return config!==undefined&&config.isInteractive===true;},extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor=void 0;switch(topLevelType){case TOP_KEY_PRESS:// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case TOP_KEY_DOWN:case TOP_KEY_UP:EventConstructor=SyntheticKeyboardEvent;break;case TOP_BLUR:case TOP_FOCUS:EventConstructor=SyntheticFocusEvent;break;case TOP_CLICK:// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return null;}/* falls through */case TOP_DOUBLE_CLICK:case TOP_MOUSE_DOWN:case TOP_MOUSE_MOVE:case TOP_MOUSE_UP:// TODO: Disabled elements should not respond to mouse events\n/* falls through */case TOP_MOUSE_OUT:case TOP_MOUSE_OVER:case TOP_CONTEXT_MENU:EventConstructor=SyntheticMouseEvent;break;case TOP_DRAG:case TOP_DRAG_END:case TOP_DRAG_ENTER:case TOP_DRAG_EXIT:case TOP_DRAG_LEAVE:case TOP_DRAG_OVER:case TOP_DRAG_START:case TOP_DROP:EventConstructor=SyntheticDragEvent;break;case TOP_TOUCH_CANCEL:case TOP_TOUCH_END:case TOP_TOUCH_MOVE:case TOP_TOUCH_START:EventConstructor=SyntheticTouchEvent;break;case TOP_ANIMATION_END:case TOP_ANIMATION_ITERATION:case TOP_ANIMATION_START:EventConstructor=SyntheticAnimationEvent;break;case TOP_TRANSITION_END:EventConstructor=SyntheticTransitionEvent;break;case TOP_SCROLL:EventConstructor=SyntheticUIEvent;break;case TOP_WHEEL:EventConstructor=SyntheticWheelEvent;break;case TOP_COPY:case TOP_CUT:case TOP_PASTE:EventConstructor=SyntheticClipboardEvent;break;case TOP_GOT_POINTER_CAPTURE:case TOP_LOST_POINTER_CAPTURE:case TOP_POINTER_CANCEL:case TOP_POINTER_DOWN:case TOP_POINTER_MOVE:case TOP_POINTER_OUT:case TOP_POINTER_OVER:case TOP_POINTER_UP:EventConstructor=SyntheticPointerEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events\n// @see http://www.w3.org/TR/html5/index.html#events-0\nEventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};var isInteractiveTopLevelEventType=SimpleEventPlugin.isInteractiveTopLevelEventType;var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM\n// traversal, but caching is difficult to do correctly without using a\n// mutation observer to listen for all DOM changes.\nwhile(inst.return){inst=inst.return;}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.\nreturn null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevel(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.\n// It's important that we build the array of ancestors before calling any\n// event handlers, because event handlers can modify the DOM, leading to\n// inconsistencies with ReactMount's node cache. See #1105.\nvar ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];runExtractedEventsInBatch(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?\nvar _enabled=true;function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**\n * Traps top-level events by using event bubbling.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */function trapBubbledEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventBubbleListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates\ndispatch.bind(null,topLevelType));}/**\n * Traps a top-level event by using event capturing.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */function trapCapturedEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventCaptureListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates\ndispatch.bind(null,topLevelType));}function dispatchInteractiveEvent(topLevelType,nativeEvent){interactiveUpdates(dispatchEvent,topLevelType,nativeEvent);}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows\n// `preventDefault`.\nbatchedUpdates(handleTopLevel,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */var alreadyListeningTo={};var reactTopListenersCounter=0;/**\n * To ensure no conflicts with other potential React instances on the page\n */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n// directly.\nif(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */function listenTo(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){switch(dependency){case TOP_SCROLL:trapCapturedEvent(TOP_SCROLL,mountAt);break;case TOP_FOCUS:case TOP_BLUR:trapCapturedEvent(TOP_FOCUS,mountAt);trapCapturedEvent(TOP_BLUR,mountAt);// We set the flag for a single dependency later in this function,\n// but this ensures we mark both as attached rather than just one.\nisListening[TOP_BLUR]=true;isListening[TOP_FOCUS]=true;break;case TOP_CANCEL:case TOP_CLOSE:if(isEventSupported(getRawEventName(dependency),true)){trapCapturedEvent(dependency,mountAt);}break;case TOP_INVALID:case TOP_SUBMIT:case TOP_RESET:// We listen to them on the target DOM elements.\n// Some of them bubble so we don't want them to fire twice.\nbreak;default:// By default, listen on the top level to all non-media events.\n// Media events don't bubble so adding the listener wouldn't do anything.\nvar isMediaEvent=mediaEventTypes.indexOf(dependency)!==-1;if(!isMediaEvent){trapBubbledEvent(dependency,mountAt);}break;}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n *//**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:[TOP_BLUR,TOP_CONTEXT_MENU,TOP_FOCUS,TOP_KEY_DOWN,TOP_KEY_UP,TOP_MOUSE_DOWN,TOP_MOUSE_UP,TOP_SELECTION_CHANGE]}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nif(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do\n// not extract events. See #3639.\nif(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.\ncase TOP_FOCUS:if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case TOP_BLUR:activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase TOP_MOUSE_DOWN:mouseDown=true;break;case TOP_CONTEXT_MENU:case TOP_MOUSE_UP:mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase TOP_SELECTION_CHANGE:if(skipSelectionChangeEvent){break;}// falls through\ncase TOP_KEY_DOWN:case TOP_KEY_UP:return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */injection.injectEventPluginOrder(DOMEventPluginOrder);injection$1.injectComponentTree(ReactDOMComponentTree);/**\n * Some important event plugins included by default (without having to require\n * them).\n */injection.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localRequestAnimationFrame$1=typeof requestAnimationFrame==='function'?requestAnimationFrame:undefined;/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate=Date;var localSetTimeout=setTimeout;var localClearTimeout=clearTimeout;var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now$1=void 0;if(hasNativePerformanceNow){var Performance=performance;now$1=function now$1(){return Performance.now();};}else{now$1=function now$1(){return localDate.now();};}var scheduleWork=void 0;var cancelScheduledWork=void 0;if(!ExecutionEnvironment.canUseDOM){var timeoutIds=new Map();scheduleWork=function scheduleWork(callback,options){// keeping return type consistent\nvar callbackConfig={scheduledCallback:callback,timeoutTime:0,next:null,prev:null};var timeoutId=localSetTimeout(function(){callback({timeRemaining:function timeRemaining(){return Infinity;},didTimeout:false});});timeoutIds.set(callback,timeoutId);return callbackConfig;};cancelScheduledWork=function cancelScheduledWork(callbackId){var callback=callbackId.scheduledCallback;var timeoutId=timeoutIds.get(callback);timeoutIds.delete(callbackId);localClearTimeout(timeoutId);};}else{{if(typeof localRequestAnimationFrame$1!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. https://fb.me/react-polyfills');}}var localRequestAnimationFrame=typeof localRequestAnimationFrame$1==='function'?localRequestAnimationFrame$1:function(callback){invariant(false,'React depends on requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills');};var headOfPendingCallbacksLinkedList=null;var tailOfPendingCallbacksLinkedList=null;// We track what the next soonest timeoutTime is, to be able to quickly tell\n// if none of the scheduled callbacks have timed out.\nvar nextSoonestTimeoutTime=-1;var isIdleScheduled=false;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking\n// will adjust this value to a faster fps if we get more frequent animation\n// frames.\nvar previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){var remaining=frameDeadline-now$1();return remaining>0?remaining:0;}};/**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */var callUnsafely=function callUnsafely(callbackConfig,arg){var callback=callbackConfig.scheduledCallback;var finishedCalling=false;try{callback(arg);finishedCalling=true;}finally{// always remove it from linked list\ncancelScheduledWork(callbackConfig);if(!finishedCalling){// an error must have been thrown\nisIdleScheduled=true;window.postMessage(messageKey,'*');}}};/**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */var callTimedOutCallbacks=function callTimedOutCallbacks(){if(headOfPendingCallbacksLinkedList===null){return;}var currentTime=now$1();// TODO: this would be more efficient if deferred callbacks are stored in\n// min heap.\n// Or in a linked list with links for both timeoutTime order and insertion\n// order.\n// For now an easy compromise is the current approach:\n// Keep a pointer to the soonest timeoutTime, and check that first.\n// If it has not expired, we can skip traversing the whole list.\n// If it has expired, then we step through all the callbacks.\nif(nextSoonestTimeoutTime===-1||nextSoonestTimeoutTime>currentTime){// We know that none of them have timed out yet.\nreturn;}// NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n// after successfully calling any timed out callbacks.\n// If a timed out callback throws an error, we could get stuck in a state\n// where the nextSoonestTimeoutTime was set wrong.\nvar updatedNextSoonestTimeoutTime=-1;// we will update nextSoonestTimeoutTime below\nvar timedOutCallbacks=[];// iterate once to find timed out callbacks and find nextSoonestTimeoutTime\nvar currentCallbackConfig=headOfPendingCallbacksLinkedList;while(currentCallbackConfig!==null){var _timeoutTime=currentCallbackConfig.timeoutTime;if(_timeoutTime!==-1&&_timeoutTime<=currentTime){// it has timed out!\ntimedOutCallbacks.push(currentCallbackConfig);}else{if(_timeoutTime!==-1&&(updatedNextSoonestTimeoutTime===-1||_timeoutTime<updatedNextSoonestTimeoutTime)){updatedNextSoonestTimeoutTime=_timeoutTime;}}currentCallbackConfig=currentCallbackConfig.next;}if(timedOutCallbacks.length>0){frameDeadlineObject.didTimeout=true;for(var i=0,len=timedOutCallbacks.length;i<len;i++){callUnsafely(timedOutCallbacks[i],frameDeadlineObject);}}// NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n// after successfully calling any timed out callbacks.\nnextSoonestTimeoutTime=updatedNextSoonestTimeoutTime;};// We use the postMessage trick to defer idle work until after the repaint.\nvar messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;if(headOfPendingCallbacksLinkedList===null){return;}// First call anything which has timed out, until we have caught up.\ncallTimedOutCallbacks();var currentTime=now$1();// Next, as long as we have idle time, try calling more callbacks.\nwhile(frameDeadline-currentTime>0&&headOfPendingCallbacksLinkedList!==null){var latestCallbackConfig=headOfPendingCallbacksLinkedList;frameDeadlineObject.didTimeout=false;// callUnsafely will remove it from the head of the linked list\ncallUnsafely(latestCallbackConfig,frameDeadlineObject);currentTime=now$1();}if(headOfPendingCallbacksLinkedList!==null){if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.\nisAnimationFrameScheduled=true;localRequestAnimationFrame(animationTick);}}};// Assumes that we have addEventListener in this environment. Might need\n// something better for old IE.\nwindow.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.\n// If we get lower than that, it is probably a bug.\nnextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.\n// If two frames are short in a row, then that's an indication that we\n// actually have a higher frame rate than what we're currently optimizing.\n// We adjust our heuristic dynamically accordingly. For example, if we're\n// running on 120hz display or 90hz VR display.\n// Take the max of the two in case one of them was an anomaly due to\n// missed frame deadlines.\nactiveFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};scheduleWork=function scheduleWork(callback,options)/* CallbackConfigType */{var timeoutTime=-1;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now$1()+options.timeout;}if(nextSoonestTimeoutTime===-1||timeoutTime!==-1&&timeoutTime<nextSoonestTimeoutTime){nextSoonestTimeoutTime=timeoutTime;}var scheduledCallbackConfig={scheduledCallback:callback,timeoutTime:timeoutTime,prev:null,next:null};if(headOfPendingCallbacksLinkedList===null){// Make this callback the head and tail of our list\nheadOfPendingCallbacksLinkedList=scheduledCallbackConfig;tailOfPendingCallbacksLinkedList=scheduledCallbackConfig;}else{// Add latest callback as the new tail of the list\nscheduledCallbackConfig.prev=tailOfPendingCallbacksLinkedList;// renaming for clarity\nvar oldTailOfPendingCallbacksLinkedList=tailOfPendingCallbacksLinkedList;if(oldTailOfPendingCallbacksLinkedList!==null){oldTailOfPendingCallbacksLinkedList.next=scheduledCallbackConfig;}tailOfPendingCallbacksLinkedList=scheduledCallbackConfig;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.\n// TODO: If this rAF doesn't materialize because the browser throttles, we\n// might want to still have setTimeout trigger scheduleWork as a backup to ensure\n// that we keep performing work.\nisAnimationFrameScheduled=true;localRequestAnimationFrame(animationTick);}return scheduledCallbackConfig;};cancelScheduledWork=function cancelScheduledWork(callbackConfig/* CallbackConfigType */){if(callbackConfig.prev===null&&headOfPendingCallbacksLinkedList!==callbackConfig){// this callbackConfig has already been cancelled.\n// cancelScheduledWork should be idempotent, a no-op after first call.\nreturn;}/**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */var next=callbackConfig.next;var prev=callbackConfig.prev;callbackConfig.next=null;callbackConfig.prev=null;if(next!==null){// we have a next\nif(prev!==null){// we have a prev\n// callbackConfig is somewhere in the middle of a list of 3 or more nodes.\nprev.next=next;next.prev=prev;return;}else{// there is a next but not a previous one;\n// callbackConfig is the head of a list of 2 or more other nodes.\nnext.prev=null;headOfPendingCallbacksLinkedList=next;return;}}else{// there is no next callback config; this must the tail of the list\nif(prev!==null){// we have a prev\n// callbackConfig is the tail of a list of 2 or more other nodes.\nprev.next=null;tailOfPendingCallbacksLinkedList=prev;return;}else{// there is no previous callback config;\n// callbackConfig is the only thing in the linked list,\n// so both head and tail point to it.\nheadOfPendingCallbacksLinkedList=null;tailOfPendingCallbacksLinkedList=null;return;}}};}var didWarnSelectedSetOnOption=false;function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;\n// invalid types are ignored.\n// We can silently skip them because invalid DOM nesting warning\n// catches these cases in Fiber.\nReact.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.\n{if(props.selected!=null&&!didWarnSelectedSetOnOption){warning(false,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue$1=void 0;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$3);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass\n// this value down\nnode._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$4);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.\nvar children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE$1;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp *//**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer=void 0;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nif(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n *//**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{!(props.suppressContentEditableWarning||!props.contentEditable||props.children==null)?warning(false,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack()):void 0;}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this whitelist too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var _hasOwnProperty=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(_hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nwarning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');var warnedUnknownTags=void 0;var suppressHydrationWarning=void 0;var validatePropertiesInDevelopment=void 0;var warnForTextDifference=void 0;var warnForPropDifference=void 0;var warnForExtraAttributes=void 0;var warnForInvalidEventListener=void 0;var normalizeMarkupForTextOrAttribute=void 0;var normalizeHTML=void 0;{getStack=getCurrentFiberStackAddendum$2;warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July\n// 2017 it intends to ship it due to widespread usage. We intentionally\n// *don't* warn for <time> even if it's unrecognized by Chrome because\n// it soon will be, and many apps have been using it anyway.\ntime:true,// There are working polyfills for <dialog>. Let people use it.\ndialog:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);};warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop\n}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.\n// We blacklist it here rather than in the property list because we emit it in SSR.\n}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag=void 0;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement=void 0;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\n!(isCustomComponentTag||type===type.toLowerCase())?warning(false,'<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type):void 0;}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$2()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props=void 0;switch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event\nfor(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':trapBubbledEvent(TOP_ERROR,domElement);props=rawProps;break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);props=rawProps;break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps=void 0;var nextProps=void 0;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey=void 0;var styleName=void 0;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.\n}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop\n}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.\n}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the whitelist in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children\n// inserted already.\n}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop\n}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the whitelist during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}return null;}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){var isCustomComponentTag=void 0;var extraAttributeNames=void 0;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$2()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);break;case'video':case'audio':// Create listener for each media event\nfor(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}break;case'source':trapBubbledEvent(TOP_ERROR,domElement);break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening\n// to onChange. Even if there is no listener.\nensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted\ncase'data-reactroot':break;// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=getPropertyInfo(propKey);if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.\n}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected'){// Noop\n}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.\nif(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$1(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState$1});// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){!(childTag==null)?warning(false,'validateDOMNesting: when childText is passed, childTag should be null'):void 0;childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$5();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export\nvalidateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;}var validateDOMNesting$1=validateDOMNesting;// Renderers that don't support persistence\n// can re-export everything from this module.\nfunction shim(){invariant(false,'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');}// Persistence (when unsupported)\nvar supportsPersistence=false;var cloneInstance=shim;var createContainerChildSet=shim;var appendChildToContainerChildSet=shim;var finalizeContainerChildren=shim;var replaceContainerChildren=shim;// Unused\nvar createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode$1=precacheFiberNode;var updateFiberProps$1=updateFiberProps;var SUPPRESS_HYDRATION_WARNING=void 0;{SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';}var eventsEnabled=null;var selectionInformation=null;function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode$1(internalInstanceHandle,domElement);updateFiberProps$1(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);}function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';}function shouldDeprioritizeSubtree(type,props){return!!props.hidden;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode$1(internalInstanceHandle,textNode);return textNode;}var now=now$1;var isPrimaryRenderer=true;var scheduleDeferredCallback=scheduleWork;var cancelDeferredCallback=cancelScheduledWork;// -------------------\n//     Mutation\n// -------------------\nvar supportsMutation=true;function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nif(shouldAutoFocusHostComponent(type,newProps)){domElement.focus();}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps$1(domElement,newProps);// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}// -------------------\n//     Hydration\n// -------------------\nvar supportsHydration=true;function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.\nwhile(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;}function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.\nwhile(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode$1(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps$1(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);}function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode$1(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}}function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}}function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}// Exports ReactDOM.createRoot\nvar enableUserTimingAPI=true;// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch=false;// Suspense\nvar enableSuspense=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects=false;// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode=true;// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback=true;// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles=false;// Warn about legacy context API\nvar warnAboutLegacyContextAPI=false;// Gather advanced timing metrics for Profiler subtrees.\nvar enableProfilerTimer=true;// Only used in www builds.\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji='\\u269B';var warningEmoji='\\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber=null;// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.\n// This could only happen if React crashed in an unexpected place earlier.\n// Don't pile on with more errors.\n// Clear marks immediately to avoid growing buffer.\nperformance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.\nreturn componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.\nreturn componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because\n// there is a fixed overhead for every measurement, and we don't\n// want to stretch the commit phase beyond necessary.\nreturn false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.\n// We could check typeof fiber.type, but does this work with RN?\nswitch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case Fragment:case ContextProvider:case ContextConsumer:case Mode:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed\n// if we continue in a later deferred loop from the same unit of work.\nvar fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber.return;}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber.return!==null){resumeTimersRecursively(fiber.return);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.\nif(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire,expirationTime){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback... will force flush in '+expirationTime+' ms)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.\ncurrentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.\n// Otherwise flamechart will be deep even for small updates.\nfiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.\ncurrentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.\ncurrentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.\n// Any other measurements are performed within.\nbeginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.\nresumeTimers();}}function stopWorkLoopTimer(interruptedBy,didCompleteRoot){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;var label=didCompleteRoot?'(React Tree Reconciliation: Completed Root)':'(React Tree Reconciliation: Yielded)';// Pause any measurements until the next loop.\npauseTimers();endMark(label,'(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Snapshot Effects)');}}function stopCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Snapshot Effects: '+count+' Total)','(Committing Snapshot Effects)',null);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}var valueStack=[];var fiberStack=void 0;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function checkThatStackIsEmpty(){{if(index!==-1){warning(false,'Expected an empty stack. Something was not reset properly.');}}}function resetStackAfterFatalErrorInDev(){{index=-1;valueStack.length=0;fiberStack.length=0;}}var warnedAboutMissingGetChildContext=void 0;{warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context\n// we have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.current===emptyObject)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when\n// somebody calls unstable_renderSubtreeIntoContainer() and we process\n// context from the parent component instance. The stack will be missing\n// because it's outside of the reconciliation, and so the pointer has not\n// been set. This is rare and doesn't matter. We'll also remove that API.\nReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\n!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node.return;!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT=1073741823;// TODO: Use an opaque type once ESLint et al support the syntax\nvar NoWork=0;var Sync=1;var Never=MAX_SIGNED_31_BIT_INT;var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.\nreturn(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return MAGIC_NUMBER_OFFSET+ceiling(currentTime-MAGIC_NUMBER_OFFSET+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncMode=1;var StrictMode=2;var ProfileMode=4;var hasBadMapPolyfill=void 0;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});var testMap=new Map([[nonExtensibleObject,null]]);var testSet=new Set([nonExtensibleObject]);// This is necessary for Rollup to not consider these unused.\n// https://github.com/rollup/rollup/issues/1771\n// TODO: we can remove these if Rollup fixes the bug.\ntestMap.set(0,0);testSet.add(0);}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\nvar debugCounter=void 0;{debugCounter=1;}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber\nthis.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.mode=mode;// Effects\nthis.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;if(enableProfilerTimer){this.actualDuration=0;this.actualStartTime=0;this.selfBaseTime=0;this.treeBaseTime=0;}{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.effectTag=NoEffect;// The effect list is no longer valid.\nworkInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;if(enableProfilerTimer){// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=0;}}workInProgress.expirationTime=expirationTime;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;if(enableProfilerTimer){workInProgress.selfBaseTime=current.selfBaseTime;workInProgress.treeBaseTime=current.treeBaseTime;}return workInProgress;}function createHostRootFiber(isAsync){var mode=isAsync?AsyncMode|StrictMode:NoContext;return createFiber(HostRoot,null,null,mode);}function createFiberFromElement(element,mode,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type;var key=element.key;var pendingProps=element.props;var fiberTag=void 0;if(typeof type==='function'){fiberTag=shouldConstruct(type)?ClassComponent:IndeterminateComponent;}else if(typeof type==='string'){fiberTag=HostComponent;}else{switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,expirationTime,key);case REACT_ASYNC_MODE_TYPE:fiberTag=Mode;mode|=AsyncMode|StrictMode;break;case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictMode;break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,expirationTime,key);case REACT_TIMEOUT_TYPE:fiberTag=TimeoutComponent;// Suspense does not require async, but its children should be strict\n// mode compatible.\nmode|=StrictMode;break;default:fiberTag=getFiberTagFromObjectType(type,owner);break;}}fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.type=type;fiber.expirationTime=expirationTime;{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function getFiberTagFromObjectType(type,owner){var $$typeof=(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null?type.$$typeof:null;switch($$typeof){case REACT_PROVIDER_TYPE:return ContextProvider;case REACT_CONTEXT_TYPE:// This is a consumer\nreturn ContextConsumer;case REACT_FORWARD_REF_TYPE:return ForwardRef;default:{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}}}function createFiberFromFragment(elements,mode,expirationTime,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromProfiler(pendingProps,mode,expirationTime,key){{if(typeof pendingProps.id!=='string'||typeof pendingProps.onRender!=='function'){invariant(false,'Profiler must specify an \"id\" string and \"onRender\" function as props');}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.type=REACT_PROFILER_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,mode,expirationTime){var fiber=createFiber(HostText,content,null,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromPortal(portal,mode,expirationTime){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoContext);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.mode=source.mode;target.effectTag=source.effectTag;target.nextEffect=source.nextEffect;target.firstEffect=source.firstEffect;target.lastEffect=source.lastEffect;target.expirationTime=source.expirationTime;target.alternate=source.alternate;if(enableProfilerTimer){target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseTime=source.selfBaseTime;target.treeBaseTime=source.treeBaseTime;}target._debugID=source._debugID;target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugIsCurrentlyTiming=source._debugIsCurrentlyTiming;return target;}// TODO: This should be lifted into the renderer.\nfunction createFiberRoot(containerInfo,isAsync,hydrate){// Cyclic construction. This cheats the type system right now because\n// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(isAsync);var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,earliestPendingTime:NoWork,latestPendingTime:NoWork,earliestSuspendedTime:NoWork,latestSuspendedTime:NoWork,latestPingedTime:NoWork,pendingCommitExpirationTime:NoWork,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,remainingExpirationTime:NoWork,firstBatch:null,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\nonCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists\nreturn true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---\n// This error was thrown as a convenience so that you can use this stack\n// to find the callsite that caused this warning to fire.\nthrow new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;var ReactStrictModeWarnings={discardPendingWarnings:function discardPendingWarnings(){},flushPendingDeprecationWarnings:function flushPendingDeprecationWarnings(){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordDeprecationWarnings:function recordDeprecationWarnings(fiber,instance){},recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){}};{var LIFECYCLE_SUGGESTIONS={UNSAFE_componentWillMount:'componentDidMount',UNSAFE_componentWillReceiveProps:'static getDerivedStateFromProps',UNSAFE_componentWillUpdate:'componentDidUpdate'};var pendingComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUnsafeLifecycleWarnings=new Map();var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutDeprecatedLifecycles=new Set();var didWarnAboutUnsafeLifecycles=new Set();var didWarnAboutLegacyContext=new Set();var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUnsafeLifecycleWarnings=new Map();pendingLegacyContextWarning=new Map();};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){pendingUnsafeLifecycleWarnings.forEach(function(lifecycleWarningsMap,strictRoot){var lifecyclesWarningMesages=[];Object.keys(lifecycleWarningsMap).forEach(function(lifecycle){var lifecycleWarnings=lifecycleWarningsMap[lifecycle];if(lifecycleWarnings.length>0){var componentNames=new Set();lifecycleWarnings.forEach(function(fiber){componentNames.add(getComponentName(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});var formatted=lifecycle.replace('UNSAFE_','');var suggestion=LIFECYCLE_SUGGESTIONS[lifecycle];var sortedComponentNames=setToSortedString(componentNames);lifecyclesWarningMesages.push(formatted+': Please update the following components to use '+(suggestion+' instead: '+sortedComponentNames));}});if(lifecyclesWarningMesages.length>0){var strictRootComponentStack=getStackAddendumByWorkInProgressFiber(strictRoot);warning(false,'Unsafe lifecycle methods were found within a strict-mode tree:%s'+'\\n\\n%s'+'\\n\\nLearn more about this warning here:'+'\\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,lifecyclesWarningMesages.join('\\n\\n'));}});pendingUnsafeLifecycleWarnings=new Map();};var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};ReactStrictModeWarnings.flushPendingDeprecationWarnings=function(){if(pendingComponentWillMountWarnings.length>0){var uniqueNames=new Set();pendingComponentWillMountWarnings.forEach(function(fiber){uniqueNames.add(getComponentName(fiber)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);lowPriorityWarning$1(false,'componentWillMount is deprecated and will be removed in the next major version. '+'Use componentDidMount instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillMount.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here:'+'\\nhttps://fb.me/react-async-component-lifecycle-hooks',sortedNames);pendingComponentWillMountWarnings=[];}if(pendingComponentWillReceivePropsWarnings.length>0){var _uniqueNames=new Set();pendingComponentWillReceivePropsWarnings.forEach(function(fiber){_uniqueNames.add(getComponentName(fiber)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames=setToSortedString(_uniqueNames);lowPriorityWarning$1(false,'componentWillReceiveProps is deprecated and will be removed in the next major version. '+'Use static getDerivedStateFromProps instead.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here:'+'\\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames);pendingComponentWillReceivePropsWarnings=[];}if(pendingComponentWillUpdateWarnings.length>0){var _uniqueNames2=new Set();pendingComponentWillUpdateWarnings.forEach(function(fiber){_uniqueNames2.add(getComponentName(fiber)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames2=setToSortedString(_uniqueNames2);lowPriorityWarning$1(false,'componentWillUpdate is deprecated and will be removed in the next major version. '+'Use componentDidUpdate instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillUpdate.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here:'+'\\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames2);pendingComponentWillUpdateWarnings=[];}};ReactStrictModeWarnings.recordDeprecationWarnings=function(fiber,instance){// Dedup strategy: Warn once per component.\nif(didWarnAboutDeprecatedLifecycles.has(fiber.type)){return;}// Don't warn about react-lifecycles-compat polyfilled components.\nif(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warning(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\n// This is difficult to track any other way since component names\n// are often vague and are likely to collide between 3rd party libraries.\n// An expand property is probably okay to use here since it's DEV-only,\n// and will only be set in the event of serious warnings.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}var warningsForRoot=void 0;if(!pendingUnsafeLifecycleWarnings.has(strictRoot)){warningsForRoot={UNSAFE_componentWillMount:[],UNSAFE_componentWillReceiveProps:[],UNSAFE_componentWillUpdate:[]};pendingUnsafeLifecycleWarnings.set(strictRoot,warningsForRoot);}else{warningsForRoot=pendingUnsafeLifecycleWarnings.get(strictRoot);}var unsafeLifecycles=[];if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillMount==='function'){unsafeLifecycles.push('UNSAFE_componentWillMount');}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillReceiveProps==='function'){unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillUpdate==='function'){unsafeLifecycles.push('UNSAFE_componentWillUpdate');}if(unsafeLifecycles.length>0){unsafeLifecycles.forEach(function(lifecycle){warningsForRoot[lifecycle].push(fiber);});}};ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warning(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentName(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);var strictRootComponentStack=getStackAddendumByWorkInProgressFiber(strictRoot);warning(false,'Legacy context API has been detected within a strict-mode tree: %s'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here:'+'\\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,sortedNames);});};}// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;// TODO: Offscreen updates\nfunction markPendingPriorityLevel(root,expirationTime){if(enableSuspense){// Update the latest and earliest pending times\nvar earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime===NoWork){// No other pending updates.\nroot.earliestPendingTime=root.latestPendingTime=expirationTime;}else{if(earliestPendingTime>expirationTime){// This is the earliest pending update.\nroot.earliestPendingTime=expirationTime;}else{var latestPendingTime=root.latestPendingTime;if(latestPendingTime<expirationTime){// This is the latest pending update\nroot.latestPendingTime=expirationTime;}}}}}function markCommittedPriorityLevels(root,currentTime,earliestRemainingTime){if(enableSuspense){if(earliestRemainingTime===NoWork){// Fast path. There's no remaining work. Clear everything.\nroot.earliestPendingTime=NoWork;root.latestPendingTime=NoWork;root.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;return;}// Let's see if the previous latest known pending level was just flushed.\nvar latestPendingTime=root.latestPendingTime;if(latestPendingTime!==NoWork){if(latestPendingTime<earliestRemainingTime){// We've flushed all the known pending levels.\nroot.earliestPendingTime=root.latestPendingTime=NoWork;}else{var earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime<earliestRemainingTime){// We've flushed the earliest known pending level. Set this to the\n// latest pending time.\nroot.earliestPendingTime=root.latestPendingTime;}}}// Now let's handle the earliest remaining level in the whole tree. We need to\n// decide whether to treat it as a pending level or as suspended. Check\n// it falls within the range of known suspended levels.\nvar earliestSuspendedTime=root.earliestSuspendedTime;if(earliestSuspendedTime===NoWork){// There's no suspended work. Treat the earliest remaining level as a\n// pending level.\nmarkPendingPriorityLevel(root,earliestRemainingTime);return;}var latestSuspendedTime=root.latestSuspendedTime;if(earliestRemainingTime>latestSuspendedTime){// The earliest remaining level is later than all the suspended work. That\n// means we've flushed all the suspended work.\nroot.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;// There's no suspended work. Treat the earliest remaining level as a\n// pending level.\nmarkPendingPriorityLevel(root,earliestRemainingTime);return;}if(earliestRemainingTime<earliestSuspendedTime){// The earliest remaining time is earlier than all the suspended work.\n// Treat it as a pending update.\nmarkPendingPriorityLevel(root,earliestRemainingTime);return;}// The earliest remaining time falls within the range of known suspended\n// levels. We should treat this as suspended work.\n}}function markSuspendedPriorityLevel(root,suspendedTime){if(enableSuspense){// First, check the known pending levels and update them if needed.\nvar earliestPendingTime=root.earliestPendingTime;var latestPendingTime=root.latestPendingTime;if(earliestPendingTime===suspendedTime){if(latestPendingTime===suspendedTime){// Both known pending levels were suspended. Clear them.\nroot.earliestPendingTime=root.latestPendingTime=NoWork;}else{// The earliest pending level was suspended. Clear by setting it to the\n// latest pending level.\nroot.earliestPendingTime=latestPendingTime;}}else if(latestPendingTime===suspendedTime){// The latest pending level was suspended. Clear by setting it to the\n// latest pending level.\nroot.latestPendingTime=earliestPendingTime;}// Next, if we're working on the lowest known suspended level, clear the ping.\n// TODO: What if a promise suspends and pings before the root completes?\nvar latestSuspendedTime=root.latestSuspendedTime;if(latestSuspendedTime===suspendedTime){root.latestPingedTime=NoWork;}// Finally, update the known suspended levels.\nvar earliestSuspendedTime=root.earliestSuspendedTime;if(earliestSuspendedTime===NoWork){// No other suspended levels.\nroot.earliestSuspendedTime=root.latestSuspendedTime=suspendedTime;}else{if(earliestSuspendedTime>suspendedTime){// This is the earliest suspended level.\nroot.earliestSuspendedTime=suspendedTime;}else if(latestSuspendedTime<suspendedTime){// This is the latest suspended level\nroot.latestSuspendedTime=suspendedTime;}}}}function markPingedPriorityLevel(root,pingedTime){if(enableSuspense){var latestSuspendedTime=root.latestSuspendedTime;if(latestSuspendedTime!==NoWork&&latestSuspendedTime<=pingedTime){var latestPingedTime=root.latestPingedTime;if(latestPingedTime===NoWork||latestPingedTime<pingedTime){root.latestPingedTime=pingedTime;}}}}function findNextPendingPriorityLevel(root){if(enableSuspense){var earliestSuspendedTime=root.earliestSuspendedTime;var earliestPendingTime=root.earliestPendingTime;if(earliestSuspendedTime===NoWork){// Fast path. There's no suspended work.\nreturn earliestPendingTime;}// First, check if there's known pending work.\nif(earliestPendingTime!==NoWork){return earliestPendingTime;}// Finally, if a suspended level was pinged, work on that. Otherwise there's\n// nothing to work on.\nreturn root.latestPingedTime;}else{return root.current.expirationTime;}}// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed — a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nvar UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate=void 0;var currentlyProcessingQueue=void 0;var resetCurrentlyProcessingQueue=void 0;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;resetCurrentlyProcessingQueue=function resetCurrentlyProcessingQueue(){currentlyProcessingQueue=null;};}function createUpdateQueue(baseState){var queue={expirationTime:NoWork,baseState:baseState,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function cloneUpdateQueue(currentQueue){var queue={expirationTime:currentQueue.expirationTime,baseState:currentQueue.baseState,firstUpdate:currentQueue.firstUpdate,lastUpdate:currentQueue.lastUpdate,// TODO: With resuming, if we bail out and resuse the child tree, we should\n// keep these effects.\nfirstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function createUpdate(expirationTime){return{expirationTime:expirationTime,tag:UpdateState,payload:null,callback:null,next:null,nextEffect:null};}function appendUpdateToQueue(queue,update,expirationTime){// Append the update to the end of the list.\nif(queue.lastUpdate===null){// Queue is empty\nqueue.firstUpdate=queue.lastUpdate=update;}else{queue.lastUpdate.next=update;queue.lastUpdate=update;}if(queue.expirationTime===NoWork||queue.expirationTime>expirationTime){// The incoming update has the earliest expiration of any update in the\n// queue. Update the queue's expiration time.\nqueue.expirationTime=expirationTime;}}function enqueueUpdate(fiber,update,expirationTime){// Update queues are created lazily.\nvar alternate=fiber.alternate;var queue1=void 0;var queue2=void 0;if(alternate===null){// There's only one fiber.\nqueue1=fiber.updateQueue;queue2=null;if(queue1===null){queue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);}}else{// There are two owners.\nqueue1=fiber.updateQueue;queue2=alternate.updateQueue;if(queue1===null){if(queue2===null){// Neither fiber has an update queue. Create new ones.\nqueue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);queue2=alternate.updateQueue=createUpdateQueue(alternate.memoizedState);}else{// Only one fiber has an update queue. Clone to create a new one.\nqueue1=fiber.updateQueue=cloneUpdateQueue(queue2);}}else{if(queue2===null){// Only one fiber has an update queue. Clone to create a new one.\nqueue2=alternate.updateQueue=cloneUpdateQueue(queue1);}else{// Both owners have an update queue.\n}}}if(queue2===null||queue1===queue2){// There's only a single queue.\nappendUpdateToQueue(queue1,update,expirationTime);}else{// There are two queues. We need to append the update to both queues,\n// while accounting for the persistent structure of the list — we don't\n// want the same update to be added multiple times.\nif(queue1.lastUpdate===null||queue2.lastUpdate===null){// One of the queues is not empty. We must add the update to both queues.\nappendUpdateToQueue(queue1,update,expirationTime);appendUpdateToQueue(queue2,update,expirationTime);}else{// Both queues are non-empty. The last update is the same in both lists,\n// because of structural sharing. So, only append to one of the lists.\nappendUpdateToQueue(queue1,update,expirationTime);// But we still need to update the `lastUpdate` pointer of queue2.\nqueue2.lastUpdate=update;}}{if(fiber.tag===ClassComponent&&(currentlyProcessingQueue===queue1||queue2!==null&&currentlyProcessingQueue===queue2)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function enqueueCapturedUpdate(workInProgress,update,renderExpirationTime){// Captured updates go into a separate list, and only on the work-in-\n// progress queue.\nvar workInProgressQueue=workInProgress.updateQueue;if(workInProgressQueue===null){workInProgressQueue=workInProgress.updateQueue=createUpdateQueue(workInProgress.memoizedState);}else{// TODO: I put this here rather than createWorkInProgress so that we don't\n// clone the queue unnecessarily. There's probably a better way to\n// structure this.\nworkInProgressQueue=ensureWorkInProgressQueueIsAClone(workInProgress,workInProgressQueue);}// Append the update to the end of the list.\nif(workInProgressQueue.lastCapturedUpdate===null){// This is the first render phase update\nworkInProgressQueue.firstCapturedUpdate=workInProgressQueue.lastCapturedUpdate=update;}else{workInProgressQueue.lastCapturedUpdate.next=update;workInProgressQueue.lastCapturedUpdate=update;}if(workInProgressQueue.expirationTime===NoWork||workInProgressQueue.expirationTime>renderExpirationTime){// The incoming update has the earliest expiration of any update in the\n// queue. Update the queue's expiration time.\nworkInProgressQueue.expirationTime=renderExpirationTime;}}function ensureWorkInProgressQueueIsAClone(workInProgress,queue){var current=workInProgress.alternate;if(current!==null){// If the work-in-progress queue is equal to the current queue,\n// we need to clone it first.\nif(queue===current.updateQueue){queue=workInProgress.updateQueue=cloneUpdateQueue(queue);}}return queue;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var _payload=update.payload;if(typeof _payload==='function'){// Updater function\n{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload.call(instance,prevState,nextProps);}}return _payload.call(instance,prevState,nextProps);}// State object\nreturn _payload;}case CaptureUpdate:{workInProgress.effectTag=workInProgress.effectTag&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload2=update.payload;var partialState=void 0;if(typeof _payload2==='function'){// Updater function\n{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload2.call(instance,prevState,nextProps);}}partialState=_payload2.call(instance,prevState,nextProps);}else{// Partial state object\npartialState=_payload2;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn _assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,queue,props,instance,renderExpirationTime){hasForceUpdate=false;if(queue.expirationTime===NoWork||queue.expirationTime>renderExpirationTime){// Insufficient priority. Bailout.\nreturn;}queue=ensureWorkInProgressQueueIsAClone(workInProgress,queue);{currentlyProcessingQueue=queue;}// These values may change as we process the queue.\nvar newBaseState=queue.baseState;var newFirstUpdate=null;var newExpirationTime=NoWork;// Iterate through the list of updates to compute the result.\nvar update=queue.firstUpdate;var resultState=newBaseState;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.\nif(newFirstUpdate===null){// This is the first skipped update. It will be the first update in\n// the new list.\nnewFirstUpdate=update;// Since this is the first update that was skipped, the current result\n// is the new base state.\nnewBaseState=resultState;}// Since this update will remain in the list, update the remaining\n// expiration time.\nif(newExpirationTime===NoWork||newExpirationTime>updateExpirationTime){newExpirationTime=updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute\n// a new result.\nresultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback=update.callback;if(_callback!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.\nupdate.nextEffect=null;if(queue.lastEffect===null){queue.firstEffect=queue.lastEffect=update;}else{queue.lastEffect.nextEffect=update;queue.lastEffect=update;}}}// Continue to the next update.\nupdate=update.next;}// Separately, iterate though the list of captured updates.\nvar newFirstCapturedUpdate=null;update=queue.firstCapturedUpdate;while(update!==null){var _updateExpirationTime=update.expirationTime;if(_updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.\nif(newFirstCapturedUpdate===null){// This is the first skipped captured update. It will be the first\n// update in the new list.\nnewFirstCapturedUpdate=update;// If this is the first update that was skipped, the current result is\n// the new base state.\nif(newFirstUpdate===null){newBaseState=resultState;}}// Since this update will remain in the list, update the remaining\n// expiration time.\nif(newExpirationTime===NoWork||newExpirationTime>_updateExpirationTime){newExpirationTime=_updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute\n// a new result.\nresultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback2=update.callback;if(_callback2!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.\nupdate.nextEffect=null;if(queue.lastCapturedEffect===null){queue.firstCapturedEffect=queue.lastCapturedEffect=update;}else{queue.lastCapturedEffect.nextEffect=update;queue.lastCapturedEffect=update;}}}update=update.next;}if(newFirstUpdate===null){queue.lastUpdate=null;}if(newFirstCapturedUpdate===null){queue.lastCapturedUpdate=null;}else{workInProgress.effectTag|=Callback;}if(newFirstUpdate===null&&newFirstCapturedUpdate===null){// We processed every update, without skipping. That means the new base\n// state is the same as the result state.\nnewBaseState=resultState;}queue.baseState=newBaseState;queue.firstUpdate=newFirstUpdate;queue.firstCapturedUpdate=newFirstCapturedUpdate;queue.expirationTime=newExpirationTime;workInProgress.memoizedState=resultState;{currentlyProcessingQueue=null;}}function callCallback(callback,context){!(typeof callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',callback):void 0;callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance,renderExpirationTime){// If the finished render included captured updates, and there are still\n// lower priority updates left over, we need to keep the captured updates\n// in the queue so that they are rebased and not dropped once we process the\n// queue again at the lower priority.\nif(finishedQueue.firstCapturedUpdate!==null){// Join the captured update list to the end of the normal list.\nif(finishedQueue.lastUpdate!==null){finishedQueue.lastUpdate.next=finishedQueue.firstCapturedUpdate;finishedQueue.lastUpdate=finishedQueue.lastCapturedUpdate;}// Clear the list of captured updates.\nfinishedQueue.firstCapturedUpdate=finishedQueue.lastCapturedUpdate=null;}// Commit the effects\nvar effect=finishedQueue.firstEffect;finishedQueue.firstEffect=finishedQueue.lastEffect=null;while(effect!==null){var _callback3=effect.callback;if(_callback3!==null){effect.callback=null;callCallback(_callback3,instance);}effect=effect.nextEffect;}effect=finishedQueue.firstCapturedEffect;finishedQueue.firstCapturedEffect=finishedQueue.lastCapturedEffect=null;while(effect!==null){var _callback4=effect.callback;if(_callback4!==null){effect.callback=null;callCallback(_callback4,instance);}effect=effect.nextEffect;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackAddendumByWorkInProgressFiber(source)};}var providerCursor=createCursor(null);var valueCursor=createCursor(null);var changedBitsCursor=createCursor(0);var rendererSigil=void 0;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}function pushProvider(providerFiber){var context=providerFiber.type._context;if(isPrimaryRenderer){push(changedBitsCursor,context._changedBits,providerFiber);push(valueCursor,context._currentValue,providerFiber);push(providerCursor,providerFiber,providerFiber);context._currentValue=providerFiber.pendingProps.value;context._changedBits=providerFiber.stateNode;{!(context._currentRenderer===undefined||context._currentRenderer===null||context._currentRenderer===rendererSigil)?warning(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer=rendererSigil;}}else{push(changedBitsCursor,context._changedBits2,providerFiber);push(valueCursor,context._currentValue2,providerFiber);push(providerCursor,providerFiber,providerFiber);context._currentValue2=providerFiber.pendingProps.value;context._changedBits2=providerFiber.stateNode;{!(context._currentRenderer2===undefined||context._currentRenderer2===null||context._currentRenderer2===rendererSigil)?warning(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer2=rendererSigil;}}}function popProvider(providerFiber){var changedBits=changedBitsCursor.current;var currentValue=valueCursor.current;pop(providerCursor,providerFiber);pop(valueCursor,providerFiber);pop(changedBitsCursor,providerFiber);var context=providerFiber.type._context;if(isPrimaryRenderer){context._currentValue=currentValue;context._changedBits=changedBits;}else{context._currentValue2=currentValue;context._changedBits2=changedBits;}}function getContextCurrentValue(context){return isPrimaryRenderer?context._currentValue:context._currentValue2;}function getContextChangedBits(context){return isPrimaryRenderer?context._changedBits:context._changedBits2;}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var commitTime=0;function getCommitTime(){return commitTime;}function recordCommitTime(){if(!enableProfilerTimer){return;}commitTime=now();}/**\n * The \"actual\" render time is total time required to render the descendants of a Profiler component.\n * This time is stored as a stack, since Profilers can be nested.\n * This time is started during the \"begin\" phase and stopped during the \"complete\" phase.\n * It is paused (and accumulated) in the event of an interruption or an aborted render.\n */var fiberStack$1=void 0;{fiberStack$1=[];}var timerPausedAt=0;var totalElapsedPauseTime=0;function checkActualRenderTimeStackEmpty(){if(!enableProfilerTimer){return;}{!(fiberStack$1.length===0)?warning(false,'Expected an empty stack. Something was not reset properly.'):void 0;}}function markActualRenderTimeStarted(fiber){if(!enableProfilerTimer){return;}{fiberStack$1.push(fiber);}fiber.actualDuration=now()-fiber.actualDuration-totalElapsedPauseTime;fiber.actualStartTime=now();}function pauseActualRenderTimerIfRunning(){if(!enableProfilerTimer){return;}if(timerPausedAt===0){timerPausedAt=now();}}function recordElapsedActualRenderTime(fiber){if(!enableProfilerTimer){return;}{!(fiber===fiberStack$1.pop())?warning(false,'Unexpected Fiber (%s) popped.',getComponentName(fiber)):void 0;}fiber.actualDuration=now()-totalElapsedPauseTime-fiber.actualDuration;}function resetActualRenderTimer(){if(!enableProfilerTimer){return;}totalElapsedPauseTime=0;}function resumeActualRenderTimerIfPaused(){if(!enableProfilerTimer){return;}if(timerPausedAt>0){totalElapsedPauseTime+=now()-timerPausedAt;timerPausedAt=0;}}/**\n * The \"base\" render time is the duration of the “begin” phase of work for a particular fiber.\n * This time is measured and stored on each fiber.\n * The time for all sibling fibers are accumulated and stored on their parent during the \"complete\" phase.\n * If a fiber bails out (sCU false) then its \"base\" timer is cancelled and the fiber is not updated.\n */var baseStartTime=-1;function recordElapsedBaseRenderTimeIfRunning(fiber){if(!enableProfilerTimer){return;}if(baseStartTime!==-1){fiber.selfBaseTime=now()-baseStartTime;}}function startBaseRenderTimer(){if(!enableProfilerTimer){return;}{if(baseStartTime!==-1){warning(false,'Cannot start base timer that is already running. '+'This error is likely caused by a bug in React. '+'Please file an issue.');}}baseStartTime=now();}function stopBaseRenderTimerIfRunning(){if(!enableProfilerTimer){return;}baseStartTime=-1;}var fakeInternalInstance={};var isArray=Array.isArray;var didWarnAboutStateAssignmentForComponent=void 0;var didWarnAboutUninitializedState=void 0;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=void 0;var didWarnAboutLegacyLifecyclesAndDerivedState=void 0;var didWarnAboutUndefinedDerivedState=void 0;var warnOnUndefinedDerivedState=void 0;var warnOnInvalidCallback$1=void 0;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutUndefinedDerivedState=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback$1=function warnOnInvalidCallback$1(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);warning(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(workInProgress,partialState){if(partialState===undefined){var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);warning(false,'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Invoke the function an extra time to help detect side-effects.\ngetDerivedStateFromProps(nextProps,prevState);}}var partialState=getDerivedStateFromProps(nextProps,prevState);{warnOnUndefinedDerivedState(workInProgress,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:_assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nvar updateQueue=workInProgress.updateQueue;if(updateQueue!==null&&updateQueue.expirationTime===NoWork){updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var currentTime=recalculateCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update,expirationTime);scheduleWork$1(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var currentTime=recalculateCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update,expirationTime);scheduleWork$1(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var currentTime=recalculateCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update,expirationTime);scheduleWork$1(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){var instance=workInProgress.stateNode;var ctor=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();{!(shouldUpdate!==undefined)?warning(false,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Component'):void 0;}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress)||'Component';var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;!noGetInitialStateOnES6?warning(false,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name):void 0;var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;!noGetDefaultPropsOnES6?warning(false,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name):void 0;var noInstancePropTypes=!instance.propTypes;!noInstancePropTypes?warning(false,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name):void 0;var noInstanceContextTypes=!instance.contextTypes;!noInstanceContextTypes?warning(false,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name):void 0;var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';!noComponentShouldUpdate?warning(false,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name):void 0;if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';!noComponentDidUnmount?warning(false,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name):void 0;var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';!noComponentDidReceiveProps?warning(false,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name):void 0;var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';!noComponentWillRecieveProps?warning(false,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name):void 0;var noUnsafeComponentWillRecieveProps=typeof instance.UNSAFE_componentWillRecieveProps!=='function';!noUnsafeComponentWillRecieveProps?warning(false,'%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name):void 0;var hasMutatedProps=instance.props!==workInProgress.pendingProps;!(instance.props===undefined||!hasMutatedProps)?warning(false,'%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name):void 0;var noInstanceDefaultProps=!instance.defaultProps;!noInstanceDefaultProps?warning(false,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name):void 0;if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);warning(false,'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentName(workInProgress));}var noInstanceGetDerivedStateFromProps=typeof instance.getDerivedStateFromProps!=='function';!noInstanceGetDerivedStateFromProps?warning(false,'%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noInstanceGetDerivedStateFromCatch=typeof instance.getDerivedStateFromCatch!=='function';!noInstanceGetDerivedStateFromCatch?warning(false,'%s: getDerivedStateFromCatch() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noStaticGetSnapshotBeforeUpdate=typeof type.getSnapshotBeforeUpdate!=='function';!noStaticGetSnapshotBeforeUpdate?warning(false,'%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name):void 0;var _state=instance.state;if(_state&&((typeof _state==='undefined'?'undefined':_typeof(_state))!=='object'||isArray(_state))){warning(false,'%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'){!(_typeof(type.childContextTypes)==='object')?warning(false,'%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name):void 0;}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props,renderExpirationTime){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;// Instantiate twice to help detect side-effects.\n{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){new ctor(props,context);// eslint-disable-line no-new\n}}var instance=new ctor(props,context);var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);warning(false,'%s: Did not properly initialize state during construction. '+'Expected state to be an object, but it was %s.',componentName,instance.state===null?'null':'undefined');}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentName(workInProgress)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);warning(false,'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://fb.me/react-async-component-lifecycle-hooks',_componentName,newApiName,foundWillMountName!==null?'\\n  '+foundWillMountName:'',foundWillReceivePropsName!==null?'\\n  '+foundWillReceivePropsName:'',foundWillUpdateName!==null?'\\n  '+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentName(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){var oldState=instance.state;startPhaseTimer(workInProgress,'componentWillReceiveProps');if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,newContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,newContext);}stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,renderExpirationTime){var ctor=workInProgress.type;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);{if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress,instance);}}var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,props,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}var getDerivedStateFromProps=workInProgress.type.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,getDerivedStateFromProps,props);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nupdateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,props,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}function resumeMountClassInstance(workInProgress,renderExpirationTime){var ctor=workInProgress.type;var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;instance.props=oldProps;var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==newContext){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){startPhaseTimer(workInProgress,'componentWillMount');if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,renderExpirationTime){var ctor=workInProgress.type;var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;instance.props=oldProps;var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==newContext){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){startPhaseTimer(workInProgress,'componentWillUpdate');if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,newContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,newContext);}stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.effectTag|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}var getCurrentFiberStackAddendum$7=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnAboutMaps=void 0;var didWarnAboutStringRefInStrictMode=void 0;var ownerHasKeyUseWarning=void 0;var ownerHasFunctionTypeWarning=void 0;var warnForMissingKey=function warnForMissingKey(child){};{didWarnAboutMaps=false;didWarnAboutStringRefInStrictMode={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'\"key\" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$7()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'\"key\" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$7());};}var isArray$1=Array.isArray;function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&(typeof mixedRef==='undefined'?'undefined':_typeof(mixedRef))!=='object'){{if(returnFiber.mode&StrictMode){var componentName=getComponentName(returnFiber)||'Component';if(!didWarnAboutStringRefInStrictMode[componentName]){warning(false,'A string ref, \"%s\", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using createRef() instead.'+'\\n%s'+'\\n\\nLearn more about using refs safely here:'+'\\nhttps://fb.me/react-strict-mode-string-ref',mixedRef,getStackAddendumByWorkInProgressFiber(returnFiber));didWarnAboutStringRefInStrictMode[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$7()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$7()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$7()||'');}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}// Deletions are added in reversed order so we add it to the front.\n// At this point, the return fiber's effect list is empty except for\n// deletions, so we can just append the deletion to the list. The remaining\n// effects aren't added until the complete phase. Once we implement\n// resuming, this may not be true.\nvar last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.\nreturn lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent,expirationTime);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index\nvar existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,expirationTime);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,expirationTime,key);created.return=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment,expirationTime);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,expirationTime);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,expirationTime);_created2.return=returnFiber;return _created2;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,expirationTime,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$7());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){!didWarnAboutMaps?warning(false,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$7()):void 0;didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(returnFiber,child,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,expirationTime,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,expirationTime);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nvar isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'&&!isUnkeyedTopLevelFragment){// If the new child is undefined, and the return fiber is a composite\n// component, throw an error. If Fiber return types are disabled,\n// we already threw above.\nswitch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.\nbreak;}}}// Intentionally fall through to the next case, which handles both\n// functions and classes\n// eslint-disable-next-lined no-fallthrough\ncase FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild.return=workInProgress;}newChild.sibling=null;}// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){if(!supportsHydration){return false;}var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,\n// these children are not part of the reconciliation list of children.\n// Even if we abort and rereconcile the children, that will try to hydrate\n// again and the nodes are still in the host tree so these will be\n// recreated.\nif(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(!supportsHydration){return false;}if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them.\n// TODO: Better heuristic.\nif(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){if(!supportsHydration){return;}hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnAboutBadClass=void 0;var didWarnAboutGetDerivedStateOnFunctionalComponent=void 0;var didWarnAboutStatelessRefs=void 0;{didWarnAboutBadClass={};didWarnAboutGetDerivedStateOnFunctionalComponent={};didWarnAboutStatelessRefs={};}// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\nfunction reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateForwardRef(current,workInProgress){var render=workInProgress.type.render;var nextProps=workInProgress.pendingProps;var ref=workInProgress.ref;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(workInProgress.memoizedProps===nextProps){var currentRef=current!==null?current.ref:null;if(ref===currentRef){return bailoutOnAlreadyFinishedWork(current,workInProgress);}}var nextChildren=void 0;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=render(nextProps,ref);ReactDebugCurrentFiber.setCurrentPhase(null);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function updateMode(current,workInProgress){var nextChildren=workInProgress.pendingProps.children;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function updateProfiler(current,workInProgress){var nextProps=workInProgress.pendingProps;if(enableProfilerTimer){workInProgress.effectTag|=Update;}if(workInProgress.memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else{if(workInProgress.memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.\n// It used to be here.\n}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren=void 0;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.\nworkInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(workInProgress.stateNode===null){// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,workInProgress.pendingProps,renderExpirationTime);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,renderExpirationTime);}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext,renderExpirationTime);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext,renderExpirationTime){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.effectTag&DidCapture)!==NoEffect;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var ctor=workInProgress.type;var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner.current=workInProgress;var nextChildren=void 0;if(didCaptureError&&(!enableGetDerivedStateFromCatch||typeof ctor.getDerivedStateFromCatch!=='function')){// If we captured an error, but getDerivedStateFrom catch is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;if(enableProfilerTimer){stopBaseRenderTimerIfRunning();}}else{{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}}// React DevTools reads this flag.\nworkInProgress.effectTag|=PerformedWork;if(didCaptureError){// If we're recovering from an error, reconcile twice: first to delete\n// all the existing children.\nreconcileChildrenAtExpirationTime(current,workInProgress,null,renderExpirationTime);workInProgress.child=null;// Now we can continue reconciling like normal. This has the effect of\n// remounting all children regardless of whether their their\n// identity matches.\n}reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);// Memoize props and state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nmemoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState!==null?prevState.element:null;processUpdateQueue(workInProgress,updateQueue,nextProps,null,renderExpirationTime);var nextState=workInProgress.memoizedState;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nvar nextChildren=nextState.element;if(nextChildren===prevChildren){// If the state is the same as before, that's a bailout because we had\n// no work that expires at this time.\nresetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.\n// We always try to hydrate. If this isn't a hydration pass there won't\n// be any children to hydrate which is effectively the same thing as\n// not hydrating.\n// This is a bit of a hack. We track the host root as a placement to\n// know that we're currently in a mounting state. That way isMounted\n// works as expected. We must reset this before committing.\n// TODO: Delete this when we delete isMounted and findDOMNode.\nworkInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking\n// side-effects. This ensures that we don't store Placement effects on\n// nodes that will be hydrated.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another\n// root.\nresetHydrationState();reconcileChildren(current,workInProgress,nextChildren);}return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.\nreturn bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(memoizedProps===nextProps){var isHidden=workInProgress.mode&AsyncMode&&shouldDeprioritizeSubtree(type,nextProps);if(isHidden){// Before bailing out, make sure we've deprioritized a hidden component.\nworkInProgress.expirationTime=Never;}if(!isHidden||renderExpirationTime!==Never){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// If we're rendering a hidden node at hidden priority, don't bailout. The\n// parent is complete, but the children may not be.\n}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also have access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.\nif(renderExpirationTime!==Never&&workInProgress.mode&AsyncMode&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.\nworkInProgress.expirationTime=Never;// Bailout and come back to this fiber later.\nworkInProgress.memoizedProps=nextProps;return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value=void 0;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress)||'Unknown';if(!didWarnAboutBadClass[componentName]){warning(false,\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.\nworkInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var Component=workInProgress.type;// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;var getDerivedStateFromProps=Component.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,getDerivedStateFromProps,props);}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext,renderExpirationTime);}else{// Proceed under the assumption that this is a functional component\nworkInProgress.tag=FunctionalComponent;{var _Component=workInProgress.type;if(_Component){!!_Component.childContextTypes?warning(false,'%s(...): childContextTypes cannot be defined on a functional component.',_Component.displayName||_Component.name||'Component'):void 0;}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutStatelessRefs[warningKey]){didWarnAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}if(typeof fn.getDerivedStateFromProps==='function'){var _componentName=getComponentName(workInProgress)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]){warning(false,'%s: Stateless functional components do not support getDerivedStateFromProps.',_componentName);didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]=true;}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateTimeoutComponent(current,workInProgress,renderExpirationTime){if(enableSuspense){var nextProps=workInProgress.pendingProps;var prevProps=workInProgress.memoizedProps;var prevDidTimeout=workInProgress.memoizedState;// Check if we already attempted to render the normal state. If we did,\n// and we timed out, render the placeholder state.\nvar alreadyCaptured=(workInProgress.effectTag&DidCapture)===NoEffect;var nextDidTimeout=!alreadyCaptured;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(nextProps===prevProps&&nextDidTimeout===prevDidTimeout){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var render=nextProps.children;var nextChildren=render(nextDidTimeout);workInProgress.memoizedProps=nextProps;workInProgress.memoizedState=nextDidTimeout;reconcileChildren(current,workInProgress,nextChildren);return workInProgress.child;}else{return null;}}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}function propagateContextChange(workInProgress,context,changedBits,renderExpirationTime){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nswitch(fiber.tag){case ContextConsumer:// Check if the context matches.\nvar observedBits=fiber.stateNode|0;if(fiber.type===context&&(observedBits&changedBits)!==0){// Update the expiration time of all the ancestors, including\n// the alternates.\nvar node=fiber;while(node!==null){var alternate=node.alternate;if(node.expirationTime===NoWork||node.expirationTime>renderExpirationTime){node.expirationTime=renderExpirationTime;if(alternate!==null&&(alternate.expirationTime===NoWork||alternate.expirationTime>renderExpirationTime)){alternate.expirationTime=renderExpirationTime;}}else if(alternate!==null&&(alternate.expirationTime===NoWork||alternate.expirationTime>renderExpirationTime)){alternate.expirationTime=renderExpirationTime;}else{// Neither alternate was updated, which means the rest of the\n// ancestor path already has sufficient priority.\nbreak;}node=node.return;}// Don't scan deeper than a matching consumer. When we render the\n// consumer, we'll continue scanning from that point. This way the\n// scanning work is time-sliced.\nnextFiber=null;}else{// Traverse down.\nnextFiber=fiber.child;}break;case ContextProvider:// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;break;default:// Traverse down.\nnextFiber=fiber.child;break;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber.return=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber.return;}}fiber=nextFiber;}}function updateContextProvider(current,workInProgress,renderExpirationTime){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var canBailOnProps=true;if(hasContextChanged()){canBailOnProps=false;// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(oldProps===newProps){workInProgress.stateNode=0;pushProvider(workInProgress);return bailoutOnAlreadyFinishedWork(current,workInProgress);}var newValue=newProps.value;workInProgress.memoizedProps=newProps;{var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider',getCurrentFiberStackAddendum$6);}}var changedBits=void 0;if(oldProps===null){// Initial render\nchangedBits=MAX_SIGNED_31_BIT_INT;}else{if(oldProps.value===newProps.value){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&canBailOnProps){workInProgress.stateNode=0;pushProvider(workInProgress);return bailoutOnAlreadyFinishedWork(current,workInProgress);}changedBits=0;}else{var oldValue=oldProps.value;// Use Object.is to compare the new context value to the old value.\n// Inlined Object.is polyfill.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nif(oldValue===newValue&&(oldValue!==0||1/oldValue===1/newValue)||oldValue!==oldValue&&newValue!==newValue// eslint-disable-line no-self-compare\n){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&canBailOnProps){workInProgress.stateNode=0;pushProvider(workInProgress);return bailoutOnAlreadyFinishedWork(current,workInProgress);}changedBits=0;}else{changedBits=typeof context._calculateChangedBits==='function'?context._calculateChangedBits(oldValue,newValue):MAX_SIGNED_31_BIT_INT;{!((changedBits&MAX_SIGNED_31_BIT_INT)===changedBits)?warning(false,'calculateChangedBits: Expected the return value to be a '+'31-bit integer. Instead received: %s',changedBits):void 0;}changedBits|=0;if(changedBits===0){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&canBailOnProps){workInProgress.stateNode=0;pushProvider(workInProgress);return bailoutOnAlreadyFinishedWork(current,workInProgress);}}else{propagateContextChange(workInProgress,context,changedBits,renderExpirationTime);}}}}workInProgress.stateNode=changedBits;pushProvider(workInProgress);var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren);return workInProgress.child;}function updateContextConsumer(current,workInProgress,renderExpirationTime){var context=workInProgress.type;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=getContextCurrentValue(context);var changedBits=getContextChangedBits(context);if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed\n// we don't do the bailout and we have to reuse existing props instead.\n}else if(changedBits===0&&oldProps===newProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}workInProgress.memoizedProps=newProps;var observedBits=newProps.unstable_observedBits;if(observedBits===undefined||observedBits===null){// Subscribe to all changes by default\nobservedBits=MAX_SIGNED_31_BIT_INT;}// Store the observedBits on the fiber's stateNode for quick access.\nworkInProgress.stateNode=observedBits;if((changedBits&observedBits)!==0){// Context change propagation stops at matching consumers, for time-\n// slicing. Continue the propagation here.\npropagateContextChange(workInProgress,context,changedBits,renderExpirationTime);}else if(oldProps===newProps){// Skip over a memoized parent with a bitmask bailout even\n// if we began working on it because of a deeper matching child.\nreturn bailoutOnAlreadyFinishedWork(current,workInProgress);}// There is no bailout on `children` equality because we expect people\n// to often pass a bound method as a child, but it may reference\n// `this.state` or `this.props` (and thus needs to re-render on `setState`).\nvar render=newProps.children;{!(typeof render==='function')?warning(false,'A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.'):void 0;}var newChildren=void 0;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');newChildren=render(newValue);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.\nworkInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,newChildren);return workInProgress.child;}/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);if(enableProfilerTimer){// Don't update \"base\" render times for bailouts.\nstopBaseRenderTimerIfRunning();}// TODO: We should ideally be able to bail out early if the children have no\n// more work to do. However, since we don't have a separation of this\n// Fiber's priority and its children yet - we don't know without doing lots\n// of the same work we do anyway. Once we have that separation we can just\n// bail out here if the children has no more work at this priority level.\n// if (workInProgress.priorityOfChildren <= priorityLevel) {\n//   // If there are side-effects in these children that have not yet been\n//   // committed we need to ensure that they get properly transferred up.\n//   if (current && current.child !== workInProgress.child) {\n//     reuseChildrenEffects(workInProgress, child);\n//   }\n//   return null;\n// }\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);if(enableProfilerTimer){// Don't update \"base\" render times for bailouts.\nstopBaseRenderTimerIfRunning();}// TODO: Handle HostComponent tags here as well and call pushHostContext()?\n// See PR 8590 discussion for context\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:pushProvider(workInProgress);break;}// TODO: What if this is currently in progress?\n// How can that happen? How is this not being cloned?\nreturn null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting\n// is handled by processUpdateQueue.\n}function beginWork(current,workInProgress,renderExpirationTime){if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){markActualRenderTimeStarted(workInProgress);}}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case TimeoutComponent:return updateTimeoutComponent(current,workInProgress,renderExpirationTime);case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case ForwardRef:return updateForwardRef(current,workInProgress);case Fragment:return updateFragment(current,workInProgress);case Mode:return updateMode(current,workInProgress);case Profiler:return updateProfiler(current,workInProgress);case ContextProvider:return updateContextProvider(current,workInProgress,renderExpirationTime);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderExpirationTime);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.effectTag|=Update;}function markRef$1(workInProgress){workInProgress.effectTag|=Ref;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse\n// down its children. Instead, we'll get insertions from each child in\n// the portal directly.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent$1=void 0;var updateHostText$1=void 0;if(supportsMutation){// Mutation mode\nupdateHostContainer=function updateHostContainer(workInProgress){// Noop\n};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance,currentHostContext){// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}else if(supportsPersistence){// Persistent host tree mode\n// An unfortunate fork of appendAllChildren because we have two different parent types.\nvar appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse\n// down its children. Instead, we'll get insertions from each child in\n// the portal directly.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.\n}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);// If children might have changed, we have to add them all to the set.\nappendAllChildrenToContainer(newChildSet,workInProgress);portalOrRoot.pendingChildren=newChildSet;// Schedule an update on the container to swap out the container.\nmarkUpdate(workInProgress);finalizeContainerChildren(container,newChildSet);}};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance,currentHostContext){// If there are no effects associated with this node, then none of our children had any updates.\n// This guarantees that we can reuse all of them.\nvar childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.\n// Note that this might release a previous clone.\nworkInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance,currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.\n// Even though we're not going to use it for anything.\n// Otherwise parents won't know that there are new children to propagate upwards.\nmarkUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.\nappendAllChildren(newInstance,workInProgress);}}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.\nvar rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.\n// This lets the parents know that at least one of their children has changed.\nmarkUpdate(workInProgress);}};}else{// No host operations\nupdateHostContainer=function updateHostContainer(workInProgress){// Noop\n};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance,currentHostContext){// Noop\n};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// Noop\n};}function completeWork(current,workInProgress,renderExpirationTime){var newProps=workInProgress.pendingProps;if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){recordElapsedActualRenderTime(workInProgress);}}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.\npopContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\npopHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.\n// TODO: Delete this when we delete isMounted and findDOMNode.\nworkInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent$1(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance,currentHostContext);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.\nreturn null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on we want to add then top->down or\n// bottom->up. Top->down is faster in IE11.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance,_currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.\nreturn null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case ForwardRef:return null;case TimeoutComponent:return null;case Fragment:return null;case Mode:return null;case Profiler:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;case ContextProvider:// Pop provider fiber\npopProvider(workInProgress);return null;case ContextConsumer:return null;// Error cases\ncase IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough\ndefault:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError){return true;}function logCapturedError(capturedError){var logError=showErrorDialog(capturedError);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\nif(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\\n\\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole.error(combinedMessage);}}var invokeGuardedCallback$3=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}function logError(boundary,errorInfo){var source=errorInfo.source;var stack=errorInfo.stack;if(stack===null&&source!==null){stack=getStackAddendumByWorkInProgressFiber(source);}var capturedError={componentName:source!==null?getComponentName(source):null,componentStack:stack!==null?stack:'',error:errorInfo.value,errorBoundary:null,errorBoundaryName:null,errorBoundaryFound:false,willRetry:false};if(boundary!==null&&boundary.tag===ClassComponent){capturedError.errorBoundary=boundary.stateNode;capturedError.errorBoundaryName=getComponentName(boundary);capturedError.errorBoundaryFound=true;capturedError.willRetry=true;}try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.\n// A cycle may still occur if logCapturedError renders a component that throws.\nvar suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$3(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureCommitPhaseError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){{invokeGuardedCallback$3(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureCommitPhaseError(current,refError);}}}else{ref.current=null;}}}function commitBeforeMutationLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{if(finishedWork.effectTag&Snapshot){if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'getSnapshotBeforeUpdate');var instance=finishedWork.stateNode;instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;var snapshot=instance.getSnapshotBeforeUpdate(prevProps,prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);warning(false,'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentName(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;stopPhaseTimer();}}return;}case HostRoot:case HostComponent:case HostText:case HostPortal:// Nothing to do for these component types\nreturn;default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitLifeCycles(finishedRoot,current,finishedWork,currentTime,committedExpirationTime){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;commitUpdateQueue(finishedWork,updateQueue,instance,committedExpirationTime);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance,committedExpirationTime);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.\nreturn;}case HostPortal:{// We have no life-cycles associated with portals.\nreturn;}case Profiler:{// We have no life-cycles associated with Profiler.\nreturn;}case TimeoutComponent:{// We have no life-cycles associated with Timeouts.\nreturn;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse=void 0;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}if(typeof ref==='function'){ref(instanceToUse);}else{{if(!ref.hasOwnProperty('current')){warning(false,'Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().%s',getComponentName(finishedWork),getStackAddendumByWorkInProgressFiber(finishedWork));}}ref.current=instanceToUse;}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){if(typeof currentRef==='function'){currentRef(null);}else{currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case HostPortal:{// TODO: this is recursive.\n// We are also not using this parent because\n// the portal will get pushed immediately.\nif(supportsMutation){unmountHostComponents(current);}else if(supportsPersistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call\n// removeChild on the inner nodes because they're removed by the top\n// call anyway. We also want to call componentWillUnmount on all\n// composites before this host node is removed from the tree. Therefore\nvar node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.\n// Skip portals because commitUnmount() currently visits them recursively.\nif(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.\n// If we don't use mutation we drill down into portals here instead.\n!supportsMutation||node.tag!==HostPortal)){node.child.return=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node.return===null||node.return===root){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we\n// should clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child. This child\n// itself will be GC:ed when the parent updates the next time.\ncurrent.return=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate.return=null;}}function emptyPortalContainer(current){if(!supportsPersistence){return;}var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);}function commitContainer(finishedWork){if(!supportsPersistence){return;}switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.effectTag&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.effectTag&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){if(!supportsMutation){return;}// Recursively insert all host nodes into the parent.\nvar parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse\n// down its children. Instead, we'll get insertions from each child in\n// the portal directly.\n}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its\nvar node=current;// Each iteration, currentParent is populated with node's host parent if not\n// currentParentIsValid.\nvar currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node.return;findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent.return;}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the\n// node from the tree.\nif(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.\n}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.\n// We will reassign it back when we pop the portal on the way up.\ncurrentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.\nif(node.child!==null){node.child.return=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.\nif(node.child!==null){node.child.return=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node.return===null||node.return===current){return;}node=node.return;if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.\n// Since we don't keep a stack of them, we will search for it.\ncurrentParentIsValid=false;}}node.sibling.return=node.return;node=node.sibling;}}function commitDeletion(current){if(supportsMutation){// Recursively delete all host nodes from the parent.\n// Detach refs and call componentWillUnmount() on the whole subtree.\nunmountHostComponents(current);}else{// Detach refs and call componentWillUnmount() on the whole subtree.\ncommitNestedUnmounts(current);}detachFiber(current);}function commitWork(current,finishedWork){if(!supportsMutation){commitContainer(finishedWork);return;}switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}case Profiler:{if(enableProfilerTimer){var onRender=finishedWork.memoizedProps.onRender;onRender(finishedWork.memoizedProps.id,current===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseTime,finishedWork.actualStartTime,getCommitTime());}return;}case TimeoutComponent:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){if(!supportsMutation){return;}resetTextContent(current.stateNode);}function createRootErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);update.tag=CaptureUpdate;var getDerivedStateFromCatch=fiber.type.getDerivedStateFromCatch;if(enableGetDerivedStateFromCatch&&typeof getDerivedStateFromCatch==='function'){var error=errorInfo.value;update.payload=function(){return getDerivedStateFromCatch(error);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){if(!enableGetDerivedStateFromCatch||getDerivedStateFromCatch!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromCatch is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error=errorInfo.value;var stack=errorInfo.stack;logError(fiber,errorInfo);this.componentDidCatch(error,{componentStack:stack!==null?stack:''});};}return update;}function schedulePing(finishedWork){// Once the promise resolves, we should try rendering the non-\n// placeholder state again.\nvar currentTime=recalculateCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,finishedWork);var recoveryUpdate=createUpdate(expirationTime);enqueueUpdate(finishedWork,recoveryUpdate,expirationTime);scheduleWork$1(finishedWork,expirationTime);}function throwException(root,returnFiber,sourceFiber,value,renderIsExpired,renderExpirationTime,currentTimeMs){// The source fiber did not complete.\nsourceFiber.effectTag|=Incomplete;// Its effect list is no longer valid.\nsourceFiber.firstEffect=sourceFiber.lastEffect=null;if(enableSuspense&&value!==null&&(typeof value==='undefined'?'undefined':_typeof(value))==='object'&&typeof value.then==='function'){// This is a thenable.\nvar thenable=value;var expirationTimeMs=expirationTimeToMs(renderExpirationTime);var startTimeMs=expirationTimeMs-5000;var elapsedMs=currentTimeMs-startTimeMs;if(elapsedMs<0){elapsedMs=0;}var remainingTimeMs=expirationTimeMs-currentTimeMs;// Find the earliest timeout of all the timeouts in the ancestor path.\n// TODO: Alternatively, we could store the earliest timeout on the context\n// stack, rather than searching on every suspend.\nvar _workInProgress=returnFiber;var earliestTimeoutMs=-1;searchForEarliestTimeout:do{if(_workInProgress.tag===TimeoutComponent){var current=_workInProgress.alternate;if(current!==null&&current.memoizedState===true){// A parent Timeout already committed in a placeholder state. We\n// need to handle this promise immediately. In other words, we\n// should never suspend inside a tree that already expired.\nearliestTimeoutMs=0;break searchForEarliestTimeout;}var timeoutPropMs=_workInProgress.pendingProps.ms;if(typeof timeoutPropMs==='number'){if(timeoutPropMs<=0){earliestTimeoutMs=0;break searchForEarliestTimeout;}else if(earliestTimeoutMs===-1||timeoutPropMs<earliestTimeoutMs){earliestTimeoutMs=timeoutPropMs;}}else if(earliestTimeoutMs===-1){earliestTimeoutMs=remainingTimeMs;}}_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// Compute the remaining time until the timeout.\nvar msUntilTimeout=earliestTimeoutMs-elapsedMs;if(renderExpirationTime===Never||msUntilTimeout>0){// There's still time remaining.\nsuspendRoot(root,thenable,msUntilTimeout,renderExpirationTime);var onResolveOrReject=function onResolveOrReject(){retrySuspendedRoot(root,renderExpirationTime);};thenable.then(onResolveOrReject,onResolveOrReject);return;}else{// No time remaining. Need to fallback to placeholder.\n// Find the nearest timeout that can be retried.\n_workInProgress=returnFiber;do{switch(_workInProgress.tag){case HostRoot:{// The root expired, but no fallback was provided. Throw a\n// helpful error.\nvar message=renderExpirationTime===Sync?'A synchronous update was suspended, but no fallback UI '+'was provided.':'An update was suspended for longer than the timeout, '+'but no fallback UI was provided.';value=new Error(message);break;}case TimeoutComponent:{if((_workInProgress.effectTag&DidCapture)===NoEffect){_workInProgress.effectTag|=ShouldCapture;var _onResolveOrReject=schedulePing.bind(null,_workInProgress);thenable.then(_onResolveOrReject,_onResolveOrReject);return;}// Already captured during this render. Continue to the next\n// Timeout ancestor.\nbreak;}}_workInProgress=_workInProgress.return;}while(_workInProgress!==null);}}// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvalue=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.effectTag|=ShouldCapture;var update=createRootErrorUpdate(workInProgress,_errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,update,renderExpirationTime);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.effectTag&DidCapture)===NoEffect&&(typeof ctor.getDerivedStateFromCatch==='function'&&enableGetDerivedStateFromCatch||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.effectTag|=ShouldCapture;// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update,renderExpirationTime);return;}break;default:break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function unwindWork(workInProgress,renderIsExpired,renderExpirationTime){if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){recordElapsedActualRenderTime(workInProgress);}}switch(workInProgress.tag){case ClassComponent:{popContextProvider(workInProgress);var effectTag=workInProgress.effectTag;if(effectTag&ShouldCapture){workInProgress.effectTag=effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var _effectTag=workInProgress.effectTag;if(_effectTag&ShouldCapture){workInProgress.effectTag=_effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostComponent:{popHostContext(workInProgress);return null;}case TimeoutComponent:{var _effectTag2=workInProgress.effectTag;if(_effectTag2&ShouldCapture){workInProgress.effectTag=_effectTag2&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:popProvider(workInProgress);return null;default:return null;}}function unwindInterruptedWork(interruptedWork){if(enableProfilerTimer){if(interruptedWork.mode&ProfileMode){// Resume in case we're picking up on work that was paused.\nresumeActualRenderTimerIfPaused();recordElapsedActualRenderTime(interruptedWork);}}switch(interruptedWork.tag){case ClassComponent:{popContextProvider(interruptedWork);break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case ContextProvider:popProvider(interruptedWork);break;default:break;}}var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;var didWarnAboutStateTransition=void 0;var didWarnSetStateChildContext=void 0;var warnAboutUpdateOnUnmounted=void 0;var warnAboutInvalidUpdates=void 0;{didWarnAboutStateTransition=false;didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,\"Can't call setState (or forceUpdate) on an unmounted component. This \"+'is a no-op, but it indicates a memory leak in your application. To '+'fix, cancel all subscriptions and asynchronous tasks in the '+'componentWillUnmount method.%s',getStackAddendumByWorkInProgressFiber(fiber));didWarnStateUpdateForUnmountedComponent[componentName]=true;};warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+\"`render` or another component's constructor). Render methods should \"+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}// Represents the current time in ms.\nvar originalStartTimeMs=now();var mostRecentCurrentTime=msToExpirationTime(0);var mostRecentCurrentTimeMs=originalStartTimeMs;// Used to ensure computeUniqueAsyncExpiration is monotonically increases.\nvar lastUniqueAsyncExpiration=0;// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.\nvar nextRenderExpirationTime=NoWork;var nextLatestTimeoutMs=-1;var nextRenderIsExpired=false;// The next fiber with an effect that we're currently committing.\nvar nextEffect=null;var isCommitting$1=false;var isRootReadyForCommit=false;var legacyErrorBoundariesThatAlreadyFailed=null;// Used for performance tracking.\nvar interruptedBy=null;var stashedWorkInProgressProperties=void 0;var replayUnitOfWork=void 0;var isReplayingFailedUnitOfWork=void 0;var originalReplayError=void 0;var rethrowOriginalError=void 0;if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=null;isReplayingFailedUnitOfWork=false;originalReplayError=null;replayUnitOfWork=function replayUnitOfWork(failedUnitOfWork,thrownValue,isAsync){if(thrownValue!==null&&(typeof thrownValue==='undefined'?'undefined':_typeof(thrownValue))==='object'&&typeof thrownValue.then==='function'){// Don't replay promises. Treat everything else like an error.\n// TODO: Need to figure out a different strategy if/when we add\n// support for catching other types.\nreturn;}// Restore the original state of the work-in-progress\nif(stashedWorkInProgressProperties===null){// This should never happen. Don't throw because this code is DEV-only.\nwarning(false,'Could not replay rendering after an error. This is likely a bug in React. '+'Please file an issue.');return;}assignFiberPropertiesInDEV(failedUnitOfWork,stashedWorkInProgressProperties);switch(failedUnitOfWork.tag){case HostRoot:popHostContainer(failedUnitOfWork);popTopLevelContextObject(failedUnitOfWork);break;case HostComponent:popHostContext(failedUnitOfWork);break;case ClassComponent:popContextProvider(failedUnitOfWork);break;case HostPortal:popHostContainer(failedUnitOfWork);break;case ContextProvider:popProvider(failedUnitOfWork);break;}// Replay the begin phase.\nisReplayingFailedUnitOfWork=true;originalReplayError=thrownValue;invokeGuardedCallback$2(null,workLoop,null,isAsync);isReplayingFailedUnitOfWork=false;originalReplayError=null;if(hasCaughtError()){clearCaughtError();if(enableProfilerTimer){if(failedUnitOfWork.mode&ProfileMode){recordElapsedActualRenderTime(failedUnitOfWork);}// Stop \"base\" render timer again (after the re-thrown error).\nstopBaseRenderTimerIfRunning();}}else{// If the begin phase did not fail the second time, set this pointer\n// back to the original value.\nnextUnitOfWork=failedUnitOfWork;}};rethrowOriginalError=function rethrowOriginalError(){throw originalReplayError;};}function resetStack(){if(nextUnitOfWork!==null){var interruptedWork=nextUnitOfWork.return;while(interruptedWork!==null){unwindInterruptedWork(interruptedWork);interruptedWork=interruptedWork.return;}}{ReactStrictModeWarnings.discardPendingWarnings();checkThatStackIsEmpty();}nextRoot=null;nextRenderExpirationTime=NoWork;nextLatestTimeoutMs=-1;nextRenderIsExpired=false;nextUnitOfWork=null;isRootReadyForCommit=false;}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,\n// updates, and deletions. To avoid needing to add a case for every\n// possible bitmap value, we remove the secondary effects from the\n// effect tag and switch on that value.\nvar primaryEffectTag=effectTag&(Placement|Update|Deletion);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the \"placement\" from effect tag so that we know that this is inserted, before\n// any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted\n// does and isMounted is deprecated anyway so we should be able\n// to kill this.\nnextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement\ncommitPlacement(nextEffect);// Clear the \"placement\" from effect tag so that we know that this is inserted, before\n// any life-cycles like componentDidMount gets called.\nnextEffect.effectTag&=~Placement;// Update\nvar _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{commitDeletion(nextEffect);break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitBeforeMutationLifecycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&Snapshot){recordEffect();var current=nextEffect.alternate;commitBeforeMutationLifeCycles(current,nextEffect);}// Don't cleanup effects yet;\n// This will be done by commitAllLifeCycles()\nnextEffect=nextEffect.nextEffect;}}function commitAllLifeCycles(finishedRoot,currentTime,committedExpirationTime){{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.flushPendingDeprecationWarnings();}if(warnAboutLegacyContextAPI){ReactStrictModeWarnings.flushLegacyContextWarning();}}while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(finishedRoot,current,nextEffect,currentTime,committedExpirationTime);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.\n// I'm not actually sure this matters because we can't reset firstEffect\n// and lastEffect since they're on every node, not just the effectful\n// ones. So we have to clean everything as we reuse nodes anyway.\nnextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect\n// tags to reason about the current life-cycle.\nnextEffect=next;}}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function commitRoot(finishedWork){isWorking=true;isCommitting$1=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;var committedExpirationTime=root.pendingCommitExpirationTime;!(committedExpirationTime!==NoWork)?invariant(false,'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.pendingCommitExpirationTime=NoWork;var currentTime=recalculateCurrentTime();// Reset this to null before calling lifecycles\nReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if\n// the root has an effect, we need to add it to the end of the list. The\n// resulting list is the set that would belong to the root's parent, if\n// it had one; that is, all the effects in the tree including the root.\nif(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.\nfirstEffect=finishedWork.firstEffect;}prepareForCommit(root.containerInfo);// Invoke instances of getSnapshotBeforeUpdate before mutation.\nnextEffect=firstEffect;startCommitSnapshotEffectsTimer();while(nextEffect!==null){var didError=false;var error=void 0;{invokeGuardedCallback$2(null,commitBeforeMutationLifecycles,null);if(hasCaughtError()){didError=true;error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,error);// Clean-up\nif(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitSnapshotEffectsTimer();if(enableProfilerTimer){// Mark the current commit time to be shared by all Profilers in this batch.\n// This enables them to be grouped later.\nrecordCommitTime();}// Commit all the side-effects within a tree. We'll do this in two passes.\n// The first pass performs all the host insertions, updates, deletions and\n// ref unmounts.\nnextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var _didError=false;var _error=void 0;{invokeGuardedCallback$2(null,commitAllHostEffects,null);if(hasCaughtError()){_didError=true;_error=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error);// Clean-up\nif(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the first pass of the commit phase, so that the previous tree is still\n// current during componentWillUnmount, but before the second pass, so that\n// the finished work is current during componentDidMount/Update.\nroot.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.\n// Life-cycles happen as a separate pass so that all placements, updates,\n// and deletions in the entire tree have already been invoked.\n// This pass also triggers any renderer-specific initial effects.\nnextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError2=false;var _error2=void 0;{invokeGuardedCallback$2(null,commitAllLifeCycles,null,root,currentTime,committedExpirationTime);if(hasCaughtError()){_didError2=true;_error2=clearCaughtError();}}if(_didError2){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}if(enableProfilerTimer){{checkActualRenderTimeStackEmpty();}resetActualRenderTimer();}isCommitting$1=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}markCommittedPriorityLevels(root,currentTime,root.current.expirationTime);var remainingTime=findNextPendingPriorityLevel(root);if(remainingTime===NoWork){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their\n// expiration times.\nreturn;}// Check for pending updates.\nvar newExpirationTime=NoWork;switch(workInProgress.tag){case HostRoot:case ClassComponent:{var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){newExpirationTime=updateQueue.expirationTime;}}}// TODO: Calls need to visit stateNode\n// Bubble up the earliest expiration time.\n// (And \"base\" render timers if that feature flag is enabled)\nif(enableProfilerTimer&&workInProgress.mode&ProfileMode){var treeBaseTime=workInProgress.selfBaseTime;var child=workInProgress.child;while(child!==null){treeBaseTime+=child.treeBaseTime;if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.treeBaseTime=treeBaseTime;}else{var _child=workInProgress.child;while(_child!==null){if(_child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>_child.expirationTime)){newExpirationTime=_child.expirationTime;}_child=_child.sibling;}}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){// Attempt to complete the current unit of work, then move to the\n// next sibling. If there are no more siblings, return to the\n// parent fiber.\nwhile(true){// The current, flushed, state of this fiber is the alternate.\n// Ideally nothing should rely on this, but relying on it here\n// means that we don't need an additional field on the work in\n// progress.\nvar current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var returnFiber=workInProgress.return;var siblingFiber=workInProgress.sibling;if((workInProgress.effectTag&Incomplete)===NoEffect){// This fiber completed.\nvar next=completeWork(current,workInProgress,nextRenderExpirationTime);stopWorkTimer(workInProgress);resetExpirationTime(workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come\n// back here again.\nreturn next;}if(returnFiber!==null&&// Do not append effects to parents if a sibling failed to complete\n(returnFiber.effectTag&Incomplete)===NoEffect){// Append all the effects of the subtree and this fiber onto the effect\n// list of the parent. The completion order of the children affects the\n// side-effect order.\nif(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's\n// side-effects. We can perform certain side-effects earlier if\n// needed, by doing multiple passes over the effect list. We don't want\n// to schedule our own side-effect on our own list because if end up\n// reusing children we'll schedule this effect onto itself since we're\n// at the end.\nvar effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.\n// PerformedWork effect is read by React DevTools but shouldn't be committed.\nif(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nreturn siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.\nworkInProgress=returnFiber;continue;}else{// We've reached the root.\nisRootReadyForCommit=true;return null;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(workInProgress,nextRenderIsExpired,nextRenderExpirationTime);// Because this fiber did not complete, don't reset its expiration time.\nif(workInProgress.effectTag&DidCapture){// Restarting an error boundary\nstopFailedWorkTimer(workInProgress);}else{stopWorkTimer(workInProgress);}{ReactDebugCurrentFiber.resetCurrentFiber();}if(_next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.effectTag&=HostEffectMask;return _next;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its effect list.\nreturnFiber.firstEffect=returnFiber.lastEffect=null;returnFiber.effectTag|=Incomplete;}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nreturn siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.\nworkInProgress=returnFiber;continue;}else{return null;}}}// Without this explicit null return Flow complains of invalid return type\n// TODO Remove the above while(true) loop\n// eslint-disable-next-line no-unreachable\nreturn null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.\n// Ideally nothing should rely on this, but relying on it here\n// means that we don't need an additional field on the work in\n// progress.\nvar current=workInProgress.alternate;// See if beginning this work spawns more work.\nstartWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=assignFiberPropertiesInDEV(stashedWorkInProgressProperties,workInProgress);}var next=void 0;if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){startBaseRenderTimer();}next=beginWork(current,workInProgress,nextRenderExpirationTime);if(workInProgress.mode&ProfileMode){// Update \"base\" time if the render wasn't bailed out on.\nrecordElapsedBaseRenderTimeIfRunning(workInProgress);stopBaseRenderTimerIfRunning();}}else{next=beginWork(current,workInProgress,nextRenderExpirationTime);}{ReactDebugCurrentFiber.resetCurrentFiber();if(isReplayingFailedUnitOfWork){// Currently replaying a failed unit of work. This should be unreachable,\n// because the render phase is meant to be idempotent, and it should\n// have thrown again. Since it didn't, rethrow the original error, so\n// React's internal stack is not misaligned.\nrethrowOriginalError();}}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.\nnext=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(isAsync){if(!isAsync){// Flush all expired work.\nwhile(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.\nwhile(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}if(enableProfilerTimer){// If we didn't finish, pause the \"actual\" render timer.\n// We'll restart it when we resume work.\npauseActualRenderTimerIfRunning();}}}function renderRoot(root,expirationTime,isAsync){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// Check if we're starting from a fresh stack, or if we're resuming from\n// previously yielded work.\nif(expirationTime!==nextRenderExpirationTime||root!==nextRoot||nextUnitOfWork===null){// Reset the stack and start working from the root.\nresetStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextLatestTimeoutMs=-1;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,nextRenderExpirationTime);root.pendingCommitExpirationTime=NoWork;}var didFatal=false;nextRenderIsExpired=!isAsync||nextRenderExpirationTime<=mostRecentCurrentTime;startWorkLoopTimer(nextUnitOfWork);do{try{workLoop(isAsync);}catch(thrownValue){if(enableProfilerTimer){// Stop \"base\" render timer in the event of an error.\nstopBaseRenderTimerIfRunning();}if(nextUnitOfWork===null){// This is a fatal error.\ndidFatal=true;onUncaughtError(thrownValue);}else{{// Reset global debug state\n// We assume this is defined in DEV\nresetCurrentlyProcessingQueue();}var failedUnitOfWork=nextUnitOfWork;if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){replayUnitOfWork(failedUnitOfWork,thrownValue,isAsync);}// TODO: we already know this isn't true in some cases.\n// At least this shows a nicer error message until we figure out the cause.\n// https://github.com/facebook/react/issues/12449#issuecomment-386727431\n!(nextUnitOfWork!==null)?invariant(false,'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.'):void 0;var sourceFiber=nextUnitOfWork;var returnFiber=sourceFiber.return;if(returnFiber===null){// This is the root. The root could capture its own errors. However,\n// we don't know if it errors before or after we pushed the host\n// context. This information is needed to avoid a stack mismatch.\n// Because we're not sure, treat this as a fatal error. We could track\n// which phase it fails in, but doesn't seem worth it. At least\n// for now.\ndidFatal=true;onUncaughtError(thrownValue);break;}throwException(root,returnFiber,sourceFiber,thrownValue,nextRenderIsExpired,nextRenderExpirationTime,mostRecentCurrentTimeMs);nextUnitOfWork=completeUnitOfWork(sourceFiber);}}break;}while(true);// We're done performing work. Time to clean up.\nvar didCompleteRoot=false;isWorking=false;// Yield back to main thread.\nif(didFatal){stopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;// There was a fatal error.\n{resetStackAfterFatalErrorInDev();}return null;}else if(nextUnitOfWork===null){// We reached the root.\nif(isRootReadyForCommit){didCompleteRoot=true;stopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;// The root successfully completed. It's ready for commit.\nroot.pendingCommitExpirationTime=expirationTime;var finishedWork=root.current.alternate;return finishedWork;}else{// The root did not complete.\nstopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;!!nextRenderIsExpired?invariant(false,'Expired work should have completed. This error is likely caused by a bug in React. Please file an issue.'):void 0;markSuspendedPriorityLevel(root,expirationTime);if(nextLatestTimeoutMs>=0){setTimeout(function(){retrySuspendedRoot(root,expirationTime);},nextLatestTimeoutMs);}var firstUnblockedExpirationTime=findNextPendingPriorityLevel(root);onBlock(firstUnblockedExpirationTime);return null;}}else{stopWorkLoopTimer(interruptedBy,didCompleteRoot);interruptedBy=null;// There's more work to do, but we ran out of time. Yield back to\n// the renderer.\nreturn null;}}function dispatch(sourceFiber,value,expirationTime){!(!isWorking||isCommitting$1)?invariant(false,'dispatch: Cannot dispatch during the render phase.'):void 0;var fiber=sourceFiber.return;while(fiber!==null){switch(fiber.tag){case ClassComponent:var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromCatch==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(value,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,expirationTime);enqueueUpdate(fiber,update,expirationTime);scheduleWork$1(fiber,expirationTime);return;}break;case HostRoot:{var _errorInfo=createCapturedValue(value,sourceFiber);var _update=createRootErrorUpdate(fiber,_errorInfo,expirationTime);enqueueUpdate(fiber,_update,expirationTime);scheduleWork$1(fiber,expirationTime);return;}}fiber=fiber.return;}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\nvar rootFiber=sourceFiber;var _errorInfo2=createCapturedValue(value,rootFiber);var _update2=createRootErrorUpdate(rootFiber,_errorInfo2,expirationTime);enqueueUpdate(rootFiber,_update2,expirationTime);scheduleWork$1(rootFiber,expirationTime);}}function captureCommitPhaseError(fiber,error){return dispatch(fiber,error,Sync);}function computeAsyncExpiration(currentTime){// Given the current clock time, returns an expiration time. We use rounding\n// to batch like updates together.\n// Should complete within ~5000ms. 5250ms max.\nvar expirationMs=5000;var bucketSizeMs=250;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeInteractiveExpiration(currentTime){var expirationMs=void 0;// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\n{// Should complete within ~500ms. 600ms max.\nexpirationMs=500;}var bucketSizeMs=100;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration(){var currentTime=recalculateCurrentTime();var result=computeAsyncExpiration(currentTime);if(result<=lastUniqueAsyncExpiration){// Since we assume the current time monotonically increases, we only hit\n// this branch when computeUniqueAsyncExpiration is fired multiple times\n// within a 200ms window (or whatever the async bucket size is).\nresult=lastUniqueAsyncExpiration+1;}lastUniqueAsyncExpiration=result;return lastUniqueAsyncExpiration;}function computeExpirationForFiber(currentTime,fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;\nexpirationTime=expirationContext;}else if(isWorking){if(isCommitting$1){// Updates that occur during the commit phase should have sync priority\n// by default.\nexpirationTime=Sync;}else{// Updates during the render phase should expire at the same time as\n// the work that is being rendered.\nexpirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently\n// performing work. Calculate a new expiration time.\nif(fiber.mode&AsyncMode){if(isBatchingInteractiveUpdates){// This is an interactive update\nexpirationTime=computeInteractiveExpiration(currentTime);}else{// This is an async update\nexpirationTime=computeAsyncExpiration(currentTime);}}else{// This is a sync update\nexpirationTime=Sync;}}if(isBatchingInteractiveUpdates){// This is an interactive update. Keep track of the lowest pending\n// interactive expiration time. This allows us to synchronously flush\n// all interactive updates when needed.\nif(lowestPendingInteractiveExpirationTime===NoWork||expirationTime>lowestPendingInteractiveExpirationTime){lowestPendingInteractiveExpirationTime=expirationTime;}}return expirationTime;}// TODO: Rename this to scheduleTimeout or something\nfunction suspendRoot(root,thenable,timeoutMs,suspendedTime){// Schedule the timeout.\nif(timeoutMs>=0&&nextLatestTimeoutMs<timeoutMs){nextLatestTimeoutMs=timeoutMs;}}function retrySuspendedRoot(root,suspendedTime){markPingedPriorityLevel(root,suspendedTime);var retryTime=findNextPendingPriorityLevel(root);if(retryTime!==NoWork){requestRetry(root,retryTime);}}function scheduleWork$1(fiber,expirationTime){recordScheduleUpdate();{if(fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's\n// expiration time.\nif(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node.return===null){if(node.tag===HostRoot){var root=node.stateNode;if(!isWorking&&nextRenderExpirationTime!==NoWork&&expirationTime<nextRenderExpirationTime){// This is an interruption. (Used for performance tracking.)\ninterruptedBy=fiber;resetStack();}markPendingPriorityLevel(root,expirationTime);var nextExpirationTimeToWorkOn=findNextPendingPriorityLevel(root);if(// If we're in the render phase, we don't need to schedule this root\n// for an update, because we'll do it before we exit...\n!isWorking||isCommitting$1||// ...unless this is a different root than the one we're rendering.\nnextRoot!==root){requestWork(root,nextExpirationTimeToWorkOn);}if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}}else{{if(fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node.return;}}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits\nmostRecentCurrentTimeMs=now()-originalStartTimeMs;mostRecentCurrentTime=msToExpirationTime(mostRecentCurrentTimeMs);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;var currentTime=recalculateCurrentTime();expirationContext=computeAsyncExpiration(currentTime);try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn,a,b,c,d){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn(a,b,c,d);}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n// Linked-list of roots\nvar firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=void 0;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var lowestPendingInteractiveExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;var isBatchingInteractiveUpdates=false;var completedBatches=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).\nif(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.\nreturn;}else{if(callbackID!==null){// Existing callback has insufficient timeout. Cancel and schedule a\n// new one.\ncancelDeferredCallback(callbackID);}}// The request callback timer is already running. Don't start a new one.\n}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.\nvar currentMs=now()-originalStartTimeMs;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}function requestRetry(root,expirationTime){if(root.remainingExpirationTime===NoWork||root.remainingExpirationTime<expirationTime){// For a retry, only update the remaining expiration time if it has a\n// *lower priority* than the existing value. This is because, on a retry,\n// we should attempt to coalesce as much as possible.\nrequestWork(root,expirationTime);}}// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root,expirationTime){addRootToSchedule(root,expirationTime);if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of\n// the currently rendering batch.\nreturn;}if(isBatchingUpdates){// Flush work at the end of the batch.\nif(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should\n// flush it now.\nnextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(root,Sync,false);}return;}// TODO: Get rid of Sync and use current time?\nif(expirationTime===Sync){performSyncWork();}else{scheduleCallbackWithExpiration(expirationTime);}}function addRootToSchedule(root,expirationTime){// Add the root to the schedule.\n// Check if this root is already part of the schedule.\nif(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.\nroot.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.\nvar remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.\nroot.remainingExpirationTime=expirationTime;}}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.\n// TODO: This check is redudant, but Flow is confused by the branch\n// below where we set lastScheduledRoot to null, even though we break\n// from the loop right after.\n!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.\nroot.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.\nvar next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.\nlastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher\nhighestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested\n// update. To prevent an infinite loop, increment the nested update count.\nvar previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot&&highestPriorityWork===Sync){nestedUpdateCount++;}else{// Reset whenever we switch roots.\nnestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,true,dl);}function performSyncWork(){performWork(Sync,false,null);}function performWork(minExpirationTime,isAsync,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach\n// the deadline.\nfindHighestPriorityRoot();if(enableProfilerTimer){resumeActualRenderTimerIfPaused();}if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();var timeout=expirationTimeToMs(nextFlushedExpirationTime);stopRequestCallbackTimer(didExpire,timeout);}if(isAsync){while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||minExpirationTime>=nextFlushedExpirationTime)&&(!deadlineDidExpire||recalculateCurrentTime()>=nextFlushedExpirationTime)){recalculateCurrentTime();performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,!deadlineDidExpire);findHighestPriorityRoot();}}else{while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||minExpirationTime>=nextFlushedExpirationTime)){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,false);findHighestPriorityRoot();}}// We're done flushing work. Either we ran out of time in this callback,\n// or there's no more work left with sufficient priority.\n// If we're inside a callback, set this to false since we just completed it.\nif(deadline!==null){callbackExpirationTime=NoWork;callbackID=null;}// If there's work left over, schedule a new callback.\nif(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.\ndeadline=null;deadlineDidExpire=false;finishRendering();}function flushRoot(root,expirationTime){!!isRendering?invariant(false,'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.'):void 0;// Perform work on root as if the given expiration time is the current time.\n// This has the effect of synchronously flushing all work up to and\n// including the given time.\nnextFlushedRoot=root;nextFlushedExpirationTime=expirationTime;performWorkOnRoot(root,expirationTime,false);// Flush any sync work that was scheduled by lifecycles\nperformSyncWork();finishRendering();}function finishRendering(){nestedUpdateCount=0;if(completedBatches!==null){var batches=completedBatches;completedBatches=null;for(var i=0;i<batches.length;i++){var batch=batches[i];try{batch._onComplete();}catch(error){if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}}if(hasUnhandledError){var error=unhandledError;unhandledError=null;hasUnhandledError=false;throw error;}}function performWorkOnRoot(root,expirationTime,isAsync){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.\nif(!isAsync){// Flush sync work.\nvar finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.\ncompleteRoot(root,finishedWork,expirationTime);}else{finishedWork=renderRoot(root,expirationTime,false);if(finishedWork!==null){// We've completed the root. Commit it.\ncompleteRoot(root,finishedWork,expirationTime);}}}else{// Flush async work.\nvar _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.\ncompleteRoot(root,_finishedWork,expirationTime);}else{_finishedWork=renderRoot(root,expirationTime,true);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time\n// before committing.\nif(!shouldYield()){// Still time left. Commit the root.\ncompleteRoot(root,_finishedWork,expirationTime);}else{// There's no time left. Mark this root as complete. We'll come\n// back and commit it later.\nroot.finishedWork=_finishedWork;if(enableProfilerTimer){// If we didn't finish, pause the \"actual\" render timer.\n// We'll restart it when we resume work.\npauseActualRenderTimerIfRunning();}}}}}isRendering=false;}function completeRoot(root,finishedWork,expirationTime){// Check if there's a batch that matches this expiration time.\nvar firstBatch=root.firstBatch;if(firstBatch!==null&&firstBatch._expirationTime<=expirationTime){if(completedBatches===null){completedBatches=[firstBatch];}else{completedBatches.push(firstBatch);}if(firstBatch._defer){// This root is blocked from committing by a batch. Unschedule it until\n// we receive another update.\nroot.finishedWork=finishedWork;root.remainingExpirationTime=NoWork;return;}}// Commit the root.\nroot.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed\n// during a timeout. This path is only hit for non-expired work.\nreturn false;}deadlineDidExpire=true;return true;}function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's\n// another update.\nnextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}function onBlock(remainingExpirationTime){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This root was blocked. Unschedule it until there's another update.\nnextFlushedRoot.remainingExpirationTime=remainingExpirationTime;}// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates(fn,a){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn(a);}finally{isUnbatchingUpdates=false;}}return fn(a);}// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync(fn,a){!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn,a);}finally{isBatchingUpdates=previousIsBatchingUpdates;performSyncWork();}}function interactiveUpdates$1(fn,a,b){if(isBatchingInteractiveUpdates){return fn(a,b);}// If there are any pending interactive updates, synchronously flush them.\n// This needs to happen before we read any handlers, because the effect of\n// the previous event may influence which handlers are called during\n// this event.\nif(!isBatchingUpdates&&!isRendering&&lowestPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.\nperformWork(lowestPendingInteractiveExpirationTime,false,null);lowestPendingInteractiveExpirationTime=NoWork;}var previousIsBatchingInteractiveUpdates=isBatchingInteractiveUpdates;var previousIsBatchingUpdates=isBatchingUpdates;isBatchingInteractiveUpdates=true;isBatchingUpdates=true;try{return fn(a,b);}finally{isBatchingInteractiveUpdates=previousIsBatchingInteractiveUpdates;isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}function flushInteractiveUpdates$1(){if(!isRendering&&lowestPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.\nperformWork(lowestPendingInteractiveExpirationTime,false,null);lowestPendingInteractiveExpirationTime=NoWork;}}function flushControlled(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,false,null);}}}// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\nvar didWarnAboutNestedUpdates=void 0;{didWarnAboutNestedUpdates=false;}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}function scheduleRootUpdate(current,element,expirationTime,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}var update=createUpdate(expirationTime);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){!(typeof callback==='function')?warning(false,'render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback):void 0;update.callback=callback;}enqueueUpdate(current,update,expirationTime);scheduleWork$1(current,expirationTime);return expirationTime;}function updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback){// TODO: If this is a nested container, this won't be the root.\nvar current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}return scheduleRootUpdate(current,element,expirationTime,callback);}function findHostInstance(component){var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Argument appears to not be a ReactComponent. Keys: %s',Object.keys(component));}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function createContainer(containerInfo,isAsync,hydrate){return createFiberRoot(containerInfo,isAsync,hydrate);}function updateContainer(element,container,parentComponent,callback){var current=container.current;var currentTime=recalculateCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,current);return updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback);}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.\nreturn null;}return _findFiberByHostInstance(instance);}}));}// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\nvar DOMRenderer=Object.freeze({updateContainerAtExpirationTime:updateContainerAtExpirationTime,createContainer:createContainer,updateContainer:updateContainer,flushRoot:flushRoot,requestWork:requestWork,computeUniqueAsyncExpiration:computeUniqueAsyncExpiration,batchedUpdates:batchedUpdates$1,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,syncUpdates:syncUpdates,interactiveUpdates:interactiveUpdates$1,flushInteractiveUpdates:flushInteractiveUpdates$1,flushControlled:flushControlled,flushSync:flushSync,getPublicRootInstance:getPublicRootInstance,findHostInstance:findHostInstance,findHostInstanceWithNoPortals:findHostInstanceWithNoPortals,injectIntoDevTools:injectIntoDevTools});function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.\nvar ReactVersion='16.4.1';// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\nvar topLevelUpdateWarnings=void 0;var warnOnInvalidCallback=void 0;var didWarnAboutUnstableCreatePortal=false;{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://fb.me/react-polyfills');}topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);if(hostInstance){!(hostInstance.parentNode===container)?warning(false,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.'):void 0;}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));!(!hasNonRootReactChild||isRootRenderedBySomeReact)?warning(false,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.'):void 0;!(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY')?warning(false,'render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.'):void 0;};warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){!(callback===null||typeof callback==='function')?warning(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback):void 0;};}injection$2.injectFiberControlledHostComponent(ReactDOMFiberComponent);function ReactBatch(root){var expirationTime=computeUniqueAsyncExpiration();this._expirationTime=expirationTime;this._root=root;this._next=null;this._callbacks=null;this._didComplete=false;this._hasChildren=false;this._children=null;this._defer=true;}ReactBatch.prototype.render=function(children){!this._defer?invariant(false,'batch.render: Cannot render a batch that already committed.'):void 0;this._hasChildren=true;this._children=children;var internalRoot=this._root._internalRoot;var expirationTime=this._expirationTime;var work=new ReactWork();updateContainerAtExpirationTime(children,internalRoot,null,expirationTime,work._onCommit);return work;};ReactBatch.prototype.then=function(onComplete){if(this._didComplete){onComplete();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onComplete);};ReactBatch.prototype.commit=function(){var internalRoot=this._root._internalRoot;var firstBatch=internalRoot.firstBatch;!(this._defer&&firstBatch!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;if(!this._hasChildren){// This batch is empty. Return.\nthis._next=null;this._defer=false;return;}var expirationTime=this._expirationTime;// Ensure this is the first batch in the list.\nif(firstBatch!==this){// This batch is not the earliest batch. We need to move it to the front.\n// Update its expiration time to be the expiration time of the earliest\n// batch, so that we can flush it without flushing the other batches.\nif(this._hasChildren){expirationTime=this._expirationTime=firstBatch._expirationTime;// Rendering this batch again ensures its children will be the final state\n// when we flush (updates are processed in insertion order: last\n// update wins).\n// TODO: This forces a restart. Should we print a warning?\nthis.render(this._children);}// Remove the batch from the list.\nvar previous=null;var batch=firstBatch;while(batch!==this){previous=batch;batch=batch._next;}!(previous!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;previous._next=batch._next;// Add it to the front.\nthis._next=firstBatch;firstBatch=internalRoot.firstBatch=this;}// Synchronously flush all the work up to this batch's expiration time.\nthis._defer=false;flushRoot(internalRoot,expirationTime);// Pop the batch from the list.\nvar next=this._next;this._next=null;firstBatch=internalRoot.firstBatch=next;// Append the next earliest batch's children to the update queue.\nif(firstBatch!==null&&firstBatch._hasChildren){firstBatch.render(firstBatch._children);}};ReactBatch.prototype._onComplete=function(){if(this._didComplete){return;}this._didComplete=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.\nfor(var i=0;i<callbacks.length;i++){var _callback=callbacks[i];_callback();}};function ReactWork(){this._callbacks=null;this._didCommit=false;// TODO: Avoid need to bind by replacing callbacks in the update queue with\n// list of Work objects.\nthis._onCommit=this._onCommit.bind(this);}ReactWork.prototype.then=function(onCommit){if(this._didCommit){onCommit();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onCommit);};ReactWork.prototype._onCommit=function(){if(this._didCommit){return;}this._didCommit=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.\nfor(var i=0;i<callbacks.length;i++){var _callback2=callbacks[i];!(typeof _callback2==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback2):void 0;_callback2();}};function ReactRoot(container,isAsync,hydrate){var root=createContainer(container,isAsync,hydrate);this._internalRoot=root;}ReactRoot.prototype.render=function(children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,null,work._onCommit);return work;};ReactRoot.prototype.unmount=function(callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(null,root,null,work._onCommit);return work;};ReactRoot.prototype.legacy_renderSubtreeIntoContainer=function(parentComponent,children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,parentComponent,work._onCommit);return work;};ReactRoot.prototype.createBatch=function(){var batch=new ReactBatch(this);var expirationTime=batch._expirationTime;var internalRoot=this._internalRoot;var firstBatch=internalRoot.firstBatch;if(firstBatch===null){internalRoot.firstBatch=batch;batch._next=null;}else{// Insert sorted by expiration time then insertion order\nvar insertAfter=null;var insertBefore=firstBatch;while(insertBefore!==null&&insertBefore._expirationTime<=expirationTime){insertAfter=insertBefore;insertBefore=insertBefore._next;}batch._next=insertBefore;if(insertAfter!==null){insertAfter._next=batch;}}return batch;};/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}injection$3.injectRenderer(DOMRenderer);var warnedAboutHydrateAPI=false;function legacyCreateRootFromDOMContainer(container,forceHydrate){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.\nif(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}// Legacy roots are not async by default.\nvar isAsync=false;return new ReactRoot(container,isAsync,shouldHydrate);}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){// TODO: Ensure all entry points contain this check\n!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{topLevelUpdateWarnings(container);}// TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n// member of intersection type.\" Whyyyyyy.\nvar root=container._reactRootContainer;if(!root){// Initial mount\nroot=container._reactRootContainer=legacyCreateRootFromDOMContainer(container,forceHydrate);if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root._internalRoot);originalCallback.call(instance);};}// Initial mount should not be batched.\nunbatchedUpdates(function(){if(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}});}else{if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root._internalRoot);_originalCallback.call(instance);};}// Update\nif(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}}return getPublicRootInstance(root._internalRoot);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument\nreturn createPortal$1(children,container,null,key);}var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;!warnedAboutRefsInRender?warning(false,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component'):void 0;owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}return findHostInstance(componentOrElement);},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);!!renderedByDifferentReact?warning(false,\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.'):void 0;}// Unmount should not be batched.\nunbatchedUpdates(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;!!hasNonRootReactChild?warning(false,\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.'):void 0;}return false;}},// Temporary alias since we already shipped React 16 RC with it.\n// TODO: remove in React 17.\nunstable_createPortal:function unstable_createPortal(){if(!didWarnAboutUnstableCreatePortal){didWarnAboutUnstableCreatePortal=true;lowPriorityWarning$1(false,'The ReactDOM.unstable_createPortal() alias has been deprecated, '+'and will be removed in React 17+. Update your code to use '+'ReactDOM.createPortal() instead. It has the exact same API, '+'but without the \"unstable_\" prefix.');}return createPortal.apply(undefined,arguments);},unstable_batchedUpdates:batchedUpdates$1,unstable_deferredUpdates:deferredUpdates,unstable_interactiveUpdates:interactiveUpdates$1,flushSync:flushSync,unstable_flushControlled:flushControlled,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source\nEventPluginHub:EventPluginHub,// Used by test-utils\nEventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};ReactDOM.unstable_createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,true,hydrate);};var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom=ReactDOM$3.default?ReactDOM$3.default:ReactDOM$3;module.exports=reactDom;})();}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzPzM4MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi40LjFcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gaGF2ZSBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbiFSZWFjdCA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uJykgOiB2b2lkIDA7XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gIH1cbn07XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW50aW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcblxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCBkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgc2NoZWR1bGVzIGFuIHVwZGF0ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFjaywgYnV0IHRoZSB0ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCB0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgY2FuY2VsZWQgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YCksIG9yIHlvdSBjYW4gY2hhbmdlIHRoZSB0ZXN0IGl0c2VsZiB0byBiZSBhc3luY2hyb25vdXMuJykgOiB2b2lkIDA7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IGludm9rZUd1YXJkZWRDYWxsYmFjaztcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICAgKlxuICAgKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gICAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICAgKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDEgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgIShnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUpID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZyhmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudHMgIT09IG51bGwpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbixcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRydW5FdmVudHNJbkJhdGNoOiBydW5FdmVudHNJbkJhdGNoLFxuXHRydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoOiBydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG5cblxuXG52YXIgRnJhZ21lbnQgPSAxMDtcbnZhciBNb2RlID0gMTE7XG52YXIgQ29udGV4dENvbnN1bWVyID0gMTI7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTM7XG52YXIgRm9yd2FyZFJlZiA9IDE0O1xudmFyIFByb2ZpbGVyID0gMTU7XG52YXIgVGltZW91dENvbXBvbmVudCA9IDE2O1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wc1xufSk7XG5cbmZ1bmN0aW9uIGdldFBhcmVudChpbnN0KSB7XG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47XG4gICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gZ2V0UGFyZW50KHRlbXBBKSkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0QiB8fCBpbnN0QSA9PT0gaW5zdEIuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICByZXR1cm4gZ2V0UGFyZW50KGluc3QpO1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBnZXRQYXJlbnQoaW5zdCk7XG4gIH1cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZnJvbSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZyb20uYWx0ZXJuYXRlO1xuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBnZXRQYXJlbnQoZnJvbSk7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBfYWx0ZXJuYXRlID0gdG8uYWx0ZXJuYXRlO1xuICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIF9hbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IGdldFBhcmVudCh0byk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAodmFyIF9pID0gcGF0aFRvLmxlbmd0aDsgX2ktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW19pXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICAhaW5zdCA/IHdhcm5pbmcoZmFsc2UsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IGdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG5cdGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNcbn0pO1xuXG4vLyBEbyBub3QgdXNlcyB0aGUgYmVsb3cgdHdvIG1ldGhvZHMgZGlyZWN0bHkhXG4vLyBJbnN0ZWFkIHVzZSBjb25zdGFudHMgZXhwb3J0ZWQgZnJvbSBET01Ub3BMZXZlbEV2ZW50VHlwZXMgaW4gUmVhY3RET00uXG4vLyAoSXQgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlc2UgbWV0aG9kcy4pXG5cbmZ1bmN0aW9uIHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZTtcbn1cblxuZnVuY3Rpb24gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxuLyoqXG4gKiBUbyBpZGVudGlmeSB0b3AgbGV2ZWwgZXZlbnRzIGluIFJlYWN0RE9NLCB3ZSB1c2UgY29uc3RhbnRzIGRlZmluZWQgYnkgdGhpc1xuICogbW9kdWxlLiBUaGlzIGlzIHRoZSBvbmx5IG1vZHVsZSB0aGF0IHVzZXMgdGhlIHVuc2FmZSogbWV0aG9kcyB0byBleHByZXNzXG4gKiB0aGF0IHRoZSBjb25zdGFudHMgYWN0dWFsbHkgY29ycmVzcG9uZCB0byB0aGUgYnJvd3NlciBldmVudCBuYW1lcy4gVGhpcyBsZXRzXG4gKiB1cyBzYXZlIHNvbWUgYnVuZGxlIHNpemUgYnkgYXZvaWRpbmcgYSB0b3AgbGV2ZWwgdHlwZSAtPiBldmVudCBuYW1lIG1hcC5cbiAqIFRoZSByZXN0IG9mIFJlYWN0RE9NIGNvZGUgc2hvdWxkIGltcG9ydCB0b3AgbGV2ZWwgdHlwZXMgZnJvbSB0aGlzIGZpbGUuXG4gKi9cbnZhciBUT1BfQUJPUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Fib3J0Jyk7XG52YXIgVE9QX0FOSU1BVElPTl9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpKTtcbnZhciBUT1BfQU5JTUFUSU9OX0lURVJBVElPTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykpO1xudmFyIFRPUF9BTklNQVRJT05fU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykpO1xudmFyIFRPUF9CTFVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdibHVyJyk7XG52YXIgVE9QX0NBTl9QTEFZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5wbGF5Jyk7XG52YXIgVE9QX0NBTl9QTEFZX1RIUk9VR0ggPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NhbnBsYXl0aHJvdWdoJyk7XG52YXIgVE9QX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FuY2VsJyk7XG52YXIgVE9QX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2hhbmdlJyk7XG52YXIgVE9QX0NMSUNLID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjbGljaycpO1xudmFyIFRPUF9DTE9TRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2xvc2UnKTtcbnZhciBUT1BfQ09NUE9TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb21wb3NpdGlvbmVuZCcpO1xudmFyIFRPUF9DT01QT1NJVElPTl9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29tcG9zaXRpb25zdGFydCcpO1xudmFyIFRPUF9DT01QT1NJVElPTl9VUERBVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbXBvc2l0aW9udXBkYXRlJyk7XG52YXIgVE9QX0NPTlRFWFRfTUVOVSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29udGV4dG1lbnUnKTtcbnZhciBUT1BfQ09QWSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29weScpO1xudmFyIFRPUF9DVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2N1dCcpO1xudmFyIFRPUF9ET1VCTEVfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RibGNsaWNrJyk7XG52YXIgVE9QX0RSQUcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWcnKTtcbnZhciBUT1BfRFJBR19FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdlbmQnKTtcbnZhciBUT1BfRFJBR19FTlRFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2VudGVyJyk7XG52YXIgVE9QX0RSQUdfRVhJVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2V4aXQnKTtcbnZhciBUT1BfRFJBR19MRUFWRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2xlYXZlJyk7XG52YXIgVE9QX0RSQUdfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ292ZXInKTtcbnZhciBUT1BfRFJBR19TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ3N0YXJ0Jyk7XG52YXIgVE9QX0RST1AgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Ryb3AnKTtcbnZhciBUT1BfRFVSQVRJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkdXJhdGlvbmNoYW5nZScpO1xudmFyIFRPUF9FTVBUSUVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbXB0aWVkJyk7XG52YXIgVE9QX0VOQ1JZUFRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5jcnlwdGVkJyk7XG52YXIgVE9QX0VOREVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbmRlZCcpO1xudmFyIFRPUF9FUlJPUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZXJyb3InKTtcbnZhciBUT1BfRk9DVVMgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2ZvY3VzJyk7XG52YXIgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2dvdHBvaW50ZXJjYXB0dXJlJyk7XG52YXIgVE9QX0lOUFVUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnB1dCcpO1xudmFyIFRPUF9JTlZBTElEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnZhbGlkJyk7XG52YXIgVE9QX0tFWV9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXlkb3duJyk7XG52YXIgVE9QX0tFWV9QUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5cHJlc3MnKTtcbnZhciBUT1BfS0VZX1VQID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXl1cCcpO1xudmFyIFRPUF9MT0FEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2FkJyk7XG52YXIgVE9QX0xPQURfU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRzdGFydCcpO1xudmFyIFRPUF9MT0FERURfREFUQSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZGVkZGF0YScpO1xudmFyIFRPUF9MT0FERURfTUVUQURBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZG1ldGFkYXRhJyk7XG52YXIgVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb3N0cG9pbnRlcmNhcHR1cmUnKTtcbnZhciBUT1BfTU9VU0VfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2Vkb3duJyk7XG52YXIgVE9QX01PVVNFX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlbW92ZScpO1xudmFyIFRPUF9NT1VTRV9PVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3V0Jyk7XG52YXIgVE9QX01PVVNFX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3ZlcicpO1xudmFyIFRPUF9NT1VTRV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2V1cCcpO1xudmFyIFRPUF9QQVNURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGFzdGUnKTtcbnZhciBUT1BfUEFVU0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BhdXNlJyk7XG52YXIgVE9QX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXknKTtcbnZhciBUT1BfUExBWUlORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGxheWluZycpO1xudmFyIFRPUF9QT0lOVEVSX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcmNhbmNlbCcpO1xudmFyIFRPUF9QT0lOVEVSX0RPV04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJkb3duJyk7XG5cblxudmFyIFRPUF9QT0lOVEVSX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJtb3ZlJyk7XG52YXIgVE9QX1BPSU5URVJfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyb3V0Jyk7XG52YXIgVE9QX1BPSU5URVJfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcm92ZXInKTtcbnZhciBUT1BfUE9JTlRFUl9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcnVwJyk7XG52YXIgVE9QX1BST0dSRVNTID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwcm9ncmVzcycpO1xudmFyIFRPUF9SQVRFX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmF0ZWNoYW5nZScpO1xudmFyIFRPUF9SRVNFVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmVzZXQnKTtcbnZhciBUT1BfU0NST0xMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzY3JvbGwnKTtcbnZhciBUT1BfU0VFS0VEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWVrZWQnKTtcbnZhciBUT1BfU0VFS0lORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2luZycpO1xudmFyIFRPUF9TRUxFQ1RJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWxlY3Rpb25jaGFuZ2UnKTtcbnZhciBUT1BfU1RBTExFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3RhbGxlZCcpO1xudmFyIFRPUF9TVUJNSVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N1Ym1pdCcpO1xudmFyIFRPUF9TVVNQRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdXNwZW5kJyk7XG52YXIgVE9QX1RFWFRfSU5QVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RleHRJbnB1dCcpO1xudmFyIFRPUF9USU1FX1VQREFURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndGltZXVwZGF0ZScpO1xudmFyIFRPUF9UT0dHTEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvZ2dsZScpO1xudmFyIFRPUF9UT1VDSF9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNoY2FuY2VsJyk7XG52YXIgVE9QX1RPVUNIX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hlbmQnKTtcbnZhciBUT1BfVE9VQ0hfTU9WRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2htb3ZlJyk7XG52YXIgVE9QX1RPVUNIX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaHN0YXJ0Jyk7XG52YXIgVE9QX1RSQU5TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykpO1xudmFyIFRPUF9WT0xVTUVfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd2b2x1bWVjaGFuZ2UnKTtcbnZhciBUT1BfV0FJVElORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2FpdGluZycpO1xudmFyIFRPUF9XSEVFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2hlZWwnKTtcblxuLy8gTGlzdCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIGluZGl2aWR1YWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50cy5cbi8vIE5vdGUgdGhhdCBldmVudHMgaW4gdGhpcyBsaXN0IHdpbGwgKm5vdCogYmUgbGlzdGVuZWQgdG8gYXQgdGhlIHRvcCBsZXZlbFxuLy8gdW5sZXNzIHRoZXkncmUgZXhwbGljaXRseSB3aGl0ZWxpc3RlZCBpbiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvYC5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbVE9QX0FCT1JULCBUT1BfQ0FOX1BMQVksIFRPUF9DQU5fUExBWV9USFJPVUdILCBUT1BfRFVSQVRJT05fQ0hBTkdFLCBUT1BfRU1QVElFRCwgVE9QX0VOQ1JZUFRFRCwgVE9QX0VOREVELCBUT1BfRVJST1IsIFRPUF9MT0FERURfREFUQSwgVE9QX0xPQURFRF9NRVRBREFUQSwgVE9QX0xPQURfU1RBUlQsIFRPUF9QQVVTRSwgVE9QX1BMQVksIFRPUF9QTEFZSU5HLCBUT1BfUFJPR1JFU1MsIFRPUF9SQVRFX0NIQU5HRSwgVE9QX1NFRUtFRCwgVE9QX1NFRUtJTkcsIFRPUF9TVEFMTEVELCBUT1BfU1VTUEVORCwgVE9QX1RJTUVfVVBEQVRFLCBUT1BfVk9MVU1FX0NIQU5HRSwgVE9QX1dBSVRJTkddO1xuXG5mdW5jdGlvbiBnZXRSYXdFdmVudE5hbWUodG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmcodG9wTGV2ZWxUeXBlKTtcbn1cblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICovXG5TeW50aGV0aWNFdmVudC5leHRlbmQgPSBmdW5jdGlvbiAoSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIGZ1bmN0aW9uIENsYXNzKCkge1xuICAgIHJldHVybiBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG5cbiAgcmV0dXJuIENsYXNzO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIHZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nICYmXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTIwMTFcbiAgIU9iamVjdC5pc1NlYWxlZChuZXcgUHJveHkoe30sIHt9KSk7XG5cbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAhKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSkgPyB3YXJuaW5nKGZhbHNlLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmcoZmFsc2UsIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG52YXIgU3ludGhldGljRXZlbnQkMSA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0NPTVBPU0lUSU9OX0VORCwgVE9QX0tFWV9QUkVTUywgVE9QX1RFWFRfSU5QVVQsIFRPUF9QQVNURV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fRU5ELCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9TVEFSVCwgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1BSRVNTLCBUT1BfS0VZX1VQLCBUT1BfTU9VU0VfRE9XTl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fVVBEQVRFLCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9FTkQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX0RPV04gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGUgPSB2b2lkIDA7XG4gIHZhciBmYWxsYmFja0RhdGEgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGV9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxUeXBlYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgVE9QX1RFWFRfSU5QVVQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsRXZlbnRUeXBlc2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NPTVBPU0lUSU9OX0VORCB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfUEFTVEU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycyA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgY29tcG9zaXRpb24gPSBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICB2YXIgYmVmb3JlSW5wdXQgPSBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBpZiAoY29tcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBiZWZvcmVJbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlSW5wdXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW2NvbXBvc2l0aW9uLCBiZWZvcmVJbnB1dF07XG4gIH1cbn07XG5cbi8vIFVzZSB0byByZXN0b3JlIGNvbnRyb2xsZWQgc3RhdGUgYWZ0ZXIgYSBjaGFuZ2UgZXZlbnQgaGFzIGZpcmVkLlxuXG52YXIgZmliZXJIb3N0Q29tcG9uZW50ID0gbnVsbDtcblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDogZnVuY3Rpb24gKGhvc3RDb21wb25lbnRJbXBsKSB7XG4gICAgLy8gVGhlIGZpYmVyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdXNlIGR5bmFtaWMgZGlzcGF0Y2ggc28gd2UgbmVlZCB0b1xuICAgIC8vIGluamVjdCB0aGUgaW1wbGVtZW50YXRpb24uXG4gICAgZmliZXJIb3N0Q29tcG9uZW50ID0gaG9zdENvbXBvbmVudEltcGw7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgIShmaWJlckhvc3RDb21wb25lbnQgJiYgdHlwZW9mIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ZpYmVyIG5lZWRzIHRvIGJlIGluamVjdGVkIHRvIGhhbmRsZSBhIGZpYmVyIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbnZhciBpbmplY3Rpb24kMiA9IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbjtcblxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpIHtcbiAgaWYgKCFyZXN0b3JlVGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDIsXG5cdGVucXVldWVTdGF0ZVJlc3RvcmU6IGVucXVldWVTdGF0ZVJlc3RvcmUsXG5cdG5lZWRzU3RhdGVSZXN0b3JlOiBuZWVkc1N0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgX2JhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcbnZhciBfaW50ZXJhY3RpdmVVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhLCBiKSB7XG4gIHJldHVybiBmbihhLCBiKTtcbn07XG52YXIgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBpc0JhdGNoaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzQmF0Y2hpbmcpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzQmF0Y2hpbmcgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBfYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG4gICAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuICAgICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlcygpO1xuICAgICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIHJldHVybiBfaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKTtcbn1cblxuXG5cbnZhciBpbmplY3Rpb24kMyA9IHtcbiAgaW5qZWN0UmVuZGVyZXI6IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgIF9iYXRjaGVkVXBkYXRlcyA9IHJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzO1xuICAgIF9pbnRlcmFjdGl2ZVVwZGF0ZXMgPSByZW5kZXJlci5pbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gICAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzID0gcmVuZGVyZXIuZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gIH1cbn07XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgLy8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbiAgLy8gYnV0IGl0IHRyaWdnZXJzIGEgYnVnIGluIElFMTEgYW5kIEVkZ2UgMTQvMTUuXG4gIC8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUmVhY3RJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfVElNRU9VVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QudGltZW91dCcpIDogMHhlYWQxO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdBc3luY01vZGUnO1xuICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0RnJhZ21lbnQnO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1JlYWN0UG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyKCcgKyBmaWJlci5wZW5kaW5nUHJvcHMuaWQgKyAnKSc7XG4gICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgcmV0dXJuICdDb250ZXh0LlByb3ZpZGVyJztcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgIGNhc2UgUkVBQ1RfVElNRU9VVF9UWVBFOlxuICAgICAgcmV0dXJuICdUaW1lb3V0JztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMVxufTtcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcblxuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsXG4vLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsXG4vLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuWydjaGVja2VkJyxcbi8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbiddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCB3aGl0ZWxpc3QuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcHBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG59KTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScpO1xufSk7XG5cbi8vIFNwZWNpYWwgY2FzZTogdGhpcyBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gSXRzIFwidGFiaW5kZXhcIiBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIGl0cyBSZWFjdCBgdGFiSW5kZXhgIG5hbWUsIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5wcm9wZXJ0aWVzLnRhYkluZGV4ID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgndGFiSW5kZXgnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid0YWJpbmRleCcsIC8vIGF0dHJpYnV0ZU5hbWVcbm51bGwpO1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvKSB7XG4gIHtcbiAgICBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOKSB7XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgcHJvcGVydHlJbmZvID09PSBudWxsKSB7XG4gICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHZhciBfYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0gPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsID8gJycgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBnZXRTYWZlVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIF9jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIV9jb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuXG4gIHZhciB2YWx1ZSA9IGdldFNhZmVWYWx1ZShwcm9wcy52YWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJyB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0U2FmZVZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICB9XG5cbiAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcywgaXNIeWRyYXRpbmcpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgX2luaXRpYWxWYWx1ZSA9ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gbm9kZS52YWx1ZTtcblxuICAgIC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIC8vIERvIG5vdCByZS1hc3NpZ24gdGhlIHZhbHVlIHByb3BlcnR5IGlmIHRoZXJlIGlzIG5vIGNoYW5nZS4gVGhpc1xuICAgICAgLy8gcG90ZW50aWFsbHkgYXZvaWRzIGEgRE9NIHdyaXRlIGFuZCBwcmV2ZW50cyBGaXJlZm94ICh+NjAuMC4xKSBmcm9tXG4gICAgICAvLyBwcmVtYXR1cmVseSBtYXJraW5nIHJlcXVpcmVkIGlucHV0cyBhcyBpbnZhbGlkXG4gICAgICBpZiAoX2luaXRpYWxWYWx1ZSAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBfaW5pdGlhbFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHZhbHVlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGRlZmF1bHRWYWx1ZS4gVGhpcyBmaXhlcyBhbiBpc3N1ZSB3aGVyZSB0aGVcbiAgICAvLyB2aXN1YWxseSBkaXNwbGF5ZWQgdmFsdWUgb2YgZGF0ZSBpbnB1dHMgZGlzYXBwZWFycyBvbiBtb2JpbGUgU2FmYXJpIGFuZCBDaHJvbWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBfaW5pdGlhbFZhbHVlO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbi8vXG4vLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChcbiAgLy8gRm9jdXNlZCBudW1iZXIgaW5wdXRzIHN5bmNocm9uaXplIG9uIGJsdXIuIFNlZSBDaGFuZ2VFdmVudFBsdWdpbi5qc1xuICB0eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNhZmVWYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DSEFOR0UsIFRPUF9DTElDSywgVE9QX0ZPQ1VTLCBUT1BfSU5QVVQsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnQsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NIQU5HRSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0ZPQ1VTKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0JMVVIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9TRUxFQ1RJT05fQ0hBTkdFIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0tFWV9VUCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfRE9XTikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQ0xJQ0spIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9JTlBVVCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9DSEFOR0UpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gdm9pZCAwLFxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSB2b2lkIDA7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0JMVVIpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRE9NRXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnVGFwRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufSk7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIHBhZ2VYOiBudWxsLFxuICBwYWdlWTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgcG9pbnRlcklkOiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICBwcmVzc3VyZTogbnVsbCxcbiAgdGlsdFg6IG51bGwsXG4gIHRpbHRZOiBudWxsLFxuICBwb2ludGVyVHlwZTogbnVsbCxcbiAgaXNQcmltYXJ5OiBudWxsXG59KTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9NT1VTRV9PVVQsIFRPUF9NT1VTRV9PVkVSXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX01PVVNFX09VVCwgVE9QX01PVVNFX09WRVJdXG4gIH0sXG4gIHBvaW50ZXJFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvblBvaW50ZXJFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX1BPSU5URVJfT1VULCBUT1BfUE9JTlRFUl9PVkVSXVxuICB9LFxuICBwb2ludGVyTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl1cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgaXNPdmVyRXZlbnQgPSB0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVkVSIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1ZFUjtcbiAgICB2YXIgaXNPdXRFdmVudCA9IHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09VVCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09VVDtcblxuICAgIGlmIChpc092ZXJFdmVudCAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW4gPSB2b2lkIDA7XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IHZvaWQgMDtcbiAgICB2YXIgdG8gPSB2b2lkIDA7XG4gICAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SW50ZXJmYWNlID0gdm9pZCAwLFxuICAgICAgICBsZWF2ZUV2ZW50VHlwZSA9IHZvaWQgMCxcbiAgICAgICAgZW50ZXJFdmVudFR5cGUgPSB2b2lkIDAsXG4gICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHZvaWQgMDtcblxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgbGVhdmVFdmVudFR5cGUgPSBldmVudFR5cGVzJDIubW91c2VMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLm1vdXNlRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVkVSKSB7XG4gICAgICBldmVudEludGVyZmFjZSA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudDtcbiAgICAgIGxlYXZlRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJFbnRlcjtcbiAgICAgIGV2ZW50VHlwZVByZWZpeCA9ICdwb2ludGVyJztcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKGxlYXZlRXZlbnRUeXBlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBldmVudEludGVyZmFjZS5nZXRQb29sZWQoZW50ZXJFdmVudFR5cGUsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjU2O1xuXG4vLyBVbmlvbiBvZiBhbGwgaG9zdCBlZmZlY3RzXG52YXIgSG9zdEVmZmVjdE1hc2sgPSAvKiAgICAgICAgKi81MTE7XG5cbnZhciBJbmNvbXBsZXRlID0gLyogICAgICAgICAgICAqLzUxMjtcbnZhciBTaG91bGRDYXB0dXJlID0gLyogICAgICAgICAqLzEwMjQ7XG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gTU9VTlRFRDtcbiAgfVxuICAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gIHJldHVybiBVTk1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAhaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgJiYgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcihlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmV4dGVuZCh7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59KTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGUgPSB2b2lkIDA7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIElFIGFuZCBFZGdlIChvbiBXaW5kb3dzKSBhbmQgQ2hyb21lIC8gU2FmYXJpIChvbiBXaW5kb3dzIGFuZCBMaW51eClcbiAgLy8gcmVwb3J0IEVudGVyIGFzIGNoYXJDb2RlIDEwIHdoZW4gY3RybCBpcyBwcmVzc2VkLlxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZXh0ZW5kKHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG5cbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59KTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQUJPUlRdLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSBuZXcgTWFwKFtcbiAqICAgW1RPUF9BQk9SVCwgeyBzYW1lQ29uZmlnIH1dLFxuICogXSk7XG4gKi9cblxudmFyIGludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMgPSBbW1RPUF9CTFVSLCAnYmx1ciddLCBbVE9QX0NBTkNFTCwgJ2NhbmNlbCddLCBbVE9QX0NMSUNLLCAnY2xpY2snXSwgW1RPUF9DTE9TRSwgJ2Nsb3NlJ10sIFtUT1BfQ09OVEVYVF9NRU5VLCAnY29udGV4dE1lbnUnXSwgW1RPUF9DT1BZLCAnY29weSddLCBbVE9QX0NVVCwgJ2N1dCddLCBbVE9QX0RPVUJMRV9DTElDSywgJ2RvdWJsZUNsaWNrJ10sIFtUT1BfRFJBR19FTkQsICdkcmFnRW5kJ10sIFtUT1BfRFJBR19TVEFSVCwgJ2RyYWdTdGFydCddLCBbVE9QX0RST1AsICdkcm9wJ10sIFtUT1BfRk9DVVMsICdmb2N1cyddLCBbVE9QX0lOUFVULCAnaW5wdXQnXSwgW1RPUF9JTlZBTElELCAnaW52YWxpZCddLCBbVE9QX0tFWV9ET1dOLCAna2V5RG93biddLCBbVE9QX0tFWV9QUkVTUywgJ2tleVByZXNzJ10sIFtUT1BfS0VZX1VQLCAna2V5VXAnXSwgW1RPUF9NT1VTRV9ET1dOLCAnbW91c2VEb3duJ10sIFtUT1BfTU9VU0VfVVAsICdtb3VzZVVwJ10sIFtUT1BfUEFTVEUsICdwYXN0ZSddLCBbVE9QX1BBVVNFLCAncGF1c2UnXSwgW1RPUF9QTEFZLCAncGxheSddLCBbVE9QX1BPSU5URVJfQ0FOQ0VMLCAncG9pbnRlckNhbmNlbCddLCBbVE9QX1BPSU5URVJfRE9XTiwgJ3BvaW50ZXJEb3duJ10sIFtUT1BfUE9JTlRFUl9VUCwgJ3BvaW50ZXJVcCddLCBbVE9QX1JBVEVfQ0hBTkdFLCAncmF0ZUNoYW5nZSddLCBbVE9QX1JFU0VULCAncmVzZXQnXSwgW1RPUF9TRUVLRUQsICdzZWVrZWQnXSwgW1RPUF9TVUJNSVQsICdzdWJtaXQnXSwgW1RPUF9UT1VDSF9DQU5DRUwsICd0b3VjaENhbmNlbCddLCBbVE9QX1RPVUNIX0VORCwgJ3RvdWNoRW5kJ10sIFtUT1BfVE9VQ0hfU1RBUlQsICd0b3VjaFN0YXJ0J10sIFtUT1BfVk9MVU1FX0NIQU5HRSwgJ3ZvbHVtZUNoYW5nZSddXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQUJPUlQsICdhYm9ydCddLCBbVE9QX0FOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnXSwgW1RPUF9BTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJ10sIFtUT1BfQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnXSwgW1RPUF9DQU5fUExBWSwgJ2NhblBsYXknXSwgW1RPUF9DQU5fUExBWV9USFJPVUdILCAnY2FuUGxheVRocm91Z2gnXSwgW1RPUF9EUkFHLCAnZHJhZyddLCBbVE9QX0RSQUdfRU5URVIsICdkcmFnRW50ZXInXSwgW1RPUF9EUkFHX0VYSVQsICdkcmFnRXhpdCddLCBbVE9QX0RSQUdfTEVBVkUsICdkcmFnTGVhdmUnXSwgW1RPUF9EUkFHX09WRVIsICdkcmFnT3ZlciddLCBbVE9QX0RVUkFUSU9OX0NIQU5HRSwgJ2R1cmF0aW9uQ2hhbmdlJ10sIFtUT1BfRU1QVElFRCwgJ2VtcHRpZWQnXSwgW1RPUF9FTkNSWVBURUQsICdlbmNyeXB0ZWQnXSwgW1RPUF9FTkRFRCwgJ2VuZGVkJ10sIFtUT1BfRVJST1IsICdlcnJvciddLCBbVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUsICdnb3RQb2ludGVyQ2FwdHVyZSddLCBbVE9QX0xPQUQsICdsb2FkJ10sIFtUT1BfTE9BREVEX0RBVEEsICdsb2FkZWREYXRhJ10sIFtUT1BfTE9BREVEX01FVEFEQVRBLCAnbG9hZGVkTWV0YWRhdGEnXSwgW1RPUF9MT0FEX1NUQVJULCAnbG9hZFN0YXJ0J10sIFtUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUsICdsb3N0UG9pbnRlckNhcHR1cmUnXSwgW1RPUF9NT1VTRV9NT1ZFLCAnbW91c2VNb3ZlJ10sIFtUT1BfTU9VU0VfT1VULCAnbW91c2VPdXQnXSwgW1RPUF9NT1VTRV9PVkVSLCAnbW91c2VPdmVyJ10sIFtUT1BfUExBWUlORywgJ3BsYXlpbmcnXSwgW1RPUF9QT0lOVEVSX01PVkUsICdwb2ludGVyTW92ZSddLCBbVE9QX1BPSU5URVJfT1VULCAncG9pbnRlck91dCddLCBbVE9QX1BPSU5URVJfT1ZFUiwgJ3BvaW50ZXJPdmVyJ10sIFtUT1BfUFJPR1JFU1MsICdwcm9ncmVzcyddLCBbVE9QX1NDUk9MTCwgJ3Njcm9sbCddLCBbVE9QX1NFRUtJTkcsICdzZWVraW5nJ10sIFtUT1BfU1RBTExFRCwgJ3N0YWxsZWQnXSwgW1RPUF9TVVNQRU5ELCAnc3VzcGVuZCddLCBbVE9QX1RJTUVfVVBEQVRFLCAndGltZVVwZGF0ZSddLCBbVE9QX1RPR0dMRSwgJ3RvZ2dsZSddLCBbVE9QX1RPVUNIX01PVkUsICd0b3VjaE1vdmUnXSwgW1RPUF9UUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnXSwgW1RPUF9XQUlUSU5HLCAnd2FpdGluZyddLCBbVE9QX1dIRUVMLCAnd2hlZWwnXV07XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKF9yZWYsIGlzSW50ZXJhY3RpdmUpIHtcbiAgdmFyIHRvcEV2ZW50ID0gX3JlZlswXSxcbiAgICAgIGV2ZW50ID0gX3JlZlsxXTtcblxuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF0sXG4gICAgaXNJbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59XG5cbmludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgdHJ1ZSk7XG59KTtcbm5vbkludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgZmFsc2UpO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFtUT1BfQUJPUlQsIFRPUF9DQU5DRUwsIFRPUF9DQU5fUExBWSwgVE9QX0NBTl9QTEFZX1RIUk9VR0gsIFRPUF9DTE9TRSwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfSU5QVVQsIFRPUF9JTlZBTElELCBUT1BfTE9BRCwgVE9QX0xPQURFRF9EQVRBLCBUT1BfTE9BREVEX01FVEFEQVRBLCBUT1BfTE9BRF9TVEFSVCwgVE9QX1BBVVNFLCBUT1BfUExBWSwgVE9QX1BMQVlJTkcsIFRPUF9QUk9HUkVTUywgVE9QX1JBVEVfQ0hBTkdFLCBUT1BfUkVTRVQsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVQk1JVCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1RPR0dMRSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIHJldHVybiBjb25maWcgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuaXNJbnRlcmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgfSxcblxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ0xJQ0s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfRE9VQkxFX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICAgIGNhc2UgVE9QX01PVVNFX01PVkU6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9VUDpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVE9QX01PVVNFX09VVDpcbiAgICAgIGNhc2UgVE9QX01PVVNFX09WRVI6XG4gICAgICBjYXNlIFRPUF9DT05URVhUX01FTlU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0RSQUc6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5URVI6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VYSVQ6XG4gICAgICBjYXNlIFRPUF9EUkFHX0xFQVZFOlxuICAgICAgY2FzZSBUT1BfRFJBR19PVkVSOlxuICAgICAgY2FzZSBUT1BfRFJBR19TVEFSVDpcbiAgICAgIGNhc2UgVE9QX0RST1A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfVE9VQ0hfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfRU5EOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfTU9WRTpcbiAgICAgIGNhc2UgVE9QX1RPVUNIX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9BTklNQVRJT05fRU5EOlxuICAgICAgY2FzZSBUT1BfQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgIGNhc2UgVE9QX0FOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1RSQU5TSVRJT05fRU5EOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1NDUk9MTDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfV0hFRUw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPUFk6XG4gICAgICBjYXNlIFRPUF9DVVQ6XG4gICAgICBjYXNlIFRPUF9QQVNURTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkU6XG4gICAgICBjYXNlIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRTpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9ET1dOOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9NT1ZFOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9PVVQ6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX09WRVI6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX1VQOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnZhciBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUgPSBTaW1wbGVFdmVudFBsdWdpbi5pc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU7XG5cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QucmV0dXJuKSB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2goYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICBkaXNwYXRjaC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGdldFJhd0V2ZW50TmFtZSh0b3BMZXZlbFR5cGUpLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb3VudEF0IENvbnRhaW5lciB3aGVyZSB0byBtb3VudCB0aGUgbGlzdGVuZXJcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHN3aXRjaCAoZGVwZW5kZW5jeSkge1xuICAgICAgICBjYXNlIFRPUF9TQ1JPTEw6XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX1NDUk9MTCwgbW91bnRBdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9GT0NVUywgbW91bnRBdCk7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX0JMVVIsIG1vdW50QXQpO1xuICAgICAgICAgIC8vIFdlIHNldCB0aGUgZmxhZyBmb3IgYSBzaW5nbGUgZGVwZW5kZW5jeSBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIGVuc3VyZXMgd2UgbWFyayBib3RoIGFzIGF0dGFjaGVkIHJhdGhlciB0aGFuIGp1c3Qgb25lLlxuICAgICAgICAgIGlzTGlzdGVuaW5nW1RPUF9CTFVSXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbVE9QX0ZPQ1VTXSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0NBTkNFTDpcbiAgICAgICAgY2FzZSBUT1BfQ0xPU0U6XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoZ2V0UmF3RXZlbnROYW1lKGRlcGVuZGVuY3kpLCB0cnVlKSkge1xuICAgICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9JTlZBTElEOlxuICAgICAgICBjYXNlIFRPUF9TVUJNSVQ6XG4gICAgICAgIGNhc2UgVE9QX1JFU0VUOlxuICAgICAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVtIG9uIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnRzLlxuICAgICAgICAgIC8vIFNvbWUgb2YgdGhlbSBidWJibGUgc28gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGZpcmUgdHdpY2UuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgbGlzdGVuIG9uIHRoZSB0b3AgbGV2ZWwgdG8gYWxsIG5vbi1tZWRpYSBldmVudHMuXG4gICAgICAgICAgLy8gTWVkaWEgZXZlbnRzIGRvbid0IGJ1YmJsZSBzbyBhZGRpbmcgdGhlIGxpc3RlbmVyIHdvdWxkbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAgIHZhciBpc01lZGlhRXZlbnQgPSBtZWRpYUV2ZW50VHlwZXMuaW5kZXhPZihkZXBlbmRlbmN5KSAhPT0gLTE7XG4gICAgICAgICAgaWYgKCFpc01lZGlhRXZlbnQpIHtcbiAgICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuXG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBlbGVtLnR5cGUgPT09ICdzZWFyY2gnIHx8IGVsZW0udHlwZSA9PT0gJ3RlbCcgfHwgZWxlbS50eXBlID09PSAndXJsJyB8fCBlbGVtLnR5cGUgPT09ICdwYXNzd29yZCcpIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKHByaW9yU2VsZWN0aW9uUmFuZ2UgIT09IG51bGwgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBzZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShpbnB1dCkge1xuICB2YXIgc2VsZWN0aW9uID0gdm9pZCAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0gZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydCxcbiAgICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09OVEVYVF9NRU5VLCBUT1BfRk9DVVMsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV04sIFRPUF9NT1VTRV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPTlRFWFRfTUVOVTpcbiAgICAgIGNhc2UgVE9QX01PVVNFX1VQOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIFRPUF9TRUxFQ1RJT05fQ0hBTkdFOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgVE9QX0tFWV9ET1dOOlxuICAgICAgY2FzZSBUT1BfS0VZX1VQOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMS5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG59KTtcblxuLy8gV2UgY2FwdHVyZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhbnkgZ2xvYmFsLCBpbiBjYXNlIGl0IGdldHMgcG9seWZpbGxlZCBhZnRlclxuLy8gdGhpcyBtb2R1bGUgaXMgaW5pdGlhbGx5IGV2YWx1YXRlZC5cbi8vIFdlIHdhbnQgdG8gYmUgdXNpbmcgYSBjb25zaXN0ZW50IGltcGxlbWVudGF0aW9uLlxuXG52YXIgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzY2hlZHVsaW5nIGxpYnJhcnkgdG8gYWxsb3cgc2NoZWR1bGluZyB3b3JrIHdpdGggbW9yZSBncmFudWxhciBwcmlvcml0eSBhbmRcbiAqIGNvbnRyb2wgdGhhbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIHJlcXVlc3RJZGxlQ2FsbGJhY2suXG4gKiBDdXJyZW50IFRPRE8gaXRlbXM6XG4gKiBYLSBQdWxsIG91dCB0aGUgc2NoZWR1bGVXb3JrIHBvbHlmaWxsIGJ1aWx0IGludG8gUmVhY3RcbiAqIFgtIEluaXRpYWwgdGVzdCBjb3ZlcmFnZVxuICogWC0gU3VwcG9ydCBmb3IgbXVsdGlwbGUgY2FsbGJhY2tzXG4gKiAtIFN1cHBvcnQgZm9yIHR3byBwcmlvcml0aWVzOyBzZXJpYWwgYW5kIGRlZmVycmVkXG4gKiAtIEJldHRlciB0ZXN0IGNvdmVyYWdlXG4gKiAtIEJldHRlciBkb2NibG9ja1xuICogLSBQb2xpc2ggZG9jdW1lbnRhdGlvbiwgQVBJXG4gKi9cblxuLy8gVGhpcyBpcyBhIGJ1aWx0LWluIHBvbHlmaWxsIGZvciByZXF1ZXN0SWRsZUNhbGxiYWNrLiBJdCB3b3JrcyBieSBzY2hlZHVsaW5nXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxuLy8gV2UgY2FwdHVyZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhbnkgZ2xvYmFsLCBpbiBjYXNlIGl0IGdldHMgcG9seWZpbGxlZCBhZnRlclxuLy8gdGhpcyBtb2R1bGUgaXMgaW5pdGlhbGx5IGV2YWx1YXRlZC5cbi8vIFdlIHdhbnQgdG8gYmUgdXNpbmcgYSBjb25zaXN0ZW50IGltcGxlbWVudGF0aW9uLlxudmFyIGxvY2FsRGF0ZSA9IERhdGU7XG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcblxudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgbm93JDEgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIG5vdyQxID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyQxID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gIH07XG59XG5cbnZhciBzY2hlZHVsZVdvcmsgPSB2b2lkIDA7XG52YXIgY2FuY2VsU2NoZWR1bGVkV29yayA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRpbWVvdXRJZHMgPSBuZXcgTWFwKCk7XG5cbiAgc2NoZWR1bGVXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgLy8ga2VlcGluZyByZXR1cm4gdHlwZSBjb25zaXN0ZW50XG4gICAgdmFyIGNhbGxiYWNrQ29uZmlnID0ge1xuICAgICAgc2NoZWR1bGVkQ2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgdGltZW91dFRpbWU6IDAsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgcHJldjogbnVsbFxuICAgIH07XG4gICAgdmFyIHRpbWVvdXRJZCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlkVGltZW91dDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRpbWVvdXRJZHMuc2V0KGNhbGxiYWNrLCB0aW1lb3V0SWQpO1xuICAgIHJldHVybiBjYWxsYmFja0NvbmZpZztcbiAgfTtcbiAgY2FuY2VsU2NoZWR1bGVkV29yayA9IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tJZC5zY2hlZHVsZWRDYWxsYmFjaztcbiAgICB2YXIgdGltZW91dElkID0gdGltZW91dElkcy5nZXQoY2FsbGJhY2spO1xuICAgIHRpbWVvdXRJZHMuZGVsZXRlKGNhbGxiYWNrSWQpO1xuICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG59IGVsc2Uge1xuICB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSQxICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB0eXBlb2YgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9PT0gJ2Z1bmN0aW9uJyA/IGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfTtcblxuICB2YXIgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuICB2YXIgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuXG4gIC8vIFdlIHRyYWNrIHdoYXQgdGhlIG5leHQgc29vbmVzdCB0aW1lb3V0VGltZSBpcywgdG8gYmUgYWJsZSB0byBxdWlja2x5IHRlbGxcbiAgLy8gaWYgbm9uZSBvZiB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrcyBoYXZlIHRpbWVkIG91dC5cbiAgdmFyIG5leHRTb29uZXN0VGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gbm93JDEoKTtcbiAgICAgIHJldHVybiByZW1haW5pbmcgPiAwID8gcmVtYWluaW5nIDogMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBjYWxsYmFjayBlcnJvcnM6XG4gICAqIC0gZG9uJ3QgY2F0Y2ggdGhlIGVycm9yLCBiZWNhdXNlIHRoaXMgY2hhbmdlcyBkZWJ1Z2dpbmcgYmVoYXZpb3JcbiAgICogLSBkbyBzdGFydCBhIG5ldyBwb3N0TWVzc2FnZSBjYWxsYmFjaywgdG8gY2FsbCBhbnkgcmVtYWluaW5nIGNhbGxiYWNrcyxcbiAgICogLSBidXQgb25seSBpZiB0aGVyZSBpcyBhbiBlcnJvciwgc28gdGhlcmUgaXMgbm90IGV4dHJhIG92ZXJoZWFkLlxuICAgKi9cbiAgdmFyIGNhbGxVbnNhZmVseSA9IGZ1bmN0aW9uIChjYWxsYmFja0NvbmZpZywgYXJnKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tDb25maWcuc2NoZWR1bGVkQ2FsbGJhY2s7XG4gICAgdmFyIGZpbmlzaGVkQ2FsbGluZyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgZmluaXNoZWRDYWxsaW5nID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJlbW92ZSBpdCBmcm9tIGxpbmtlZCBsaXN0XG4gICAgICBjYW5jZWxTY2hlZHVsZWRXb3JrKGNhbGxiYWNrQ29uZmlnKTtcblxuICAgICAgaWYgKCFmaW5pc2hlZENhbGxpbmcpIHtcbiAgICAgICAgLy8gYW4gZXJyb3IgbXVzdCBoYXZlIGJlZW4gdGhyb3duXG4gICAgICAgIGlzSWRsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGZvciB0aW1lZCBvdXQgY2FsbGJhY2tzLCBydW5zIHRoZW0sIGFuZCB0aGVuIGNoZWNrcyBhZ2FpbiB0byBzZWUgaWZcbiAgICogYW55IG1vcmUgaGF2ZSB0aW1lZCBvdXQuXG4gICAqIEtlZXBzIGRvaW5nIHRoaXMgdW50aWwgdGhlcmUgYXJlIG5vbmUgd2hpY2ggaGF2ZSBjdXJyZW50bHkgdGltZWQgb3V0LlxuICAgKi9cbiAgdmFyIGNhbGxUaW1lZE91dENhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3ckMSgpO1xuICAgIC8vIFRPRE86IHRoaXMgd291bGQgYmUgbW9yZSBlZmZpY2llbnQgaWYgZGVmZXJyZWQgY2FsbGJhY2tzIGFyZSBzdG9yZWQgaW5cbiAgICAvLyBtaW4gaGVhcC5cbiAgICAvLyBPciBpbiBhIGxpbmtlZCBsaXN0IHdpdGggbGlua3MgZm9yIGJvdGggdGltZW91dFRpbWUgb3JkZXIgYW5kIGluc2VydGlvblxuICAgIC8vIG9yZGVyLlxuICAgIC8vIEZvciBub3cgYW4gZWFzeSBjb21wcm9taXNlIGlzIHRoZSBjdXJyZW50IGFwcHJvYWNoOlxuICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIHRoZSBzb29uZXN0IHRpbWVvdXRUaW1lLCBhbmQgY2hlY2sgdGhhdCBmaXJzdC5cbiAgICAvLyBJZiBpdCBoYXMgbm90IGV4cGlyZWQsIHdlIGNhbiBza2lwIHRyYXZlcnNpbmcgdGhlIHdob2xlIGxpc3QuXG4gICAgLy8gSWYgaXQgaGFzIGV4cGlyZWQsIHRoZW4gd2Ugc3RlcCB0aHJvdWdoIGFsbCB0aGUgY2FsbGJhY2tzLlxuICAgIGlmIChuZXh0U29vbmVzdFRpbWVvdXRUaW1lID09PSAtMSB8fCBuZXh0U29vbmVzdFRpbWVvdXRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCBub25lIG9mIHRoZW0gaGF2ZSB0aW1lZCBvdXQgeWV0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOT1RFOiB3ZSBpbnRlbnRpb25hbGx5IHdhaXQgdG8gdXBkYXRlIHRoZSBuZXh0U29vbmVzdFRpbWVvdXRUaW1lIHVudGlsXG4gICAgLy8gYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNhbGxpbmcgYW55IHRpbWVkIG91dCBjYWxsYmFja3MuXG4gICAgLy8gSWYgYSB0aW1lZCBvdXQgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yLCB3ZSBjb3VsZCBnZXQgc3R1Y2sgaW4gYSBzdGF0ZVxuICAgIC8vIHdoZXJlIHRoZSBuZXh0U29vbmVzdFRpbWVvdXRUaW1lIHdhcyBzZXQgd3JvbmcuXG4gICAgdmFyIHVwZGF0ZWROZXh0U29vbmVzdFRpbWVvdXRUaW1lID0gLTE7IC8vIHdlIHdpbGwgdXBkYXRlIG5leHRTb29uZXN0VGltZW91dFRpbWUgYmVsb3dcbiAgICB2YXIgdGltZWRPdXRDYWxsYmFja3MgPSBbXTtcblxuICAgIC8vIGl0ZXJhdGUgb25jZSB0byBmaW5kIHRpbWVkIG91dCBjYWxsYmFja3MgYW5kIGZpbmQgbmV4dFNvb25lc3RUaW1lb3V0VGltZVxuICAgIHZhciBjdXJyZW50Q2FsbGJhY2tDb25maWcgPSBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICB3aGlsZSAoY3VycmVudENhbGxiYWNrQ29uZmlnICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3RpbWVvdXRUaW1lID0gY3VycmVudENhbGxiYWNrQ29uZmlnLnRpbWVvdXRUaW1lO1xuICAgICAgaWYgKF90aW1lb3V0VGltZSAhPT0gLTEgJiYgX3RpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIGl0IGhhcyB0aW1lZCBvdXQhXG4gICAgICAgIHRpbWVkT3V0Q2FsbGJhY2tzLnB1c2goY3VycmVudENhbGxiYWNrQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdGltZW91dFRpbWUgIT09IC0xICYmICh1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZSA9PT0gLTEgfHwgX3RpbWVvdXRUaW1lIDwgdXBkYXRlZE5leHRTb29uZXN0VGltZW91dFRpbWUpKSB7XG4gICAgICAgICAgdXBkYXRlZE5leHRTb29uZXN0VGltZW91dFRpbWUgPSBfdGltZW91dFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDYWxsYmFja0NvbmZpZyA9IGN1cnJlbnRDYWxsYmFja0NvbmZpZy5uZXh0O1xuICAgIH1cblxuICAgIGlmICh0aW1lZE91dENhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRpbWVkT3V0Q2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNhbGxVbnNhZmVseSh0aW1lZE91dENhbGxiYWNrc1tpXSwgZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgaW50ZW50aW9uYWxseSB3YWl0IHRvIHVwZGF0ZSB0aGUgbmV4dFNvb25lc3RUaW1lb3V0VGltZSB1bnRpbFxuICAgIC8vIGFmdGVyIHN1Y2Nlc3NmdWxseSBjYWxsaW5nIGFueSB0aW1lZCBvdXQgY2FsbGJhY2tzLlxuICAgIG5leHRTb29uZXN0VGltZW91dFRpbWUgPSB1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZTtcbiAgfTtcblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgY2FsbCBhbnl0aGluZyB3aGljaCBoYXMgdGltZWQgb3V0LCB1bnRpbCB3ZSBoYXZlIGNhdWdodCB1cC5cbiAgICBjYWxsVGltZWRPdXRDYWxsYmFja3MoKTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gICAgLy8gTmV4dCwgYXMgbG9uZyBhcyB3ZSBoYXZlIGlkbGUgdGltZSwgdHJ5IGNhbGxpbmcgbW9yZSBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGZyYW1lRGVhZGxpbmUgLSBjdXJyZW50VGltZSA+IDAgJiYgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBsYXRlc3RDYWxsYmFja0NvbmZpZyA9IGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0O1xuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAvLyBjYWxsVW5zYWZlbHkgd2lsbCByZW1vdmUgaXQgZnJvbSB0aGUgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3RcbiAgICAgIGNhbGxVbnNhZmVseShsYXRlc3RDYWxsYmFja0NvbmZpZywgZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgICBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gICAgfVxuICAgIGlmIChoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgYW5pbWF0aW9uIGNhbGxiYWNrIHNvIHdlIHJldHJ5IGxhdGVyLlxuICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBzY2hlZHVsZVdvcmsgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIC8qIENhbGxiYWNrQ29uZmlnVHlwZSAqL3tcbiAgICB2YXIgdGltZW91dFRpbWUgPSAtMTtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aW1lb3V0VGltZSA9IG5vdyQxKCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmIChuZXh0U29vbmVzdFRpbWVvdXRUaW1lID09PSAtMSB8fCB0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPCBuZXh0U29vbmVzdFRpbWVvdXRUaW1lKSB7XG4gICAgICBuZXh0U29vbmVzdFRpbWVvdXRUaW1lID0gdGltZW91dFRpbWU7XG4gICAgfVxuXG4gICAgdmFyIHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnID0ge1xuICAgICAgc2NoZWR1bGVkQ2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgdGltZW91dFRpbWU6IHRpbWVvdXRUaW1lLFxuICAgICAgcHJldjogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9PT0gbnVsbCkge1xuICAgICAgLy8gTWFrZSB0aGlzIGNhbGxiYWNrIHRoZSBoZWFkIGFuZCB0YWlsIG9mIG91ciBsaXN0XG4gICAgICBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnO1xuICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIGxhdGVzdCBjYWxsYmFjayBhcyB0aGUgbmV3IHRhaWwgb2YgdGhlIGxpc3RcbiAgICAgIHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnLnByZXYgPSB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICAgIC8vIHJlbmFtaW5nIGZvciBjbGFyaXR5XG4gICAgICB2YXIgb2xkVGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdDtcbiAgICAgIGlmIChvbGRUYWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gbnVsbCkge1xuICAgICAgICBvbGRUYWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdC5uZXh0ID0gc2NoZWR1bGVkQ2FsbGJhY2tDb25maWc7XG4gICAgICB9XG4gICAgICB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnO1xuICAgIH1cblxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgc2NoZWR1bGVXb3JrIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgfTtcblxuICBjYW5jZWxTY2hlZHVsZWRXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrQ29uZmlnIC8qIENhbGxiYWNrQ29uZmlnVHlwZSAqL1xuICApIHtcbiAgICBpZiAoY2FsbGJhY2tDb25maWcucHJldiA9PT0gbnVsbCAmJiBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gY2FsbGJhY2tDb25maWcpIHtcbiAgICAgIC8vIHRoaXMgY2FsbGJhY2tDb25maWcgaGFzIGFscmVhZHkgYmVlbiBjYW5jZWxsZWQuXG4gICAgICAvLyBjYW5jZWxTY2hlZHVsZWRXb3JrIHNob3VsZCBiZSBpZGVtcG90ZW50LCBhIG5vLW9wIGFmdGVyIGZpcnN0IGNhbGwuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGZvdXIgcG9zc2libGUgY2FzZXM6XG4gICAgICogLSBIZWFkL25vZGVUb1JlbW92ZS9UYWlsIC0+IG51bGxcbiAgICAgKiAgIEluIHRoaXMgY2FzZSB3ZSBzZXQgSGVhZCBhbmQgVGFpbCB0byBudWxsLlxuICAgICAqIC0gSGVhZCAtPiAuLi4gbWlkZGxlIG5vZGVzLi4uIC0+IFRhaWwvbm9kZVRvUmVtb3ZlXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5uZXh0IHRvIG51bGwgYW5kIHB1dCBtaWRkbGUgYXMgdGhlIG5ld1xuICAgICAqICAgVGFpbC5cbiAgICAgKiAtIEhlYWQvbm9kZVRvUmVtb3ZlIC0+IC4uLm1pZGRsZSBub2Rlcy4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5wcmV2IGF0IG51bGwgYW5kIG1vdmUgdGhlIEhlYWQgdG9cbiAgICAgKiAgIG1pZGRsZS5cbiAgICAgKiAtIEhlYWQgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBub2RlVG9SZW1vdmUgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIEhlYWQubmV4dCB0byB0aGUgVGFpbCBhbmQgdGhlIFRhaWwucHJldiB0b1xuICAgICAqICAgdGhlIEhlYWQuXG4gICAgICovXG4gICAgdmFyIG5leHQgPSBjYWxsYmFja0NvbmZpZy5uZXh0O1xuICAgIHZhciBwcmV2ID0gY2FsbGJhY2tDb25maWcucHJldjtcbiAgICBjYWxsYmFja0NvbmZpZy5uZXh0ID0gbnVsbDtcbiAgICBjYWxsYmFja0NvbmZpZy5wcmV2ID0gbnVsbDtcbiAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gd2UgaGF2ZSBhIG5leHRcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGxpc3Qgb2YgMyBvciBtb3JlIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG5leHQgYnV0IG5vdCBhIHByZXZpb3VzIG9uZTtcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIGhlYWQgb2YgYSBsaXN0IG9mIDIgb3IgbW9yZSBvdGhlciBub2Rlcy5cbiAgICAgICAgbmV4dC5wcmV2ID0gbnVsbDtcbiAgICAgICAgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBuZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgY2FsbGJhY2sgY29uZmlnOyB0aGlzIG11c3QgdGhlIHRhaWwgb2YgdGhlIGxpc3RcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyB0aGUgdGFpbCBvZiBhIGxpc3Qgb2YgMiBvciBtb3JlIG90aGVyIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHByZXY7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNhbGxiYWNrIGNvbmZpZztcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIG9ubHkgdGhpbmcgaW4gdGhlIGxpbmtlZCBsaXN0LFxuICAgICAgICAvLyBzbyBib3RoIGhlYWQgYW5kIHRhaWwgcG9pbnQgdG8gaXQuXG4gICAgICAgIGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIC8vIFdlIGNhbiBzaWxlbnRseSBza2lwIHRoZW0gYmVjYXVzZSBpbnZhbGlkIERPTSBuZXN0aW5nIHdhcm5pbmdcbiAgLy8gY2F0Y2hlcyB0aGVzZSBjYXNlcyBpbiBGaWJlci5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gIHtcbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbiAgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICAhKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDIoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4lcycsIG5hbWUsIGxvd2VyQ2FzZWROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuU2hhZHlET00gPSBmYWxzZTtcblxudmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbnZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgPSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJztcbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9IE5hbWVzcGFjZXMuaHRtbDtcblxuXG52YXIgZ2V0U3RhY2sgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKCcnKTtcblxudmFyIHdhcm5lZFVua25vd25UYWdzID0gdm9pZCAwO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHZvaWQgMDtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSB2b2lkIDA7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IHZvaWQgMDtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IHZvaWQgMDtcblxudmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IHZvaWQgMDtcbnZhciBub3JtYWxpemVIVE1MID0gdm9pZCAwO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSFRNTCBwYXJzaW5nIG5vcm1hbGl6ZXMgQ1IgYW5kIENSTEYgdG8gTEYuXG4gIC8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2gsIGl0IG1pZ2h0IGJlIGNhdXNlZCBieSB0aGF0LlxuICAvLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBpc0RvY3VtZW50T3JGcmFnbWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudE9yRnJhZ21lbnQgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IHZvaWQgMDtcblxuICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICEoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpKSA/IHdhcm5pbmcoZmFsc2UsICc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcyA9IHZvaWQgMDtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfUkVTRVQsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfU1VCTUlULCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1RPR0dMRSwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzID0gdm9pZCAwO1xuICB2YXIgbmV4dFByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5ID0gdm9pZCAwO1xuICB2YXIgc3R5bGVOYW1lID0gdm9pZCAwO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9UT0dHTEUsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRydWUgJiZcbiAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KTtcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSAmJiAhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgICAgICB2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG51bGwgJiYgc3RhbmRhcmROYW1lICE9PSBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4gICAgICAgICAgICAgIC8vIChhbmQgd291bGQgYmUgaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCkuXG4gICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbiAgICAgICAgICAgICAgLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMVxufSk7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICAhKGNoaWxkVGFnID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpIDogdm9pZCAwO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBSZW5kZXJlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHBlcnNpc3RlbmNlXG4vLyBjYW4gcmUtZXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIG1vZHVsZS5cblxuZnVuY3Rpb24gc2hpbSgpIHtcbiAgaW52YXJpYW50KGZhbHNlLCAnVGhlIGN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuLy8gUGVyc2lzdGVuY2UgKHdoZW4gdW5zdXBwb3J0ZWQpXG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9IGZhbHNlO1xudmFyIGNsb25lSW5zdGFuY2UgPSBzaGltO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gc2hpbTtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBzaGltO1xudmFyIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSBzaGltO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHNoaW07XG5cbi8vIFVudXNlZFxuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbnZhciBjcmVhdGVUZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlJDE7XG52YXIgc2V0SW5pdGlhbFByb3BlcnRpZXMgPSBzZXRJbml0aWFsUHJvcGVydGllcyQxO1xudmFyIGRpZmZQcm9wZXJ0aWVzID0gZGlmZlByb3BlcnRpZXMkMTtcbnZhciB1cGRhdGVQcm9wZXJ0aWVzID0gdXBkYXRlUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMgPSBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dCA9IGRpZmZIeWRyYXRlZFRleHQkMTtcbnZhciB3YXJuRm9yVW5tYXRjaGVkVGV4dCA9IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxO1xudmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmckMS51cGRhdGVkQW5jZXN0b3JJbmZvO1xudmFyIHByZWNhY2hlRmliZXJOb2RlJDEgPSBwcmVjYWNoZUZpYmVyTm9kZTtcbnZhciB1cGRhdGVGaWJlclByb3BzJDEgPSB1cGRhdGVGaWJlclByb3BzO1xuXG5cbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9IHZvaWQgMDtcbntcbiAgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbn1cblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICB7XG4gICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgfVxuICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gIH1cbiAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHNldEVuYWJsZWQoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZXNldEFmdGVyQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHtcbiAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gIHVwZGF0ZUZpYmVyUHJvcHMkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICByZXR1cm4gdGV4dE5vZGU7XG59XG5cbnZhciBub3cgPSBub3ckMTtcbnZhciBpc1ByaW1hcnlSZW5kZXJlciA9IHRydWU7XG52YXIgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrID0gc2NoZWR1bGVXb3JrO1xudmFyIGNhbmNlbERlZmVycmVkQ2FsbGJhY2sgPSBjYW5jZWxTY2hlZHVsZWRXb3JrO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgTXV0YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzTXV0YXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBjb21taXRNb3VudChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgLy8gZmlyZXMgaWYgdGhlcmUgaXMgYW4gYFVwZGF0ZWAgZWZmZWN0IHNjaGVkdWxlZCBkdXJpbmcgbW91bnRpbmcuXG4gIC8vIFRoaXMgaGFwcGVucyBpZiBgZmluYWxpemVJbml0aWFsQ2hpbGRyZW5gIHJldHVybnMgYHRydWVgICh3aGljaCBpdFxuICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgLy8gdGhlcmUgYXJlIGFsc28gb3RoZXIgY2FzZXMgd2hlbiB0aGlzIG1pZ2h0IGhhcHBlbiAoc3VjaCBhcyBwYXRjaGluZ1xuICAvLyB1cCB0ZXh0IGNvbnRlbnQgZHVyaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaCkuIFNvIHdlJ2xsIGNoZWNrIHRoaXMgYWdhaW4uXG4gIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRVcGRhdGUoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gIHVwZGF0ZUZpYmVyUHJvcHMkMShkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuXG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuXG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIEh5ZHJhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNIeWRyYXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBjYW5IeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSkge1xuICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZSQxKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gIC8vIGdldCBhdHRhY2hlZC5cbiAgdXBkYXRlRmliZXJQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHByZWNhY2hlRmliZXJOb2RlJDEoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIEV4cGVyaW1lbnRhbCBlcnJvci1ib3VuZGFyeSBBUEkgdGhhdCBjYW4gcmVjb3ZlciBmcm9tIGVycm9ycyB3aXRoaW4gYSBzaW5nbGVcbi8vIHJlbmRlciBwaGFzZVxudmFyIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGZhbHNlO1xuLy8gU3VzcGVuc2VcbnZhciBlbmFibGVTdXNwZW5zZSA9IGZhbHNlO1xuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSB0cnVlO1xuXG4vLyBUbyBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBkZWJ1Z2dlciwgd2Vcbi8vIHJlcGxheSB0aGUgYmVnaW4gcGhhc2Ugb2YgYSBmYWlsZWQgY29tcG9uZW50IGluc2lkZSBpbnZva2VHdWFyZGVkQ2FsbGJhY2suXG52YXIgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSB0cnVlO1xuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcbnZhciB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IGZhbHNlO1xuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxudmFyIHdhcm5BYm91dExlZ2FjeUNvbnRleHRBUEkgPSBmYWxzZTtcblxuLy8gR2F0aGVyIGFkdmFuY2VkIHRpbWluZyBtZXRyaWNzIGZvciBQcm9maWxlciBzdWJ0cmVlcy5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTtcblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbi8vIFByZWZpeCBtZWFzdXJlbWVudHMgc28gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIGZpbHRlciB0aGVtLlxuLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG52YXIgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbnZhciB3YXJuaW5nRW1vamkgPSAnXFx1MjZENCc7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IGZpYmVyIHNvIHRoYXQgd2Uga25vdyB0aGUgcGF0aCB0byB1bndpbmQgb24gcGF1c2UuXG4vLyBUT0RPOiB0aGlzIGxvb2tzIHRoZSBzYW1lIGFzIG5leHRVbml0T2ZXb3JrIGluIHNjaGVkdWxlci4gQ2FuIHdlIHVuaWZ5IHRoZW0/XG52YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxudmFyIGN1cnJlbnRQaGFzZSA9IG51bGw7XG52YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbnZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xudmFyIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xudmFyIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbnZhciBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuLy8gRHVyaW5nIGNvbW1pdHMsIHdlIG9ubHkgc2hvdyBhIG1lYXN1cmVtZW50IG9uY2UgcGVyIG1ldGhvZCBuYW1lXG4vLyB0byBhdm9pZCBzdHJldGNoIHRoZSBjb21taXQgcGhhc2Ugd2l0aCBtZWFzdXJlbWVudCBvdmVyaGVhZC5cbnZhciBsYWJlbHNJbkN1cnJlbnRDb21taXQgPSBuZXcgU2V0KCk7XG5cbnZhciBmb3JtYXRNYXJrTmFtZSA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICByZXR1cm4gcmVhY3RFbW9qaSArICcgJyArIG1hcmtOYW1lO1xufTtcblxudmFyIGZvcm1hdExhYmVsID0gZnVuY3Rpb24gKGxhYmVsLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBwcmVmaXggPSB3YXJuaW5nJCQxID8gd2FybmluZ0Vtb2ppICsgJyAnIDogcmVhY3RFbW9qaSArICcgJztcbiAgdmFyIHN1ZmZpeCA9IHdhcm5pbmckJDEgPyAnIFdhcm5pbmc6ICcgKyB3YXJuaW5nJCQxIDogJyc7XG4gIHJldHVybiAnJyArIHByZWZpeCArIGxhYmVsICsgc3VmZml4O1xufTtcblxudmFyIGJlZ2luTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5tYXJrKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgY2xlYXJNYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBlbmRNYXJrID0gZnVuY3Rpb24gKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSkge1xuICB2YXIgZm9ybWF0dGVkTWFya05hbWUgPSBmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSk7XG4gIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsLCB3YXJuaW5nJCQxKTtcbiAgdHJ5IHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGZvcm1hdHRlZExhYmVsLCBmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge31cbiAgLy8gSWYgcHJldmlvdXMgbWFyayB3YXMgbWlzc2luZyBmb3Igc29tZSByZWFzb24sIHRoaXMgd2lsbCB0aHJvdy5cbiAgLy8gVGhpcyBjb3VsZCBvbmx5IGhhcHBlbiBpZiBSZWFjdCBjcmFzaGVkIGluIGFuIHVuZXhwZWN0ZWQgcGxhY2UgZWFybGllci5cbiAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuXG4gIC8vIENsZWFyIG1hcmtzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGdyb3dpbmcgYnVmZmVyLlxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG59O1xuXG52YXIgZ2V0RmliZXJNYXJrTmFtZSA9IGZ1bmN0aW9uIChsYWJlbCwgZGVidWdJRCkge1xuICByZXR1cm4gbGFiZWwgKyAnICgjJyArIGRlYnVnSUQgKyAnKSc7XG59O1xuXG52YXIgZ2V0RmliZXJMYWJlbCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKSB7XG4gIGlmIChwaGFzZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXNlIGFyZSBjb21wb3NpdGUgY29tcG9uZW50IHRvdGFsIHRpbWUgbWVhc3VyZW1lbnRzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJyBbJyArIChpc01vdW50ZWQgPyAndXBkYXRlJyA6ICdtb3VudCcpICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcuJyArIHBoYXNlO1xuICB9XG59O1xuXG52YXIgYmVnaW5GaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuXG4gIGlmIChpc0NvbW1pdHRpbmcgJiYgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmhhcyhsYWJlbCkpIHtcbiAgICAvLyBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3Qgc2hvdyBkdXBsaWNhdGUgbGFiZWxzIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBhIGZpeGVkIG92ZXJoZWFkIGZvciBldmVyeSBtZWFzdXJlbWVudCwgYW5kIHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBzdHJldGNoIHRoZSBjb21taXQgcGhhc2UgYmV5b25kIG5lY2Vzc2FyeS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmFkZChsYWJlbCk7XG5cbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGJlZ2luTWFyayhtYXJrTmFtZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNsZWFyRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGNsZWFyTWFyayhtYXJrTmFtZSk7XG59O1xuXG52YXIgZW5kRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSwgd2FybmluZyQkMSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGVuZE1hcmsobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKTtcbn07XG5cbnZhciBzaG91bGRJZ25vcmVGaWJlciA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAvLyBIb3N0IGNvbXBvbmVudHMgc2hvdWxkIGJlIHNraXBwZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAvLyBXZSBjb3VsZCBjaGVjayB0eXBlb2YgZmliZXIudHlwZSwgYnV0IGRvZXMgdGhpcyB3b3JrIHdpdGggUk4/XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlci5yZXR1cm4gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlci5yZXR1cm4pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4gd2lsbCBmb3JjZSBmbHVzaCBpbiAnICsgZXhwaXJhdGlvblRpbWUgKyAnIG1zKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyQkMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgdmFyIGxhYmVsID0gZGlkQ29tcGxldGVSb290ID8gJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBDb21wbGV0ZWQgUm9vdCknIDogJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uOiBZaWVsZGVkKSc7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyayhsYWJlbCwgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG52YXIgZmliZXJTdGFjayA9IHZvaWQgMDtcblxue1xuICBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICB7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCkge1xuICB7XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YWx1ZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmliZXJTdGFjay5sZW5ndGggPSAwO1xuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZW1wdHlPYmplY3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG5cbi8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxuXG52YXIgTm9Xb3JrID0gMDtcbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSAyO1xuXG4vLyAxIHVuaXQgb2YgZXhwaXJhdGlvbiB0aW1lIHJlcHJlc2VudHMgMTBtcy5cbmZ1bmN0aW9uIG1zVG9FeHBpcmF0aW9uVGltZShtcykge1xuICAvLyBBbHdheXMgYWRkIGFuIG9mZnNldCBzbyB0aGF0IHdlIGRvbid0IGNsYXNoIHdpdGggdGhlIG1hZ2ljIG51bWJlciBmb3IgTm9Xb3JrLlxuICByZXR1cm4gKG1zIC8gVU5JVF9TSVpFIHwgMCkgKyBNQUdJQ19OVU1CRVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIChleHBpcmF0aW9uVGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQpICogVU5JVF9TSVpFO1xufVxuXG5mdW5jdGlvbiBjZWlsaW5nKG51bSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiAoKG51bSAvIHByZWNpc2lvbiB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiBNQUdJQ19OVU1CRVJfT0ZGU0VUICsgY2VpbGluZyhjdXJyZW50VGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNNb2RlID0gMTtcbnZhciBTdHJpY3RNb2RlID0gMjtcbnZhciBQcm9maWxlTW9kZSA9IDQ7XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IHZvaWQgMDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICB2YXIgdGVzdE1hcCA9IG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIHZhciB0ZXN0U2V0ID0gbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBSb2xsdXAgdG8gbm90IGNvbnNpZGVyIHRoZXNlIHVudXNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTc3MVxuICAgIC8vIFRPRE86IHdlIGNhbiByZW1vdmUgdGhlc2UgaWYgUm9sbHVwIGZpeGVzIHRoZSBidWcuXG4gICAgdGVzdE1hcC5zZXQoMCwgMCk7XG4gICAgdGVzdFNldC5hZGQoMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxudmFyIGRlYnVnQ291bnRlciA9IHZvaWQgMDtcblxue1xuICBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuc2VsZkJhc2VUaW1lID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlVGltZSA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgcGVuZGluZ1Byb3BzLCBjdXJyZW50LmtleSwgY3VycmVudC5tb2RlKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gMDtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZVRpbWUgPSBjdXJyZW50LnNlbGZCYXNlVGltZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZVRpbWUgPSBjdXJyZW50LnRyZWVCYXNlVGltZTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKSB7XG4gIHZhciBtb2RlID0gaXNBc3luYyA/IEFzeW5jTW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gIHZhciBmaWJlclRhZyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXJUYWcgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBDbGFzc0NvbXBvbmVudCA6IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gQXN5bmNNb2RlIHwgU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1RJTUVPVVRfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBUaW1lb3V0Q29tcG9uZW50O1xuICAgICAgICAvLyBTdXNwZW5zZSBkb2VzIG5vdCByZXF1aXJlIGFzeW5jLCBidXQgaXRzIGNoaWxkcmVuIHNob3VsZCBiZSBzdHJpY3RcbiAgICAgICAgLy8gbW9kZSBjb21wYXRpYmxlLlxuICAgICAgICBtb2RlIHw9IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmliZXJUYWcgPSBnZXRGaWJlclRhZ0Zyb21PYmplY3RUeXBlKHR5cGUsIG93bmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci50eXBlID0gdHlwZTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyVGFnRnJvbU9iamVjdFR5cGUodHlwZSwgb3duZXIpIHtcbiAgdmFyICQkdHlwZW9mID0gdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgPyB0eXBlLiQkdHlwZW9mIDogbnVsbDtcblxuICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgcmV0dXJuIENvbnRleHRQcm92aWRlcjtcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgcmV0dXJuIENvbnRleHRDb25zdW1lcjtcbiAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwZW5kaW5nUHJvcHMub25SZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgc3RyaW5nIGFuZCBcIm9uUmVuZGVyXCIgZnVuY3Rpb24gYXMgcHJvcHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG4vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VUaW1lID0gc291cmNlLnNlbGZCYXNlVGltZTtcbiAgICB0YXJnZXQudHJlZUJhc2VUaW1lID0gc291cmNlLnRyZWVCYXNlVGltZTtcbiAgfVxuICB0YXJnZXQuX2RlYnVnSUQgPSBzb3VyY2UuX2RlYnVnSUQ7XG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHNvdXJjZS5fZGVidWdJc0N1cnJlbnRseVRpbWluZztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbGlmdGVkIGludG8gdGhlIHJlbmRlcmVyLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKTtcbiAgdmFyIHJvb3QgPSB7XG4gICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuXG4gICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgIGxhdGVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgZWFybGllc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgIGxhdGVzdFBpbmdlZFRpbWU6IE5vV29yayxcblxuICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIHJlY29yZERlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIExJRkVDWUNMRV9TVUdHRVNUSU9OUyA9IHtcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcycsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6ICdjb21wb25lbnREaWRVcGRhdGUnXG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG4gIHZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlV2FybmluZ3NNYXAsIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IGxpZmVjeWNsZS5yZXBsYWNlKCdVTlNBRkVfJywgJycpO1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgdmFyIHNvcnRlZENvbXBvbmVudE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50TmFtZXMpO1xuXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLnB1c2goZm9ybWF0dGVkICsgJzogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlICcgKyAoc3VnZ2VzdGlvbiArICcgaW5zdGVhZDogJyArIHNvcnRlZENvbXBvbmVudE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vuc2FmZSBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGZvdW5kIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6JXMnICsgJ1xcblxcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbE1vdW50IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1VzZSBjb21wb25lbnREaWRNb3VudCBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQuJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnLCBzb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIF91bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lcyk7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2Ugc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbnN0ZWFkLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfdW5pcXVlTmFtZXMyID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMyLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lczIpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzMik7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICAvLyBUaGlzIGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbnkgb3RoZXIgd2F5IHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICAgIC8vIGFyZSBvZnRlbiB2YWd1ZSBhbmQgYXJlIGxpa2VseSB0byBjb2xsaWRlIGJldHdlZW4gM3JkIHBhcnR5IGxpYnJhcmllcy5cbiAgICAvLyBBbiBleHBhbmQgcHJvcGVydHkgaXMgcHJvYmFibHkgb2theSB0byB1c2UgaGVyZSBzaW5jZSBpdCdzIERFVi1vbmx5LFxuICAgIC8vIGFuZCB3aWxsIG9ubHkgYmUgc2V0IGluIHRoZSBldmVudCBvZiBzZXJpb3VzIHdhcm5pbmdzLlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSB2b2lkIDA7XG4gICAgaWYgKCFwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuaGFzKHN0cmljdFJvb3QpKSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6IFtdLFxuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiBbXVxuICAgICAgfTtcblxuICAgICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZ2V0KHN0cmljdFJvb3QpO1xuICAgIH1cblxuICAgIHZhciB1bnNhZmVMaWZlY3ljbGVzID0gW107XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgIH1cblxuICAgIGlmICh1bnNhZmVMaWZlY3ljbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdFtsaWZlY3ljbGVdLnB1c2goZmliZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICB2YXIgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzdHJpY3RSb290KTtcblxuICAgICAgd2FybmluZyhmYWxzZSwgJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlOiAlcycgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgc29ydGVkTmFtZXMpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxuLy8gVE9ETzogT2Zmc2NyZWVuIHVwZGF0ZXNcblxuZnVuY3Rpb24gbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IGFuZCBlYXJsaWVzdCBwZW5kaW5nIHRpbWVzXG4gICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gTm8gb3RoZXIgcGVuZGluZyB1cGRhdGVzLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHBlbmRpbmcgdXBkYXRlLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHBlbmRpbmcgdXBkYXRlXG4gICAgICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyhyb290LCBjdXJyZW50VGltZSwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLiBDbGVhciBldmVyeXRoaW5nLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExldCdzIHNlZSBpZiB0aGUgcHJldmlvdXMgbGF0ZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwgd2FzIGp1c3QgZmx1c2hlZC5cbiAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgICAgLy8gV2UndmUgZmx1c2hlZCBhbGwgdGhlIGtub3duIHBlbmRpbmcgbGV2ZWxzLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lIDwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gICAgICAgICAgLy8gV2UndmUgZmx1c2hlZCB0aGUgZWFybGllc3Qga25vd24gcGVuZGluZyBsZXZlbC4gU2V0IHRoaXMgdG8gdGhlXG4gICAgICAgICAgLy8gbGF0ZXN0IHBlbmRpbmcgdGltZS5cbiAgICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm93IGxldCdzIGhhbmRsZSB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGluIHRoZSB3aG9sZSB0cmVlLiBXZSBuZWVkIHRvXG4gICAgLy8gZGVjaWRlIHdoZXRoZXIgdG8gdHJlYXQgaXQgYXMgYSBwZW5kaW5nIGxldmVsIG9yIGFzIHN1c3BlbmRlZC4gQ2hlY2tcbiAgICAvLyBpdCBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG5cbiAgICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lID4gbGF0ZXN0U3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpcyBsYXRlciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuIFRoYXRcbiAgICAgIC8vIG1lYW5zIHdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuXG4gICAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lIDwgZWFybGllc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIHRpbWUgaXMgZWFybGllciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuXG4gICAgICAvLyBUcmVhdCBpdCBhcyBhIHBlbmRpbmcgdXBkYXRlLlxuICAgICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkXG4gICAgLy8gbGV2ZWxzLiBXZSBzaG91bGQgdHJlYXQgdGhpcyBhcyBzdXNwZW5kZWQgd29yay5cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIEZpcnN0LCBjaGVjayB0aGUga25vd24gcGVuZGluZyBsZXZlbHMgYW5kIHVwZGF0ZSB0aGVtIGlmIG5lZWRlZC5cbiAgICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgICAgLy8gQm90aCBrbm93biBwZW5kaW5nIGxldmVscyB3ZXJlIHN1c3BlbmRlZC4gQ2xlYXIgdGhlbS5cbiAgICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBlYXJsaWVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBsYXRlc3RQZW5kaW5nVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGUgbGF0ZXN0IHBlbmRpbmcgbGV2ZWwgd2FzIHN1c3BlbmRlZC4gQ2xlYXIgYnkgc2V0dGluZyBpdCB0byB0aGVcbiAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuXG4gICAgLy8gTmV4dCwgaWYgd2UncmUgd29ya2luZyBvbiB0aGUgbG93ZXN0IGtub3duIHN1c3BlbmRlZCBsZXZlbCwgY2xlYXIgdGhlIHBpbmcuXG4gICAgLy8gVE9ETzogV2hhdCBpZiBhIHByb21pc2Ugc3VzcGVuZHMgYW5kIHBpbmdzIGJlZm9yZSB0aGUgcm9vdCBjb21wbGV0ZXM/XG4gICAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gICAgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG4gICAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICAgIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgICAgLy8gTm8gb3RoZXIgc3VzcGVuZGVkIGxldmVscy5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA+IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZWFybGllc3Qgc3VzcGVuZGVkIGxldmVsLlxuICAgICAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gICAgICB9IGVsc2UgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPCBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhdGVzdCBzdXNwZW5kZWQgbGV2ZWxcbiAgICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcGluZ2VkVGltZSkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgICBpZiAobGF0ZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFN1c3BlbmRlZFRpbWUgPD0gcGluZ2VkVGltZSkge1xuICAgICAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gICAgICBpZiAobGF0ZXN0UGluZ2VkVGltZSA9PT0gTm9Xb3JrIHx8IGxhdGVzdFBpbmdlZFRpbWUgPCBwaW5nZWRUaW1lKSB7XG4gICAgICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IHBpbmdlZFRpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAvLyBGYXN0IHBhdGguIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuXG4gICAgICByZXR1cm4gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlcmUncyBrbm93biBwZW5kaW5nIHdvcmsuXG4gICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yaykge1xuICAgICAgcmV0dXJuIGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgaWYgYSBzdXNwZW5kZWQgbGV2ZWwgd2FzIHBpbmdlZCwgd29yayBvbiB0aGF0LiBPdGhlcndpc2UgdGhlcmUnc1xuICAgIC8vIG5vdGhpbmcgdG8gd29yayBvbi5cbiAgICByZXR1cm4gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuLy8gVXBkYXRlUXVldWUgaXMgYSBsaW5rZWQgbGlzdCBvZiBwcmlvcml0aXplZCB1cGRhdGVzLlxuLy9cbi8vIExpa2UgZmliZXJzLCB1cGRhdGUgcXVldWVzIGNvbWUgaW4gcGFpcnM6IGEgY3VycmVudCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuLy8gdGhlIHZpc2libGUgc3RhdGUgb2YgdGhlIHNjcmVlbiwgYW5kIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgd2hpY2ggaXNcbi8vIGNhbiBiZSBtdXRhdGVkIGFuZCBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkgYmVmb3JlIGl0IGlzIGNvbW1pdHRlZCDigJQgYSBmb3JtXG4vLyBvZiBkb3VibGUgYnVmZmVyaW5nLiBJZiBhIHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyIGlzIGRpc2NhcmRlZCBiZWZvcmVcbi8vIGZpbmlzaGluZywgd2UgY3JlYXRlIGEgbmV3IHdvcmstaW4tcHJvZ3Jlc3MgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBCb3RoIHF1ZXVlcyBzaGFyZSBhIHBlcnNpc3RlbnQsIHNpbmdseS1saW5rZWQgbGlzdCBzdHJ1Y3R1cmUuIFRvIHNjaGVkdWxlIGFuXG4vLyB1cGRhdGUsIHdlIGFwcGVuZCBpdCB0byB0aGUgZW5kIG9mIGJvdGggcXVldWVzLiBFYWNoIHF1ZXVlIG1haW50YWlucyBhXG4vLyBwb2ludGVyIHRvIGZpcnN0IHVwZGF0ZSBpbiB0aGUgcGVyc2lzdGVudCBsaXN0IHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkLlxuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlciBhbHdheXMgaGFzIGEgcG9zaXRpb24gZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4vLyB0aGUgY3VycmVudCBxdWV1ZSwgc2luY2Ugd2UgYWx3YXlzIHdvcmsgb24gdGhhdCBvbmUuIFRoZSBjdXJyZW50IHF1ZXVlJ3Ncbi8vIHBvaW50ZXIgaXMgb25seSB1cGRhdGVkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3aGVuIHdlIHN3YXAgaW4gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgQ3VycmVudCBwb2ludGVyOiAgICAgICAgICAgQSAtIEIgLSBDIC0gRCAtIEUgLSBGXG4vLyAgIFdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlcjogICAgICAgICAgICAgIEQgLSBFIC0gRlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGhhc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgbW9yZSB1cGRhdGVzIHRoYW4gY3VycmVudC5cbi8vXG4vLyBUaGUgcmVhc29uIHdlIGFwcGVuZCB0byBib3RoIHF1ZXVlcyBpcyBiZWNhdXNlIG90aGVyd2lzZSB3ZSBtaWdodCBkcm9wXG4vLyB1cGRhdGVzIHdpdGhvdXQgZXZlciBwcm9jZXNzaW5nIHRoZW0uIEZvciBleGFtcGxlLCBpZiB3ZSBvbmx5IGFkZCB1cGRhdGVzIHRvXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgc29tZSB1cGRhdGVzIGNvdWxkIGJlIGxvc3Qgd2hlbmV2ZXIgYSB3b3JrLWluXG4vLyAtcHJvZ3Jlc3MgcmVuZGVyIHJlc3RhcnRzIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LiBTaW1pbGFybHksIGlmIHdlIG9ubHkgYWRkXG4vLyB1cGRhdGVzIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCB0aGUgdXBkYXRlcyB3aWxsIGJlIGxvc3Qgd2hlbmV2ZXIgYW4gYWxyZWFkeVxuLy8gaW4tcHJvZ3Jlc3MgcXVldWUgY29tbWl0cyBhbmQgc3dhcHMgd2l0aCB0aGUgY3VycmVudCBxdWV1ZS4gSG93ZXZlciwgYnlcbi8vIGFkZGluZyB0byBib3RoIHF1ZXVlcywgd2UgZ3VhcmFudGVlIHRoYXQgdGhlIHVwZGF0ZSB3aWxsIGJlIHBhcnQgb2YgdGhlIG5leHRcbi8vIHdvcmstaW4tcHJvZ3Jlc3MuIChBbmQgYmVjYXVzZSB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBiZWNvbWVzIHRoZVxuLy8gY3VycmVudCBxdWV1ZSBvbmNlIGl0IGNvbW1pdHMsIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGFwcGx5aW5nIHRoZSBzYW1lXG4vLyB1cGRhdGUgdHdpY2UuKVxuLy9cbi8vIFByaW9yaXRpemF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLVxuLy9cbi8vIFVwZGF0ZXMgYXJlIG5vdCBzb3J0ZWQgYnkgcHJpb3JpdHksIGJ1dCBieSBpbnNlcnRpb247IG5ldyB1cGRhdGVzIGFyZSBhbHdheXNcbi8vIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4vL1xuLy8gVGhlIHByaW9yaXR5IGlzIHN0aWxsIGltcG9ydGFudCwgdGhvdWdoLiBXaGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZVxuLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIG9ubHkgdGhlIHVwZGF0ZXMgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5IGFyZVxuLy8gaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC4gSWYgd2Ugc2tpcCBhbiB1cGRhdGUgYmVjYXVzZSBpdCBoYXMgaW5zdWZmaWNpZW50XG4vLyBwcmlvcml0eSwgaXQgcmVtYWlucyBpbiB0aGUgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGxhdGVyLCBkdXJpbmcgYSBsb3dlclxuLy8gcHJpb3JpdHkgcmVuZGVyLiBDcnVjaWFsbHksIGFsbCB1cGRhdGVzIHN1YnNlcXVlbnQgdG8gYSBza2lwcGVkIHVwZGF0ZSBhbHNvXG4vLyByZW1haW4gaW4gdGhlIHF1ZXVlICpyZWdhcmRsZXNzIG9mIHRoZWlyIHByaW9yaXR5Ki4gVGhhdCBtZWFucyBoaWdoIHByaW9yaXR5XG4vLyB1cGRhdGVzIGFyZSBzb21ldGltZXMgcHJvY2Vzc2VkIHR3aWNlLCBhdCB0d28gc2VwYXJhdGUgcHJpb3JpdGllcy4gV2UgYWxzb1xuLy8ga2VlcCB0cmFjayBvZiBhIGJhc2Ugc3RhdGUsIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgYmVmb3JlIHRoZSBmaXJzdFxuLy8gdXBkYXRlIGluIHRoZSBxdWV1ZSBpcyBhcHBsaWVkLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgR2l2ZW4gYSBiYXNlIHN0YXRlIG9mICcnLCBhbmQgdGhlIGZvbGxvd2luZyBxdWV1ZSBvZiB1cGRhdGVzXG4vL1xuLy8gICAgIEExIC0gQjIgLSBDMSAtIEQyXG4vL1xuLy8gICB3aGVyZSB0aGUgbnVtYmVyIGluZGljYXRlcyB0aGUgcHJpb3JpdHksIGFuZCB0aGUgdXBkYXRlIGlzIGFwcGxpZWQgdG8gdGhlXG4vLyAgIHByZXZpb3VzIHN0YXRlIGJ5IGFwcGVuZGluZyBhIGxldHRlciwgUmVhY3Qgd2lsbCBwcm9jZXNzIHRoZXNlIHVwZGF0ZXMgYXNcbi8vICAgdHdvIHNlcGFyYXRlIHJlbmRlcnMsIG9uZSBwZXIgZGlzdGluY3QgcHJpb3JpdHkgbGV2ZWw6XG4vL1xuLy8gICBGaXJzdCByZW5kZXIsIGF0IHByaW9yaXR5IDE6XG4vLyAgICAgQmFzZSBzdGF0ZTogJydcbi8vICAgICBVcGRhdGVzOiBbQTEsIEMxXVxuLy8gICAgIFJlc3VsdCBzdGF0ZTogJ0FDJ1xuLy9cbi8vICAgU2Vjb25kIHJlbmRlciwgYXQgcHJpb3JpdHkgMjpcbi8vICAgICBCYXNlIHN0YXRlOiAnQScgICAgICAgICAgICA8LSAgVGhlIGJhc2Ugc3RhdGUgZG9lcyBub3QgaW5jbHVkZSBDMSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVjYXVzZSBCMiB3YXMgc2tpcHBlZC5cbi8vICAgICBVcGRhdGVzOiBbQjIsIEMxLCBEMl0gICAgICA8LSAgQzEgd2FzIHJlYmFzZWQgb24gdG9wIG9mIEIyXG4vLyAgICAgUmVzdWx0IHN0YXRlOiAnQUJDRCdcbi8vXG4vLyBCZWNhdXNlIHdlIHByb2Nlc3MgdXBkYXRlcyBpbiBpbnNlcnRpb24gb3JkZXIsIGFuZCByZWJhc2UgaGlnaCBwcmlvcml0eVxuLy8gdXBkYXRlcyB3aGVuIHByZWNlZGluZyB1cGRhdGVzIGFyZSBza2lwcGVkLCB0aGUgZmluYWwgcmVzdWx0IGlzIGRldGVybWluaXN0aWNcbi8vIHJlZ2FyZGxlc3Mgb2YgcHJpb3JpdHkuIEludGVybWVkaWF0ZSBzdGF0ZSBtYXkgdmFyeSBhY2NvcmRpbmcgdG8gc3lzdGVtXG4vLyByZXNvdXJjZXMsIGJ1dCB0aGUgZmluYWwgc3RhdGUgaXMgYWx3YXlzIHRoZSBzYW1lLlxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzO1xuXG4vLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxudmFyIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdm9pZCAwO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbnZhciByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbntcbiAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xuICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZmlyc3RVcGRhdGU6IG51bGwsXG4gICAgbGFzdFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGxhc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50UXVldWUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgIGZpcnN0VXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RVcGRhdGUsXG4gICAgbGFzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RVcGRhdGUsXG5cbiAgICAvLyBUT0RPOiBXaXRoIHJlc3VtaW5nLCBpZiB3ZSBiYWlsIG91dCBhbmQgcmVzdXNlIHRoZSBjaGlsZCB0cmVlLCB3ZSBzaG91bGRcbiAgICAvLyBrZWVwIHRoZXNlIGVmZmVjdHMuXG4gICAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG5cbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG5cbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsLFxuICAgIG5leHRFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZSwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3RVcGRhdGUgPSBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGUgaW5jb21pbmcgdXBkYXRlIGhhcyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiBvZiBhbnkgdXBkYXRlIGluIHRoZVxuICAgIC8vIHF1ZXVlLiBVcGRhdGUgdGhlIHF1ZXVlJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBVcGRhdGUgcXVldWVzIGFyZSBjcmVhdGVkIGxhemlseS5cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IHZvaWQgMDtcbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBvbmUgZmliZXIuXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIG93bmVycy5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOZWl0aGVyIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENyZWF0ZSBuZXcgb25lcy5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShmaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQm90aCBvd25lcnMgaGF2ZSBhbiB1cGRhdGUgcXVldWUuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChxdWV1ZTIgPT09IG51bGwgfHwgcXVldWUxID09PSBxdWV1ZTIpIHtcbiAgICAvLyBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgcXVldWUuXG4gICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gcXVldWVzLiBXZSBuZWVkIHRvIGFwcGVuZCB0aGUgdXBkYXRlIHRvIGJvdGggcXVldWVzLFxuICAgIC8vIHdoaWxlIGFjY291bnRpbmcgZm9yIHRoZSBwZXJzaXN0ZW50IHN0cnVjdHVyZSBvZiB0aGUgbGlzdCDigJQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRoZSBzYW1lIHVwZGF0ZSB0byBiZSBhZGRlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAocXVldWUxLmxhc3RVcGRhdGUgPT09IG51bGwgfHwgcXVldWUyLmxhc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIE9uZSBvZiB0aGUgcXVldWVzIGlzIG5vdCBlbXB0eS4gV2UgbXVzdCBhZGQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUyLCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBxdWV1ZXMgYXJlIG5vbi1lbXB0eS4gVGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGluIGJvdGggbGlzdHMsXG4gICAgICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIG9ubHkgYXBwZW5kIHRvIG9uZSBvZiB0aGUgbGlzdHMuXG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0VXBkYXRlYCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgICAgIHF1ZXVlMi5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBxdWV1ZTEgfHwgcXVldWUyICE9PSBudWxsICYmIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUyKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBnbyBpbnRvIGEgc2VwYXJhdGUgbGlzdCwgYW5kIG9ubHkgb24gdGhlIHdvcmstaW4tXG4gIC8vIHByb2dyZXNzIHF1ZXVlLlxuICB2YXIgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IEkgcHV0IHRoaXMgaGVyZSByYXRoZXIgdGhhbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyBzbyB0aGF0IHdlIGRvbid0XG4gICAgLy8gY2xvbmUgdGhlIHF1ZXVlIHVubmVjZXNzYXJpbHkuIFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvXG4gICAgLy8gc3RydWN0dXJlIHRoaXMuXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3NRdWV1ZSk7XG4gIH1cblxuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGhhc2UgdXBkYXRlXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3NRdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzUXVldWUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZSBpbmNvbWluZyB1cGRhdGUgaGFzIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIG9mIGFueSB1cGRhdGUgaW4gdGhlXG4gICAgLy8gcXVldWUuIFVwZGF0ZSB0aGUgcXVldWUncyBleHBpcmF0aW9uIHRpbWUuXG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUpIHtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgcXVldWUsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9uZSBpdCBmaXJzdC5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnQudXBkYXRlUXVldWUpIHtcbiAgICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGF0ZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIF9wYXlsb2FkO1xuICAgICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkMiA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkMiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gSW5zdWZmaWNpZW50IHByaW9yaXR5LiBCYWlsb3V0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHF1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSk7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlO1xuICB9XG5cbiAgLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG4gIHZhciBuZXdCYXNlU3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIHZhciBuZXdGaXJzdFVwZGF0ZSA9IG51bGw7XG4gIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdFVwZGF0ZTtcbiAgdmFyIHJlc3VsdFN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgc2tpcHBlZCB1cGRhdGUuIEl0IHdpbGwgYmUgdGhlIGZpcnN0IHVwZGF0ZSBpblxuICAgICAgICAvLyB0aGUgbmV3IGxpc3QuXG4gICAgICAgIG5ld0ZpcnN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgIC8vIGlzIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCByZXN1bHRTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdEVmZmVjdCA9IHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgLy8gU2VwYXJhdGVseSwgaXRlcmF0ZSB0aG91Z2ggdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgdmFyIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB1cGRhdGUgPSBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIF91cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoX3VwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgY2FwdHVyZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0IGlzXG4gICAgICAgIC8vIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBfdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBfdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcmVzdWx0U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICB2YXIgX2NhbGxiYWNrMiA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAgIGlmIChfY2FsbGJhY2syICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0Lm5leHRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfVxuICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwgJiYgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHByb2Nlc3NlZCBldmVyeSB1cGRhdGUsIHdpdGhvdXQgc2tpcHBpbmcuIFRoYXQgbWVhbnMgdGhlIG5ldyBiYXNlXG4gICAgLy8gc3RhdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBzdGF0ZS5cbiAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgcXVldWUuZmlyc3RVcGRhdGUgPSBuZXdGaXJzdFVwZGF0ZTtcbiAgcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIElmIHRoZSBmaW5pc2hlZCByZW5kZXIgaW5jbHVkZWQgY2FwdHVyZWQgdXBkYXRlcywgYW5kIHRoZXJlIGFyZSBzdGlsbFxuICAvLyBsb3dlciBwcmlvcml0eSB1cGRhdGVzIGxlZnQgb3Zlciwgd2UgbmVlZCB0byBrZWVwIHRoZSBjYXB0dXJlZCB1cGRhdGVzXG4gIC8vIGluIHRoZSBxdWV1ZSBzbyB0aGF0IHRoZXkgYXJlIHJlYmFzZWQgYW5kIG5vdCBkcm9wcGVkIG9uY2Ugd2UgcHJvY2VzcyB0aGVcbiAgLy8gcXVldWUgYWdhaW4gYXQgdGhlIGxvd2VyIHByaW9yaXR5LlxuICBpZiAoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSm9pbiB0aGUgY2FwdHVyZWQgdXBkYXRlIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgbm9ybWFsIGxpc3QuXG4gICAgaWYgKGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlLm5leHQgPSBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgICBmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgdmFyIGVmZmVjdCA9IGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3Q7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RFZmZlY3QgPSBudWxsO1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazMgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazMgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrMywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIGVmZmVjdCA9IGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdDtcbiAgZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0ID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSBudWxsO1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazQgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazQgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrNCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoc291cmNlKVxuICB9O1xufVxuXG52YXIgcHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgY2hhbmdlZEJpdHNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCk7XG5cbnZhciByZW5kZXJlclNpZ2lsID0gdm9pZCAwO1xue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBwdXNoKGNoYW5nZWRCaXRzQ3Vyc29yLCBjb250ZXh0Ll9jaGFuZ2VkQml0cywgcHJvdmlkZXJGaWJlcik7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHByb3ZpZGVyQ3Vyc29yLCBwcm92aWRlckZpYmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByb3ZpZGVyRmliZXIucGVuZGluZ1Byb3BzLnZhbHVlO1xuICAgIGNvbnRleHQuX2NoYW5nZWRCaXRzID0gcHJvdmlkZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAge1xuICAgICAgIShjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSByZW5kZXJlclNpZ2lsKSA/IHdhcm5pbmcoZmFsc2UsICdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaChjaGFuZ2VkQml0c0N1cnNvciwgY29udGV4dC5fY2hhbmdlZEJpdHMyLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcbiAgICBwdXNoKHByb3ZpZGVyQ3Vyc29yLCBwcm92aWRlckZpYmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBwcm92aWRlckZpYmVyLnBlbmRpbmdQcm9wcy52YWx1ZTtcbiAgICBjb250ZXh0Ll9jaGFuZ2VkQml0czIgPSBwcm92aWRlckZpYmVyLnN0YXRlTm9kZTtcbiAgICB7XG4gICAgICAhKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHJlbmRlcmVyU2lnaWwpID8gd2FybmluZyhmYWxzZSwgJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY2hhbmdlZEJpdHMgPSBjaGFuZ2VkQml0c0N1cnNvci5jdXJyZW50O1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcblxuICBwb3AocHJvdmlkZXJDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICBwb3AoY2hhbmdlZEJpdHNDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuXG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgY29udGV4dC5fY2hhbmdlZEJpdHMgPSBjaGFuZ2VkQml0cztcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICAgIGNvbnRleHQuX2NoYW5nZWRCaXRzMiA9IGNoYW5nZWRCaXRzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRDdXJyZW50VmFsdWUoY29udGV4dCkge1xuICByZXR1cm4gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Q2hhbmdlZEJpdHMoY29udGV4dCkge1xuICByZXR1cm4gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jaGFuZ2VkQml0cyA6IGNvbnRleHQuX2NoYW5nZWRCaXRzMjtcbn1cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gIC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIGNvbW1pdFRpbWUgPSAwO1xuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbW1pdFRpbWUgPSBub3coKTtcbn1cblxuLyoqXG4gKiBUaGUgXCJhY3R1YWxcIiByZW5kZXIgdGltZSBpcyB0b3RhbCB0aW1lIHJlcXVpcmVkIHRvIHJlbmRlciB0aGUgZGVzY2VuZGFudHMgb2YgYSBQcm9maWxlciBjb21wb25lbnQuXG4gKiBUaGlzIHRpbWUgaXMgc3RvcmVkIGFzIGEgc3RhY2ssIHNpbmNlIFByb2ZpbGVycyBjYW4gYmUgbmVzdGVkLlxuICogVGhpcyB0aW1lIGlzIHN0YXJ0ZWQgZHVyaW5nIHRoZSBcImJlZ2luXCIgcGhhc2UgYW5kIHN0b3BwZWQgZHVyaW5nIHRoZSBcImNvbXBsZXRlXCIgcGhhc2UuXG4gKiBJdCBpcyBwYXVzZWQgKGFuZCBhY2N1bXVsYXRlZCkgaW4gdGhlIGV2ZW50IG9mIGFuIGludGVycnVwdGlvbiBvciBhbiBhYm9ydGVkIHJlbmRlci5cbiAqL1xuXG52YXIgZmliZXJTdGFjayQxID0gdm9pZCAwO1xuXG57XG4gIGZpYmVyU3RhY2skMSA9IFtdO1xufVxuXG52YXIgdGltZXJQYXVzZWRBdCA9IDA7XG52YXIgdG90YWxFbGFwc2VkUGF1c2VUaW1lID0gMDtcblxuZnVuY3Rpb24gY2hlY2tBY3R1YWxSZW5kZXJUaW1lU3RhY2tFbXB0eSgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICAhKGZpYmVyU3RhY2skMS5sZW5ndGggPT09IDApID8gd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQWN0dWFsUmVuZGVyVGltZVN0YXJ0ZWQoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICBmaWJlclN0YWNrJDEucHVzaChmaWJlcik7XG4gIH1cblxuICBmaWJlci5hY3R1YWxEdXJhdGlvbiA9IG5vdygpIC0gZmliZXIuYWN0dWFsRHVyYXRpb24gLSB0b3RhbEVsYXBzZWRQYXVzZVRpbWU7XG4gIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiBwYXVzZUFjdHVhbFJlbmRlclRpbWVySWZSdW5uaW5nKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRpbWVyUGF1c2VkQXQgPT09IDApIHtcbiAgICB0aW1lclBhdXNlZEF0ID0gbm93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkRWxhcHNlZEFjdHVhbFJlbmRlclRpbWUoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICAhKGZpYmVyID09PSBmaWJlclN0YWNrJDEucG9wKCkpID8gd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgKCVzKSBwb3BwZWQuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikpIDogdm9pZCAwO1xuICB9XG5cbiAgZmliZXIuYWN0dWFsRHVyYXRpb24gPSBub3coKSAtIHRvdGFsRWxhcHNlZFBhdXNlVGltZSAtIGZpYmVyLmFjdHVhbER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiByZXNldEFjdHVhbFJlbmRlclRpbWVyKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdG90YWxFbGFwc2VkUGF1c2VUaW1lID0gMDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQWN0dWFsUmVuZGVyVGltZXJJZlBhdXNlZCgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0aW1lclBhdXNlZEF0ID4gMCkge1xuICAgIHRvdGFsRWxhcHNlZFBhdXNlVGltZSArPSBub3coKSAtIHRpbWVyUGF1c2VkQXQ7XG4gICAgdGltZXJQYXVzZWRBdCA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgXCJiYXNlXCIgcmVuZGVyIHRpbWUgaXMgdGhlIGR1cmF0aW9uIG9mIHRoZSDigJxiZWdpbuKAnSBwaGFzZSBvZiB3b3JrIGZvciBhIHBhcnRpY3VsYXIgZmliZXIuXG4gKiBUaGlzIHRpbWUgaXMgbWVhc3VyZWQgYW5kIHN0b3JlZCBvbiBlYWNoIGZpYmVyLlxuICogVGhlIHRpbWUgZm9yIGFsbCBzaWJsaW5nIGZpYmVycyBhcmUgYWNjdW11bGF0ZWQgYW5kIHN0b3JlZCBvbiB0aGVpciBwYXJlbnQgZHVyaW5nIHRoZSBcImNvbXBsZXRlXCIgcGhhc2UuXG4gKiBJZiBhIGZpYmVyIGJhaWxzIG91dCAoc0NVIGZhbHNlKSB0aGVuIGl0cyBcImJhc2VcIiB0aW1lciBpcyBjYW5jZWxsZWQgYW5kIHRoZSBmaWJlciBpcyBub3QgdXBkYXRlZC5cbiAqL1xuXG52YXIgYmFzZVN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiByZWNvcmRFbGFwc2VkQmFzZVJlbmRlclRpbWVJZlJ1bm5pbmcoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChiYXNlU3RhcnRUaW1lICE9PSAtMSkge1xuICAgIGZpYmVyLnNlbGZCYXNlVGltZSA9IG5vdygpIC0gYmFzZVN0YXJ0VGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydEJhc2VSZW5kZXJUaW1lcigpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHtcbiAgICBpZiAoYmFzZVN0YXJ0VGltZSAhPT0gLTEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3Qgc3RhcnQgYmFzZSB0aW1lciB0aGF0IGlzIGFscmVhZHkgcnVubmluZy4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG4gIGJhc2VTdGFydFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VTdGFydFRpbWUgPSAtMTtcbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuXG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzblxcJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUod29ya0luUHJvZ3Jlc3MsIHBhcnRpYWxTdGF0ZSk7XG4gIH1cbiAgLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuXG4gIC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIHtcbiAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZyhmYWxzZSwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAhbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA/IHdhcm5pbmcoZmFsc2UsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAhbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA/IHdhcm5pbmcoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgIW5vSW5zdGFuY2VQcm9wVHlwZXMgPyB3YXJuaW5nKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICFub0luc3RhbmNlQ29udGV4dFR5cGVzID8gd2FybmluZyhmYWxzZSwgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRVbm1vdW50ID8gd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICEoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzKSA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICFub0luc3RhbmNlRGVmYXVsdFByb3BzID8gd2FybmluZyhmYWxzZSwgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKHR5cGUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKHR5cGUpO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cblxuICAgIHZhciBub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA/IHdhcm5pbmcoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCgpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSB0eXBlb2YgdHlwZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA/IHdhcm5pbmcoZmFsc2UsICclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBfc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAhKHR5cGVvZiB0eXBlLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyB3YXJuaW5nKGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIG5lZWRzQ29udGV4dCA9IGlzQ29udGV4dENvbnN1bWVyKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG5cbiAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICB7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBEaWQgbm90IHByb3Blcmx5IGluaXRpYWxpemUgc3RhdGUgZHVyaW5nIGNvbnN0cnVjdGlvbi4gJyArICdFeHBlY3RlZCBzdGF0ZSB0byBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXMgJXMuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgc3RvcFBoYXNlVGltZXIoKTtcblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICB9XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG5cbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuXG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0ge307XG5cbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBzdHJpbmcgcmVmLCBcIiVzXCIswqBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIocmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgdHlwZW9mIGN1cnJlbnQucmVmID09PSAnZnVuY3Rpb24nICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcXG4yLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIHJlbmRlciBtZXRob2RcXG4zLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDcoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ3KCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNygpKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG4vLyBUaGUgZGVlcGVzdCBGaWJlciBvbiB0aGUgc3RhY2sgaW52b2x2ZWQgaW4gYSBoeWRyYXRpb24gY29udGV4dC5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG4gIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gIGZpYmVyLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG4gIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgfVxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTtcbiAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICB7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIC8vIElmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaHlkcmF0aW5nIGJ1dCB3ZSdyZSBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LCB0aGVuXG4gICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAvLyBzaWJsaW5ncy5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG4gIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gZmFsc2U7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZWxlc3NSZWZzID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbi8vIFRPRE86IFJlbW92ZSB0aGlzIGFuZCB1c2UgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGRpcmVjdGx5LlxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbikge1xuICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlbmRlciA9IHdvcmtJblByb2dyZXNzLnR5cGUucmVuZGVyO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5yZWYgOiBudWxsO1xuICAgIGlmIChyZWYgPT09IGN1cnJlbnRSZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXIobmV4dFByb3BzLCByZWYpO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiByZWYgIT09IG51bGwgfHwgY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogY29uc2lkZXIgYnJpbmdpbmcgZm4uc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkgYmFjay5cbiAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gIH1cblxuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV4dENoaWxkcmVuID0gZm4obmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpICE9PSBOb0VmZmVjdDtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAvLyBSZXJlbmRlclxuICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgKCFlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbSBjYXRjaCBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICBzdG9wQmFzZVJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgaWYgKGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHR3aWNlOiBmaXJzdCB0byBkZWxldGVcbiAgICAvLyBhbGwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAvLyBOb3cgd2UgY2FuIGNvbnRpbnVlIHJlY29uY2lsaW5nIGxpa2Ugbm9ybWFsLiBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgLy8gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgfVxuICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG4gIGlmIChoYXNDb250ZXh0KSB7XG4gICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuZWxlbWVudCA6IG51bGw7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV4dFByb3BzLCBudWxsLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAgIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAvLyBub3QgaHlkcmF0aW5nLlxuXG4gICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgIC8vIHdvcmtzIGFzIGV4cGVjdGVkLiBXZSBtdXN0IHJlc2V0IHRoaXMgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgY2hpbGRyZW4gbW91bnQgaW50byB0aGlzIHJvb3Qgd2l0aG91dCB0cmFja2luZ1xuICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgLy8gcm9vdC5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAvLyBJZiB0aGVyZSBpcyBubyB1cGRhdGUgcXVldWUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB0aGUgcm9vdCBoYXMgbm8gcHJvcHMuXG4gIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2UgaWYgKG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgIHZhciBpc0hpZGRlbiA9IHdvcmtJblByb2dyZXNzLm1vZGUgJiBBc3luY01vZGUgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpO1xuICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgLy8gQmVmb3JlIGJhaWxpbmcgb3V0LCBtYWtlIHN1cmUgd2UndmUgZGVwcmlvcml0aXplZCBhIGhpZGRlbiBjb21wb25lbnQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIH1cbiAgICBpZiAoIWlzSGlkZGVuIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlcikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSByZW5kZXJpbmcgYSBoaWRkZW4gbm9kZSBhdCBoaWRkZW4gcHJpb3JpdHksIGRvbid0IGJhaWxvdXQuIFRoZVxuICAgIC8vIHBhcmVudCBpcyBjb21wbGV0ZSwgYnV0IHRoZSBjaGlsZHJlbiBtYXkgbm90IGJlLlxuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBBc3luY01vZGUgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAhKGN1cnJlbnQgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSBmbihwcm9wcywgY29udGV4dCk7XG4gIH1cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICB7XG4gICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgIGlmIChfQ29tcG9uZW50KSB7XG4gICAgICAgICEhX0NvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIF9Db21wb25lbnQuZGlzcGxheU5hbWUgfHwgX0NvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiVzJXMnLCBpbmZvLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclczogU3RhdGVsZXNzIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBwcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVvdXRDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHByZXZQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cbiAgICB2YXIgcHJldkRpZFRpbWVvdXQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmVuZGVyIHRoZSBub3JtYWwgc3RhdGUuIElmIHdlIGRpZCxcbiAgICAvLyBhbmQgd2UgdGltZWQgb3V0LCByZW5kZXIgdGhlIHBsYWNlaG9sZGVyIHN0YXRlLlxuICAgIHZhciBhbHJlYWR5Q2FwdHVyZWQgPSAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0O1xuICAgIHZhciBuZXh0RGlkVGltZW91dCA9ICFhbHJlYWR5Q2FwdHVyZWQ7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBwcmV2UHJvcHMgJiYgbmV4dERpZFRpbWVvdXQgPT09IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlciA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gcmVuZGVyKG5leHREaWRUaW1lb3V0KTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0RGlkVGltZW91dDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7XG4gICAgLy8gVmlzaXQgdGhpcyBmaWJlci5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBmaWJlci5zdGF0ZU5vZGUgfCAwO1xuICAgICAgICBpZiAoZmliZXIudHlwZSA9PT0gY29udGV4dCAmJiAob2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZ1xuICAgICAgICAgIC8vIHRoZSBhbHRlcm5hdGVzLlxuICAgICAgICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAgIC8vIGFuY2VzdG9yIHBhdGggYWxyZWFkeSBoYXMgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIHRoYW4gYSBtYXRjaGluZyBjb25zdW1lci4gV2hlbiB3ZSByZW5kZXIgdGhlXG4gICAgICAgICAgLy8gY29uc3VtZXIsIHdlJ2xsIGNvbnRpbnVlIHNjYW5uaW5nIGZyb20gdGhhdCBwb2ludC4gVGhpcyB3YXkgdGhlXG4gICAgICAgICAgLy8gc2Nhbm5pbmcgd29yayBpcyB0aW1lLXNsaWNlZC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBjYW5CYWlsT25Qcm9wcyA9IHRydWU7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICBjYW5CYWlsT25Qcm9wcyA9IGZhbHNlO1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gMDtcbiAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAge1xuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFuZ2VkQml0cyA9IHZvaWQgMDtcbiAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCByZW5kZXJcbiAgICBjaGFuZ2VkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2xkUHJvcHMudmFsdWUgPT09IG5ld1Byb3BzLnZhbHVlKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiBjYW5CYWlsT25Qcm9wcykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSAwO1xuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgICAgLy8gVXNlIE9iamVjdC5pcyB0byBjb21wYXJlIHRoZSBuZXcgY29udGV4dCB2YWx1ZSB0byB0aGUgb2xkIHZhbHVlLlxuICAgICAgLy8gSW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUgJiYgKG9sZFZhbHVlICE9PSAwIHx8IDEgLyBvbGRWYWx1ZSA9PT0gMSAvIG5ld1ZhbHVlKSB8fCBvbGRWYWx1ZSAhPT0gb2xkVmFsdWUgJiYgbmV3VmFsdWUgIT09IG5ld1ZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICApIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgY2FuQmFpbE9uUHJvcHMpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICAgICAge1xuICAgICAgICAgICEoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyhmYWxzZSwgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlZEJpdHMgfD0gMDtcblxuICAgICAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgY2FuQmFpbE9uUHJvcHMpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IDA7XG4gICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY2hhbmdlZEJpdHM7XG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICB2YXIgbmV3VmFsdWUgPSBnZXRDb250ZXh0Q3VycmVudFZhbHVlKGNvbnRleHQpO1xuICB2YXIgY2hhbmdlZEJpdHMgPSBnZXRDb250ZXh0Q2hhbmdlZEJpdHMoY29udGV4dCk7XG5cbiAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICB9IGVsc2UgaWYgKGNoYW5nZWRCaXRzID09PSAwICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAgdmFyIG9ic2VydmVkQml0cyA9IG5ld1Byb3BzLnVuc3RhYmxlX29ic2VydmVkQml0cztcbiAgaWYgKG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCkge1xuICAgIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBieSBkZWZhdWx0XG4gICAgb2JzZXJ2ZWRCaXRzID0gTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuICB9XG4gIC8vIFN0b3JlIHRoZSBvYnNlcnZlZEJpdHMgb24gdGhlIGZpYmVyJ3Mgc3RhdGVOb2RlIGZvciBxdWljayBhY2Nlc3MuXG4gIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG9ic2VydmVkQml0cztcblxuICBpZiAoKGNoYW5nZWRCaXRzICYgb2JzZXJ2ZWRCaXRzKSAhPT0gMCkge1xuICAgIC8vIENvbnRleHQgY2hhbmdlIHByb3BhZ2F0aW9uIHN0b3BzIGF0IG1hdGNoaW5nIGNvbnN1bWVycywgZm9yIHRpbWUtXG4gICAgLy8gc2xpY2luZy4gQ29udGludWUgdGhlIHByb3BhZ2F0aW9uIGhlcmUuXG4gICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAvLyBTa2lwIG92ZXIgYSBtZW1vaXplZCBwYXJlbnQgd2l0aCBhIGJpdG1hc2sgYmFpbG91dCBldmVuXG4gICAgLy8gaWYgd2UgYmVnYW4gd29ya2luZyBvbiBpdCBiZWNhdXNlIG9mIGEgZGVlcGVyIG1hdGNoaW5nIGNoaWxkLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICAvLyBUaGVyZSBpcyBubyBiYWlsb3V0IG9uIGBjaGlsZHJlbmAgZXF1YWxpdHkgYmVjYXVzZSB3ZSBleHBlY3QgcGVvcGxlXG4gIC8vIHRvIG9mdGVuIHBhc3MgYSBib3VuZCBtZXRob2QgYXMgYSBjaGlsZCwgYnV0IGl0IG1heSByZWZlcmVuY2VcbiAgLy8gYHRoaXMuc3RhdGVgIG9yIGB0aGlzLnByb3BzYCAoYW5kIHRodXMgbmVlZHMgdG8gcmUtcmVuZGVyIG9uIGBzZXRTdGF0ZWApLlxuXG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmcoZmFsc2UsICdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4pO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbi8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICB9XG5cbiAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAvLyBtb3JlIHdvcmsgdG8gZG8uIEhvd2V2ZXIsIHNpbmNlIHdlIGRvbid0IGhhdmUgYSBzZXBhcmF0aW9uIG9mIHRoaXNcbiAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gIC8vIGJhaWwgb3V0IGhlcmUgaWYgdGhlIGNoaWxkcmVuIGhhcyBubyBtb3JlIHdvcmsgYXQgdGhpcyBwcmlvcml0eSBsZXZlbC5cbiAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gIC8vICAgLy8gY29tbWl0dGVkIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSBnZXQgcHJvcGVybHkgdHJhbnNmZXJyZWQgdXAuXG4gIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiBudWxsO1xuICAvLyB9XG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BCYXNlUmVuZGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgfVxuXG4gIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gIC8vIEhvdyBjYW4gdGhhdCBoYXBwZW4/IEhvdyBpcyB0aGlzIG5vdCBiZWluZyBjbG9uZWQ/XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbmZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBtYXJrQWN0dWFsUmVuZGVyVGltZVN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjYXNlIFRpbWVvdXRDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlVGltZW91dENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0VGV4dCQxID0gdm9pZCAwO1xuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG5cbiAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHdvcmtJblByb2dyZXNzLCBjaGlsZHJlblVuY2hhbmdlZCwgcmVjeWNsYWJsZUluc3RhbmNlKTtcbiAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgcmVjb3JkRWxhcHNlZEFjdHVhbFJlbmRlclRpbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgLy8gVE9ETzogRXhwZXJpZW5jaW5nIGFuIGVycm9yIHdoZXJlIG9sZFByb3BzIGlzIG51bGwuIFN1Z2dlc3RzIGEgaG9zdFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgICAgICAgLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cbiAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVGltZW91dENvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEVycm9yIGNhc2VzXG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG4gIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZXJyb3IgJiYgZXJyb3Iuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgaWYgKHN1cHByZXNzTG9nZ2luZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwnICsgY29tcG9uZW50TmFtZSArICc+IGNvbXBvbmVudDonIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1JlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoICcgKyAoJ3VzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy5cXG4nICsgJ1JlY3JlYXRpbmcgdGhlIHRyZWUgZnJvbSBzY3JhdGNoIGZhaWxlZCBzbyBSZWFjdCB3aWxsIHVubW91bnQgdGhlIHRyZWUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWVycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG4gIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgaWYgKHN0YWNrID09PSBudWxsICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgIHN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UpIDogbnVsbCxcbiAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnLFxuICAgIGVycm9yOiBlcnJvckluZm8udmFsdWUsXG4gICAgZXJyb3JCb3VuZGFyeTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5TmFtZTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGZhbHNlLFxuICAgIHdpbGxSZXRyeTogZmFsc2VcbiAgfTtcblxuICBpZiAoYm91bmRhcnkgIT09IG51bGwgJiYgYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeSA9IGJvdW5kYXJ5LnN0YXRlTm9kZTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeSk7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgIGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGUgJiYgZS5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xufTtcblxuLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgdW5tb3VudEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDMobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY3VycmVudFRpbWUsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIFByb2ZpbGVyLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBUaW1lb3V0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBUaW1lb3V0cy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgKyAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJXMnLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yayksIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcbiAgfVxuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gIHZhciBub2RlID0gcm9vdDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIGN1cnJlbnQucmV0dXJuID0gbnVsbDtcbiAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gIGlmIChjdXJyZW50LmFsdGVybmF0ZSkge1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXG4gIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVySW5mbyk7XG4gIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG4gIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcbiAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG4gIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgcmVzZXRUZXh0Q29udGVudChwYXJlbnQpO1xuICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIC8vIElmIHRoZSBpbnNlcnRpb24gaXRzZWxmIGlzIGEgcG9ydGFsLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpIHtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShwYXJlbnQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgLy8gQWZ0ZXIgYWxsIHRoZSBjaGlsZHJlbiBoYXZlIHVubW91bnRlZCwgaXQgaXMgbm93IHNhZmUgdG8gcmVtb3ZlIHRoZVxuICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50KSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICB9XG4gIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgIHZhciBvblJlbmRlciA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm9uUmVuZGVyO1xuICAgICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZVRpbWUsIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGdldENvbW1pdFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgVGltZW91dENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB1cGRhdGUucGF5bG9hZCA9IHsgZWxlbWVudDogbnVsbCB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoO1xuICBpZiAoZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICYmIHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoKGVycm9yKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICBpZiAoIWVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCB8fCBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGluZyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gT25jZSB0aGUgcHJvbWlzZSByZXNvbHZlcywgd2Ugc2hvdWxkIHRyeSByZW5kZXJpbmcgdGhlIG5vbi1cbiAgLy8gcGxhY2Vob2xkZXIgc3RhdGUgYWdhaW4uXG4gIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmluaXNoZWRXb3JrKTtcbiAgdmFyIHJlY292ZXJ5VXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgZW5xdWV1ZVVwZGF0ZShmaW5pc2hlZFdvcmssIHJlY292ZXJ5VXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gIHNjaGVkdWxlV29yayQxKGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByZW5kZXJJc0V4cGlyZWQsIHJlbmRlckV4cGlyYXRpb25UaW1lLCBjdXJyZW50VGltZU1zKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZWZmZWN0VGFnIHw9IEluY29tcGxldGU7XG4gIC8vIEl0cyBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgdmFyIHRoZW5hYmxlID0gdmFsdWU7XG5cbiAgICB2YXIgZXhwaXJhdGlvblRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhyZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHN0YXJ0VGltZU1zID0gZXhwaXJhdGlvblRpbWVNcyAtIDUwMDA7XG4gICAgdmFyIGVsYXBzZWRNcyA9IGN1cnJlbnRUaW1lTXMgLSBzdGFydFRpbWVNcztcbiAgICBpZiAoZWxhcHNlZE1zIDwgMCkge1xuICAgICAgZWxhcHNlZE1zID0gMDtcbiAgICB9XG4gICAgdmFyIHJlbWFpbmluZ1RpbWVNcyA9IGV4cGlyYXRpb25UaW1lTXMgLSBjdXJyZW50VGltZU1zO1xuXG4gICAgLy8gRmluZCB0aGUgZWFybGllc3QgdGltZW91dCBvZiBhbGwgdGhlIHRpbWVvdXRzIGluIHRoZSBhbmNlc3RvciBwYXRoLlxuICAgIC8vIFRPRE86IEFsdGVybmF0aXZlbHksIHdlIGNvdWxkIHN0b3JlIHRoZSBlYXJsaWVzdCB0aW1lb3V0IG9uIHRoZSBjb250ZXh0XG4gICAgLy8gc3RhY2ssIHJhdGhlciB0aGFuIHNlYXJjaGluZyBvbiBldmVyeSBzdXNwZW5kLlxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICB2YXIgZWFybGllc3RUaW1lb3V0TXMgPSAtMTtcbiAgICBzZWFyY2hGb3JFYXJsaWVzdFRpbWVvdXQ6IGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBUaW1lb3V0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3dvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gQSBwYXJlbnQgVGltZW91dCBhbHJlYWR5IGNvbW1pdHRlZCBpbiBhIHBsYWNlaG9sZGVyIHN0YXRlLiBXZVxuICAgICAgICAgIC8vIG5lZWQgdG8gaGFuZGxlIHRoaXMgcHJvbWlzZSBpbW1lZGlhdGVseS4gSW4gb3RoZXIgd29yZHMsIHdlXG4gICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHN1c3BlbmQgaW5zaWRlIGEgdHJlZSB0aGF0IGFscmVhZHkgZXhwaXJlZC5cbiAgICAgICAgICBlYXJsaWVzdFRpbWVvdXRNcyA9IDA7XG4gICAgICAgICAgYnJlYWsgc2VhcmNoRm9yRWFybGllc3RUaW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0UHJvcE1zID0gX3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5tcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0UHJvcE1zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmICh0aW1lb3V0UHJvcE1zIDw9IDApIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gMDtcbiAgICAgICAgICAgIGJyZWFrIHNlYXJjaEZvckVhcmxpZXN0VGltZW91dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVhcmxpZXN0VGltZW91dE1zID09PSAtMSB8fCB0aW1lb3V0UHJvcE1zIDwgZWFybGllc3RUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gdGltZW91dFByb3BNcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xKSB7XG4gICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSByZW1haW5pbmdUaW1lTXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF93b3JrSW5Qcm9ncmVzcyA9IF93b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgfSB3aGlsZSAoX3dvcmtJblByb2dyZXNzICE9PSBudWxsKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHJlbWFpbmluZyB0aW1lIHVudGlsIHRoZSB0aW1lb3V0LlxuICAgIHZhciBtc1VudGlsVGltZW91dCA9IGVhcmxpZXN0VGltZW91dE1zIC0gZWxhcHNlZE1zO1xuXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlciB8fCBtc1VudGlsVGltZW91dCA+IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgc3RpbGwgdGltZSByZW1haW5pbmcuXG4gICAgICBzdXNwZW5kUm9vdChyb290LCB0aGVuYWJsZSwgbXNVbnRpbFRpbWVvdXQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHZhciBvblJlc29sdmVPclJlamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0cnlTdXNwZW5kZWRSb290KHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH07XG4gICAgICB0aGVuYWJsZS50aGVuKG9uUmVzb2x2ZU9yUmVqZWN0LCBvblJlc29sdmVPclJlamVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIHRpbWUgcmVtYWluaW5nLiBOZWVkIHRvIGZhbGxiYWNrIHRvIHBsYWNlaG9sZGVyLlxuICAgICAgLy8gRmluZCB0aGUgbmVhcmVzdCB0aW1lb3V0IHRoYXQgY2FuIGJlIHJldHJpZWQuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3dpdGNoIChfd29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHJvb3QgZXhwaXJlZCwgYnV0IG5vIGZhbGxiYWNrIHdhcyBwcm92aWRlZC4gVGhyb3cgYVxuICAgICAgICAgICAgICAvLyBoZWxwZnVsIGVycm9yLlxuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBTeW5jID8gJ0Egc3luY2hyb25vdXMgdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBmYWxsYmFjayBVSSAnICsgJ3dhcyBwcm92aWRlZC4nIDogJ0FuIHVwZGF0ZSB3YXMgc3VzcGVuZGVkIGZvciBsb25nZXIgdGhhbiB0aGUgdGltZW91dCwgJyArICdidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHByb3ZpZGVkLic7XG4gICAgICAgICAgICAgIHZhbHVlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFRpbWVvdXRDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkge1xuICAgICAgICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICB2YXIgX29uUmVzb2x2ZU9yUmVqZWN0ID0gc2NoZWR1bGVQaW5nLmJpbmQobnVsbCwgX3dvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGVuYWJsZS50aGVuKF9vblJlc29sdmVPclJlamVjdCwgX29uUmVzb2x2ZU9yUmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgICAgICAgICAgIC8vIFRpbWVvdXQgYW5jZXN0b3IuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcyA9IF93b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID09PSAnZnVuY3Rpb24nICYmIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlcklzRXhwaXJlZCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBUaW1lb3V0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2VmZmVjdFRhZzIgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIGlmIChfZWZmZWN0VGFnMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgaWYgKGludGVycnVwdGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc3VtZSBpbiBjYXNlIHdlJ3JlIHBpY2tpbmcgdXAgb24gd29yayB0aGF0IHdhcyBwYXVzZWQuXG4gICAgICByZXN1bWVBY3R1YWxSZW5kZXJUaW1lcklmUGF1c2VkKCk7XG4gICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZShpbnRlcnJ1cHRlZFdvcmspO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcENvbnRleHRQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdm9pZCAwO1xudmFyIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbnZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IHZvaWQgMDtcbnZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgXCJDYW4ndCBjYWxsIHNldFN0YXRlIChvciBmb3JjZVVwZGF0ZSkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZC4lcycsIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG4vLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG52YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IG5vdygpO1xudmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcbnZhciBtb3N0UmVjZW50Q3VycmVudFRpbWVNcyA9IG9yaWdpbmFsU3RhcnRUaW1lTXM7XG5cbi8vIFVzZWQgdG8gZW5zdXJlIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMuXG52YXIgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IDA7XG5cbi8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbi8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbi8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbnZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxudmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4vLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG52YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xudmFyIG5leHRSb290ID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbnZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbmV4dExhdGVzdFRpbWVvdXRNcyA9IC0xO1xudmFyIG5leHRSZW5kZXJJc0V4cGlyZWQgPSBmYWxzZTtcblxuLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbnZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxudmFyIGlzQ29tbWl0dGluZyQxID0gZmFsc2U7XG5cbnZhciBpc1Jvb3RSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbnZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxudmFyIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG52YXIgcmVwbGF5VW5pdE9mV29yayA9IHZvaWQgMDtcbnZhciBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHZvaWQgMDtcbnZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbmlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBudWxsO1xuICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gIHJlcGxheVVuaXRPZldvcmsgPSBmdW5jdGlvbiAoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzQXN5bmMpIHtcbiAgICBpZiAodGhyb3duVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHRocm93blZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhyb3duVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhIGRpZmZlcmVudCBzdHJhdGVneSBpZi93aGVuIHdlIGFkZFxuICAgICAgLy8gc3VwcG9ydCBmb3IgY2F0Y2hpbmcgb3RoZXIgdHlwZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3NcbiAgICBpZiAoc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBEb24ndCB0aHJvdyBiZWNhdXNlIHRoaXMgY29kZSBpcyBERVYtb25seS5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdDb3VsZCBub3QgcmVwbGF5IHJlbmRlcmluZyBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKGZhaWxlZFVuaXRPZldvcmssIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMpO1xuXG4gICAgc3dpdGNoIChmYWlsZWRVbml0T2ZXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcG9wSG9zdENvbnRleHQoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgcG9wUHJvdmlkZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZXBsYXkgdGhlIGJlZ2luIHBoYXNlLlxuICAgIGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yayA9IHRydWU7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHRocm93blZhbHVlO1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc0FzeW5jKTtcbiAgICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gbnVsbDtcbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICBpZiAoZmFpbGVkVW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICByZWNvcmRFbGFwc2VkQWN0dWFsUmVuZGVyVGltZShmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgXCJiYXNlXCIgcmVuZGVyIHRpbWVyIGFnYWluIChhZnRlciB0aGUgcmUtdGhyb3duIGVycm9yKS5cbiAgICAgICAgc3RvcEJhc2VSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgYmVnaW4gcGhhc2UgZGlkIG5vdCBmYWlsIHRoZSBzZWNvbmQgdGltZSwgc2V0IHRoaXMgcG9pbnRlclxuICAgICAgLy8gYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICBuZXh0VW5pdE9mV29yayA9IGZhaWxlZFVuaXRPZldvcms7XG4gICAgfVxuICB9O1xuICByZXRocm93T3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBvcmlnaW5hbFJlcGxheUVycm9yO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNldFN0YWNrKCkge1xuICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gbmV4dFVuaXRPZldvcmsucmV0dXJuO1xuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICAgIGNoZWNrVGhhdFN0YWNrSXNFbXB0eSgpO1xuICB9XG5cbiAgbmV4dFJvb3QgPSBudWxsO1xuICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIG5leHRMYXRlc3RUaW1lb3V0TXMgPSAtMTtcbiAgbmV4dFJlbmRlcklzRXhwaXJlZCA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG5cbiAgaXNSb290UmVhZHlGb3JDb21taXQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uKTtcbiAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgIGNhc2UgUGxhY2VtZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBjbGVhbnVwIGVmZmVjdHMgeWV0O1xuICAgIC8vIFRoaXMgd2lsbCBiZSBkb25lIGJ5IGNvbW1pdEFsbExpZmVDeWNsZXMoKVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcblxuICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcykge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgIH1cblxuICAgIGlmICh3YXJuQWJvdXRMZWdhY3lDb250ZXh0QVBJKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50LCBuZXh0RWZmZWN0LCBjdXJyZW50VGltZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAvLyBhbmQgbGFzdEVmZmVjdCBzaW5jZSB0aGV5J3JlIG9uIGV2ZXJ5IG5vZGUsIG5vdCBqdXN0IHRoZSBlZmZlY3RmdWxcbiAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzZXQgdGhlIGVmZmVjdFRhZyBoZXJlIHNvIHRoYXQgd2UgY2FuIHJlbHkgb24gZWZmZWN0XG4gICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gIGlzV29ya2luZyA9IHRydWU7XG4gIGlzQ29tbWl0dGluZyQxID0gdHJ1ZTtcbiAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICEoY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuXG4gIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgfVxuXG4gIHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcblxuICAvLyBJbnZva2UgaW5zdGFuY2VzIG9mIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGJlZm9yZSBtdXRhdGlvbi5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCk7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIC8vIENsZWFuLXVwXG4gICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpcyBiYXRjaC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgfVxuXG4gIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gIC8vIHJlZiB1bm1vdW50cy5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAvLyBDbGVhbi11cFxuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwsIHJvb3QsIGN1cnJlbnRUaW1lLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHtcbiAgICAgIGNoZWNrQWN0dWFsUmVuZGVyVGltZVN0YWNrRW1wdHkoKTtcbiAgICB9XG4gICAgcmVzZXRBY3R1YWxSZW5kZXJUaW1lcigpO1xuICB9XG5cbiAgaXNDb21taXR0aW5nJDEgPSBmYWxzZTtcbiAgaXNXb3JraW5nID0gZmFsc2U7XG4gIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgc3RvcENvbW1pdFRpbWVyKCk7XG4gIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICB9XG4gIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGN1cnJlbnRUaW1lLCByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWUpO1xuICB2YXIgcmVtYWluaW5nVGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG4gIHJldHVybiByZW1haW5pbmdUaW1lO1xufVxuXG5mdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgLy8gKEFuZCBcImJhc2VcIiByZW5kZXIgdGltZXJzIGlmIHRoYXQgZmVhdHVyZSBmbGFnIGlzIGVuYWJsZWQpXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgIHZhciB0cmVlQmFzZVRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZVRpbWU7XG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB0cmVlQmFzZVRpbWUgKz0gY2hpbGQudHJlZUJhc2VUaW1lO1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VUaW1lID0gdHJlZUJhc2VUaW1lO1xuICB9IGVsc2Uge1xuICAgIHZhciBfY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoX2NoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBfY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gX2NoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gIC8vIG5leHQgc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGVcbiAgLy8gcGFyZW50IGZpYmVyLlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIEluY29tcGxldGUpID09PSBOb0VmZmVjdCkge1xuICAgICAgLy8gVGhpcyBmaWJlciBjb21wbGV0ZWQuXG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiZcbiAgICAgIC8vIERvIG5vdCBhcHBlbmQgZWZmZWN0cyB0byBwYXJlbnRzIGlmIGEgc2libGluZyBmYWlsZWQgdG8gY29tcGxldGVcbiAgICAgIChyZXR1cm5GaWJlci5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgLy8gU2tpcCBib3RoIE5vV29yayBhbmQgUGVyZm9ybWVkV29yayB0YWdzIHdoZW4gY3JlYXRpbmcgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICBpZiAoZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIGlzUm9vdFJlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSBiZWNhdXNlIHNvbWV0aGluZyB0aHJldy4gUG9wIHZhbHVlcyBvZmZcbiAgICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuICAgICAgLy8gY2FwdHVyZSB2YWx1ZXMgaWYgcG9zc2libGUuXG4gICAgICB2YXIgX25leHQgPSB1bndpbmRXb3JrKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVySXNFeHBpcmVkLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAvLyBSZXN0YXJ0aW5nIGFuIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5lZmZlY3RUYWcgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHJldHVybiBfbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgZWZmZWN0IGxpc3QuXG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybkZpYmVyLmVmZmVjdFRhZyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gIC8vIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBzdGFydEJhc2VSZW5kZXJUaW1lcigpO1xuICAgIH1cblxuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBVcGRhdGUgXCJiYXNlXCIgdGltZSBpZiB0aGUgcmVuZGVyIHdhc24ndCBiYWlsZWQgb3V0IG9uLlxuICAgICAgcmVjb3JkRWxhcHNlZEJhc2VSZW5kZXJUaW1lSWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHN0b3BCYXNlUmVuZGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgaWYgKGlzUmVwbGF5aW5nRmFpbGVkVW5pdE9mV29yaykge1xuICAgICAgLy8gQ3VycmVudGx5IHJlcGxheWluZyBhIGZhaWxlZCB1bml0IG9mIHdvcmsuIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgcmVuZGVyIHBoYXNlIGlzIG1lYW50IHRvIGJlIGlkZW1wb3RlbnQsIGFuZCBpdCBzaG91bGRcbiAgICAgIC8vIGhhdmUgdGhyb3duIGFnYWluLiBTaW5jZSBpdCBkaWRuJ3QsIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yLCBzb1xuICAgICAgLy8gUmVhY3QncyBpbnRlcm5hbCBzdGFjayBpcyBub3QgbWlzYWxpZ25lZC5cbiAgICAgIHJldGhyb3dPcmlnaW5hbEVycm9yKCk7XG4gICAgfVxuICB9XG4gIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGlzQXN5bmMpIHtcbiAgaWYgKCFpc0FzeW5jKSB7XG4gICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluaXNoLCBwYXVzZSB0aGUgXCJhY3R1YWxcIiByZW5kZXIgdGltZXIuXG4gICAgICAvLyBXZSdsbCByZXN0YXJ0IGl0IHdoZW4gd2UgcmVzdW1lIHdvcmsuXG4gICAgICBwYXVzZUFjdHVhbFJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzQXN5bmMpIHtcbiAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIGlzV29ya2luZyA9IHRydWU7XG5cbiAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCByb290ICE9PSBuZXh0Um9vdCB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgIHJlc2V0U3RhY2soKTtcbiAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgbmV4dExhdGVzdFRpbWVvdXRNcyA9IC0xO1xuICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxuXG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIG5leHRSZW5kZXJJc0V4cGlyZWQgPSAhaXNBc3luYyB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuXG4gIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcChpc0FzeW5jKTtcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgLy8gU3RvcCBcImJhc2VcIiByZW5kZXIgdGltZXIgaW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yLlxuICAgICAgICBzdG9wQmFzZVJlbmRlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3IuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBnbG9iYWwgZGVidWcgc3RhdGVcbiAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhpcyBpcyBkZWZpbmVkIGluIERFVlxuICAgICAgICAgIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFpbGVkVW5pdE9mV29yayA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAgIHJlcGxheVVuaXRPZldvcmsoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzQXN5bmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogd2UgYWxyZWFkeSBrbm93IHRoaXMgaXNuJ3QgdHJ1ZSBpbiBzb21lIGNhc2VzLlxuICAgICAgICAvLyBBdCBsZWFzdCB0aGlzIHNob3dzIGEgbmljZXIgZXJyb3IgbWVzc2FnZSB1bnRpbCB3ZSBmaWd1cmUgb3V0IHRoZSBjYXVzZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjQ0OSNpc3N1ZWNvbW1lbnQtMzg2NzI3NDMxXG4gICAgICAgICEobmV4dFVuaXRPZldvcmsgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRmFpbGVkIHRvIHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgd2l0aCBhIHJlcHJvZHVjaW5nIGNhc2UgdG8gaGVscCB1cyBmaW5kIGl0LicpIDogdm9pZCAwO1xuXG4gICAgICAgIHZhciBzb3VyY2VGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3QuIFRoZSByb290IGNvdWxkIGNhcHR1cmUgaXRzIG93biBlcnJvcnMuIEhvd2V2ZXIsXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCBlcnJvcnMgYmVmb3JlIG9yIGFmdGVyIHdlIHB1c2hlZCB0aGUgaG9zdFxuICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaW5mb3JtYXRpb24gaXMgbmVlZGVkIHRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2guXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBub3Qgc3VyZSwgdHJlYXQgdGhpcyBhcyBhIGZhdGFsIGVycm9yLiBXZSBjb3VsZCB0cmFja1xuICAgICAgICAgIC8vIHdoaWNoIHBoYXNlIGl0IGZhaWxzIGluLCBidXQgZG9lc24ndCBzZWVtIHdvcnRoIGl0LiBBdCBsZWFzdFxuICAgICAgICAgIC8vIGZvciBub3cuXG4gICAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB0aHJvd25WYWx1ZSwgbmV4dFJlbmRlcklzRXhwaXJlZCwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lLCBtb3N0UmVjZW50Q3VycmVudFRpbWVNcyk7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICB2YXIgZGlkQ29tcGxldGVSb290ID0gZmFsc2U7XG4gIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFlpZWxkIGJhY2sgdG8gbWFpbiB0aHJlYWQuXG4gIGlmIChkaWRGYXRhbCkge1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUgd2FzIGEgZmF0YWwgZXJyb3IuXG4gICAge1xuICAgICAgcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICBpZiAoaXNSb290UmVhZHlGb3JDb21taXQpIHtcbiAgICAgIGRpZENvbXBsZXRlUm9vdCA9IHRydWU7XG4gICAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpO1xuICAgICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgICAvLyBUaGUgcm9vdCBzdWNjZXNzZnVsbHkgY29tcGxldGVkLiBJdCdzIHJlYWR5IGZvciBjb21taXQuXG4gICAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICByZXR1cm4gZmluaXNoZWRXb3JrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGNvbXBsZXRlLlxuICAgICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgICAgISFuZXh0UmVuZGVySXNFeHBpcmVkID8gaW52YXJpYW50KGZhbHNlLCAnRXhwaXJlZCB3b3JrIHNob3VsZCBoYXZlIGNvbXBsZXRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXh0TGF0ZXN0VGltZW91dE1zID49IDApIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0cnlTdXNwZW5kZWRSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfSwgbmV4dExhdGVzdFRpbWVvdXRNcyk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RVbmJsb2NrZWRFeHBpcmF0aW9uVGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gICAgICBvbkJsb2NrKGZpcnN0VW5ibG9ja2VkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUncyBtb3JlIHdvcmsgdG8gZG8sIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWUuIFlpZWxkIGJhY2sgdG9cbiAgICAvLyB0aGUgcmVuZGVyZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goc291cmNlRmliZXIsIHZhbHVlLCBleHBpcmF0aW9uVGltZSkge1xuICAhKCFpc1dvcmtpbmcgfHwgaXNDb21taXR0aW5nJDEpID8gaW52YXJpYW50KGZhbHNlLCAnZGlzcGF0Y2g6IENhbm5vdCBkaXNwYXRjaCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgZmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIF9lcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCBfdXBkYXRlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgc2NoZWR1bGVXb3JrJDEoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgdmFyIHJvb3RGaWJlciA9IHNvdXJjZUZpYmVyO1xuICAgIHZhciBfZXJyb3JJbmZvMiA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHJvb3RGaWJlcik7XG4gICAgdmFyIF91cGRhdGUyID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgX2Vycm9ySW5mbzIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgX3VwZGF0ZTIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBzY2hlZHVsZVdvcmskMShyb290RmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpIHtcbiAgcmV0dXJuIGRpc3BhdGNoKGZpYmVyLCBlcnJvciwgU3luYyk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gfjUwMDBtcy4gNTI1MG1zIG1heC5cbiAgdmFyIGV4cGlyYXRpb25NcyA9IDUwMDA7XG4gIHZhciBidWNrZXRTaXplTXMgPSAyNTA7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleHBpcmF0aW9uTXMgPSB2b2lkIDA7XG4gIC8vIFdlIGludGVudGlvbmFsbHkgc2V0IGEgaGlnaGVyIGV4cGlyYXRpb24gdGltZSBmb3IgaW50ZXJhY3RpdmUgdXBkYXRlcyBpblxuICAvLyBkZXYgdGhhbiBpbiBwcm9kdWN0aW9uLlxuICAvLyBJZiB0aGUgbWFpbiB0aHJlYWQgaXMgYmVpbmcgYmxvY2tlZCBzbyBsb25nIHRoYXQgeW91IGhpdCB0aGUgZXhwaXJhdGlvbixcbiAgLy8gaXQncyBhIHByb2JsZW0gdGhhdCBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBiZXR0ZXIgc2NoZWR1bGluZy5cbiAgLy8gUGVvcGxlIHdpbGwgYmUgbW9yZSBsaWtlbHkgdG8gbm90aWNlIHRoaXMgYW5kIGZpeCBpdCB3aXRoIHRoZSBsb25nXG4gIC8vIGV4cGlyYXRpb24gdGltZSBpbiBkZXZlbG9wbWVudC5cbiAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBvcHQgZm9yIGJldHRlciBVWCBhdCB0aGUgcmlzayBvZiBtYXNraW5nIHNjaGVkdWxpbmdcbiAgLy8gcHJvYmxlbXMsIGJ5IGV4cGlyaW5nIGZhc3QuXG4gIHtcbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH41MDBtcy4gNjAwbXMgbWF4LlxuICAgIGV4cGlyYXRpb25NcyA9IDUwMDtcbiAgfVxuICB2YXIgYnVja2V0U2l6ZU1zID0gMTAwO1xuICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbn1cblxuLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG5mdW5jdGlvbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgaWYgKHJlc3VsdCA8PSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uKSB7XG4gICAgLy8gU2luY2Ugd2UgYXNzdW1lIHRoZSBjdXJyZW50IHRpbWUgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMsIHdlIG9ubHkgaGl0XG4gICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gd2l0aGluIGEgMjAwbXMgd2luZG93IChvciB3aGF0ZXZlciB0aGUgYXN5bmMgYnVja2V0IHNpemUgaXMpLlxuICAgIHJlc3VsdCA9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gKyAxO1xuICB9XG4gIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gPSByZXN1bHQ7XG4gIHJldHVybiBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcikge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nJDEpIHtcbiAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBBc3luY01vZGUpIHtcbiAgICAgIGlmIChpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICB9XG4gIH1cbiAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGludGVyYWN0aXZlIHVwZGF0ZS4gS2VlcCB0cmFjayBvZiB0aGUgbG93ZXN0IHBlbmRpbmdcbiAgICAvLyBpbnRlcmFjdGl2ZSBleHBpcmF0aW9uIHRpbWUuIFRoaXMgYWxsb3dzIHVzIHRvIHN5bmNocm9ub3VzbHkgZmx1c2hcbiAgICAvLyBhbGwgaW50ZXJhY3RpdmUgdXBkYXRlcyB3aGVuIG5lZWRlZC5cbiAgICBpZiAobG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA+IGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbi8vIFRPRE86IFJlbmFtZSB0aGlzIHRvIHNjaGVkdWxlVGltZW91dCBvciBzb21ldGhpbmdcbmZ1bmN0aW9uIHN1c3BlbmRSb290KHJvb3QsIHRoZW5hYmxlLCB0aW1lb3V0TXMsIHN1c3BlbmRlZFRpbWUpIHtcbiAgLy8gU2NoZWR1bGUgdGhlIHRpbWVvdXQuXG4gIGlmICh0aW1lb3V0TXMgPj0gMCAmJiBuZXh0TGF0ZXN0VGltZW91dE1zIDwgdGltZW91dE1zKSB7XG4gICAgbmV4dExhdGVzdFRpbWVvdXRNcyA9IHRpbWVvdXRNcztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVN1c3BlbmRlZFJvb3Qocm9vdCwgc3VzcGVuZGVkVGltZSkge1xuICBtYXJrUGluZ2VkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKTtcbiAgdmFyIHJldHJ5VGltZSA9IGZpbmROZXh0UGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCk7XG4gIGlmIChyZXRyeVRpbWUgIT09IE5vV29yaykge1xuICAgIHJlcXVlc3RSZXRyeShyb290LCByZXRyeVRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayQxKGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUnc1xuICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgbm9kZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmICghaXNXb3JraW5nICYmIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgICAgIHJlc2V0U3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB2YXIgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBmaW5kTmV4dFBlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSByZW5kZXIgcGhhc2UsIHdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgdGhpcyByb290XG4gICAgICAgIC8vIGZvciBhbiB1cGRhdGUsIGJlY2F1c2Ugd2UnbGwgZG8gaXQgYmVmb3JlIHdlIGV4aXQuLi5cbiAgICAgICAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmckMSB8fFxuICAgICAgICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gICAgICAgIG5leHRSb290ICE9PSByb290KSB7XG4gICAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkge1xuICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gIG1vc3RSZWNlbnRDdXJyZW50VGltZU1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUobW9zdFJlY2VudEN1cnJlbnRUaW1lTXMpO1xuICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xufVxuXG5mdW5jdGlvbiBkZWZlcnJlZFVwZGF0ZXMoZm4pIHtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gIH1cbn1cblxuLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbi8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbnZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGNhbGxiYWNrSUQgPSB2b2lkIDA7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbnZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xudmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbnZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xudmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbnZhciBkZWFkbGluZSA9IG51bGw7XG5cbnZhciBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xudmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gZmFsc2U7XG5cbnZhciBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcblxuLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xudmFyIE5FU1RFRF9VUERBVEVfTElNSVQgPSAxMDAwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxudmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPiBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbGJhY2tJRCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gb3JpZ2luYWxTdGFydFRpbWVNcztcbiAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICBpZiAocm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIEZvciBhIHJldHJ5LCBvbmx5IHVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSBpZiBpdCBoYXMgYVxuICAgIC8vICpsb3dlciBwcmlvcml0eSogdGhhbiB0aGUgZXhpc3RpbmcgdmFsdWUuIFRoaXMgaXMgYmVjYXVzZSwgb24gYSByZXRyeSxcbiAgICAvLyB3ZSBzaG91bGQgYXR0ZW1wdCB0byBjb2FsZXNjZSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG4vLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbmZ1bmN0aW9uIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGFkZFJvb3RUb1NjaGVkdWxlKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcblxuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgaWYgKHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBzY2hlZHVsZWQsIGJ1dCBpdHMgcHJpb3JpdHkgbWF5IGhhdmUgaW5jcmVhc2VkLlxuICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eS5cbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKSB7XG4gIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290ICYmIGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cbiAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGhpZ2hlc3RQcmlvcml0eVdvcms7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgcGVyZm9ybVdvcmsoTm9Xb3JrLCB0cnVlLCBkbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgaXNBc3luYywgZGwpIHtcbiAgZGVhZGxpbmUgPSBkbDtcblxuICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAvLyB0aGUgZGVhZGxpbmUuXG4gIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXN1bWVBY3R1YWxSZW5kZXJUaW1lcklmUGF1c2VkKCk7XG4gIH1cblxuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIHRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKGlzQXN5bmMpIHtcbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBtaW5FeHBpcmF0aW9uVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSAmJiAoIWRlYWRsaW5lRGlkRXhwaXJlIHx8IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCAhZGVhZGxpbmVEaWRFeHBpcmUpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGNhbGxiYWNrSUQgPSBudWxsO1xuICB9XG4gIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgLy8gQ2xlYW4tdXAuXG4gIGRlYWRsaW5lID0gbnVsbDtcbiAgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcblxuICBmaW5pc2hSZW5kZXJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gIC8vIFBlcmZvcm0gd29yayBvbiByb290IGFzIGlmIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUgaXMgdGhlIGN1cnJlbnQgdGltZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBzeW5jaHJvbm91c2x5IGZsdXNoaW5nIGFsbCB3b3JrIHVwIHRvIGFuZFxuICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgLy8gRmx1c2ggYW55IHN5bmMgd29yayB0aGF0IHdhcyBzY2hlZHVsZWQgYnkgbGlmZWN5Y2xlc1xuICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgZmluaXNoUmVuZGVyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZygpIHtcbiAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gIGlmIChjb21wbGV0ZWRCYXRjaGVzICE9PSBudWxsKSB7XG4gICAgdmFyIGJhdGNoZXMgPSBjb21wbGV0ZWRCYXRjaGVzO1xuICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhdGNoLl9vbkNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgaXNBc3luYykge1xuICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhc3luYyB3b3JrIG9yIHN5bmMvZXhwaXJlZCB3b3JrLlxuICBpZiAoIWlzQXN5bmMpIHtcbiAgICAvLyBGbHVzaCBzeW5jIHdvcmsuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgdmFyIF9maW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgdHJ1ZSk7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIC8vIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG5cbiAgICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmlzaCwgcGF1c2UgdGhlIFwiYWN0dWFsXCIgcmVuZGVyIHRpbWVyLlxuICAgICAgICAgICAgLy8gV2UnbGwgcmVzdGFydCBpdCB3aGVuIHdlIHJlc3VtZSB3b3JrLlxuICAgICAgICAgICAgcGF1c2VBY3R1YWxSZW5kZXJUaW1lcklmUnVubmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzUmVuZGVyaW5nID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBiYXRjaCB0aGF0IG1hdGNoZXMgdGhpcyBleHBpcmF0aW9uIHRpbWUuXG4gIHZhciBmaXJzdEJhdGNoID0gcm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCAhPT0gbnVsbCAmJiBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZSA8PSBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjb21wbGV0ZWRCYXRjaGVzID09PSBudWxsKSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzID0gW2ZpcnN0QmF0Y2hdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZWRCYXRjaGVzLnB1c2goZmlyc3RCYXRjaCk7XG4gICAgfVxuICAgIGlmIChmaXJzdEJhdGNoLl9kZWZlcikge1xuICAgICAgLy8gVGhpcyByb290IGlzIGJsb2NrZWQgZnJvbSBjb21taXR0aW5nIGJ5IGEgYmF0Y2guIFVuc2NoZWR1bGUgaXQgdW50aWxcbiAgICAgIC8vIHdlIHJlY2VpdmUgYW5vdGhlciB1cGRhdGUuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tbWl0IHRoZSByb290LlxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG59XG5cbi8vIFdoZW4gd29ya2luZyBvbiBhc3luYyB3b3JrLCB0aGUgcmVjb25jaWxlciBhc2tzIHRoZSByZW5kZXJlciBpZiBpdCBzaG91bGRcbi8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gIGlmIChkZWFkbGluZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGVhZGxpbmUudGltZVJlbWFpbmluZygpID4gdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmspIHtcbiAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAvLyBhbm90aGVyIHVwZGF0ZS5cbiAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25CbG9jayhyZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgcm9vdCB3YXMgYmxvY2tlZC4gVW5zY2hlZHVsZSBpdCB1bnRpbCB0aGVyZSdzIGFub3RoZXIgdXBkYXRlLlxuICBuZXh0Rmx1c2hlZFJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZuKGEpO1xufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4sIGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgIHJldHVybiBmbihhLCBiKTtcbiAgfVxuICAvLyBJZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcywgc3luY2hyb25vdXNseSBmbHVzaCB0aGVtLlxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgbWF5IGluZmx1ZW5jZSB3aGljaCBoYW5kbGVycyBhcmUgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGlzIGV2ZW50LlxuICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZyAmJiBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUsIGZhbHNlLCBudWxsKTtcbiAgICBsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHRydWU7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxKCkge1xuICBpZiAoIWlzUmVuZGVyaW5nICYmIGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICBwZXJmb3JtV29yayhsb3dlc3RQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UsIG51bGwpO1xuICAgIGxvd2VzdFBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ29udHJvbGxlZChmbikge1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgc3luY1VwZGF0ZXMoZm4pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgZmFsc2UsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gIHJldHVybiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikgPyBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSA6IHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50LCB1cGRhdGUsIGV4cGlyYXRpb25UaW1lKTtcblxuICBzY2hlZHVsZVdvcmskMShjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0FyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50KSk7XG4gICAgfVxuICB9XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGN1cnJlbnQpO1xuICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoX2Fzc2lnbih7fSwgZGV2VG9vbHNDb25maWcsIHtcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9KSk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbnRlbnRpb25hbGx5IGRvZXMgKm5vdCogaGF2ZSB0aGUgRmxvdyBhbm5vdGF0aW9uLlxuLy8gRG9uJ3QgYWRkIGl0LiBTZWUgYC4vaW5saW5lLXR5cGVkLmpzYCBmb3IgYW4gZXhwbGFuYXRpb24uXG5cblxuXG52YXIgRE9NUmVuZGVyZXIgPSBPYmplY3QuZnJlZXplKHtcblx0dXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZTogdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZSxcblx0Y3JlYXRlQ29udGFpbmVyOiBjcmVhdGVDb250YWluZXIsXG5cdHVwZGF0ZUNvbnRhaW5lcjogdXBkYXRlQ29udGFpbmVyLFxuXHRmbHVzaFJvb3Q6IGZsdXNoUm9vdCxcblx0cmVxdWVzdFdvcms6IHJlcXVlc3RXb3JrLFxuXHRjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uLFxuXHRiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMkMSxcblx0dW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblx0ZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cdHN5bmNVcGRhdGVzOiBzeW5jVXBkYXRlcyxcblx0aW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblx0Zmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXM6IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzJDEsXG5cdGZsdXNoQ29udHJvbGxlZDogZmx1c2hDb250cm9sbGVkLFxuXHRmbHVzaFN5bmM6IGZsdXNoU3luYyxcblx0Z2V0UHVibGljUm9vdEluc3RhbmNlOiBnZXRQdWJsaWNSb290SW5zdGFuY2UsXG5cdGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cdGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyxcblx0aW5qZWN0SW50b0RldlRvb2xzOiBpbmplY3RJbnRvRGV2VG9vbHNcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi40LjEnO1xuXG4vLyBUT0RPOiBUaGlzIHR5cGUgaXMgc2hhcmVkIGJldHdlZW4gdGhlIHJlY29uY2lsZXIgYW5kIFJlYWN0RE9NLCBidXQgd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgb3V0IHRvIHRoZSByZW5kZXJlci5cbnZhciB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gdm9pZCAwO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IGZhbHNlO1xuXG57XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8XG4gIC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbiAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gIFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxuXG4gIHRvcExldmVsVXBkYXRlV2FybmluZ3MgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuX2ludGVybmFsUm9vdC5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgIShob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyKSA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgISghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcbiAgfTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICAhKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuaW5qZWN0aW9uJDIuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUmVhY3RCYXRjaChyb290KSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24oKTtcbiAgdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21wbGV0ZSA9IGZhbHNlO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICB0aGlzLl9jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX2RlZmVyID0gdHJ1ZTtcbn1cblJlYWN0QmF0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAhdGhpcy5fZGVmZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5yZW5kZXI6IENhbm5vdCByZW5kZXIgYSBiYXRjaCB0aGF0IGFscmVhZHkgY29tbWl0dGVkLicpIDogdm9pZCAwO1xuICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZhciBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShjaGlsZHJlbiwgaW50ZXJuYWxSb290LCBudWxsLCBleHBpcmF0aW9uVGltZSwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tcGxldGUpIHtcbiAgaWYgKHRoaXMuX2RpZENvbXBsZXRlKSB7XG4gICAgb25Db21wbGV0ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21wbGV0ZSk7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICAhKHRoaXMuX2RlZmVyICYmIGZpcnN0QmF0Y2ggIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJykgOiB2b2lkIDA7XG5cbiAgaWYgKCF0aGlzLl9oYXNDaGlsZHJlbikge1xuICAgIC8vIFRoaXMgYmF0Y2ggaXMgZW1wdHkuIFJldHVybi5cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lO1xuXG4gIC8vIEVuc3VyZSB0aGlzIGlzIHRoZSBmaXJzdCBiYXRjaCBpbiB0aGUgbGlzdC5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IHRoaXMpIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIG5vdCB0aGUgZWFybGllc3QgYmF0Y2guIFdlIG5lZWQgdG8gbW92ZSBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gVXBkYXRlIGl0cyBleHBpcmF0aW9uIHRpbWUgdG8gYmUgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgZWFybGllc3RcbiAgICAvLyBiYXRjaCwgc28gdGhhdCB3ZSBjYW4gZmx1c2ggaXQgd2l0aG91dCBmbHVzaGluZyB0aGUgb3RoZXIgYmF0Y2hlcy5cbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWUgPSBmaXJzdEJhdGNoLl9leHBpcmF0aW9uVGltZTtcbiAgICAgIC8vIFJlbmRlcmluZyB0aGlzIGJhdGNoIGFnYWluIGVuc3VyZXMgaXRzIGNoaWxkcmVuIHdpbGwgYmUgdGhlIGZpbmFsIHN0YXRlXG4gICAgICAvLyB3aGVuIHdlIGZsdXNoICh1cGRhdGVzIGFyZSBwcm9jZXNzZWQgaW4gaW5zZXJ0aW9uIG9yZGVyOiBsYXN0XG4gICAgICAvLyB1cGRhdGUgd2lucykuXG4gICAgICAvLyBUT0RPOiBUaGlzIGZvcmNlcyBhIHJlc3RhcnQuIFNob3VsZCB3ZSBwcmludCBhIHdhcm5pbmc/XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLl9jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgdmFyIGJhdGNoID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoYmF0Y2ggIT09IHRoaXMpIHtcbiAgICAgIHByZXZpb3VzID0gYmF0Y2g7XG4gICAgICBiYXRjaCA9IGJhdGNoLl9uZXh0O1xuICAgIH1cbiAgICAhKHByZXZpb3VzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuICAgIHByZXZpb3VzLl9uZXh0ID0gYmF0Y2guX25leHQ7XG5cbiAgICAvLyBBZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIHRoaXMuX25leHQgPSBmaXJzdEJhdGNoO1xuICAgIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IHRoaXM7XG4gIH1cblxuICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCB0aGUgd29yayB1cCB0byB0aGlzIGJhdGNoJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICB0aGlzLl9kZWZlciA9IGZhbHNlO1xuICBmbHVzaFJvb3QoaW50ZXJuYWxSb290LCBleHBpcmF0aW9uVGltZSk7XG5cbiAgLy8gUG9wIHRoZSBiYXRjaCBmcm9tIHRoZSBsaXN0LlxuICB2YXIgbmV4dCA9IHRoaXMuX25leHQ7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSBuZXh0O1xuXG4gIC8vIEFwcGVuZCB0aGUgbmV4dCBlYXJsaWVzdCBiYXRjaCdzIGNoaWxkcmVuIHRvIHRoZSB1cGRhdGUgcXVldWUuXG4gIGlmIChmaXJzdEJhdGNoICE9PSBudWxsICYmIGZpcnN0QmF0Y2guX2hhc0NoaWxkcmVuKSB7XG4gICAgZmlyc3RCYXRjaC5yZW5kZXIoZmlyc3RCYXRjaC5fY2hpbGRyZW4pO1xuICB9XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUuX29uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9kaWRDb21wbGV0ZSA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICBfY2FsbGJhY2soKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RXb3JrKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9kaWRDb21taXQgPSBmYWxzZTtcbiAgLy8gVE9ETzogQXZvaWQgbmVlZCB0byBiaW5kIGJ5IHJlcGxhY2luZyBjYWxsYmFja3MgaW4gdGhlIHVwZGF0ZSBxdWV1ZSB3aXRoXG4gIC8vIGxpc3Qgb2YgV29yayBvYmplY3RzLlxuICB0aGlzLl9vbkNvbW1pdCA9IHRoaXMuX29uQ29tbWl0LmJpbmQodGhpcyk7XG59XG5SZWFjdFdvcmsucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25Db21taXQpIHtcbiAgaWYgKHRoaXMuX2RpZENvbW1pdCkge1xuICAgIG9uQ29tbWl0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBjYWxsYmFja3MucHVzaChvbkNvbW1pdCk7XG59O1xuUmVhY3RXb3JrLnByb3RvdHlwZS5fb25Db21taXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tbWl0ID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiBFcnJvciBoYW5kbGluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NhbGxiYWNrMiA9IGNhbGxiYWNrc1tpXTtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2syID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjazIpIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjazIoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpO1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGJhdGNoLl9leHBpcmF0aW9uVGltZTtcblxuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5pbmplY3Rpb24kMy5pbmplY3RSZW5kZXJlcihET01SZW5kZXJlcik7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpIHtcbiAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG4gIC8vIExlZ2FjeSByb290cyBhcmUgbm90IGFzeW5jIGJ5IGRlZmF1bHQuXG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaXNBc3luYywgc2hvdWxkSHlkcmF0ZSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlLCBjYWxsYmFjaykge1xuICAvLyBUT0RPOiBFbnN1cmUgYWxsIGVudHJ5IHBvaW50cyBjb250YWluIHRoaXMgY2hlY2tcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIHRvcExldmVsVXBkYXRlV2FybmluZ3MoY29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhcmVudENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIHJvb3QubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QucmVuZGVyKGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9vcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gVXBkYXRlXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QucmVuZGVyKGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgZmluZERPTU5vZGU6IGZ1bmN0aW9uIChjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgICB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICAhd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgISFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPyB3YXJuaW5nKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgICEhaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPyB3YXJuaW5nKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9LFxuXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzJDEsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblxuICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5SZWFjdERPTS51bnN0YWJsZV9jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIHRydWUsIGh5ZHJhdGUpO1xufTtcblxudmFyIGZvdW5kRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzLmRlZmF1bHQgPyBSZWFjdERPTSQzLmRlZmF1bHQgOiBSZWFjdERPTSQzO1xu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QUF5QkE7QUFVQTtBQUNBO0FBdUJBO0FBQ0E7QUFvRkE7QUFDQTtBQUNBO0FBTUE7QUEwQkE7QUFDQTtBQWdDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQW9EQTtBQUVBO0FBeURBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVBBO0FBWUE7QUFDQTtBQUtBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBUUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBUkE7QUFhQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFRQTtBQUVBO0FBQ0E7QUFIQTtBQVFBO0FBRUE7QUFDQTtBQUhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSEE7QUFRQTtBQUdBO0FBSUE7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFPQTtBQTRCQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBbUJBOzs7Ozs7QUF1QkE7QUFTQTtBQXNCQTtBQUNBO0FBS0E7QUFhQTtBQUNBOzs7QUE0Q0E7QUFNQTs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBcUVBO0FBMkJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBbUJBO0FBa0JBOztBQU9BOztBQU1BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF1QkE7QUFHQTtBQUNBOzs7O0FBUUE7OztBQVVBOzs7QUFhQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQXdCQTs7Ozs7Ozs7O0FBYUE7QUFvQ0E7Ozs7Ozs7O0FBZUE7OztBQVlBO0FBUUE7QUFDQTtBQUNBOzs7QUFrQkE7OztBQXVCQTs7Ozs7O0FBd0NBO0FBVUE7QUFNQTtBQUdBO0FBZ0JBO0FBTUE7Ozs7Ozs7O0FBaURBOzs7O0FBT0E7QUFhQTtBQUlBO0FBV0E7QUFhQTtBQUNBO0FBZ0JBO0FBQ0E7QUFHQTtBQUNBO0FBaUNBO0FBUUE7QUFDQTtBQUNBO0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CQTtBQXVCQTtBQUNBO0FBR0E7QUFHQTtBQVVBO0FBc0JBO0FBQ0E7QUFVQTtBQXNCQTtBQUNBOzs7O0FBZ0JBOzs7QUFVQTs7O0FBVUE7Ozs7Ozs7OztBQWNBO0FBUUE7QUFLQTtBQUlBO0FBQ0E7QUFLQTtBQUNBOzs7QUFXQTs7OztBQW9CQTs7O0FBMkNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUlBO0FBQ0E7QUFJQTtBQUNBOzs7QUFTQTtBQVdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOzs7QUFjQTs7O0FBUUE7Ozs7QUFnQkE7OztBQVVBO0FBR0E7QUFJQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBaUNBO0FBb0JBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFTQTtBQTBEQTtBQUNBOzs7O0FBb0JBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFNQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTs7Ozs7Ozs7QUFtQkE7QUFRQTs7Ozs7Ozs7QUFZQTtBQVFBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUVBOztBQU1BO0FBSUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFnQkE7QUFDQTtBQWFBO0FBQ0E7QUFHQTtBQUNBOzs7OztBQTZCQTs7Ozs7O0FBY0E7Ozs7OztBQWdCQTs7O0FBMkJBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBcUJBO0FBNEJBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFLQTtBQUNBOzs7Ozs7Ozs7OztBQXFCQTtBQVdBO0FBQ0E7Ozs7O0FBc0NBOzs7O0FBS0E7Ozs7QUFrQkE7QUFVQTs7Ozs7QUE4QkE7QUFLQTtBQU1BOzs7OztBQVlBOzs7Ozs7OztBQTBDQTs7Ozs7QUF1QkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7Ozs7Ozs7Ozs7O0FBK0JBO0FBTUE7QUFDQTtBQVFBO0FBYUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQVlBOzs7QUFPQTtBQVNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMEJBO0FBdUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7Ozs7O0FBaUJBO0FBUUE7QUFJQTs7OztBQVdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFpQkE7QUFDQTtBQUlBO0FBWUE7QUFJQTtBQUlBO0FBTUE7QUFNQTtBQUNBO0FBUUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNEJBO0FBSUE7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQWlCQTtBQU9BO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFPQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTs7QUFnQkE7QUFFQTtBQVVBO0FBaUJBOztBQXVCQTtBQXlCQTtBQWFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBb0NBO0FBd0NBO0FBQ0E7QUFVQTtBQUlBO0FBZUE7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JBO0FBR0E7QUE2QkE7QUFDQTtBQUdBO0FBZUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFjQTtBQWNBO0FBSUE7QUFHQTs7QUFRQTtBQWFBOzs7Ozs7QUFTQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUF3QkE7O0FBZUE7QUFvQ0E7Ozs7O0FBZ0JBOzs7QUFRQTtBQUdBO0FBQ0E7Ozs7Ozs7O0FBZUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQVNBO0FBR0E7O0FBNkVBOzs7OztBQU1BOzs7Ozs7QUE0QkE7QUF5QkE7QUFFQTtBQUFBO0FBb0JBO0FBRUE7QUFXQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBa0pBO0FBb1ZBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFvQkE7QUFLQTtBQUdBO0FBc0NBO0FBQ0E7QUFNQTtBQVlBO0FBQ0E7QUFLQTtBQXdGQTtBQWlCQTtBQUNBO0FBQ0E7QUFRQTtBQWdDQTtBQVNBO0FBQ0E7QUFnQkE7QUFDQTtBQUtBO0FBb0NBO0FBb0NBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBSUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQWVBO0FBbUJBO0FBQ0E7QUFVQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQWlDQTtBQVVBO0FBOEJBO0FBQ0E7QUFXQTtBQUNBO0FBT0E7QUFDQTtBQWFBO0FBQ0E7QUFLQTtBQUNBO0FBWUE7QUFPQTtBQW1DQTtBQTBCQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBYUE7QUFDQTtBQUtBO0FBU0E7QUFVQTtBQWlCQTtBQUNBO0FBT0E7QUFHQTtBQU9BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUErQkE7QUFRQTtBQXdCQTtBQUNBO0FBU0E7QUFDQTtBQU1BO0FBQ0E7QUFhQTtBQUdBO0FBQ0E7QUFRQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0JBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQVNBO0FBUUE7QUFVQTtBQVNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFjQTtBQUVBO0FBT0E7QUFDQTtBQUtBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUF5Q0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBNkJBO0FBQ0E7O0FBbUNBO0FBRUE7QUFFQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFLQTtBQUdBO0FBR0E7QUFHQTtBQU9BO0FBQ0E7QUFDQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTs7QUFTQTtBQXNEQTtBQUNBO0FBOERBO0FBTUE7QUFFQTtBQUtBO0FBU0E7QUFrR0E7QUE0REE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBZ0RBO0FBQ0E7QUFFQTtBQU9BO0FBTUE7QUFHQTtBQU1BO0FBU0E7QUFTQTtBQUNBO0FBdUVBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBMkJBO0FBQ0E7QUFFQTtBQUNBO0FBV0E7QUFHQTtBQVlBO0FBQ0E7QUFDQTtBQTZCQTtBQUNBO0FBMEJBO0FBQ0E7QUFvQkE7QUErQ0E7QUFjQTtBQUNBO0FBV0E7QUFlQTtBQThDQTtBQUNBO0FBRUE7QUF1QkE7QUFpTEE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBNkNBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFVQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBS0E7QUFRQTtBQUVBO0FBNkJBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFHQTtBQVFBO0FBTUE7QUFlQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFXQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBa0RBO0FBQ0E7QUE0QkE7QUEyREE7QUFNQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBb0NBO0FBRUE7QUFDQTtBQTZDQTtBQUtBO0FBQ0E7QUFDQTtBQU9BO0FBS0E7QUFRQTtBQUtBOzs7Ozs7Ozs7Ozs7QUE2QkE7QUFpQkE7QUFDQTtBQUNBO0FBNENBO0FBK0dBO0FBS0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTJDQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBR0E7QUFHQTtBQUlBO0FBS0E7QUFXQTtBQVNBO0FBSUE7QUFLQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFLQTtBQUNBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFNQTtBQUtBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBTUE7QUFHQTtBQUlBO0FBR0E7QUF3QkE7QUFJQTtBQUtBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQXFDQTtBQUNBO0FBMkJBO0FBRUE7QUFPQTtBQUNBO0FBTUE7QUFLQTtBQU9BO0FBS0E7QUFJQTtBQUtBO0FBR0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBY0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFPQTtBQUNBO0FBUUE7QUFDQTtBQWNBO0FBUUE7QUFPQTtBQU1BO0FBUUE7QUFJQTtBQUdBO0FBZ0JBO0FBVUE7QUFLQTtBQU1BO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBVUE7QUFJQTtBQU1BO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBc0JBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBSUE7QUF5QkE7QUFDQTtBQWNBO0FBMkVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBcUJBO0FBS0E7QUFDQTtBQU1BO0FBQ0E7Ozs7O0FBNEJBOzs7OztBQTBFQTtBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFVQTtBQUlBO0FBQ0E7QUF3SkE7QUFhQTtBQUdBO0FBaUJBO0FBQ0E7QUFDQTtBQStCQTtBQUNBO0FBb0RBO0FBeUNBO0FBQ0E7QUFHQTtBQUNBO0FBNEJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFpQkE7QUFDQTtBQWVBO0FBQ0E7QUFlQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFRQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFzQkE7QUFDQTtBQWtCQTtBQUNBO0FBWUE7QUFDQTtBQUtBO0FBQ0E7Ozs7QUF5QkE7QUFpREE7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUlBO0FBQ0E7QUFVQTtBQUNBO0FBZ0JBO0FBQ0E7QUFVQTtBQU9BO0FBSUE7QUFJQTtBQU9BO0FBQ0E7QUFTQTtBQUtBO0FBU0E7QUFVQTtBQVVBO0FBS0E7QUFTQTtBQUtBO0FBU0E7QUFDQTtBQUNBO0FBMkNBO0FBSUE7QUFDQTtBQUNBO0FBb0RBO0FBQ0E7O0FBeUNBO0FBaUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQU1BO0FBQ0E7QUFRQTtBQVVBO0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFVQTtBQUVBO0FBS0E7QUFNQTtBQUNBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQU1BO0FBQ0E7QUFRQTtBQVVBO0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFXQTtBQUNBO0FBc0NBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQWtDQTtBQUNBO0FBQ0E7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQVNBO0FBOEJBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVGQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUVBO0FBQ0E7QUFpQkE7QUFDQTtBQXNDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUF3QkE7QUFDQTtBQVlBO0FBQ0E7QUEwQkE7QUFVQTtBQUNBO0FBS0E7QUFDQTtBQWNBO0FBUUE7QUFDQTtBQUNBO0FBS0E7QUFNQTtBQVVBO0FBTUE7QUFXQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpQkE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBYUE7QUFlQTtBQUNBO0FBSUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFpQkE7QUFDQTtBQUlBO0FBTUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBRUE7QUFFQTtBQWdCQTtBQUNBO0FBOEJBO0FBTUE7QUFVQTtBQUNBO0FBQ0E7QUFNQTtBQWdEQTtBQUNBO0FBS0E7QUFDQTtBQW9CQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBS0E7QUFHQTtBQUdBO0FBQ0E7QUFZQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUlBO0FBS0E7QUFHQTtBQUlBO0FBTUE7QUFLQTtBQWtCQTtBQUNBO0FBb0JBO0FBSUE7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBZUE7QUE4QkE7QUFDQTtBQVFBO0FBR0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQWVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUlBO0FBQ0E7QUFlQTtBQUNBO0FBSUE7QUFPQTtBQUNBO0FBaURBO0FBQ0E7QUFTQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBeUJBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFNQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBdUJBO0FBSUE7QUFHQTtBQU1BO0FBQ0E7QUFJQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBR0E7QUFPQTtBQUlBO0FBQ0E7QUFLQTtBQUVBO0FBR0E7QUFHQTtBQWtCQTtBQWNBO0FBQ0E7QUFFQTtBQUNBO0FBWUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBV0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBUUE7QUFXQTtBQUNBO0FBS0E7QUErQkE7QUFLQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQXNCQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBMENBO0FBQ0E7QUFnQkE7QUEwREE7QUE4REE7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUtBO0FBS0E7QUFLQTtBQStDQTtBQUNBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0VBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQVFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFRQTtBQUVBO0FBV0E7QUFxQkE7QUFFQTtBQUtBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBcUJBO0FBR0E7QUFDQTtBQStCQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFRQTtBQWdCQTtBQUNBO0FBV0E7QUFDQTtBQUdBO0FBcUJBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFjQTtBQUNBO0FBQ0E7QUFxQ0E7QUFFQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBU0E7QUFFQTtBQUlBO0FBV0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBbUJBO0FBSUE7QUFRQTtBQUNBO0FBTUE7QUFDQTtBQWFBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFjQTtBQU1BO0FBc0VBO0FBa0RBO0FBQ0E7QUE2QkE7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFLQTtBQVNBO0FBY0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQXdCQTtBQWNBO0FBSUE7QUFDQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFHQTtBQW1DQTtBQUNBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQThCQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFNQTtBQWdCQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFnQkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBMkNBO0FBQ0E7QUFRQTtBQUNBO0FBSUE7QUFjQTtBQUNBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQWFBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFnQkE7QUFHQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFVQTtBQUdBO0FBU0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQW1CQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFXQTtBQUtBO0FBTUE7QUFDQTtBQVVBO0FBQ0E7QUFFQTtBQW9CQTtBQUtBO0FBS0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBSUE7QUFJQTtBQU1BO0FBS0E7QUFLQTtBQWlCQTtBQUNBO0FBbUNBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQVVBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFHQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQTBCQTtBQUNBO0FBYUE7QUFPQTtBQUNBO0FBRUE7QUFxQkE7QUEwQkE7QUFFQTtBQUNBO0FBcUJBO0FBUUE7QUFFQTtBQUlBO0FBQ0E7QUFJQTtBQUtBO0FBV0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFRQTtBQVNBO0FBQ0E7QUFFQTtBQVdBO0FBR0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBTUE7QUFZQTtBQWFBO0FBQ0E7QUFLQTtBQWtCQTtBQUNBO0FBMEJBO0FBRUE7QUFDQTtBQUtBO0FBS0E7QUFTQTtBQUNBO0FBQ0E7QUFJQTtBQXFDQTtBQUVBO0FBR0E7QUFLQTtBQUtBO0FBR0E7QUFLQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQVlBO0FBU0E7QUFDQTtBQU9BO0FBS0E7QUFDQTtBQU1BO0FBQ0E7QUFTQTtBQUNBO0FBVUE7QUFJQTtBQUNBO0FBY0E7QUFDQTtBQWFBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXFCQTtBQW1CQTtBQUdBO0FBMEJBO0FBQ0E7QUFlQTtBQXNGQTtBQVFBO0FBSUE7QUF1QkE7QUFLQTtBQVVBO0FBR0E7QUFDQTtBQU9BO0FBRUE7QUFtRUE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFVQTtBQUtBO0FBSUE7QUFLQTtBQWNBO0FBVUE7QUFDQTtBQXVCQTtBQTZEQTs7Ozs7O0FBc0JBO0FBNEJBO0FBb0JBO0FBTUE7QUFPQTtBQUNBO0FBR0E7QUFTQTtBQWdCQTtBQWNBO0FBMEJBO0FBb0JBO0FBTUE7QUFDQTtBQU9BO0FBV0E7QUFDQTtBQXFCQTtBQUVBO0FBdUJBO0FBR0E7QUFnQkE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/OTVjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBS0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.4.1\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n    var invariant = __webpack_require__(/*! fbjs/lib/invariant */ \"./node_modules/fbjs/lib/invariant.js\");\n    var emptyObject = __webpack_require__(/*! fbjs/lib/emptyObject */ \"./node_modules/fbjs/lib/emptyObject.js\");\n    var warning = __webpack_require__(/*! fbjs/lib/warning */ \"./node_modules/fbjs/lib/warning.js\");\n    var emptyFunction = __webpack_require__(/*! fbjs/lib/emptyFunction */ \"./node_modules/fbjs/lib/emptyFunction.js\");\n    var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\n    // TODO: this is special because it gets imported during build.\n\n    var ReactVersion = '16.4.1';\n\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\n    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\n    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\n    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\n    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\n    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\n    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\n    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\n    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n    var REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;\n\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    // Relying on the `invariant()` implementation lets us\n    // have preserve the format and params in the www builds.\n\n    // Exports ReactDOM.createRoot\n\n\n    // Experimental error-boundary API that can recover from errors within a single\n    // render phase\n\n    // Suspense\n    var enableSuspense = false;\n    // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n    // In some cases, StrictMode should also double-render lifecycles.\n    // This can be confusing for tests though,\n    // And it can be bad for performance in production.\n    // This feature flag can be used to control the behavior:\n\n\n    // To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n    // replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n    // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n    // Warn about legacy context API\n\n\n    // Gather advanced timing metrics for Profiler subtrees.\n\n\n    // Only used in www builds.\n\n    /**\n     * Forked from fbjs/warning:\n     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n     *\n     * Only change is we use console.warn instead of console.error,\n     * and do nothing when 'console' is not supported.\n     * This really simplifies the code.\n     * ---\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n    var lowPriorityWarning = function lowPriorityWarning() {};\n\n    {\n      var printWarning = function printWarning(format) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n        if (typeof console !== 'undefined') {\n          console.warn(message);\n        }\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          throw new Error(message);\n        } catch (x) {}\n      };\n\n      lowPriorityWarning = function lowPriorityWarning(condition, format) {\n        if (format === undefined) {\n          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n        if (!condition) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n\n          printWarning.apply(undefined, [format].concat(args));\n        }\n      };\n    }\n\n    var lowPriorityWarning$1 = lowPriorityWarning;\n\n    var didWarnStateUpdateForUnmountedComponent = {};\n\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + '.' + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        warning(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n\n    /**\n     * This is the abstract API for an update queue.\n     */\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function isMounted(publicInstance) {\n        return false;\n      },\n\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      // We initialize the default updater but the real one gets injected by the\n      // renderer.\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    Component.prototype.isReactComponent = {};\n\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n    Component.prototype.setState = function (partialState, callback) {\n      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function get() {\n            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context;\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent;\n    // Avoid an extra prototype jump for these methods.\n    _assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n\n    var specialPropKeyWarningShown = void 0;\n    var specialPropRefWarningShown = void 0;\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function warnAboutAccessingKey() {\n        if (!specialPropKeyWarningShown) {\n          specialPropKeyWarningShown = true;\n          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function warnAboutAccessingRef() {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, no instanceof check\n     * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @param {*} owner\n     * @param {*} props\n     * @internal\n     */\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {};\n\n        // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        });\n        // self and source are DEV only properties.\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        });\n        // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n\n      return element;\n    };\n\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n    function createElement(type, config, children) {\n      var propName = void 0;\n\n      // Reserved names are extracted\n      var props = {};\n\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n        }\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source;\n        // Remaining properties are added to a new props object\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      }\n\n      // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      }\n\n      // Resolve default props\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n            if (key) {\n              defineKeyPropWarningGetter(props, displayName);\n            }\n            if (ref) {\n              defineRefPropWarningGetter(props, displayName);\n            }\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n\n    /**\n     * Return a function that produces ReactElements of a given type.\n     * See https://reactjs.org/docs/react-api.html#createfactory\n     */\n\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n      return newElement;\n    }\n\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n    function cloneElement(element, config, children) {\n      !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n      var propName = void 0;\n\n      // Original props are copied\n      var props = _assign({}, element.props);\n\n      // Reserved names are extracted\n      var key = element.key;\n      var ref = element.ref;\n      // Self is preserved since the owner is preserved.\n      var self = element._self;\n      // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n      var source = element._source;\n\n      // Owner will be preserved, unless ref is overridden\n      var owner = element._owner;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          key = '' + config.key;\n        }\n\n        // Remaining properties override existing props\n        var defaultProps = void 0;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      }\n\n      // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a valid component.\n     * @final\n     */\n    function isValidElement(object) {\n      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n\n    var ReactDebugCurrentFrame = {};\n\n    {\n      // Component that is being worked on\n      ReactDebugCurrentFrame.getCurrentStack = null;\n\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          return impl();\n        }\n        return null;\n      };\n    }\n\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = ('' + key).replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n\n      return '$' + escapedString;\n    }\n\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n\n    var POOL_SIZE = 10;\n    var traverseContextPool = [];\n    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n      if (traverseContextPool.length) {\n        var traverseContext = traverseContextPool.pop();\n        traverseContext.result = mapResult;\n        traverseContext.keyPrefix = keyPrefix;\n        traverseContext.func = mapFunction;\n        traverseContext.context = mapContext;\n        traverseContext.count = 0;\n        return traverseContext;\n      } else {\n        return {\n          result: mapResult,\n          keyPrefix: keyPrefix,\n          func: mapFunction,\n          context: mapContext,\n          count: 0\n        };\n      }\n    }\n\n    function releaseTraverseContext(traverseContext) {\n      traverseContext.result = null;\n      traverseContext.keyPrefix = null;\n      traverseContext.func = null;\n      traverseContext.context = null;\n      traverseContext.count = 0;\n      if (traverseContextPool.length < POOL_SIZE) {\n        traverseContextPool.push(traverseContext);\n      }\n    }\n\n    /**\n     * @param {?*} children Children tree container.\n     * @param {!string} nameSoFar Name of the key path so far.\n     * @param {!function} callback Callback to invoke with each child found.\n     * @param {?*} traverseContext Used to pass information throughout the traversal\n     * process.\n     * @return {!number} The number of children in this subtree.\n     */\n    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);\n\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n\n      var invokeCallback = false;\n\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n\n      if (invokeCallback) {\n        callback(traverseContext, children,\n        // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows.\n        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n        return 1;\n      }\n\n      var child = void 0;\n      var nextName = void 0;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n      if (Array.isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getComponentKey(child, i);\n          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === children.entries) {\n              !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;\n              didWarnAboutMaps = true;\n            }\n          }\n\n          var iterator = iteratorFn.call(children);\n          var step = void 0;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getComponentKey(child, ii++);\n            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n          }\n        } else if (type === 'object') {\n          var addendum = '';\n          {\n            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n          }\n          var childrenString = '' + children;\n          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n        }\n      }\n\n      return subtreeCount;\n    }\n\n    /**\n     * Traverses children that are typically specified as `props.children`, but\n     * might also be specified through attributes:\n     *\n     * - `traverseAllChildren(this.props.children, ...)`\n     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n     *\n     * The `traverseContext` is an optional argument that is passed through the\n     * entire traversal. It can be used to store accumulations or anything else that\n     * the callback might find relevant.\n     *\n     * @param {?*} children Children tree object.\n     * @param {!function} callback To invoke upon traversing each child.\n     * @param {?*} traverseContext Context for traversal.\n     * @return {!number} The number of children in this subtree.\n     */\n    function traverseAllChildren(children, callback, traverseContext) {\n      if (children == null) {\n        return 0;\n      }\n\n      return traverseAllChildrenImpl(children, '', callback, traverseContext);\n    }\n\n    /**\n     * Generate a key string that identifies a component within a set.\n     *\n     * @param {*} component A component that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n    function getComponentKey(component, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {\n        // Explicit key\n        return escape(component.key);\n      }\n      // Implicit key determined by the index in the set\n      return index.toString(36);\n    }\n\n    function forEachSingleChild(bookKeeping, child, name) {\n      var func = bookKeeping.func,\n          context = bookKeeping.context;\n\n      func.call(context, child, bookKeeping.count++);\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      if (children == null) {\n        return children;\n      }\n      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n      traverseAllChildren(children, forEachSingleChild, traverseContext);\n      releaseTraverseContext(traverseContext);\n    }\n\n    function mapSingleChildIntoContext(bookKeeping, child, childKey) {\n      var result = bookKeeping.result,\n          keyPrefix = bookKeeping.keyPrefix,\n          func = bookKeeping.func,\n          context = bookKeeping.context;\n\n      var mappedChild = func.call(context, child, bookKeeping.count++);\n      if (Array.isArray(mappedChild)) {\n        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n      } else if (mappedChild != null) {\n        if (isValidElement(mappedChild)) {\n          mappedChild = cloneAndReplaceKey(mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n        }\n        result.push(mappedChild);\n      }\n    }\n\n    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n      var escapedPrefix = '';\n      if (prefix != null) {\n        escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n      }\n      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n      releaseTraverseContext(traverseContext);\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, key, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n      return result;\n    }\n\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n    function countChildren(children) {\n      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n    }\n\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n    function toArray(children) {\n      var result = [];\n      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n      return result;\n    }\n\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n    function onlyChild(children) {\n      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n      return children;\n    }\n\n    function createContext(defaultValue, calculateChangedBits) {\n      if (calculateChangedBits === undefined) {\n        calculateChangedBits = null;\n      } else {\n        {\n          !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n        }\n      }\n\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        _calculateChangedBits: calculateChangedBits,\n        _defaultValue: defaultValue,\n        _currentValue: defaultValue,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue2: defaultValue,\n        _changedBits: 0,\n        _changedBits2: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null\n      };\n\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      context.Consumer = context;\n\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n\n      return context;\n    }\n\n    function forwardRef(render) {\n      {\n        !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render === 'undefined' ? 'undefined' : _typeof(render)) : void 0;\n\n        if (render != null) {\n          !(render.defaultProps == null && render.propTypes == null) ? warning(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\n        }\n      }\n\n      return {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n    }\n\n    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n\n    function isValidElementType(type) {\n      return typeof type === 'string' || typeof type === 'function' ||\n      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n      type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_TIMEOUT_TYPE || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n    }\n\n    function getComponentName(fiber) {\n      var type = fiber.type;\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_ASYNC_MODE_TYPE:\n          return 'AsyncMode';\n        case REACT_CONTEXT_TYPE:\n          return 'Context.Consumer';\n        case REACT_FRAGMENT_TYPE:\n          return 'ReactFragment';\n        case REACT_PORTAL_TYPE:\n          return 'ReactPortal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler(' + fiber.pendingProps.id + ')';\n        case REACT_PROVIDER_TYPE:\n          return 'Context.Provider';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_TIMEOUT_TYPE:\n          return 'Timeout';\n      }\n      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null) {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            var functionName = type.render.displayName || type.render.name || '';\n            return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n        }\n      }\n      return null;\n    }\n\n    /**\n     * ReactElementValidator provides a wrapper around a element factory\n     * which validates the props passed to the element. This is intended to be\n     * used only in DEV and could be replaced by a static type checker for languages\n     * that support it.\n     */\n\n    var currentlyValidatingElement = void 0;\n    var propTypesMisspellWarningShown = void 0;\n\n    var getDisplayName = function getDisplayName() {};\n    var getStackAddendum = function getStackAddendum() {};\n\n    {\n      currentlyValidatingElement = null;\n\n      propTypesMisspellWarningShown = false;\n\n      getDisplayName = function getDisplayName(element) {\n        if (element == null) {\n          return '#empty';\n        } else if (typeof element === 'string' || typeof element === 'number') {\n          return '#text';\n        } else if (typeof element.type === 'string') {\n          return element.type;\n        }\n\n        var type = element.type;\n        if (type === REACT_FRAGMENT_TYPE) {\n          return 'React.Fragment';\n        } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n          var functionName = type.render.displayName || type.render.name || '';\n          return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n        } else {\n          return type.displayName || type.name || 'Unknown';\n        }\n      };\n\n      getStackAddendum = function getStackAddendum() {\n        var stack = '';\n        if (currentlyValidatingElement) {\n          var name = getDisplayName(currentlyValidatingElement);\n          var owner = currentlyValidatingElement._owner;\n          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n        }\n        stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n        return stack;\n      };\n    }\n\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentName(ReactCurrentOwner.current);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n\n    function getSourceInfoErrorAddendum(elementProps) {\n      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n        var source = elementProps.__source;\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n        }\n      }\n      return info;\n    }\n\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n      // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n      }\n\n      currentlyValidatingElement = element;\n      {\n        warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n      }\n      currentlyValidatingElement = null;\n    }\n\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n    function validateChildKeys(node, parentType) {\n      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {\n        return;\n      }\n      if (Array.isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step = void 0;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n    function validatePropTypes(element) {\n      var type = element.type;\n      var name = void 0,\n          propTypes = void 0;\n      if (typeof type === 'function') {\n        // Class or functional component\n        name = type.displayName || type.name;\n        propTypes = type.propTypes;\n      } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n        // ForwardRef\n        var functionName = type.render.displayName || type.render.name || '';\n        name = functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';\n        propTypes = type.propTypes;\n      } else {\n        return;\n      }\n      if (propTypes) {\n        currentlyValidatingElement = element;\n        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n        currentlyValidatingElement = null;\n      } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n        propTypesMisspellWarningShown = true;\n        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n      }\n      if (typeof type.getDefaultProps === 'function') {\n        !type.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n      }\n    }\n\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n    function validateFragmentProps(fragment) {\n      currentlyValidatingElement = fragment;\n\n      var keys = Object.keys(fragment.props);\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (key !== 'children' && key !== 'key') {\n          warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n          break;\n        }\n      }\n\n      if (fragment.ref !== null) {\n        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n      }\n\n      currentlyValidatingElement = null;\n    }\n\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type);\n\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      if (!validType) {\n        var info = '';\n        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n\n        var sourceInfo = getSourceInfoErrorAddendum(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n\n        info += getStackAddendum() || '';\n\n        var typeString = void 0;\n        if (type === null) {\n          typeString = 'null';\n        } else if (Array.isArray(type)) {\n          typeString = 'array';\n        } else {\n          typeString = typeof type === 'undefined' ? 'undefined' : _typeof(type);\n        }\n\n        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n      }\n\n      var element = createElement.apply(this, arguments);\n\n      // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n      if (element == null) {\n        return element;\n      }\n\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n\n      return element;\n    }\n\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      // Legacy hook: remove it\n      {\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function get() {\n            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n\n      return validatedFactory;\n    }\n\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n\n    var React = {\n      Children: {\n        map: mapChildren,\n        forEach: forEachChildren,\n        count: countChildren,\n        toArray: toArray,\n        only: onlyChild\n      },\n\n      createRef: createRef,\n      Component: Component,\n      PureComponent: PureComponent,\n\n      createContext: createContext,\n      forwardRef: forwardRef,\n\n      Fragment: REACT_FRAGMENT_TYPE,\n      StrictMode: REACT_STRICT_MODE_TYPE,\n      unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n      unstable_Profiler: REACT_PROFILER_TYPE,\n\n      createElement: createElementWithValidation,\n      cloneElement: cloneElementWithValidation,\n      createFactory: createFactoryWithValidation,\n      isValidElement: isValidElement,\n\n      version: ReactVersion,\n\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        ReactCurrentOwner: ReactCurrentOwner,\n        // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n        assign: _assign\n      }\n    };\n\n    if (enableSuspense) {\n      React.Timeout = REACT_TIMEOUT_TYPE;\n    }\n\n    {\n      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n        // These should not be included in production.\n        ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n        // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n        // TODO: remove in React 17.0.\n        ReactComponentTreeHook: {}\n      });\n    }\n\n    var React$2 = Object.freeze({\n      default: React\n    });\n\n    var React$3 = React$2 && React || React$2;\n\n    // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n    var react = React$3.default ? React$3.default : React$3;\n\n    module.exports = react;\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanM/ZGZjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjQuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuNC4xJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1RJTUVPVVRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnRpbWVvdXQnKSA6IDB4ZWFkMTtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBoYXZlIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG5cbi8vIFN1c3BlbnNlXG52YXIgZW5hYmxlU3VzcGVuc2UgPSBmYWxzZTtcbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxuXG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgIShjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgX2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY2hhbmdlZEJpdHM6IDAsXG4gICAgX2NoYW5nZWRCaXRzMjogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuXG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgY29udGV4dC5Db25zdW1lciA9IGNvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgICEodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAhKHJlbmRlci5kZWZhdWx0UHJvcHMgPT0gbnVsbCAmJiByZW5kZXIucHJvcFR5cGVzID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfVElNRU9VVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnQXN5bmNNb2RlJztcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdEZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdFBvcnRhbCc7XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcignICsgZmliZXIucGVuZGluZ1Byb3BzLmlkICsgJyknO1xuICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFJFQUNUX1RJTUVPVVRfVFlQRTpcbiAgICAgIHJldHVybiAnVGltZW91dCc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0eXBlLnJlbmRlci5kaXNwbGF5TmFtZSB8fCB0eXBlLnJlbmRlci5uYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/ICdGb3J3YXJkUmVmKCcgKyBmdW5jdGlvbk5hbWUgKyAnKScgOiAnRm9yd2FyZFJlZic7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSB2b2lkIDA7XG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbnZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xudmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdHlwZS5yZW5kZXIuZGlzcGxheU5hbWUgfHwgdHlwZS5yZW5kZXIubmFtZSB8fCAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIG5hbWUgPSB2b2lkIDAsXG4gICAgICBwcm9wVHlwZXMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENsYXNzIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAvLyBGb3J3YXJkUmVmXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgbmFtZSA9IGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZyhmYWxzZSwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7XG5cbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB2YXIgdHlwZVN0cmluZyA9IHZvaWQgMDtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBjcmVhdGVSZWY6IGNyZWF0ZVJlZixcbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgZm9yd2FyZFJlZjogZm9yd2FyZFJlZixcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcbiAgU3RyaWN0TW9kZTogUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgdW5zdGFibGVfQXN5bmNNb2RlOiBSRUFDVF9BU1lOQ19NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX1Byb2ZpbGVyOiBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbmlmIChlbmFibGVTdXNwZW5zZSkge1xuICBSZWFjdC5UaW1lb3V0ID0gUkVBQ1RfVElNRU9VVF9UWVBFO1xufVxuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkMy5kZWZhdWx0ID8gUmVhY3QkMy5kZWZhdWx0IDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBOURBO0FBQ0E7QUFnRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7O0FBSUE7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU5BO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUE1QkE7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzP2YyNTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar v1 = __webpack_require__(/*! ./v1 */ \"./node_modules/uuid/v1.js\");\nvar v4 = __webpack_require__(/*! ./v4 */ \"./node_modules/uuid/v4.js\");\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXVpZC9pbmRleC5qcz9mMGYwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/index.js\n");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nmodule.exports = bytesToUuid;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzPzQ1NDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/lib/bytesToUuid.js\n");

/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzPzAwOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/lib/rng-browser.js\n");

/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC92MS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXVpZC92MS5qcz81OTg5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG52YXIgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/v1.js\n");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng-browser.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC92NC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdXVpZC92NC5qcz9iYzVmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/v4.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcz9mYTMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ })

/******/ });